<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>HanSi&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="HanSi&#39;s Blog">
<meta property="og:url" content="http://huhansi.com/page/54/index.html">
<meta property="og:site_name" content="HanSi&#39;s Blog">
<meta property="og:locale">
<meta property="article:author" content="HanSi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HanSi's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HanSi&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://huhansi.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-MySQL/MySQL如何实现分布式XA事务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/12/MySQL/MySQL%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8FXA%E4%BA%8B%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2020-04-11T16:00:00.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/12/MySQL/MySQL%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8FXA%E4%BA%8B%E5%8A%A1/">MySQL中的XA事务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL中的XA事务"><a href="#MySQL中的XA事务" class="headerlink" title="MySQL中的XA事务"></a>MySQL中的XA事务</h1><p>存储引擎的事务特性能够保证在存储引擎级别实现ACID，而分布式事务则让存储引擎级别的ACID可以扩展到数据库层面，甚至可以扩展到多个数据库之间-这需要两阶段提交实现。MySQL5.0和更新的版本的数据库已经开始支持XA事务了。</p>
<p>XA事务中需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）。如果协调器受到所有参与者都准备好的消息，就会告诉所有的事务可以提交了，这时第二阶段。MySQL在这个XA事务过程中扮演一个参与者的角色，而不是协调者。</p>
<p>实际上，在MySQL中有两种XA事务。一方面，MySQL可以参与到外部的分布式事务中；另一方面，还可以通过XA事务来协调存储引擎和二进制日志。</p>
<h2 id="内部XA事务"><a href="#内部XA事务" class="headerlink" title="内部XA事务"></a>内部XA事务</h2><p>MySQL本身的插件式架构导致再起内部需要使用XA事务。MySQL中各个存储引擎是完全独立的，彼此不知道对方的存在，所以一个跨存储引擎的事务就需要一个外部的协调者。如果不使用XA协议，例如，跨存储引擎的事务提交就只是顺序地要求每个存储引擎各自提交。如果在某个存储提交过程中发生系统崩溃，就会破坏事务的特性。（要么全部提交，要么不做任何操作）。</p>
<p>如果将MySQL记录的二进制日志操作看做一个独立的“存储引擎”，就不难理解为什么即使是一个存储殷勤参数的事务仍然需要XA事务了。在存储引擎提交的同时，需要将“提交”的信息写入二进制日志，这是一个分布式事务，只不过二进制日志的参与者是MySQL本身。</p>
<h2 id="外部XA事务"><a href="#外部XA事务" class="headerlink" title="外部XA事务"></a>外部XA事务</h2><p>外部XA用于跨多MySQL实例的分布式事务，需要应用层作为协调者，通俗的说就是比如我们在PHP中写代码，那么PHP书写的逻辑就是协调者。应用层负责决定提交还是回滚，崩溃时的悬挂事务。MySQL数据库外部XA可以用在分布式数据库代理层，实现对MySQL数据库的分布式事务支持。</p>
<h3 id="MySQL事务基本语法"><a href="#MySQL事务基本语法" class="headerlink" title="MySQL事务基本语法"></a>MySQL事务基本语法</h3><blockquote>
<p>XA {START|BEGIN} xid [JOIN|RESUME] 启动xid事务 (xid 必须是一个唯一值; 不支持[JOIN|RESUME]子句)<br>XA END xid [SUSPEND [FOR MIGRATE]] 结束xid事务 ( 不支持[SUSPEND [FOR MIGRATE]] 子句)<br>XA PREPARE xid 准备、预提交xid事务<br>XA COMMIT xid [ONE PHASE] 提交xid事务<br>XA ROLLBACK xid 回滚xid事务<br>XA RECOVER 查看处于PREPARE 阶段的所有事务</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/soonfly/article/details/70677138">详解Mysql分布式事务XA（跨数据库事务）</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/12/MySQL/MySQL%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8FXA%E4%BA%8B%E5%8A%A1/" data-id="cl541frv600155srw35oqfhb9" data-title="MySQL中的XA事务" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/XA/" rel="tag">XA</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL/优化MySQL索引的N种方法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/12/MySQL/%E4%BC%98%E5%8C%96MySQL%E7%B4%A2%E5%BC%95%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2020-04-11T16:00:00.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/12/MySQL/%E4%BC%98%E5%8C%96MySQL%E7%B4%A2%E5%BC%95%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/">优化MySQL索引的N种方法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="优化MySQL索引的N种方法"><a href="#优化MySQL索引的N种方法" class="headerlink" title="优化MySQL索引的N种方法"></a>优化MySQL索引的N种方法</h1><p>正确创建和使用索引是实现高性能查询的基础。</p>
<h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>索引列不能是表达式的一部分， 也不能是函数的参数，必须是独立的列。如果查询中的列不是独立的，则MySQL就不会使用索引。</p>
<h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>有时候需要索引很长的字符列，这回让索引变得大且慢。那么，就可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>前缀所以是一种能使索引更小、更快的有效办法，但另一方面，它也限制了使用前缀索引做ORDER BY 和GROUP BY的可能，也无法使用前缀索引做覆盖扫描。</p>
<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新的版本引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。在更早的版本上，MySQL只能使用其中某一个单列索引，然而这种情况下没有哪一个独立的单列索引是非常有效的。</p>
<p>例如，表film_actor在film_id和actor_id上各有一个单列索引。但对于下面这个查询WHERE条件，这两个单列索引都不是好的选择</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> film_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在老的MySQL版本中，MySQL对这个查询会使用全表扫描。除非改写成吐下两个查询UNION的方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">where</span> actor_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_acotr <span class="keyword">where</span> film_id <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> actor_id <span class="operator">&lt;&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>但在MySQL5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR条件的联合，AND条件的小脚，组合前两种状况的联合及相交。</p>
<p>MySQL会使用这类技术优化复杂查询，所以在某些语句的Extra列中还可以看到嵌套操作。</p>
<p>索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕：</p>
<ul>
<li>当出现服务器对多个索引做相交操作时（通常有多个AND），通常意味着需要一个包含所有相关列的多列索引</li>
<li>当服务器需要对多个索引做联合操作时（通常有多个OR），通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并带扫描返回大量数据的时候。</li>
</ul>
<h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页上。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能由一个聚簇索引。</p>
<p>InnoDB通过主键聚集数据，也就是说，主键列会建一个聚簇索引。</p>
<p>如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</p>
<p>聚簇索引有一些重要的优点：</p>
<ul>
<li>可以把相关的数据保存在一起。例如，实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘IO。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值</li>
</ul>
<p>同时聚簇索引也有一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了IO密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了</li>
<li>插入速度验证依赖于插入顺序。按照主键的顺序插入是家在数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完后最好使用OPTIMIZE TABLE命令重新组织一下表</li>
<li>更新聚簇索引的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续时候</li>
<li>二级索引（非聚簇索引）可能比想象的要大，因为在二级索引的叶子节点包含了引用行的主键列（二级索引保存的是行的主键值，而不是指向行的物理位置的指针）。</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p> 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称之为覆盖索引。覆盖索引是非常有用的工具，能够极大地提高性能。</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那就会极大地较少减少数据访问量。</li>
<li>因为索引是按照列值顺序存储的（至少单个页内是如此），所以，对于IO密集型的范围查询回避随机从磁盘读取每一行数据IO要少得多</li>
<li>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统缓存，一次访问数据需要一次系统调用</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<h2 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h2><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作。</p>
<h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀要说来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认只压缩字符串，但通过参数配置也可以对整数做压缩。MyIASM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</p>
<h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<p>冗余索引和重复索引有一些不同。如果创建了索引（A，B），再创建索引（A）就是冗余索引。因为这只是前一个索引的前缀索引。因此索引（A，B）也可以当做索引（A）来使用（这种冗余只是对B-Tree索引来说的）。但是如果再创建索引（B,A），则不是冗余索引，索引（B）也不是，因为B不是索引（A，B）的最左前缀列。另外，其他不同类型的索引（例如哈希索引或全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。</p>
<h2 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h2><p>删除即可。</p>
<h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>索引可以让查询锁定更少的行。如果你的查询从不访问哪些不需要的行，那么就会锁定更少的行，从两个方面看着对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存的使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>
<p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。这时候已经无法避免锁定行了：InnoDB已经锁住了这些行，到适当时候才释放。在MySQL5.1 和更新的版本中，InnoDB可以在服务器端过滤掉行之后就释放锁，但在早期的MySQL版本中，InnoDB只有在事务提交后才能释放锁。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/12/MySQL/%E4%BC%98%E5%8C%96MySQL%E7%B4%A2%E5%BC%95%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/" data-id="cl541frvb001b5srwfroeh6lj" data-title="优化MySQL索引的N种方法" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95/" rel="tag">前缀索引</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" rel="tag">索引优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/" rel="tag">聚簇索引</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-分布式/分布式ID-雪花算法实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2020-04-11T16:00:00.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/">分布式ID生成-SnowFlake实现</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分布式ID生成-SnowFlake实现"><a href="#分布式ID生成-SnowFlake实现" class="headerlink" title="分布式ID生成-SnowFlake实现"></a>分布式ID生成-SnowFlake实现</h1><h2 id="SnowFlake原理"><a href="#SnowFlake原理" class="headerlink" title="SnowFlake原理"></a>SnowFlake原理</h2><p>Twitter的snowflake算法解决了分布式系统生成全局ID的需求，生成64位的Long型数字.</p>
<p>它是把64位分成各个部分，分别代表：</p>
<ul>
<li>第一位不使用，预留</li>
<li>接下来的41位表示毫秒时间</li>
<li>5位数据中心ID</li>
<li>5位worker的ID</li>
<li>最后12位是毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序列</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-12-snowflake.jpg" alt="位数分组图示"></p>
<p>这样的好处是：毫秒数在高位，生成的ID整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上QPS约为409.6w&#x2F;s（1000*2^12），并且整个分布式系统内不会产生ID碰撞；可根据自身业务灵活分配bit位。</p>
<p>不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成ID重复。</p>
<h2 id="SnowFlake实现"><a href="#SnowFlake实现" class="headerlink" title="SnowFlake实现"></a>SnowFlake实现</h2><p>因为实现比较简单，就贴一个网友的Java版<a target="_blank" rel="noopener" href="https://github.com/beyondfengyu/SnowFlake">实现</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * twitter的snowflake算法 -- java实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> beyond</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016/11/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowFlake</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 起始的时间戳</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">START_STMP</span> <span class="operator">=</span> <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">SEQUENCE_BIT</span> <span class="operator">=</span> <span class="number">12</span>; <span class="comment">// 序列号占用的位数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MACHINE_BIT</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 机器标识占用的位数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">DATACENTER_BIT</span> <span class="operator">=</span> <span class="number">5</span>;<span class="comment">// 数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每一部分的最大值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MAX_DATACENTER_NUM</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATACENTER_BIT);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MAX_MACHINE_NUM</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MAX_SEQUENCE</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">MACHINE_LEFT</span> <span class="operator">=</span> SEQUENCE_BIT;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">DATACENTER_LEFT</span> <span class="operator">=</span> SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">TIMESTMP_LEFT</span> <span class="operator">=</span> DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> datacenterId; <span class="comment">// 数据中心</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> machineId; <span class="comment">// 机器标识</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>; <span class="comment">// 序列号</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastStmp</span> <span class="operator">=</span> -<span class="number">1L</span>;<span class="comment">// 上一次时间戳</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SnowFlake</span><span class="params">(<span class="type">long</span> datacenterId, <span class="type">long</span> machineId)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;datacenterId can&#x27;t be greater than MAX_DATACENTER_NUM or less than 0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;machineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">		<span class="built_in">this</span>.machineId = machineId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 产生下一个ID</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">currStmp</span> <span class="operator">=</span> getNewstmp();</span><br><span class="line">		<span class="keyword">if</span> (currStmp &lt; lastStmp) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (currStmp == lastStmp) &#123;</span><br><span class="line">			<span class="comment">// 相同毫秒内，序列号自增</span></span><br><span class="line">			sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">			<span class="comment">// 同一毫秒的序列数已经达到最大</span></span><br><span class="line">			<span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">				currStmp = getNextMill();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 不同毫秒内，序列号置为0</span></span><br><span class="line">			sequence = <span class="number">0L</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lastStmp = currStmp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT <span class="comment">// 时间戳部分</span></span><br><span class="line">				| datacenterId &lt;&lt; DATACENTER_LEFT <span class="comment">// 数据中心部分</span></span><br><span class="line">				| machineId &lt;&lt; MACHINE_LEFT <span class="comment">// 机器标识部分</span></span><br><span class="line">				| sequence; <span class="comment">// 序列号部分</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getNextMill</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">mill</span> <span class="operator">=</span> getNewstmp();</span><br><span class="line">		<span class="keyword">while</span> (mill &lt;= lastStmp) &#123;</span><br><span class="line">			mill = getNewstmp();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mill;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">long</span> <span class="title function_">getNewstmp</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">SnowFlake</span> <span class="variable">snowFlake</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnowFlake</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">12</span>); i++) &#123;</span><br><span class="line">			System.out.println(snowFlake.nextId());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" data-id="cl541frwd002s5srw4yy0f157" data-title="分布式ID生成-SnowFlake实现" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SnowFlake/" rel="tag">SnowFlake</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/" rel="tag">分布式ID</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-分布式/分布式事务入门" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/" class="article-date">
  <time class="dt-published" datetime="2020-04-11T16:00:00.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/">分布式事务入门</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分布式事务入门"><a href="#分布式事务入门" class="headerlink" title="分布式事务入门"></a>分布式事务入门</h1><h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>要理解分布式事务，先看看什么是事务？</p>
<p>事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。可以通俗理解为 （ALL OR NOTHING）：就是把多件事情当做一件事情来处理，好比大家同在一条船上，要活一起活，要完一起完 。</p>
<p>而随着微服务、SOA等服务架构大规模普及，一个单体应用往往被拆分成N个不同的微服务。这时候本来是本地数据库的一致性就演变成为了不同服务之间不同数据库之间的一致性。又或者是相同服务之前的不同数据库（分库）之间的一致性。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-multi-service.png" alt="不同服务之间不同数据库产生的分布式事务"></p>
<p>必须要保证积分、优惠券、余额同时扣减成功。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-multi-resource.png" alt="相同服务之间不同数据库产生的分布式事务"></p>
<p>扣款和增款必须同时成功</p>
<p>分布式事务就是要保证上述两种不同数据库之间的一致性而产生的。分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<h2 id="分布式系统的一致性问题"><a href="#分布式系统的一致性问题" class="headerlink" title="分布式系统的一致性问题"></a>分布式系统的一致性问题</h2><p>下面举几个例子说一下常见的系统存在的哪些不一致的问题。</p>
<h3 id="下订单和扣库存"><a href="#下订单和扣库存" class="headerlink" title="下订单和扣库存"></a>下订单和扣库存</h3><p>电商系统中有一个经典的案例，即下订单和扣库存如何保持一致。如果先下订单，，扣库存失败，那么就会导致超卖；如果下订单不成功，扣库存成功，就会导致少卖。</p>
<h3 id="同步调用超时"><a href="#同步调用超时" class="headerlink" title="同步调用超时"></a>同步调用超时</h3><p>服务化的系统间调用常常因为网络问题导致系统间调用超时，即使是网络状况很好的机房在亿次流量的基数下，同步调用超时也是家常便饭。系统A同步调用系统B超时，系统A可以明确导致超市反馈，但是无法确定系统B是否已经完成了预设的功能。于是，系统A不知道应该继续做什么，如何反馈给使用方。</p>
<h3 id="异步回调超时"><a href="#异步回调超时" class="headerlink" title="异步回调超时"></a>异步回调超时</h3><p>此案例和上一个同步超时的案例类似，不过这是一个受理模式的场景，使用了异步回调返回处理结果，系统A同步调用系统B发起指令，系统B采用受理模式，受理后则返回成功信息，然后系统B处理后异步通知系统A处理结果。在这个过程中，如果系统A由于某种原因迟迟没有收到回调结果，那么这两个系统间的状态就不一致，互相认知的状态不同会导致系统间发生错误，在严重情况下会影响核心链路上的交易的状态准确性，甚至会导致资金损失。</p>
<h3 id="掉单"><a href="#掉单" class="headerlink" title="掉单"></a>掉单</h3><p>在分布式系统中，两个系统写作处理一个流程，分别为对方的上下游，如果一个系统中存在一个请求（通常指订单），另一个系统不存在，则会导致掉单，掉单的后果很严重，有时也会导致资金损失。</p>
<h3 id="系统间状态不一致"><a href="#系统间状态不一致" class="headerlink" title="系统间状态不一致"></a>系统间状态不一致</h3><p>此案例与上面掉单的案例类似，不同的是两个系统间都存在请求，但请求的状态不一致。</p>
<h3 id="缓存和数据库不一致"><a href="#缓存和数据库不一致" class="headerlink" title="缓存和数据库不一致"></a>缓存和数据库不一致</h3><p>缓存和数据库之间的数据如何保持一致性？是要保持强一致性还是弱一致性。</p>
<h3 id="本地缓存节点间不一致"><a href="#本地缓存节点间不一致" class="headerlink" title="本地缓存节点间不一致"></a>本地缓存节点间不一致</h3><p>一个服务池上的多个节点为了满足较高的性能需求，需要使用本地缓存，这样每个节点都会有一份缓存数据的复制，如果这些数据是静态的，不变的，就永远不会有问题，但是如果这些数据时半静态的或者经常被更新的，则被更新时各个节点的更新是有先后顺序的，在更新的瞬间，在某个时间窗内各个节点的数据时不一致的，如果这些数据视为某个开关服务的，则想象一下重复的请求进入了不同的节点，一个请求进入了开关打开的逻辑，同时另一个进入了开关关闭的逻辑，会导致请求被处理两次，最坏的情况是导致资金损失。</p>
<h3 id="缓存数据结构不一致"><a href="#缓存数据结构不一致" class="headerlink" title="缓存数据结构不一致"></a>缓存数据结构不一致</h3><p>某系统需要在缓存中暂存某种类型的数据，该数据由多个数据元素组成，其中，某个数据元素需要从数据库或者服务中获取，如果一部分数据元素获取失败，则由于程序处理不正确，仍然将不完成的数据存入缓存中，在缓存使用者使用时很有可能因为数据的不完全而抛出异常，例如NullPointerException等，然后可能因为没有合理处理异常而导致程序出错。</p>
<h2 id="分布式事务的理论基础"><a href="#分布式事务的理论基础" class="headerlink" title="分布式事务的理论基础"></a>分布式事务的理论基础</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p><img src="https://huhansi.github.io/images/2020-04-11-cap.png" alt="CAP定理"></p>
<p>CAP定理，又被称为布鲁尔定理，是分布式计算领域公认的一个定理。</p>
<ul>
<li>C：Consistency，一致性。在分布式系统中的所有数据备份，在同一时刻，具有同样的值，所有节点在同一时刻读取的数据都是最新的数据副本。</li>
<li>A：Availability，可用性，好的响应性能。完全的可用性指的是在任何故障模型下，服务都会在有限的时间内处理完成并进行响应</li>
<li>P：Partition tolerance，分区容忍性。尽管网络上有部分消息丢失，但系统仍然可以继续工作。</li>
</ul>
<p>CAP原理证明，任何分布式系统只可同时满足以上两点，另外一个必须被牺牲。分布式的服务化系统都需要满足分区容忍性，那么只能选择CP（一致性+分区容忍性）或者AP（可用性+分区容忍性）这两个，而不能选择AC（可用性+一致性）。</p>
<p>如果在网络上有消息丢失，就出现了网络分区，复制操作可能会被延后，这时候，如果我们选择等待复制完成再返回，则可能导致有限的时间内无法响应，失去了可用性；二如果选择不等待复制完成，在主分片写完后立即返回，则具备了可用性，但失去了一致性。</p>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE思想解决了CAP提出的分布式系统的一致性和可用性不可兼得的问题。BASE思想和ACID原理截然不同，它满足CAP原理，通过牺牲强一致性获得可用性，一般应用于服务化系统的应用层或者大数据处理系统中，通过达到最终一致性来尽量满足业务的绝大多数需求。</p>
<p>BASE模型包含如下三个元素：</p>
<ul>
<li>BA：Basically Available，基本可用</li>
<li>S：Soft State，软状态，状态可以在一段时间内不同步</li>
<li>E：Eventually Consistent，最终一致，在一定的时间窗口内，最终数据达成一致即可。</li>
</ul>
<h2 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h2><p>国际开放标准组织Open Group定义了DTS（分布式事务处理模型），模型中包含4种角色：应用程序、事务管理器、资源管理器和通信资源管理器。事务管理器是统管全局的管理者，资源管理器和通信资源管理器是事务的参与者。</p>
<p>下面的两阶段提交协议、三阶段提交协议以及TCC协议，都是根据DTS这一思想演变而来的。</p>
<h3 id="两阶段提交协议（强一致性）"><a href="#两阶段提交协议（强一致性）" class="headerlink" title="两阶段提交协议（强一致性）"></a>两阶段提交协议（强一致性）</h3><p>JEE的XA协议就是根据两阶段提交来保证事务的完整性，并实现分布式服务化的强一致性。</p>
<p>两阶段提交协议把分布式事务分为两个阶段，一个是准备阶段，另一个是提交阶段。准备阶段和提交阶段都是由事务管理器发起的。</p>
<p>两阶段提交协议的流程如下所述：</p>
<ul>
<li>准备阶段：事务管理器向资源管理器发起指令，资源管理器评估自己的状态，如果资源管理器评估指令可以完成，则会写redo 或者 undo日志，然后锁定资源，执行操作，但是并不提交</li>
<li>提交阶段：如果每个资源管理器明确返回准备成功，也就是预留资源和执行操作成功，则事务管理器向资源管理器发起提交指令，资源管理器提交资源变更的事务，释放锁定的资源；如果任何一个资源管理器明确返回准备失败，也就是预留资源或者执行操作失败，则事务管理器向资源管理器发起终止之灵，资源管理器取消已经变更的事务，执行undo日志，释放锁定的资源。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-11-2pc1.png" alt="两阶段事务提交成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-2pc3.png" alt="两阶段事务提交成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-2pc2.png" alt="两阶段事务提交失败，回滚"></p>
<p>两阶段提交协议在准备阶段锁定资源，这时一个重量级的操作，能保证强一致性，但是实现起来复杂、成本较高、不够灵活，更重要的是它还有以下的致命问题：</p>
<ul>
<li>阻塞：任何一次指令都必须受到明确的响应，才会继续下一步，否则处于阻塞状态，占用的资源会被一直锁定，不会被释放。</li>
<li>单点故障：如果事务管理器宕机，资源管理器没有事务管理器指挥，就会一直阻塞，尽管可以通过选择新的事务管理器替代原有的事务管理器，但是如果事务管理器在发送一个提交指令后宕机，并且提交指令仅仅被一个资源管理器接受，并且资源管理器接受后也宕机，那么新上任的资源管理器无法处理这种情况</li>
<li>脑裂：事务管理器发送提交指令，有的资源管理器受到并执行了事务，有的没有收到就没有执行事务，多个参与者之间状态就不一致</li>
</ul>
<h3 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h3><p>三阶段提交协议是两阶段提交协议的改进版本。它通过超时机制解决了阻塞的问题，并把两阶段增加为以下三个阶段：</p>
<ul>
<li>询问阶段：事务管理器询问资源管理器是否可以完成指令，资源管理器只需要回答是或者不是，而不需要做真正的操作，这个阶段超时会导致终止。</li>
<li>准备阶段：如果在询问阶段所有资源管理器都返回可以执行操作，则事务管理器向资源管理器发送预执行请求，然后资源管理器写redo和undo日志，执行操作但是不提交操作；如果在询问阶段任意资源管理器返回不能执行操作的结果，则事务管理器向资源管理器发送终止请求，这里的逻辑与两阶段提交协议的准备阶段是类似的</li>
<li>提交阶段：如果每个资源管理器在准备阶段都返回准备成功，也就是说预留资源和执行操作成功，则事务管理器向资源管理器发起提交指令，资源管理器提交资源变更的事务，释放锁定的资源；如果任何参与者返回准备失败，也就是说预留资源或者执行操作失败，则事务管理器向资源管理器发起终止指令，资源管理器取消已经变更的事务，执行undo日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段是一致的。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc1.png" alt="三阶段提交-询问阶段成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc2.png" alt="三阶段提交-询问阶段失败"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc3.png" alt="三阶段提交-准备阶段成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc4.png" alt="三阶段提交-准备阶段失败"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc5.png" alt="三阶段提交-提交成功时序图"></p>
<p>三阶段提交协议与两阶段提交协议主要有以下两个不同点：</p>
<ul>
<li>增加了一个询问阶段，询问阶段可以确保尽可能早地发现无法执行操作而需要终止的行为，但是它并不能发现所有这种行为，只会减少这种情况发生</li>
<li>在准备阶段以后，事务管理器和资源管理器执行的任务都增加了超时，一旦超时，则事务管理器和资源管理器都会继续提交事务，默认为成功，这也是根据概率统计超市后默认为成功的正确性最大。</li>
</ul>
<h3 id="TCC（最终一致性）"><a href="#TCC（最终一致性）" class="headerlink" title="TCC（最终一致性）"></a>TCC（最终一致性）</h3><p>TCC协议将一个任务拆分成Try、Confirm、Cancel三个步骤。正常流程会先执行Try，如果执行没有问题，则再执行Confirm，如果执行过程中出了问题，则执行操作的逆操作Cancel。</p>
<ul>
<li>Try：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</li>
<li>Confirm：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</li>
<li>Cancel：取消执行，释放Try阶段预留的业务资源。 Cancel操作满足幂等性，Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</li>
</ul>
<p>从正常流程上讲，这仍然是一个两阶段提交协议，但是在执行出现问题时有一定的自我修复能力，如果任何参与者出现了问题，则事务管理器通过执行操作的逆操作Cancel之前的操作，达到最终一致的状态。</p>
<h3 id="本地消息表（最终一致性）"><a href="#本地消息表（最终一致性）" class="headerlink" title="本地消息表（最终一致性）"></a>本地消息表（最终一致性）</h3><p><a href="%5Bhttps://queue.acm.org/detail.cfm?id=1394128%E3%80%82%5D(https://queue.acm.org/detail.cfm?id=1394128%E3%80%82)">本地消息表</a>的方案最初是由ebay提出的。核心思路是将分布式事务拆分成本地事务进行处理。方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样设计可以避免“<strong>业务处理成功+事务消息发送失败</strong>”或“<strong>业务处理失败+事务消息发送成功</strong>”的棘手情况出现，保证2个系统事务的数据一致性。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-local-message.png" alt="本地消息表"></p>
<p>以上文案例1为例，扣库存和下订单服务分布在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要往外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p>整个业务处理流程如下：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-local-message.png" alt="本地消息表业务流程"></p>
<ol>
<li>事务主动方处理本地事务</li>
<li>事务主动方通过消息中间件，通知事务被动方处理事务</li>
<li>事务被动方通过消息中间件，通知事务主动方已处理的消息</li>
</ol>
<p>为了数据一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<ol>
<li>当步骤1处理出错，事务回滚，等同于什么都没有发生</li>
<li>当步骤2、步骤3处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。</li>
<li>如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</li>
<li>如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。</li>
</ol>
<h3 id="MQ事务（最终一致性）"><a href="#MQ事务（最终一致性）" class="headerlink" title="MQ事务（最终一致性）"></a>MQ事务（最终一致性）</h3><p>基于MQ的分布式事务方案其实是对本地消息表的封装，将本地消息表基于MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ的事务消息相对于普通MQ，相对于提供了2PC的提交接口，方案如下：</p>
<p><strong>正常情况——事务主动方发消息</strong> 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-mq-transaction.png" alt="MQ事务成功"></p>
<ol>
<li>发送方向 MQ服务端(MQ Server)发送half消息</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功</li>
<li>发送方开始执行本地事务逻辑</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）</li>
<li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除half消息，订阅方将不会接受该消息。</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-12-mq-transaction1.png" alt="MQ事务异常"></p>
<ol>
<li>MQ Server 对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认</li>
<li>MQ Server基于commit &#x2F; rollback 对消息进行投递或者删除</li>
</ol>
<h3 id="Saga事务（最终一致性）"><a href="#Saga事务（最终一致性）" class="headerlink" title="Saga事务（最终一致性）"></a>Saga事务（最终一致性）</h3><p>其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<p>每个Saga事务都是由一些<strong>本地</strong>子事务T1、T2、……、Tn组成，对应的每个事务Ti，都会有一Ti，撤销操作Ci。</p>
<p>Saga事务只有两种执行路径：</p>
<ol>
<li>事务正常执行完成：T1、T2、……、Tn</li>
<li>事务Ti执行失败：T1、T2、……、Ti、Ci、Ci-1、……、C1</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-12-saga.png" alt="Saga事务执行情况"></p>
<h4 id="Saga恢复策略"><a href="#Saga恢复策略" class="headerlink" title="Saga恢复策略"></a>Saga恢复策略</h4><h5 id="向前恢复"><a href="#向前恢复" class="headerlink" title="向前恢复"></a>向前恢复</h5><p><img src="https://huhansi.github.io/images/2020-04-12-saga1.png" alt="向前恢复"></p>
<p>本地事务Ti执行失败，就一直执行Ti，直到成功为止，在这种情况下，没有对应的撤销Ci操作。</p>
<h5 id="向后恢复"><a href="#向后恢复" class="headerlink" title="向后恢复"></a>向后恢复</h5><p><img src="https://huhansi.github.io/images/2020-04-12-saga2.png" alt="向后恢复"></p>
<p>本地事务Ti执行失败，就执行对应的撤销操作Ci，直到执行完C0为止。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="命令协调"><a href="#命令协调" class="headerlink" title="命令协调"></a>命令协调</h5><p>中央协调器负责集中处理事件的决策和业务逻辑排序。</p>
<p>中央协调器（Orchestrator，简称OSO）以命令&#x2F;回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-saga3.png" alt="Saga命令协调模式"></p>
<h5 id="事件编排"><a href="#事件编排" class="headerlink" title="事件编排"></a>事件编排</h5><p>没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。</p>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-saga4.png" alt="Saga事件编排"></p>
<h2 id="保证最终一致性的模式"><a href="#保证最终一致性的模式" class="headerlink" title="保证最终一致性的模式"></a>保证最终一致性的模式</h2><p>在大规模、高并发服务化系统中，一个功能被拆分成多个具有单一功能的子功能，一个流程会有多个系统的多个单一功能的服务组合实现，如果实现两阶段提交协议和三阶段提交协议，则缺失能解决系统间的一致性问题。除了这两个协议的自身问题，其实现也比较复杂、成本比较高，最重要的是性能不好，相比来看，TCC协议更简单且更容易实现，但是TCC协议由于每个事务都需要执行Try，再执行Confirm，略显臃肿，因此，现实系统的底线是仅仅需要达到最终一致性，而不需要实现专业的、复杂的一致性协议。实现最终一致性有一些非常有效、简单的模式。</p>
<h3 id="查询模式"><a href="#查询模式" class="headerlink" title="查询模式"></a>查询模式</h3><p>任何服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态。服务操作的使用方可以通过查询接口的值服务操作的执行状态，然后根据不同的状态来做不同的处理操作。</p>
<p>上文的案例2-5，可以使用查询模式来了解被调用服务的处理情况，决定下一步做什么，例如是补偿未完成的操作还是混滚已经完成的操作。</p>
<h3 id="补偿模式"><a href="#补偿模式" class="headerlink" title="补偿模式"></a>补偿模式</h3><p>为了让系统最终达到一状态而做的牡蛎都叫做补偿操作。</p>
<p>补偿操作根据发起形式分为以下几种：</p>
<ul>
<li>自动恢复：程序根据发生不一致的环境，通过继续进行未完成的操作，或者回滚已经完成的操作，来自动达到一致状态</li>
<li>通知运营：如果程序无法自动恢复，并且设计时考虑到了不一致的场景，则可以提供运营功能，通过运营手动进行补偿</li>
<li>如果很不巧，系统无法自动恢复，有没有运营功能，那么必须通过技术手段来解决，技术手段包括进行数据库变更或者代码变更</li>
</ul>
<h3 id="异步确保模式"><a href="#异步确保模式" class="headerlink" title="异步确保模式"></a>异步确保模式</h3><p>异步确保模式是补偿模式的一个典型案例，经常应用到使用方对响应时间要求不太高的场景中，通常把这类操作从主流程中摘除，通过异步的方式进行处理，处理后把结果通过通知系统通知给使用方。</p>
<p>案例3中，若对某个操作没有收到响应，则通过查询模式、补偿模式和异步确保模式来继续未完成的操作。</p>
<h3 id="定期校对模式"><a href="#定期校对模式" class="headerlink" title="定期校对模式"></a>定期校对模式</h3><p>在操作主流程中的系统间执行校对操作，可以在时候异步的批量校对操作的状态，如果发现不一致的操作，则进行补偿。</p>
<p>对于案例4和4，通常通过定期校对模式发现问题，并通过补偿模式来修复，最后达到系统间的最终一致性。</p>
<h3 id="可靠消息模式"><a href="#可靠消息模式" class="headerlink" title="可靠消息模式"></a>可靠消息模式</h3><p>通过消息队列实现异步化。</p>
<h4 id="消息的可靠发送"><a href="#消息的可靠发送" class="headerlink" title="消息的可靠发送"></a>消息的可靠发送</h4><p>消息的可靠发送可以认为是仅最大努力发送消息通知，有以下两种实现方法。</p>
<p>第一种是在发送消息之前将消息持久到数据库，状态标记为待发送，然后发送消息，如果发送成功，则将消息改为发送成功。定时任务定时从数据库老区在一定时间内未发送的消息并发送。</p>
<p>第二种是持久消息的数据库时独立的。</p>
<h4 id="消息处理器的幂等性"><a href="#消息处理器的幂等性" class="headerlink" title="消息处理器的幂等性"></a>消息处理器的幂等性</h4><ul>
<li>使用数据库表的唯一键进行滤重</li>
<li>使用分布式表对请求进行滤重</li>
<li>使用状态流转的方向性来滤重，通常使用数据库的行级锁进行实现</li>
<li>根据业务的特点，操作本身就是幂等的，例如：删除一个资源等</li>
</ul>
<h3 id="缓存一致性模式"><a href="#缓存一致性模式" class="headerlink" title="缓存一致性模式"></a>缓存一致性模式</h3><ul>
<li>如果性能要求不是非常高，则尽量使用分布式缓存，而不要使用本地缓存</li>
<li>写缓存时数据一定要完成，如果缓存数据的一部分有效，另一部分无效，则宁可在需要时回源数据库，也不要把部分数据放入缓存中</li>
<li>使用缓存牺牲了一致性，为了提高性能，数据库与缓存只需要保持弱一致性，而不需要保持强一致性，否则就违背了使用缓存的初衷</li>
<li>读的顺序是先读缓存，后读数据库，写的顺序是先写数据库，后写缓存。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="">百度百科-分布式事务</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b5a0bf9f265da0f6523913b">再有人问你分布式事务，把这篇扔给他</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c0e5bf8e51d45063322fe50">理解分布式事务</a></p>
<p><a href="">分布式服务架构原理、设计与实战</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/" data-id="cl541frwf002u5srw8xl67yqr" data-title="分布式事务入门" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BASE/" rel="tag">BASE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CAP/" rel="tag">CAP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DTS/" rel="tag">DTS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MQ%E4%BA%8B%E5%8A%A1/" rel="tag">MQ事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Saga%E4%BA%8B%E5%8A%A1/" rel="tag">Saga事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCC/" rel="tag">TCC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" rel="tag">三阶段提交</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" rel="tag">两阶段提交</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8/" rel="tag">本地消息表</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-分布式/分布式锁的几种实现" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time class="dt-published" datetime="2020-04-11T16:00:00.000Z" itemprop="datePublished">2020-04-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/">分布式锁的几种实现方式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h1><h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>在许多场景中，有些操作是只能被执行一次的，比如，用户消费之后的通知短信，发送多了，会招致投诉。在单机场景下，可以使用并发API或者锁解决，但是在分布式场景中，就没有那么简单了。</p>
<p>分布式场景是多进程场景，相同服务的不同实例可能都不知道对方的存在，这个时候要确保只有一个实例执行了某个操作，方法之一就是使用分布式锁。</p>
<h2 id="分布式锁的特性"><a href="#分布式锁的特性" class="headerlink" title="分布式锁的特性"></a>分布式锁的特性</h2><p>根据分布式场景的特性，分布式锁需要具备以下一些特性：</p>
<ul>
<li>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</li>
<li>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li>
<li>锁超时:和本地锁一样支持锁超时，防止死锁。</li>
<li>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li>
<li>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</li>
<li>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。</li>
</ul>
<h2 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h2><p>下面我们看看常用的实现分布式锁的方法</p>
<h3 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h3><h4 id="使用数据库表做分布式锁"><a href="#使用数据库表做分布式锁" class="headerlink" title="使用数据库表做分布式锁"></a>使用数据库表做分布式锁</h4><p>要通过数据库实现分布式锁，最简单的就是给数据库里面插入一张锁表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `lock` (</span><br><span class="line">	`id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">not</span> <span class="keyword">null</span> AUTO_INCREMENT,</span><br><span class="line">    `resource_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    `node_info` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> null.</span><br><span class="line">    `count` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">    `<span class="keyword">desc</span>` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    `update_time` <span class="type">timestamp</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">    `create_time` <span class="type">timestamp</span> <span class="keyword">null</span> <span class="keyword">default</span> <span class="keyword">null</span></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `unique_resource` (`resource_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>

<p>当我们向锁住某个资源的时候，就插入一条记录，以资源名称和插入线程的名称（NodeInfo）为值。因为对resource_name做了唯一性约束，第二个请求达到数据库的时候先判断是否存在resource_name的记录，并且记录的node_info是不是当前线程的，是的话，就增加计数count，否则拒绝。</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-fenbushilock.png" alt="Lock示例"></p>
<p>释放锁的时候，删除记录就行了</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>数据库锁存在以下几个问题：</p>
<ol>
<li>强烈依赖数据库的可用性，一旦单点数据库宕机，业务就会不可用</li>
<li>锁没有失效时间，一旦解锁失败就会导致锁记录一直存在，其他线程无法再次获得锁</li>
<li>锁只能是非阻塞的，insert失败就会马上失败，没有等待队列一说</li>
<li>非公平锁</li>
</ol>
<h4 id="基于数据库排他锁做分布式锁"><a href="#基于数据库排他锁做分布式锁" class="headerlink" title="基于数据库排他锁做分布式锁"></a>基于数据库排他锁做分布式锁</h4><p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁。</p>
<p>如果执行失败，就会一直阻塞，直至成功。使用排他锁可以解决阻塞和无法释放锁的问题。</p>
<p>锁定之后宕机，数据库会自己释放锁。</p>
<p>加锁操作可以做成如下这种：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> xxx <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>解锁操作就可以是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>

<p>但是，如果这个排他锁一直不提交，就会占用数据库连接，长久会撑爆数据库的连接池。</p>
<h3 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h3><p>基于Zookeeper实现分布式锁，需要具备相关的Zookeeper的信息。</p>
<ul>
<li>Zookeeper 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 Zookeeper 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。</li>
<li>Zookeeper的数据以目录树的形式，每个目录称为 znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。</li>
<li>子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。</li>
<li>Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>上锁，改为创建临时有序节点，每个上锁的动作都能创建成功，只是他们的序号不同。只有序号最小的节点才可以用有锁，如果这个节点不是最小的序号，那么就watch序号比它小1号的前一个节点。因此，基于这个原理的锁，是一个公平锁。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>新建一个&#x2F;lock目录</li>
<li>每当需要竞争获取锁的时候，在&#x2F;lock目录下创建一个有序的临时节点（EPHEMERAL_SEQUENTIAL）</li>
<li>判断节点序号是不是所有节点中最小的，是的话，获取锁成功。否则，watch序号比本身小1的前一个节点</li>
<li>watch事件到来后，再次判断是否是最小的序号，成功获取锁后，执行代码，最后释放资源，删除当前节点。</li>
</ol>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>借助setNx命令。</p>
<p>如果不存在则更新，其可以很好的用来实现我们的分布式锁。对于某个资源加锁我们只需要</p>
<blockquote>
<p>setNx resourceName value</p>
</blockquote>
<p>这里有个问题，加锁了之后如果机器宕机那么这个锁就不会得到释放所以会加入过期时间，加入过期时间需要和setNx同一个原子操作，在Redis2.8之前我们需要使用Lua脚本达到我们的目的，但是redis2.8之后redis支持nx和ex操作是同一原子操作。</p>
<blockquote>
<p>set resourceName value ex 5 nx</p>
</blockquote>
<h4 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h4><p>redisson是在redis基础上实现的一套开源解决方案，不仅提供了一系列的分布式的java常用对象，还提供了许多分布式服务，宗旨是促进使用者对redis的关注分离，更多的关注业务逻辑的处理上。</p>
<p>Redission实现了Java的Lock接口</p>
<p>简单的使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config1.useSingleServer().setAddress(<span class="string">&quot;redis://xxxx1:xxx1&quot;</span>)</span><br><span class="line">                .setPassword(<span class="string">&quot;xxxx1&quot;</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient1</span> <span class="operator">=</span> Redisson.create(config1);</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config2.useSingleServer()</span><br><span class="line">                .setAddress(<span class="string">&quot;redis://xxxx2:xxx2&quot;</span>)</span><br><span class="line">                .setPassword(<span class="string">&quot;xxxx2&quot;</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient2</span> <span class="operator">=</span> Redisson.create(config2);</span><br><span class="line"></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config3.useSingleServer().</span><br><span class="line">                setAddress(<span class="string">&quot;redis://xxxx3:xxx3&quot;</span>)</span><br><span class="line">                .setPassword(<span class="string">&quot;xxxx3&quot;</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient3</span> <span class="operator">=</span> Redisson.create(config3);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockName</span> <span class="operator">=</span> <span class="string">&quot;redlock-test&quot;</span>;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonClient1.getLock(lockName);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonClient2.getLock(lockName);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonClient3.getLock(lockName);</span><br><span class="line"></span><br><span class="line">        <span class="type">RedissonRedLock</span> <span class="variable">redLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedissonRedLock</span>(lock1, lock2, lock3);</span><br><span class="line">        <span class="type">boolean</span> isLock;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isLock = redLock.tryLock(<span class="number">500</span>, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            System.out.println(<span class="string">&quot;isLock = &quot;</span> + isLock);</span><br><span class="line">            <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">                <span class="comment">// lock success, do something;</span></span><br><span class="line">                Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论如何, 最后都要解锁</span></span><br><span class="line">            redLock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;unlock success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-12-redission1.png" alt="Redission加锁过程"></p>
<p><img src="https://huhansi.github.io/images/2020-04-12-redission2.png" alt="Redission解锁过程"></p>
<h4 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h4><p>RedLock是基于redis实现的分布式锁，它能够保证以下特性：</p>
<ol>
<li>互斥性：在任何时候，只能有一个客户端能够持有锁；</li>
<li>避免死锁：当客户端拿到锁后，即使发生了网络分区或者客户端宕机，也不会发生死锁；（利用key的存活时间）</li>
<li>容错性：只要多数节点的redis实例正常运行，就能够对外提供服务，加锁或者释放锁；</li>
</ol>
<h5 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h5><p>假设有N个redis的master节点，这些节点是相互独立的（不需要主从或者其他协调的系统）。<strong>N推荐为奇数</strong></p>
<p>客户端在获取锁时，需要做以下操作：</p>
<ul>
<li>获取当前时间戳，以微秒为单位</li>
<li>使用相同的lockName和lockValue，尝试从N个节点获取锁。</li>
<li>在获取锁时，要求等待获取锁的时间远小于锁的释放时间，如锁的lease_time为10s，那么wait_time应该为5-50毫秒；避免因为redis实例挂掉，客户端需要等待更长的时间才能返回，即需要让客户端能够fast_fail；如果一个redis实例不可用，那么需要继续从下个redis实例获取锁</li>
<li>当从N个节点获取锁结束后，如果客户端能够从多数节点(N&#x2F;2 + 1)中成功获取锁，且获取锁的时间小于失效时间，那么可认为，客户端成功获得了锁。（获取锁的时间&#x3D;当前时间戳 - 步骤1的时间戳）</li>
<li>客户端成功获得锁后，那么锁的实际有效时间 &#x3D; 设置锁的有效时间 - 获取锁的时间。</li>
<li>客户端获取锁失败后，N个节点的redis实例都会释放锁，即使未能加锁成功。</li>
<li>当客户端无法获取到锁时，应该随机延时后进行重试，防止多个客户端在同一时间抢夺同一资源的锁（会导致脑裂，最终都不能获取到锁）。客户端获得超过半数节点的锁花费的时间越短，那么脑裂的概率就越低。所以，理想的情况下，客户端最好能够同时（并发）向所有redis发出set命令。</li>
<li>当客户端从多数节点获取锁失败时，应该尽快释放已经成功获取的锁，这样其他客户端不需要等待锁过期后再获取。（如果存在网络分区，客户端已经无法和redis进行通信，那么此时只能等待锁过期后自动释放）</li>
<li>向所有redis实例发送释放锁命令即可，不需要关心redis实例有没有成功上锁。</li>
</ul>
<h3 id="基于Consul实现的分布式锁"><a href="#基于Consul实现的分布式锁" class="headerlink" title="基于Consul实现的分布式锁"></a>基于Consul实现的分布式锁</h3><h4 id="基于K-x2F-V"><a href="#基于K-x2F-V" class="headerlink" title="基于K&#x2F;V"></a>基于K&#x2F;V</h4><p>Consul的KV支持acquire和release操作。<code>acquire/release</code>操作实现了一种类似 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Compare-and-swap">Check-And-Set</a>操作，这两个操作使用 Consul Session 进行操作：</p>
<ul>
<li><code>acquire</code>操作只有当 Key 的锁不存在持有者（Session）时才会返回 true，同时执行操作的 Session 会持有对该 Key 的锁；否则就返回false；</li>
<li><code>release</code>操作则是使用指定的 Session 来释放某个Key的锁，如果指定的 Session无效，那么会返回 false，否则就会set设置Value值，并返回 true。</li>
</ul>
<p>由于同一时间只有一个 Session 可以占有一个 Key 的锁，因此可以将一个 Key 当做一把锁，在访问临界资源时调用<code>acquire</code>操作实现 Lock 操作；在访问结束后调用<code>release</code>操作实现 Unlock 操作。</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-consul2.png" alt="基于KV和Session的分布式锁"></p>
<p>需要注意的是，上面的这个锁，如果一直没有释放的话，就永远释放不了了。因此，在创建session的时候需要给这个session加一个ttl，时间到了就自动释放锁。</p>
<h5 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> <span class="string">&quot;lock/&quot;</span>;  <span class="comment">// 同步锁参数前缀</span></span><br><span class="line">    <span class="keyword">private</span> ConsulClient consulClient;</span><br><span class="line">    <span class="keyword">private</span> String sessionName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sessionId</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String lockKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consulClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionName   同步锁的session名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey       同步锁在consul的KV存储中的Key路径，会自动增加prefix前缀，方便归类查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Lock</span><span class="params">(ConsulClient consulClient, String sessionName, String lockKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.consulClient = consulClient;</span><br><span class="line">        <span class="built_in">this</span>.sessionName = sessionName;</span><br><span class="line">        <span class="built_in">this</span>.lockKey = prefix + lockKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取同步锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> block     是否阻塞，直到获取到锁为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">lock</span><span class="params">(<span class="type">boolean</span> block)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sessionId != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(sessionId + <span class="string">&quot; - Already locked!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sessionId = createSession(sessionName);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">PutParams</span> <span class="variable">putParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutParams</span>();</span><br><span class="line">            putParams.setAcquireSession(sessionId);</span><br><span class="line">            <span class="keyword">if</span>(consulClient.setKVValue(lockKey, <span class="string">&quot;lock:&quot;</span> + LocalDateTime.now(), putParams).getValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(block) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放同步锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">PutParams</span> <span class="variable">putParams</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutParams</span>();</span><br><span class="line">        putParams.setReleaseSession(sessionId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> consulClient.setKVValue(lockKey, <span class="string">&quot;unlock:&quot;</span> + LocalDateTime.now(), putParams).getValue();</span><br><span class="line">        consulClient.sessionDestroy(sessionId, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">createSession</span><span class="params">(String sessionName)</span> &#123;</span><br><span class="line">        <span class="type">NewSession</span> <span class="variable">newSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NewSession</span>();</span><br><span class="line">        newSession.setName(sessionName);</span><br><span class="line">        <span class="keyword">return</span> consulClient.sessionCreate(newSession, <span class="literal">null</span>).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于Consul的分布式信号量"><a href="#基于Consul的分布式信号量" class="headerlink" title="基于Consul的分布式信号量"></a>基于Consul的分布式信号量</h4><p>上一个小章节中，利用Consul做了分布式锁，基于Consul的KV，但是只用到了K，没有用到V。如果把V也用上的话，我们就可以实现一个分布式信号量。</p>
<p>当然，也是借助acquire和release操作</p>
<ul>
<li><p>信号量存储：semaphore&#x2F;key</p>
</li>
<li><p>acquired操作：</p>
<ul>
<li>创建session</li>
<li>锁定key竞争者：semaphore&#x2F;key&#x2F;session</li>
<li>查询信号量：semaphore&#x2F;key&#x2F;.lock，可以获得如下内容（如果是第一次创建信号量，将获取不到，这个时候就直接创建）</li>
<li>如果持有者已达上限，返回false，如果阻塞模式，就继续尝试acquired操作</li>
<li>如果持有者未达上限，更新semaphore&#x2F;key&#x2F;.lock的内容，将当前线程的sessionId加入到holders中。注意：更新的时候需要设置cas，它的值是“查询信号量”步骤获得的“ModifyIndex”值，该值用于保证更新操作的基础没有被其他竞争者更新。如果更新成功，就开始执行具体逻辑。如果没有更新成功，说明有其他竞争者抢占了资源，返回false，阻塞模式下继续尝试acquired操作</li>
</ul>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;limit&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;holders&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;90c0772a-4bd3-3a3c-8215-3b8937e36027&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;93e5611d-5365-a374-8190-f80c4a7280ab&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>release操作：</p>
<ul>
<li>从semaphore&#x2F;key&#x2F;.lock的holders中移除当前sessionId</li>
<li>删除semaphore&#x2F;key&#x2F;session</li>
<li>删除当前的session</li>
</ul>
</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-14-consul3.png" alt="基于KV和Session的分布式信号量"></p>
<p>实际应用的时候，必须加入TTL的session清理以及对.lock资源中的无效holder进行清理的机制。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94704241">分布式锁的几种实现方式</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/42056183">分布式锁看这篇就够了</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1034053">基于Consul的分布式锁实现</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/docs/guides/semaphore.html">Distributed Semaphores with Sessions</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/" data-id="cl541frwi00315srw3ts5f78x" data-title="分布式锁的几种实现方式" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RedLock/" rel="tag">RedLock</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redission/" rel="tag">Redission</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Zookeeper/" rel="tag">Zookeeper</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="tag">分布式锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL/2020-04-11-MySQL中的各种锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/11/MySQL/2020-04-11-MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2020-04-10T16:00:00.000Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/11/MySQL/2020-04-11-MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/">MySQL中的各种锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL中的各种锁"><a href="#MySQL中的各种锁" class="headerlink" title="MySQL中的各种锁"></a>MySQL中的各种锁</h1><h2 id="MySQL的锁管理机制"><a href="#MySQL的锁管理机制" class="headerlink" title="MySQL的锁管理机制"></a>MySQL的锁管理机制</h2><p>相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-MySQL-lock.png" alt="MySQL锁管理机制">‘</p>
<ul>
<li><p>元数据锁（MDL，MetaData Lock）： 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。</p>
<p>  因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</p>
</li>
<li><p>存储引擎特有锁：InnoDB-行级锁、间隙锁；BDB-页级锁</p>
</li>
<li><p>表级锁：</p>
</li>
<li><p>全局读锁：对整个数据库实例加锁，命令是Flash tables with read lock（FTWRL）。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
</li>
</ul>
<h2 id="各种锁解析"><a href="#各种锁解析" class="headerlink" title="各种锁解析"></a>各种锁解析</h2><p>下面我们一起看一下MySQL中的各种锁。</p>
<h3 id="元数据锁（MDL，Meta-Data-Lock）"><a href="#元数据锁（MDL，Meta-Data-Lock）" class="headerlink" title="元数据锁（MDL，Meta Data Lock）"></a>元数据锁（MDL，Meta Data Lock）</h3><p>元数据锁是一个读写锁，因此，可以多线程的对一张表，进行增删改查操作，因为它此时加的是MDL读锁；但当要对表做结构变更操作的时候，就会加上 MDL 写锁。</p>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p><strong>MDL锁是没有超时时间的，因此，只要事务还没有提交，这个MDL锁就会一直锁着，在下面这种场景下就会x造成线程阻塞、业务中断。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. sessionA:</span><br><span class="line">begin;</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">2. sessionB:</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">3. sessionC:</span><br><span class="line">alter table t add f int;</span><br><span class="line">#会mdl锁住</span><br><span class="line"> </span><br><span class="line">4. sessionD:</span><br><span class="line">select * from t limit 1;</span><br></pre></td></tr></table></figure>

<p>如上例子，会话A申请了MDL读锁，但是没有提交；会话B也申请了读锁，正常执行（读锁不排他）；这时候会话C想要修改表字段，那么它就要获取这个表的写锁。但是因为会话A的读锁还没有释放，因此会话C阻塞，从而也造成后面的会话D阻塞。</p>
<p>解决办法就是找到这个长时间未执行完的事务，提交或者回滚即可。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul>
<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。<ul>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，<br>  锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>锁模式的兼容情况：</strong></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-lock-mode.jpg" alt="锁模式的兼容状况"></p>
<p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><ul>
<li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li>
<li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>  别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。</li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h4 id="使用间隙锁的目的"><a href="#使用间隙锁的目的" class="headerlink" title="使用间隙锁的目的"></a>使用间隙锁的目的</h4><p>使用间隙锁有以下目的：</p>
<ol>
<li>防止幻读，以满足相关隔离级别的要求；</li>
<li>满足恢复和复制的需要</li>
</ol>
<p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p>
<ol>
<li><p>MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p>
</li>
<li><p>MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p>
</li>
</ol>
<p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁的语法是</p>
<blockquote>
<p>LOCK TABLES table_name READ&#x2F;WRITE</p>
<p>例如：LOCK TABLES t1 READ， t2 WRITE</p>
</blockquote>
<p>如果表被其他线程锁定了，当前线程会等待，直到获取了锁为止。</p>
<p>可以执行以下命令来释放锁 </p>
<blockquote>
<p>UNLOCK  TABLES</p>
</blockquote>
<p>UNLOCK TABLES会释放当前线程获得的所有锁。另外，当前线程执行另一个LOCK TABLES或者与服务器连接被关闭时，当前线程获得的所有锁将会被隐式释放。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li>在用LOCK TABLES对InnoDB表加锁时，需要将AutoCommit设置为0，否则MySQL不会给表加锁</li>
<li>事务结束前，不要用UNLOCK TABLES 释放表锁，因为UNLOCK TABLES会隐式提交当前事务</li>
<li>COMMIT或者ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁</li>
<li>lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
</ol>
<p>在上面的例子中，如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<h3 id="全局读锁"><a href="#全局读锁" class="headerlink" title="全局读锁"></a>全局读锁</h3><p><strong>全局锁的典型使用场景是，做全库逻辑备份（mysqldump）。重新做主从时候</strong><br>也就是把整库每个表都 select 出来存成文本。</p>
<p>数据库只读状态的危险性：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<h4 id="全局锁两种方法"><a href="#全局锁两种方法" class="headerlink" title="全局锁两种方法"></a>全局锁两种方法</h4><ol>
<li>FLUSH TABLES WRITE READ LOCK</li>
<li>set global readonly&#x3D;true</li>
</ol>
<p>既然要全库只读，为什么不使用 set global readonly&#x3D;true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，建议用 FTWRL 方式，主要有几个原因：</p>
<ol>
<li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大.</li>
<li>在异常处理机制上有差异。如果执行FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
<li>readonly 对super用户权限无效</li>
</ol>
<h2 id="InnoDB加锁方法"><a href="#InnoDB加锁方法" class="headerlink" title="InnoDB加锁方法"></a>InnoDB加锁方法</h2><ul>
<li>意向锁是InnoDB自动加的，不需要用户干预；</li>
<li>对于UPDATE、INSERT和DELETE语句，InnoDB会自动给涉及的数据集加排他锁（X）</li>
<li>对于普通SELECT语句，InnoDB不会加锁</li>
<li>事务可以通过以下语句显示地给数据集加共享锁或排他锁<ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。其他事务仍可以查询记录并对当前数据集加共享锁。但如果当前事务需要对该数据集进行更新操作，则很有可能造成死锁</li>
<li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE.其他事务可以查询当前数据集，但是不能对该数据集加共享锁或排他锁。</li>
</ul>
</li>
</ul>
<p>InnoDB在事务执行的识货使用两阶段锁协议：</p>
<ol>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</li>
</ol>
<h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>当不同的事务或线程出现循环资源依赖的时候，就会出现死锁。</p>
<p>比如，事务A获取了记录R1的写锁，修改成功之后，准备获取记录R2的写锁；而事务B先获取了记录R2的写锁，修改成功之后，准备获取R1的写锁。此时，事务AB等在等对方释放锁，就会产生死循环，造成死锁。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-deat-lock.png" alt="死锁"></p>
<h3 id="死锁对策"><a href="#死锁对策" class="headerlink" title="死锁对策"></a>死锁对策</h3><ol>
<li>主动等待超时，由参数 <code>innodb_lock_wait_timeout</code> 设置，但是业务无法等待；</li>
<li>主动死锁检测（<code>innodb_deadlock_detect=on</code>）</li>
</ol>
<p>发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。</p>
<p>另外，我们可以采取以下方式避免死锁：</p>
<ul>
<li>通过表级锁来减少死锁产生的概率；</li>
<li>多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；</li>
<li>同一个事务尽可能做到一次锁定所需要的所有资源。</li>
</ul>
<p>另外，死锁检测也非常耗费资源，判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://hoxis.github.io/mysql-zhuanlan-06-07-lock.html">MySQL实战 | 06&#x2F;07 简单说说MySQL中的锁</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/eygle/article/details/94384306">史上最详细MySQL全局锁和表锁</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29150809">MySQL锁总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/11/MySQL/2020-04-11-MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/" data-id="cl541frua00075srw5nuica9l" data-title="MySQL中的各种锁" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%BB%E9%94%81/" rel="tag">死锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL/2020-04-11-MySQL事务原理以及4种隔离级别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/11/MySQL/2020-04-11-MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2020-04-10T16:00:00.000Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/MySQL/">MySQL</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/11/MySQL/2020-04-11-MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">MySQL事务原理以及4种隔离级别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL事务原理及4种隔离级别"><a href="#MySQL事务原理及4种隔离级别" class="headerlink" title="MySQL事务原理及4种隔离级别"></a>MySQL事务原理及4种隔离级别</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是关系型数据区区别于其他NoSQL数据库的一个主要方面，是保障数据一致性的重要手段。</p>
<p>事务会把数据库从一种一致性的状态转移到另外一种一致性的状态。在数据库事务提交的时候，事务可以确保要么所有的修改都已经生效保存，要么所有的修改都不保存。</p>
<p>拿一个常见的银行转账作为例子：A账户给B账户转账1000块买东西。在这个交易的过程中，有几个问题需要思考：</p>
<ul>
<li>如何<strong>同时保证</strong>上述交易中A账户总金额减少1000，B账户总金额增加1000？ （A）</li>
<li>A 账户如果同时在和C账户交易，如何让这两笔交易互不影响？（I）</li>
<li>如果交易完成时数据库突然崩溃，如何保证交易数据成功保存在数据库中？（D）</li>
<li>如何在支持大量交易的同时，保证数据的合法性（没有钱凭空产生或消失）？（C）</li>
</ul>
<p>要保证交易正常可靠地进行，数据库就得解决上面的四个问题，这也就是<code>事务</code>诞生的背景，它能解决上面的四个问题，对应地，它拥有四大特性：</p>
<ul>
<li>原子性（<strong>A</strong>tomicity）：一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作。</li>
<li>隔离性（<strong>I</strong>solation）：<strong>通常来说</strong>，一个事务所做的修改在最终提交以前，对其他事务是不可见的。下文讨论隔离级别的时候，就会发现为什么要说“通常来说”。</li>
<li>持久性（<strong>D</strong>urability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时，即使系统崩溃，修改的数据也不会丢失。</li>
<li>一致性（<strong>C</strong>onsistency）：数据库总是从一个一致性的状态转换到另一个一致性的状态。</li>
</ul>
<h2 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h2><p>事务的最终目的是为了保证数据的一致性，因此，ACID中的AID就是为了实现C而做的铺垫。下面就分别看看原子性（A）、隔离性（I）、持久性（D）的实现原理。</p>
<h3 id="原子性实现原理（MySQL）"><a href="#原子性实现原理（MySQL）" class="headerlink" title="原子性实现原理（MySQL）"></a>原子性实现原理（MySQL）</h3><p>Undo Log是MySQL实现事务原子性的基础。当事务对数据库进行修改时，InnoDB会生成对应的Undo Log；如果事务实行失败或者调用了rollback，导致事务需要回滚，便可以利用Undo Log中的信息将数据回滚到修改之前的样子。</p>
<p>Undo Log属于逻辑日志，它记录的是sql执行的相关信息。当发生回滚时，InnoDB会根据Undo Log的内容做与之前相反的工作：对于每个Insert，回滚时会delete；每个delete，回滚时会insert；每个update就做一个相反的update，改回原数据。</p>
<p>拿上文A转账给B账户的例子来说</p>
<p>假设初始时候，A账户有10000，B账号有4000</p>
<blockquote>
<p>账户表-account</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>account_name</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>10000</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>4000</td>
</tr>
</tbody></table>
<p>执行了一个转账事务之后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<p>如果事务成功提交了，account表的内容就变成了</p>
<blockquote>
<p>账户表-account</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>account_name</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>9000</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>5000</td>
</tr>
</tbody></table>
<p>另外，MySQL还会给这个事务生成Undo Log</p>
<table>
<thead>
<tr>
<th>type</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>update</td>
<td>table: account id:1 balance:10000</td>
</tr>
<tr>
<td>update</td>
<td>table:account id:2 balance:4000</td>
</tr>
</tbody></table>
<p>如果此时事务需要回滚，那么就可以根据Undo Log的信息，把数据恢复到修改之前的状态了。</p>
<h3 id="隔离性实现原理（MySQL）"><a href="#隔离性实现原理（MySQL）" class="headerlink" title="隔离性实现原理（MySQL）"></a>隔离性实现原理（MySQL）</h3><p>隔离性研究或者保证的是不同事务之间的影响。事务内部的操作和其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>隔离性主要是通过锁机制和MVCC保证的。</p>
<p>锁机制保证一个事务的<strong>写</strong>操作不对另外一个事务的<strong>写</strong>操作产生影响</p>
<p>MVCC保证一个事务的<strong>写</strong>操作不对另外一个事务的<strong>读</strong>操作产生影响</p>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>锁机制的原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得相应的锁之后，事务才可以修改数据；在当前事务操作期间，其他事务如果要来修改，只能等待当前事务提交或者回滚后释放锁。</p>
<p>MySQL锁按照粒度可以分为：</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。支持引擎-MyISAM、MEMORY、InnoDB</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。支持引擎-InnoDB</li>
<li>页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。支持引擎-BDB</li>
<li>全局锁：对整个数据库实例加锁</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC全称是多版本并发控制（MultiVersion Concurrency Control）。InnoDB的MVCC是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事物，系统版本号都会自动递增。事物开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作比较。</p>
<h3 id="持久性实现原理（MySQL）"><a href="#持久性实现原理（MySQL）" class="headerlink" title="持久性实现原理（MySQL）"></a>持久性实现原理（MySQL）</h3><p>持久性原理是通过Redo Log实现的。</p>
<p>数据库的数据是存放到磁盘中的，但如果每次读写数据都进行磁盘ID，效率无疑会很低下。因此，InnoDB引入了Buffer pool。Buffer pool包含了部分数据页的映射，作为缓冲。数据先从Buffer Pool中读取，如果没有，从磁盘读取后再放入Buffer Pool；同理，写入的话，也是先写入到Buffer Pool中，然后定期刷回磁盘。</p>
<p>Buffer Pool的使用大大提高了读写数据的效率，但也产生了新的问题：如果在Buffer Pool中的新数据还没有刷新到磁盘之前数据库就宕机了，就会导致数据丢失，无法保证事务的持久性。</p>
<p>于是Redo Log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在Redo Log中记录这次操作；当事务提交时，会调用fsync接口对Redo Log进行刷盘。如果MySQL宕机，重启的时候可以读取Redo Log中的数据，对数据库进行恢复。</p>
<p>Redo Log采用的是WAL（Write-Ahead Loggin，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因为MySQL宕机二而消失，从而满足了持久性要求。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL标准中定义了四种隔离级别。级别越低的可以执行越高的并发， 但同时实现复杂度以及开销也越大。</p>
<p>MySQL中隔离级别有以下四种（级别由低到高）：</p>
<ul>
<li><strong>READ UNCOMMITED （读未提交）</strong></li>
<li><strong>READ COMMITED（读提交）</strong></li>
<li><strong>REPEATABLE READ（可重复读）</strong></li>
<li><strong>SERIALIZABLE（串行化）</strong></li>
</ul>
<p>我们还是从银行转账的例子举例说明这四个隔离级别。</p>
<h3 id="READ-UNCOMMITED（读未提交）"><a href="#READ-UNCOMMITED（读未提交）" class="headerlink" title="READ UNCOMMITED（读未提交）"></a>READ UNCOMMITED（读未提交）</h3><table>
<thead>
<tr>
<th>时间</th>
<th>事务T1</th>
<th>账户A余额</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>10000</td>
<td>start transaction</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>update account set balance &#x3D; balance - 1000 where id &#x3D; 1</td>
<td>10000</td>
<td>select balance from account where id &#x3D; 1</td>
<td>9000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>commit</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>9000</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在时间1，发起了两个事务T1和T2，T1给账号A扣除1000，T2查询账号A余额。在时间点2的时候，T1更新了A的余额，但是没有提交，此时T2查询A的余额，取得9000。在时间点4的时候，事务T1 commit。此时余额才真正为9000.</p>
<p>试想一下，如果事务T1在时间点4执行的时候发生异常，回滚了，那么A账号的余额还是为10000，那么事务在时间点2读取到的就是脏数据了。这就叫<strong>脏读</strong>。</p>
<h3 id="READ-COMMITED（读提交）"><a href="#READ-COMMITED（读提交）" class="headerlink" title="READ COMMITED（读提交）"></a>READ COMMITED（读提交）</h3><p>还是两个事务T1和T2修改账号A余额的例子。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务T1</th>
<th>结果</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>余额1000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select balance from account where id &#x3D; 1</td>
<td>余额10000</td>
<td>start transaction</td>
<td>余额10000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>update account set balance &#x3D; balance - 1000 where id &#x3D; 1</td>
<td>余额10000</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>commit</td>
<td>余额9000</td>
</tr>
<tr>
<td>5</td>
<td>select balance from account where id &#x3D; 1</td>
<td>余额9000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>造成这种情况的原因就是，事务T1在执行而未提交的过程中，事务T2修改了事务T1的数据项，并且这个修改对事务T1可见，造成事务T1两次读取到的数据不一致。这就叫<strong>不可重复读</strong>。</p>
<h3 id="Repeatable-Read（可重复读）"><a href="#Repeatable-Read（可重复读）" class="headerlink" title="Repeatable Read（可重复读）"></a>Repeatable Read（可重复读）</h3><p>在可重复读这个级别，是当前事务读取的数据是不会读取到其他事务对当前事务数据的修改的。但是它无法避免读取到新的数据。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务T1</th>
<th>结果</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>10000；<br />4000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select balance from account；</td>
<td>10000<br />4000</td>
<td>start transaction</td>
<td>10000<br />4000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>insert into account values(3, “C”, 8000)</td>
<td>10000<br />4000</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>commit</td>
<td>10000<br />4000<br />8000</td>
</tr>
<tr>
<td>5</td>
<td>select balance from account;</td>
<td>10000<br />4000<br />8000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Serializable（串行化）"><a href="#Serializable（串行化）" class="headerlink" title="Serializable（串行化）"></a>Serializable（串行化）</h3><p>最高级别，这个级别下，所有的事务都串行执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43493165">深入理解数据库事务</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86347112">深入学习MySQL事务：ACID特性的实现原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/11/MySQL/2020-04-11-MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" data-id="cl541fruf000b5srw7d0b0ljo" data-title="MySQL事务原理以及4种隔离级别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACID/" rel="tag">ACID</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%B2%E8%A1%8C%E5%8C%96/" rel="tag">串行化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/" rel="tag">可重复读</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E6%8F%90%E4%BA%A4/" rel="tag">读提交</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4/" rel="tag">读未提交</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" rel="tag">隔离级别</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL/MySQL中的各种锁" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/11/MySQL/MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/" class="article-date">
  <time class="dt-published" datetime="2020-04-10T16:00:00.000Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/11/MySQL/MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/">MySQL中的各种锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL中的各种锁"><a href="#MySQL中的各种锁" class="headerlink" title="MySQL中的各种锁"></a>MySQL中的各种锁</h1><h2 id="MySQL的锁管理机制"><a href="#MySQL的锁管理机制" class="headerlink" title="MySQL的锁管理机制"></a>MySQL的锁管理机制</h2><p>相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-MySQL-lock.png" alt="MySQL锁管理机制">‘</p>
<ul>
<li><p>元数据锁（MDL，MetaData Lock）： 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。</p>
<p>  因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</p>
</li>
<li><p>存储引擎特有锁：InnoDB-行级锁、间隙锁；BDB-页级锁</p>
</li>
<li><p>表级锁：</p>
</li>
<li><p>全局读锁：对整个数据库实例加锁，命令是Flash tables with read lock（FTWRL）。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
</li>
</ul>
<h2 id="各种锁解析"><a href="#各种锁解析" class="headerlink" title="各种锁解析"></a>各种锁解析</h2><p>下面我们一起看一下MySQL中的各种锁。</p>
<h3 id="元数据锁（MDL，Meta-Data-Lock）"><a href="#元数据锁（MDL，Meta-Data-Lock）" class="headerlink" title="元数据锁（MDL，Meta Data Lock）"></a>元数据锁（MDL，Meta Data Lock）</h3><p>元数据锁是一个读写锁，因此，可以多线程的对一张表，进行增删改查操作，因为它此时加的是MDL读锁；但当要对表做结构变更操作的时候，就会加上 MDL 写锁。</p>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p><strong>MDL锁是没有超时时间的，因此，只要事务还没有提交，这个MDL锁就会一直锁着，在下面这种场景下就会x造成线程阻塞、业务中断。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. sessionA:</span><br><span class="line">begin;</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">2. sessionB:</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">3. sessionC:</span><br><span class="line">alter table t add f int;</span><br><span class="line">#会mdl锁住</span><br><span class="line"> </span><br><span class="line">4. sessionD:</span><br><span class="line">select * from t limit 1;</span><br></pre></td></tr></table></figure>

<p>如上例子，会话A申请了MDL读锁，但是没有提交；会话B也申请了读锁，正常执行（读锁不排他）；这时候会话C想要修改表字段，那么它就要获取这个表的写锁。但是因为会话A的读锁还没有释放，因此会话C阻塞，从而也造成后面的会话D阻塞。</p>
<p>解决办法就是找到这个长时间未执行完的事务，提交或者回滚即可。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul>
<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。<ul>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，<br>  锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>锁模式的兼容情况：</strong></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-lock-mode.jpg" alt="锁模式的兼容状况"></p>
<p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><ul>
<li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li>
<li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>  别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。</li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h4 id="使用间隙锁的目的"><a href="#使用间隙锁的目的" class="headerlink" title="使用间隙锁的目的"></a>使用间隙锁的目的</h4><p>使用间隙锁有以下目的：</p>
<ol>
<li>防止幻读，以满足相关隔离级别的要求；</li>
<li>满足恢复和复制的需要</li>
</ol>
<p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p>
<ol>
<li><p>MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p>
</li>
<li><p>MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p>
</li>
</ol>
<p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁的语法是</p>
<blockquote>
<p>LOCK TABLES table_name READ&#x2F;WRITE</p>
<p>例如：LOCK TABLES t1 READ， t2 WRITE</p>
</blockquote>
<p>如果表被其他线程锁定了，当前线程会等待，直到获取了锁为止。</p>
<p>可以执行以下命令来释放锁 </p>
<blockquote>
<p>UNLOCK  TABLES</p>
</blockquote>
<p>UNLOCK TABLES会释放当前线程获得的所有锁。另外，当前线程执行另一个LOCK TABLES或者与服务器连接被关闭时，当前线程获得的所有锁将会被隐式释放。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li>在用LOCK TABLES对InnoDB表加锁时，需要将AutoCommit设置为0，否则MySQL不会给表加锁</li>
<li>事务结束前，不要用UNLOCK TABLES 释放表锁，因为UNLOCK TABLES会隐式提交当前事务</li>
<li>COMMIT或者ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁</li>
<li>lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
</ol>
<p>在上面的例子中，如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<h3 id="全局读锁"><a href="#全局读锁" class="headerlink" title="全局读锁"></a>全局读锁</h3><p><strong>全局锁的典型使用场景是，做全库逻辑备份（mysqldump）。重新做主从时候</strong><br>也就是把整库每个表都 select 出来存成文本。</p>
<p>数据库只读状态的危险性：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<h4 id="全局锁两种方法"><a href="#全局锁两种方法" class="headerlink" title="全局锁两种方法"></a>全局锁两种方法</h4><ol>
<li>FLUSH TABLES WRITE READ LOCK</li>
<li>set global readonly&#x3D;true</li>
</ol>
<p>既然要全库只读，为什么不使用 set global readonly&#x3D;true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，建议用 FTWRL 方式，主要有几个原因：</p>
<ol>
<li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大.</li>
<li>在异常处理机制上有差异。如果执行FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
<li>readonly 对super用户权限无效</li>
</ol>
<h2 id="InnoDB加锁方法"><a href="#InnoDB加锁方法" class="headerlink" title="InnoDB加锁方法"></a>InnoDB加锁方法</h2><ul>
<li>意向锁是InnoDB自动加的，不需要用户干预；</li>
<li>对于UPDATE、INSERT和DELETE语句，InnoDB会自动给涉及的数据集加排他锁（X）</li>
<li>对于普通SELECT语句，InnoDB不会加锁</li>
<li>事务可以通过以下语句显示地给数据集加共享锁或排他锁<ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。其他事务仍可以查询记录并对当前数据集加共享锁。但如果当前事务需要对该数据集进行更新操作，则很有可能造成死锁</li>
<li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE.其他事务可以查询当前数据集，但是不能对该数据集加共享锁或排他锁。</li>
</ul>
</li>
</ul>
<p>InnoDB在事务执行的识货使用两阶段锁协议：</p>
<ol>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</li>
</ol>
<h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>当不同的事务或线程出现循环资源依赖的时候，就会出现死锁。</p>
<p>比如，事务A获取了记录R1的写锁，修改成功之后，准备获取记录R2的写锁；而事务B先获取了记录R2的写锁，修改成功之后，准备获取R1的写锁。此时，事务AB等在等对方释放锁，就会产生死循环，造成死锁。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-deat-lock.png" alt="死锁"></p>
<h3 id="死锁对策"><a href="#死锁对策" class="headerlink" title="死锁对策"></a>死锁对策</h3><ol>
<li>主动等待超时，由参数 <code>innodb_lock_wait_timeout</code> 设置，但是业务无法等待；</li>
<li>主动死锁检测（<code>innodb_deadlock_detect=on</code>）</li>
</ol>
<p>发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。</p>
<p>另外，我们可以采取以下方式避免死锁：</p>
<ul>
<li>通过表级锁来减少死锁产生的概率；</li>
<li>多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；</li>
<li>同一个事务尽可能做到一次锁定所需要的所有资源。</li>
</ul>
<p>另外，死锁检测也非常耗费资源，判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://hoxis.github.io/mysql-zhuanlan-06-07-lock.html">MySQL实战 | 06&#x2F;07 简单说说MySQL中的锁</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/eygle/article/details/94384306">史上最详细MySQL全局锁和表锁</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29150809">MySQL锁总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/11/MySQL/MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/" data-id="cl541fruz000u5srw7f175h5y" data-title="MySQL中的各种锁" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%BB%E9%94%81/" rel="tag">死锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL/MySQL事务原理以及4种隔离级别" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/11/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" class="article-date">
  <time class="dt-published" datetime="2020-04-10T16:00:00.000Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/11/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">MySQL事务原理以及4种隔离级别</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MySQL事务原理及4种隔离级别"><a href="#MySQL事务原理及4种隔离级别" class="headerlink" title="MySQL事务原理及4种隔离级别"></a>MySQL事务原理及4种隔离级别</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是关系型数据区区别于其他NoSQL数据库的一个主要方面，是保障数据一致性的重要手段。</p>
<p>事务会把数据库从一种一致性的状态转移到另外一种一致性的状态。在数据库事务提交的时候，事务可以确保要么所有的修改都已经生效保存，要么所有的修改都不保存。</p>
<p>拿一个常见的银行转账作为例子：A账户给B账户转账1000块买东西。在这个交易的过程中，有几个问题需要思考：</p>
<ul>
<li>如何<strong>同时保证</strong>上述交易中A账户总金额减少1000，B账户总金额增加1000？ （A）</li>
<li>A 账户如果同时在和C账户交易，如何让这两笔交易互不影响？（I）</li>
<li>如果交易完成时数据库突然崩溃，如何保证交易数据成功保存在数据库中？（D）</li>
<li>如何在支持大量交易的同时，保证数据的合法性（没有钱凭空产生或消失）？（C）</li>
</ul>
<p>要保证交易正常可靠地进行，数据库就得解决上面的四个问题，这也就是<code>事务</code>诞生的背景，它能解决上面的四个问题，对应地，它拥有四大特性：</p>
<ul>
<li>原子性（<strong>A</strong>tomicity）：一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作。</li>
<li>隔离性（<strong>I</strong>solation）：<strong>通常来说</strong>，一个事务所做的修改在最终提交以前，对其他事务是不可见的。下文讨论隔离级别的时候，就会发现为什么要说“通常来说”。</li>
<li>持久性（<strong>D</strong>urability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时，即使系统崩溃，修改的数据也不会丢失。</li>
<li>一致性（<strong>C</strong>onsistency）：数据库总是从一个一致性的状态转换到另一个一致性的状态。</li>
</ul>
<h2 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h2><p>事务的最终目的是为了保证数据的一致性，因此，ACID中的AID就是为了实现C而做的铺垫。下面就分别看看原子性（A）、隔离性（I）、持久性（D）的实现原理。</p>
<h3 id="原子性实现原理（MySQL）"><a href="#原子性实现原理（MySQL）" class="headerlink" title="原子性实现原理（MySQL）"></a>原子性实现原理（MySQL）</h3><p>Undo Log是MySQL实现事务原子性的基础。当事务对数据库进行修改时，InnoDB会生成对应的Undo Log；如果事务实行失败或者调用了roolback，导致事务需要回滚，便可以利用Undo Log中的信息将数据回滚到修改之前的样子。</p>
<p>Undo Log属于逻辑日志，它记录的是sql执行的相关信息。当发生回滚时，InnoDB会根据Undo Log的内容做与之前相反的工作：对于每个Insert，回滚时会delete；每个delete，回滚时会insert；每个update就做一个相反的update，改回原数据。</p>
<p>拿上文A转账给B账户的例子来说</p>
<p>假设初始时候，A账户有10000，B账号有4000</p>
<blockquote>
<p>账户表-account</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>account_name</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>10000</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>4000</td>
</tr>
</tbody></table>
<p>执行了一个转账事务之后</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<p>如果事务成功提交了，account表的内容就变成了</p>
<blockquote>
<p>账户表-account</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>account_name</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>9000</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>5000</td>
</tr>
</tbody></table>
<p>另外，MySQL还会给这个事务生成Undo Log</p>
<table>
<thead>
<tr>
<th>type</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>update</td>
<td>table: account id:1 balance:10000</td>
</tr>
<tr>
<td>update</td>
<td>table:account id:2 balance:4000</td>
</tr>
</tbody></table>
<p>如果此时事务需要回滚，那么就可以根据Undo Log的信息，把数据恢复到修改之前的状态了。</p>
<h3 id="隔离性实现原理（MySQL）"><a href="#隔离性实现原理（MySQL）" class="headerlink" title="隔离性实现原理（MySQL）"></a>隔离性实现原理（MySQL）</h3><p>隔离性研究或者保证的是不同事务之间的影响。事务内部的操作和其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>隔离性主要是通过锁机制和MVCC保证的。</p>
<p>锁机制保证一个事务的<strong>写</strong>操作不对另外一个事务的<strong>写</strong>操作产生影响</p>
<p>MVCC保证一个事务的<strong>写</strong>操作不对另外一个事务的<strong>读</strong>操作产生影响</p>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>锁机制的原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得相应的锁之后，事务才可以修改数据；在当前事务操作期间，其他事务如果要来修改，只能等待当前事务提交或者回滚后释放锁。</p>
<p>MySQL锁按照粒度可以分为：</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。支持引擎-MyISAM、MEMORY、InnoDB</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。支持引擎-InnoDB</li>
<li>页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。支持引擎-BDB</li>
<li>全局所：对整个数据库实例加锁</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC全称是多版本并发控制（MultiVersion Concurrency Control）。InnoDB的MVCC是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事物，系统版本号都会自动递增。事物开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作比较。</p>
<h3 id="持久性实现原理（MySQL）"><a href="#持久性实现原理（MySQL）" class="headerlink" title="持久性实现原理（MySQL）"></a>持久性实现原理（MySQL）</h3><p>持久性原理是通过Redo Log实现的。</p>
<p>数据库的数据是存放到磁盘中的，但如果每次读写数据都进行磁盘ID，效率无疑会很低下。因此，InnoDB引入了Buffer pool。Buffer pool包含了部分数据页的映射，作为缓冲。数据先从Buffer Pool中读取，如果没有，从磁盘读取后再放入Buffer Pool；同理，写入的话，也是先写入到Buffer Pool中，然后定期刷回磁盘。</p>
<p>Buffer Pool的使用大大提高了读写数据的效率，但也产生了新的问题：如果在Buffer Pool中的新数据还没有刷新到磁盘之前数据库就宕机了，就会导致数据丢失，误报保证事务的持久性。</p>
<p>于是Redo Log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在Redo Log中记录这次操作；当事务提交时，会调用fsync接口对Redo Log进行刷盘。如果MySQL宕机，重启的时候可以读取Redo Log中的数据，对数据库进行恢复。</p>
<p>Redo Log采用的是WAL（Write-Ahead Loggin，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因为MySQL宕机二小时，从而满足了持久性要求。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL标准中定义了四种隔离级别。级别越低的可以执行越高的并发， 但同时实现复杂度以及开销也越大。</p>
<p>MySQL中隔离级别有以下四种（级别由低到高）：</p>
<ul>
<li><strong>READ UNCOMMITED （读未提交）</strong></li>
<li><strong>READ COMMITED（读提交）</strong></li>
<li><strong>REPEATABLE READ（可重复读）</strong></li>
<li><strong>SERIALIZABLE（串行化）</strong></li>
</ul>
<p>我们还是从银行转账的例子举例说明这四个隔离级别。</p>
<h3 id="READ-UNCOMMITED（读未提交）"><a href="#READ-UNCOMMITED（读未提交）" class="headerlink" title="READ UNCOMMITED（读未提交）"></a>READ UNCOMMITED（读未提交）</h3><table>
<thead>
<tr>
<th>时间</th>
<th>事务T1</th>
<th>账户A余额</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>10000</td>
<td>start transaction</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>update account set balance &#x3D; balance - 1000 where id &#x3D; 1</td>
<td>10000</td>
<td>select balance from account where id &#x3D; 1</td>
<td>9000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>commit</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>9000</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在时间1，发起了两个事务T1和T2，T1给账号A扣除1000，T2查询账号A余额。在时间点2的时候，T1更新了A的余额，但是没有提交，此时T2查询A的余额，取得9000。在时间点4的时候，事务T1 commit。此时余额才真正为9000.</p>
<p>试想一下，如果事务T1在时间点4执行的时候发生异常，回滚了，那么A账号的余额还是为10000，那么事务在时间点2读取到的就是脏数据了。这就叫<strong>脏读</strong>。</p>
<h3 id="READ-COMMITED（读提交）"><a href="#READ-COMMITED（读提交）" class="headerlink" title="READ COMMITED（读提交）"></a>READ COMMITED（读提交）</h3><p>还是两个事务T1和T2修改账号A余额的例子。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务T1</th>
<th>结果</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>余额1000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select balance from account where id &#x3D; 1</td>
<td>余额10000</td>
<td>start transaction</td>
<td>余额10000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>update account set balance &#x3D; balance - 1000 where id &#x3D; 1</td>
<td>余额10000</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>commit</td>
<td>余额9000</td>
</tr>
<tr>
<td>5</td>
<td>select balance from account where id &#x3D; 1</td>
<td>余额9000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>造成这种情况的原因就是，事务T1在执行而未提交的过程中，事务T2修改了事务T1的数据项，并且这个修改对事务T1可见，造成事务T1两次读取到的数据不一致。这就叫<strong>不可重复读</strong>。</p>
<h3 id="Repeatable-Read（可重复读）"><a href="#Repeatable-Read（可重复读）" class="headerlink" title="Repeatable Read（可重复读）"></a>Repeatable Read（可重复读）</h3><p>在可重复读这个级别，是当前事务读取的数据是不会读取到其他事务对当前事务数据的修改的。但是它无法避免读取到新的数据。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务T1</th>
<th>结果</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>10000；<br />4000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select balance from account；</td>
<td>10000<br />4000</td>
<td>start transaction</td>
<td>10000<br />4000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>insert into account values(3, “C”, 8000)</td>
<td>10000<br />4000</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>commit</td>
<td>10000<br />4000<br />8000</td>
</tr>
<tr>
<td>5</td>
<td>select balance from account;</td>
<td>10000<br />4000<br />8000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Serializable（串行化）"><a href="#Serializable（串行化）" class="headerlink" title="Serializable（串行化）"></a>Serializable（串行化）</h3><p>最高级别，这个级别下，所有的事务都串行执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43493165">深入理解数据库事务</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/86347112">深入学习MySQL事务：ACID特性的实现原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/11/MySQL/MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" data-id="cl541frv2000z5srw2de69rp9" data-title="MySQL事务原理以及4种隔离级别" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACID/" rel="tag">ACID</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%B2%E8%A1%8C%E5%8C%96/" rel="tag">串行化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/" rel="tag">可重复读</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E6%8F%90%E4%BA%A4/" rel="tag">读提交</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4/" rel="tag">读未提交</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" rel="tag">隔离级别</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MySQL/MySQL分库分表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/04/11/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2020-04-10T16:00:00.000Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/04/11/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">MySQL中的各种锁</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="MySQL中的各种锁"><a href="#MySQL中的各种锁" class="headerlink" title="MySQL中的各种锁"></a>MySQL中的各种锁</h2><h2 id="MySQL的锁管理机制"><a href="#MySQL的锁管理机制" class="headerlink" title="MySQL的锁管理机制"></a>MySQL的锁管理机制</h2><p>相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-MySQL-lock.png" alt="MySQL锁管理机制">‘</p>
<ul>
<li><p>元数据锁（MDL，MetaData Lock）： 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。</p>
<p>  因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</p>
</li>
<li><p>存储引擎特有锁：InnoDB-行级锁、间隙锁；BDB-页级锁</p>
</li>
<li><p>表级锁：</p>
</li>
<li><p>全局读锁：对整个数据库实例加锁，命令是Flash tables with read lock（FTWRL）。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
</li>
</ul>
<h2 id="各种锁解析"><a href="#各种锁解析" class="headerlink" title="各种锁解析"></a>各种锁解析</h2><p>下面我们一起看一下MySQL中的各种锁。</p>
<h3 id="元数据锁（MDL，Meta-Data-Lock）"><a href="#元数据锁（MDL，Meta-Data-Lock）" class="headerlink" title="元数据锁（MDL，Meta Data Lock）"></a>元数据锁（MDL，Meta Data Lock）</h3><p>元数据锁是一个读写锁，因此，可以多线程的对一张表，进行增删改查操作，因为它此时加的是MDL读锁；但当要对表做结构变更操作的时候，就会加上 MDL 写锁。</p>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p><strong>MDL锁是没有超时时间的，因此，只要事务还没有提交，这个MDL锁就会一直锁着，在下面这种场景下就会x造成线程阻塞、业务中断。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. sessionA:</span><br><span class="line">begin;</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">2. sessionB:</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">3. sessionC:</span><br><span class="line">alter table t add f int;</span><br><span class="line">#会mdl锁住</span><br><span class="line"> </span><br><span class="line">4. sessionD:</span><br><span class="line">select * from t limit 1;</span><br></pre></td></tr></table></figure>

<p>如上例子，会话A申请了MDL读锁，但是没有提交；会话B也申请了读锁，正常执行（读锁不排他）；这时候会话C想要修改表字段，那么它就要获取这个表的写锁。但是因为会话A的读锁还没有释放，因此会话C阻塞，从而也造成后面的会话D阻塞。</p>
<p>解决办法就是找到这个长时间未执行完的事务，提交或者回滚即可。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul>
<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。<ul>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，<br>  锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>锁模式的兼容情况：</strong></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-lock-mode.jpg" alt="锁模式的兼容状况"></p>
<p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><ul>
<li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li>
<li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>  别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。</li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h4 id="使用间隙锁的目的"><a href="#使用间隙锁的目的" class="headerlink" title="使用间隙锁的目的"></a>使用间隙锁的目的</h4><p>使用间隙锁有以下目的：</p>
<ol>
<li>防止幻读，以满足相关隔离级别的要求；</li>
<li>满足恢复和复制的需要</li>
</ol>
<p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p>
<ol>
<li><p>MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p>
</li>
<li><p>MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p>
</li>
</ol>
<p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁的语法是</p>
<blockquote>
<p>LOCK TABLES table_name READ&#x2F;WRITE</p>
<p>例如：LOCK TABLES t1 READ， t2 WRITE</p>
</blockquote>
<p>如果表被其他线程锁定了，当前线程会等待，直到获取了锁为止。</p>
<p>可以执行以下命令来释放锁 </p>
<blockquote>
<p>UNLOCK  TABLES</p>
</blockquote>
<p>UNLOCK TABLES会释放当前线程获得的所有锁。另外，当前线程执行另一个LOCK TABLES或者与服务器连接被关闭时，当前线程获得的所有锁将会被隐式释放。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li>在用LOCK TABLES对InnoDB表加锁时，需要将AutoCommit设置为0，否则MySQL不会给表加锁</li>
<li>事务结束前，不要用UNLOCK TABLES 释放表锁，因为UNLOCK TABLES会隐式提交当前事务</li>
<li>COMMIT或者ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁</li>
<li>lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
</ol>
<p>在上面的例子中，如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<h3 id="全局读锁"><a href="#全局读锁" class="headerlink" title="全局读锁"></a>全局读锁</h3><p><strong>全局锁的典型使用场景是，做全库逻辑备份（mysqldump）。重新做主从时候</strong><br>也就是把整库每个表都 select 出来存成文本。</p>
<p>数据库只读状态的危险性：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<h4 id="全局锁两种方法"><a href="#全局锁两种方法" class="headerlink" title="全局锁两种方法"></a>全局锁两种方法</h4><ol>
<li>FLUSH TABLES WRITE READ LOCK</li>
<li>set global readonly&#x3D;true</li>
</ol>
<p>既然要全库只读，为什么不使用 set global readonly&#x3D;true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，建议用 FTWRL 方式，主要有几个原因：</p>
<ol>
<li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大.</li>
<li>在异常处理机制上有差异。如果执行FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
<li>readonly 对super用户权限无效</li>
</ol>
<h2 id="InnoDB加锁方法"><a href="#InnoDB加锁方法" class="headerlink" title="InnoDB加锁方法"></a>InnoDB加锁方法</h2><ul>
<li>意向锁是InnoDB自动加的，不需要用户干预；</li>
<li>对于UPDATE、INSERT和DELETE语句，InnoDB会自动给涉及的数据集加排他锁（X）</li>
<li>对于普通SELECT语句，InnoDB不会加锁</li>
<li>事务可以通过以下语句显示地给数据集加共享锁或排他锁<ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。其他事务仍可以查询记录并对当前数据集加共享锁。但如果当前事务需要对该数据集进行更新操作，则很有可能造成死锁</li>
<li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE.其他事务可以查询当前数据集，但是不能对该数据集加共享锁或排他锁。</li>
</ul>
</li>
</ul>
<p>InnoDB在事务执行的识货使用两阶段锁协议：</p>
<ol>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</li>
</ol>
<h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>当不同的事务或线程出现循环资源依赖的时候，就会出现死锁。</p>
<p>比如，事务A获取了记录R1的写锁，修改成功之后，准备获取记录R2的写锁；而事务B先获取了记录R2的写锁，修改成功之后，准备获取R1的写锁。此时，事务AB等在等对方释放锁，就会产生死循环，造成死锁。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-deat-lock.png" alt="死锁"></p>
<h3 id="死锁对策"><a href="#死锁对策" class="headerlink" title="死锁对策"></a>死锁对策</h3><ol>
<li>主动等待超时，由参数 <code>innodb_lock_wait_timeout</code> 设置，但是业务无法等待；</li>
<li>主动死锁检测（<code>innodb_deadlock_detect=on</code>）</li>
</ol>
<p>发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。</p>
<p>另外，我们可以采取以下方式避免死锁：</p>
<ul>
<li>通过表级锁来减少死锁产生的概率；</li>
<li>多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；</li>
<li>同一个事务尽可能做到一次锁定所需要的所有资源。</li>
</ul>
<p>另外，死锁检测也非常耗费资源，判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://hoxis.github.io/mysql-zhuanlan-06-07-lock.html">MySQL实战 | 06&#x2F;07 简单说说MySQL中的锁</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/eygle/article/details/94384306">史上最详细MySQL全局锁和表锁</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29150809">MySQL锁总结</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://huhansi.com/2020/04/11/MySQL/MySQL%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" data-id="cl541frv400125srw2y8ke48t" data-title="MySQL中的各种锁" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%AD%BB%E9%94%81/" rel="tag">死锁</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/53/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/52/">52</a><a class="page-number" href="/page/53/">53</a><span class="page-number current">54</span><a class="page-number" href="/page/55/">55</a><a class="page-number" href="/page/56/">56</a><span class="space">&hellip;</span><a class="page-number" href="/page/92/">92</a><a class="extend next" rel="next" href="/page/55/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CAS/">CAS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Guava/">Guava</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud/">Spring Cloud</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Spring-Cloud-Gateway/">Spring Cloud Gateway</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%AE%89%E5%85%A8/">Web安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-NIO/">java NIO</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">java多线程设计模式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/leetcode/">leetcode</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E5%AD%A6%E4%B9%A0/">python学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python%E7%88%AC%E8%99%AB/">python爬虫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/">官方文档翻译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/">源码</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%BA%90%E7%A0%81/%E5%A4%9A%E7%BA%BF%E7%A8%8B/CAS/">CAS</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACID/" rel="tag">ACID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AJAX/" rel="tag">AJAX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AQS/" rel="tag">AQS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AbstractQueuedSynchronizer/" rel="tag">AbstractQueuedSynchronizer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Abuse-case/" rel="tag">Abuse case</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Access-Control/" rel="tag">Access Control</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Active-Object%E6%A8%A1%E5%BC%8F/" rel="tag">Active Object模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayBlockingQueue/" rel="tag">ArrayBlockingQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/" rel="tag">ArrayList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arrays/" rel="tag">Arrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arrrays/" rel="tag">Arrrays</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Arthas/" rel="tag">Arthas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicBoolean/" rel="tag">AtomicBoolean</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicInteger/" rel="tag">AtomicInteger</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicIntegerArray/" rel="tag">AtomicIntegerArray</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicIntegerFieldUpdater/" rel="tag">AtomicIntegerFieldUpdater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicLong/" rel="tag">AtomicLong</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicLongArray/" rel="tag">AtomicLongArray</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicLongFieldUpdater/" rel="tag">AtomicLongFieldUpdater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicMarkableReference/" rel="tag">AtomicMarkableReference</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicReference/" rel="tag">AtomicReference</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicReferenceArray/" rel="tag">AtomicReferenceArray</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicReferenceFieldUpdater/" rel="tag">AtomicReferenceFieldUpdater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AtomicStampedReference/" rel="tag">AtomicStampedReference</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/B-Tree/" rel="tag">B-Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BASE/" rel="tag">BASE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Balking-%E6%A8%A1%E5%BC%8F/" rel="tag">Balking 模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Bash/" rel="tag">Bash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BlockingQueue/" rel="tag">BlockingQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAP/" rel="tag">CAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CAS/" rel="tag">CAS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CMS/" rel="tag">CMS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/COW/" rel="tag">COW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Callable/" rel="tag">Callable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CharMatcher/" rel="tag">CharMatcher</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ClassLoader/" rel="tag">ClassLoader</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CompletableFuture/" rel="tag">CompletableFuture</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Concurrent-Mark-Sweep/" rel="tag">Concurrent Mark Sweep</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentHashMap/" rel="tag">ConcurrentHashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentLinkedQueue/" rel="tag">ConcurrentLinkedQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Condition/" rel="tag">Condition</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Consul/" rel="tag">Consul</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CopyOnWriteArrayList/" rel="tag">CopyOnWriteArrayList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CopyOnWriteArraySet/" rel="tag">CopyOnWriteArraySet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CountDownLatch/" rel="tag">CountDownLatch</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CyclicBarrier/" rel="tag">CyclicBarrier</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DTS/" rel="tag">DTS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DelayQueue/" rel="tag">DelayQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoubleAccumulator/" rel="tag">DoubleAccumulator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DoubleAdder/" rel="tag">DoubleAdder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Etcd/" rel="tag">Etcd</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Eureka/" rel="tag">Eureka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Feign/" rel="tag">Feign</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fibonacci/" rel="tag">Fibonacci</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FullGC/" rel="tag">FullGC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Future/" rel="tag">Future</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FutureTask/" rel="tag">FutureTask</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Future%E6%A8%A1%E5%BC%8F/" rel="tag">Future模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/G1/" rel="tag">G1</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Garbage-First/" rel="tag">Garbage First</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gossip/" rel="tag">Gossip</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Guarded-Suspension-%E6%A8%A1%E5%BC%8F/" rel="tag">Guarded Suspension 模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Guava/" rel="tag">Guava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP%E8%AF%B7%E6%B1%82/" rel="tag">HTTP请求</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hash/" rel="tag">Hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/" rel="tag">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashSet/" rel="tag">HashSet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hystrix/" rel="tag">Hystrix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IO%E5%A4%8D%E7%94%A8/" rel="tag">IO复用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Immutable-%E6%A8%A1%E5%BC%8F/" rel="tag">Immutable 模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Joiner/" rel="tag">Joiner</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kafka/" rel="tag">Kafka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LDAP/" rel="tag">LDAP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedBlockingQueue/" rel="tag">LinkedBlockingQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/" rel="tag">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/List/" rel="tag">List</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lock/" rel="tag">Lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LockSupport/" rel="tag">LockSupport</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LongAccumulator/" rel="tag">LongAccumulator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LongAdder/" rel="tag">LongAdder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MQ%E4%BA%8B%E5%8A%A1/" rel="tag">MQ事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Math/" rel="tag">Math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NIO/" rel="tag">NIO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NoSql/" rel="tag">NoSql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/N%E5%8F%89%E6%A0%91/" rel="tag">N叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PriotityBlockingQueue/" rel="tag">PriotityBlockingQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Producer-Consumer-%E6%A8%A1%E5%BC%8F/" rel="tag">Producer-Consumer 模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PutLock/" rel="tag">PutLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Queue/" rel="tag">Queue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RAFT/" rel="tag">RAFT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/" rel="tag">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RabbitMQ/" rel="tag">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Random/" rel="tag">Random</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Read-Write-Lock-%E6%A8%A1%E5%BC%8F/" rel="tag">Read-Write Lock 模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RedLock/" rel="tag">RedLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redission/" rel="tag">Redission</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantLock/" rel="tag">ReentrantLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ReentrantReadWriteLock/" rel="tag">ReentrantReadWriteLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Saga%E4%BA%8B%E5%8A%A1/" rel="tag">Saga事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Semaphore/" rel="tag">Semaphore</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Set/" rel="tag">Set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Single-Threaded-Execution%E6%A8%A1%E5%BC%8F/" rel="tag">Single Threaded Execution模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SnowFlake/" rel="tag">SnowFlake</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sorted-Set/" rel="tag">Sorted Set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spliter/" rel="tag">Spliter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud/" rel="tag">Spring Cloud</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud-Gateway/" rel="tag">Spring Cloud Gateway</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-Cloud-Stream/" rel="tag">Spring Cloud Stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stack/" rel="tag">Stack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/StampedLock/" rel="tag">StampedLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Stream/" rel="tag">Stream</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/String/" rel="tag">String</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Strings/" rel="tag">Strings</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Striped64/" rel="tag">Striped64</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SynchronousQueue/" rel="tag">SynchronousQueue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TCC/" rel="tag">TCC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TakeLock/" rel="tag">TakeLock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread-Per-Message-%E6%A8%A1%E5%BC%8F/" rel="tag">Thread-Per-Message 模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Thread-Specific-Storage%E6%A8%A1%E5%BC%8F/" rel="tag">Thread-Specific-Storage模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadLocal/" rel="tag">ThreadLocal</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadLocalRandom/" rel="tag">ThreadLocalRandom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ThreadPoolExecutor/" rel="tag">ThreadPoolExecutor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tree/" rel="tag">Tree</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Two-Phase-Termination%E6%A8%A1%E5%BC%8F/" rel="tag">Two-Phase-Termination模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UnSave/" rel="tag">UnSave</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Worker-Thread-%E6%A8%A1%E5%BC%8F/" rel="tag">Worker Thread 模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XA/" rel="tag">XA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/" rel="tag">XML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XPath/" rel="tag">XPath</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XSS%E6%94%BB%E5%87%BB/" rel="tag">XSS攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zookeeper/" rel="tag">Zookeeper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cglib/" rel="tag">cglib</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cross-join/" rel="tag">cross join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dfs/" rel="tag">dfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dubbo/" rel="tag">dubbo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/epoll/" rel="tag">epoll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/equals/" rel="tag">equals</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/full-outter-join/" rel="tag">full outter join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hashCode/" rel="tag">hashCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/inner-join/" rel="tag">inner join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/" rel="tag">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jmap/" rel="tag">jmap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/join/" rel="tag">join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jps/" rel="tag">jps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstack/" rel="tag">jstack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jstat/" rel="tag">jstat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/left-join/" rel="tag">left join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/list/" rel="tag">list</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/math/" rel="tag">math</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mathng/" rel="tag">mathng</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paxos/" rel="tag">paxos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/poll/" rel="tag">poll</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python3-%E8%AF%AD%E6%B3%95/" rel="tag">python3 语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/right-join/" rel="tag">right join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/select/" rel="tag">select</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/self-join/" rel="tag">self join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/set/" rel="tag">set</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/synchronized/" rel="tag">synchronized</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/transaction/" rel="tag">transaction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/union/" rel="tag">union</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/union-all/" rel="tag">union all</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/zuul/" rel="tag">zuul</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" rel="tag">三阶段提交</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" rel="tag">两阶段提交</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">中介者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/" rel="tag">中位数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">中序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%B2%E8%A1%8C%E5%8C%96/" rel="tag">串行化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%BB%E4%BB%8E/" rel="tag">主从</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" rel="tag">二分搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" rel="tag">二叉搜索树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" rel="tag">二进制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" rel="tag">享元模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86/" rel="tag">代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" rel="tag">代理模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%97%E6%95%B0/" rel="tag">众数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BC%9A%E8%AF%9D/" rel="tag">会话</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" rel="tag">位运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92/" rel="tag">依赖传递</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%83%E7%BB%84/" rel="tag">元组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A5%E9%97%A8/" rel="tag">入门</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/" rel="tag">全文索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" rel="tag">内存区域</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" rel="tag">内存模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/" rel="tag">写时复制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/" rel="tag">分代收集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%8C%BA/" rel="tag">分区</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/" rel="tag">分布式ID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag">分布式事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" rel="tag">分布式缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="tag">分布式锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%80/" rel="tag">分式化简</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">前序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95/" rel="tag">前缀索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A0%E6%B3%95/" rel="tag">加法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" rel="tag">动态代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8C%85%E5%86%B2%E7%AA%81/" rel="tag">包冲突</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%8B%E7%BC%A9/" rel="tag">压缩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" rel="tag">原型模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/" rel="tag">双亲委派</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E5%B0%84/" rel="tag">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/" rel="tag">可重复读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%88%E5%B9%B6/" rel="tag">合并</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E6%AD%A5/" rel="tag">同步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">后序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" rel="tag">命令模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/" rel="tag">哈希索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" rel="tag">哈希表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%A8%E5%85%B5/" rel="tag">哨兵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%94%B6/" rel="tag">回收</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%96%87/" rel="tag">回文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" rel="tag">垃圾回收器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" rel="tag">垃圾回收算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86/" rel="tag">堆</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" rel="tag">堆排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" rel="tag">备忘录模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" rel="tag">外观模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">子字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E5%BA%8F%E5%88%97/" rel="tag">子序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E6%95%B0%E7%BB%84/" rel="tag">子数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E5%85%B8/" rel="tag">字典</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC/" rel="tag">字符串翻转</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%89%E5%85%A8/" rel="tag">安全</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" rel="tag">官方文档</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E9%94%99/" rel="tag">容错</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/" rel="tag">层次遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" rel="tag">工厂模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" rel="tag">布隆过滤器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">平衡二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">建造者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%95%E7%94%A8/" rel="tag">引用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/" rel="tag">循环队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/" rel="tag">微服务架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E4%B9%90%E6%95%B0/" rel="tag">快乐数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" rel="tag">快速排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" rel="tag">抽象工厂模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%90%9C%E7%B4%A2/" rel="tag">搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/" rel="tag">摩尔投票</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" rel="tag">操作系统命令</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" rel="tag">数据存储</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%8B%AC/" rel="tag">数独</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/" rel="tag">文件路径</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/" rel="tag">斐波那契</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/" rel="tag">斐波那契数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E6%9C%9F/" rel="tag">日期</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80/" rel="tag">最左前缀</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/" rel="tag">最长公共前缀</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%89%E5%BA%8F/" rel="tag">有序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E4%B8%B2%E8%81%94%E6%A8%A1%E5%BC%8F/" rel="tag">服务串联模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" rel="tag">服务代理模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F/" rel="tag">服务共享数据模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%88%86%E6%94%AF%E6%A8%A1%E5%BC%8F/" rel="tag">服务分支模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" rel="tag">服务发现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F/" rel="tag">服务异步消息模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/" rel="tag">服务治理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E8%81%9A%E5%90%88%E6%A8%A1%E5%BC%8F/" rel="tag">服务聚合模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8/" rel="tag">本地消息表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/" rel="tag">杨辉三角</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag">架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6/" rel="tag">标记-复制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86/" rel="tag">标记-整理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4/" rel="tag">标记-清除</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88/" rel="tag">栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%91/" rel="tag">树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" rel="tag">桥接模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/" rel="tag">桶排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/" rel="tag">模板模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%BB%E9%94%81/" rel="tag">死锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B1%89%E8%AF%BA%E5%A1%94/" rel="tag">汉诺塔</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E5%85%A5/" rel="tag">注入</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E8%A7%A3/" rel="tag">注解</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" rel="tag">深度优先搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" rel="tag">滑动窗口</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%86%94%E6%96%AD/" rel="tag">熔断</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/" rel="tag">牛顿迭代法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" rel="tag">状态模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%BD%A2/" rel="tag">环形</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/" rel="tag">电子邮件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A9%E9%98%B5/" rel="tag">矩阵</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" rel="tag">策略模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98/" rel="tag">算法题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/" rel="tag">类加载模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" rel="tag">索引优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" rel="tag">组合模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" rel="tag">缓存穿透</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" rel="tag">缓存雪崩</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD/" rel="tag">缓存预热</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%BD%AC/" rel="tag">翻转</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/" rel="tag">聚簇索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%8A%82%E7%82%B9/" rel="tag">节点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">装饰器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">观察者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">解释器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80/" rel="tag">解释性语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1/" rel="tag">设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/" rel="tag">访问控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">访问者模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E6%8F%90%E4%BA%A4/" rel="tag">读提交</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4/" rel="tag">读未提交</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" rel="tag">责任链模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83/" rel="tag">贪心</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3/" rel="tag">迭代</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">迭代器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">适配器模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91/" rel="tag">逻辑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/" rel="tag">逻辑运算</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%93%BE%E8%A1%A8/" rel="tag">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%94%81/" rel="tag">锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%9F%E5%88%97/" rel="tag">队列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%B6%E4%B9%98/" rel="tag">阶乘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%98%BB%E5%A1%9E/" rel="tag">阻塞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%99%8D%E7%BA%A7/" rel="tag">降级</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%99%90%E6%B5%81/" rel="tag">限流</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" rel="tag">隔离级别</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E5%90%88/" rel="tag">集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%86%E7%BE%A4/" rel="tag">集群</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/" rel="tag">静态代理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/" rel="tag">非阻塞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AA%8C%E8%AF%81/" rel="tag">验证</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACID/" style="font-size: 10.32px;">ACID</a> <a href="/tags/AJAX/" style="font-size: 10px;">AJAX</a> <a href="/tags/AQS/" style="font-size: 10px;">AQS</a> <a href="/tags/AbstractQueuedSynchronizer/" style="font-size: 10px;">AbstractQueuedSynchronizer</a> <a href="/tags/Abuse-case/" style="font-size: 10px;">Abuse case</a> <a href="/tags/Access-Control/" style="font-size: 10px;">Access Control</a> <a href="/tags/Active-Object%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Active Object模式</a> <a href="/tags/ArrayBlockingQueue/" style="font-size: 10px;">ArrayBlockingQueue</a> <a href="/tags/ArrayList/" style="font-size: 10px;">ArrayList</a> <a href="/tags/Arrays/" style="font-size: 12.26px;">Arrays</a> <a href="/tags/Arrrays/" style="font-size: 10.32px;">Arrrays</a> <a href="/tags/Arthas/" style="font-size: 10px;">Arthas</a> <a href="/tags/AtomicBoolean/" style="font-size: 10.97px;">AtomicBoolean</a> <a href="/tags/AtomicInteger/" style="font-size: 10px;">AtomicInteger</a> <a href="/tags/AtomicIntegerArray/" style="font-size: 10.32px;">AtomicIntegerArray</a> <a href="/tags/AtomicIntegerFieldUpdater/" style="font-size: 10px;">AtomicIntegerFieldUpdater</a> <a href="/tags/AtomicLong/" style="font-size: 10px;">AtomicLong</a> <a href="/tags/AtomicLongArray/" style="font-size: 10px;">AtomicLongArray</a> <a href="/tags/AtomicLongFieldUpdater/" style="font-size: 10.32px;">AtomicLongFieldUpdater</a> <a href="/tags/AtomicMarkableReference/" style="font-size: 10px;">AtomicMarkableReference</a> <a href="/tags/AtomicReference/" style="font-size: 10px;">AtomicReference</a> <a href="/tags/AtomicReferenceArray/" style="font-size: 10px;">AtomicReferenceArray</a> <a href="/tags/AtomicReferenceFieldUpdater/" style="font-size: 10px;">AtomicReferenceFieldUpdater</a> <a href="/tags/AtomicStampedReference/" style="font-size: 10px;">AtomicStampedReference</a> <a href="/tags/B-Tree/" style="font-size: 10.32px;">B-Tree</a> <a href="/tags/BASE/" style="font-size: 10px;">BASE</a> <a href="/tags/Balking-%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Balking 模式</a> <a href="/tags/Bash/" style="font-size: 10.32px;">Bash</a> <a href="/tags/BlockingQueue/" style="font-size: 10px;">BlockingQueue</a> <a href="/tags/CAP/" style="font-size: 10px;">CAP</a> <a href="/tags/CAS/" style="font-size: 10.32px;">CAS</a> <a href="/tags/CMS/" style="font-size: 10px;">CMS</a> <a href="/tags/COW/" style="font-size: 10px;">COW</a> <a href="/tags/Callable/" style="font-size: 10px;">Callable</a> <a href="/tags/CharMatcher/" style="font-size: 10px;">CharMatcher</a> <a href="/tags/ClassLoader/" style="font-size: 10px;">ClassLoader</a> <a href="/tags/CompletableFuture/" style="font-size: 10px;">CompletableFuture</a> <a href="/tags/Concurrent-Mark-Sweep/" style="font-size: 10px;">Concurrent Mark Sweep</a> <a href="/tags/ConcurrentHashMap/" style="font-size: 10.32px;">ConcurrentHashMap</a> <a href="/tags/ConcurrentLinkedQueue/" style="font-size: 10px;">ConcurrentLinkedQueue</a> <a href="/tags/Condition/" style="font-size: 10.97px;">Condition</a> <a href="/tags/Consul/" style="font-size: 10.32px;">Consul</a> <a href="/tags/CopyOnWriteArrayList/" style="font-size: 10px;">CopyOnWriteArrayList</a> <a href="/tags/CopyOnWriteArraySet/" style="font-size: 10px;">CopyOnWriteArraySet</a> <a href="/tags/CountDownLatch/" style="font-size: 10px;">CountDownLatch</a> <a href="/tags/CyclicBarrier/" style="font-size: 10px;">CyclicBarrier</a> <a href="/tags/DTS/" style="font-size: 10px;">DTS</a> <a href="/tags/DelayQueue/" style="font-size: 10px;">DelayQueue</a> <a href="/tags/DoubleAccumulator/" style="font-size: 10px;">DoubleAccumulator</a> <a href="/tags/DoubleAdder/" style="font-size: 10px;">DoubleAdder</a> <a href="/tags/Etcd/" style="font-size: 10px;">Etcd</a> <a href="/tags/Eureka/" style="font-size: 11.61px;">Eureka</a> <a href="/tags/Feign/" style="font-size: 10.97px;">Feign</a> <a href="/tags/Fibonacci/" style="font-size: 10px;">Fibonacci</a> <a href="/tags/FullGC/" style="font-size: 10px;">FullGC</a> <a href="/tags/Future/" style="font-size: 10px;">Future</a> <a href="/tags/FutureTask/" style="font-size: 10.32px;">FutureTask</a> <a href="/tags/Future%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Future模式</a> <a href="/tags/G1/" style="font-size: 10px;">G1</a> <a href="/tags/Garbage-First/" style="font-size: 10px;">Garbage First</a> <a href="/tags/Gossip/" style="font-size: 10px;">Gossip</a> <a href="/tags/Guarded-Suspension-%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Guarded Suspension 模式</a> <a href="/tags/Guava/" style="font-size: 11.29px;">Guava</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/HTTP%E8%AF%B7%E6%B1%82/" style="font-size: 10px;">HTTP请求</a> <a href="/tags/Hash/" style="font-size: 10px;">Hash</a> <a href="/tags/HashMap/" style="font-size: 12.26px;">HashMap</a> <a href="/tags/HashSet/" style="font-size: 10px;">HashSet</a> <a href="/tags/Hystrix/" style="font-size: 10.97px;">Hystrix</a> <a href="/tags/IO%E5%A4%8D%E7%94%A8/" style="font-size: 10px;">IO复用</a> <a href="/tags/Immutable-%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Immutable 模式</a> <a href="/tags/JVM/" style="font-size: 13.87px;">JVM</a> <a href="/tags/Java/" style="font-size: 19.03px;">Java</a> <a href="/tags/Joiner/" style="font-size: 10px;">Joiner</a> <a href="/tags/Kafka/" style="font-size: 10.32px;">Kafka</a> <a href="/tags/LDAP/" style="font-size: 10px;">LDAP</a> <a href="/tags/LinkedBlockingQueue/" style="font-size: 10px;">LinkedBlockingQueue</a> <a href="/tags/LinkedList/" style="font-size: 11.29px;">LinkedList</a> <a href="/tags/List/" style="font-size: 10px;">List</a> <a href="/tags/Lock/" style="font-size: 10px;">Lock</a> <a href="/tags/LockSupport/" style="font-size: 10px;">LockSupport</a> <a href="/tags/LongAccumulator/" style="font-size: 10px;">LongAccumulator</a> <a href="/tags/LongAdder/" style="font-size: 10.32px;">LongAdder</a> <a href="/tags/MQ%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">MQ事务</a> <a href="/tags/Math/" style="font-size: 18.39px;">Math</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MySQL/" style="font-size: 12.26px;">MySQL</a> <a href="/tags/NIO/" style="font-size: 10px;">NIO</a> <a href="/tags/NoSql/" style="font-size: 10px;">NoSql</a> <a href="/tags/N%E5%8F%89%E6%A0%91/" style="font-size: 10.65px;">N叉树</a> <a href="/tags/PriotityBlockingQueue/" style="font-size: 10px;">PriotityBlockingQueue</a> <a href="/tags/Producer-Consumer-%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Producer-Consumer 模式</a> <a href="/tags/PutLock/" style="font-size: 10px;">PutLock</a> <a href="/tags/Queue/" style="font-size: 11.94px;">Queue</a> <a href="/tags/RAFT/" style="font-size: 10.32px;">RAFT</a> <a href="/tags/RPC/" style="font-size: 10px;">RPC</a> <a href="/tags/RabbitMQ/" style="font-size: 10.32px;">RabbitMQ</a> <a href="/tags/Random/" style="font-size: 10px;">Random</a> <a href="/tags/Read-Write-Lock-%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Read-Write Lock 模式</a> <a href="/tags/RedLock/" style="font-size: 10px;">RedLock</a> <a href="/tags/Redis/" style="font-size: 10.65px;">Redis</a> <a href="/tags/Redission/" style="font-size: 10px;">Redission</a> <a href="/tags/ReentrantLock/" style="font-size: 12.58px;">ReentrantLock</a> <a href="/tags/ReentrantReadWriteLock/" style="font-size: 10px;">ReentrantReadWriteLock</a> <a href="/tags/SQL/" style="font-size: 18.06px;">SQL</a> <a href="/tags/Saga%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">Saga事务</a> <a href="/tags/Semaphore/" style="font-size: 10.65px;">Semaphore</a> <a href="/tags/Set/" style="font-size: 10px;">Set</a> <a href="/tags/Single-Threaded-Execution%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Single Threaded Execution模式</a> <a href="/tags/SnowFlake/" style="font-size: 10px;">SnowFlake</a> <a href="/tags/Sorted-Set/" style="font-size: 10px;">Sorted Set</a> <a href="/tags/Spliter/" style="font-size: 10px;">Spliter</a> <a href="/tags/Spring/" style="font-size: 14.84px;">Spring</a> <a href="/tags/Spring-Cloud/" style="font-size: 10.97px;">Spring Cloud</a> <a href="/tags/Spring-Cloud-Gateway/" style="font-size: 10.32px;">Spring Cloud Gateway</a> <a href="/tags/Spring-Cloud-Stream/" style="font-size: 10.32px;">Spring Cloud Stream</a> <a href="/tags/Stack/" style="font-size: 10.32px;">Stack</a> <a href="/tags/StampedLock/" style="font-size: 10px;">StampedLock</a> <a href="/tags/Stream/" style="font-size: 10px;">Stream</a> <a href="/tags/String/" style="font-size: 11.94px;">String</a> <a href="/tags/Strings/" style="font-size: 10px;">Strings</a> <a href="/tags/Striped64/" style="font-size: 10px;">Striped64</a> <a href="/tags/SynchronousQueue/" style="font-size: 10px;">SynchronousQueue</a> <a href="/tags/TCC/" style="font-size: 10px;">TCC</a> <a href="/tags/TakeLock/" style="font-size: 10px;">TakeLock</a> <a href="/tags/Thread-Per-Message-%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Thread-Per-Message 模式</a> <a href="/tags/Thread-Specific-Storage%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Thread-Specific-Storage模式</a> <a href="/tags/ThreadLocal/" style="font-size: 10px;">ThreadLocal</a> <a href="/tags/ThreadLocalRandom/" style="font-size: 10px;">ThreadLocalRandom</a> <a href="/tags/ThreadPoolExecutor/" style="font-size: 10px;">ThreadPoolExecutor</a> <a href="/tags/Tree/" style="font-size: 10.65px;">Tree</a> <a href="/tags/Two-Phase-Termination%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Two-Phase-Termination模式</a> <a href="/tags/UnSave/" style="font-size: 10px;">UnSave</a> <a href="/tags/Web/" style="font-size: 15.16px;">Web</a> <a href="/tags/Worker-Thread-%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">Worker Thread 模式</a> <a href="/tags/XA/" style="font-size: 10.32px;">XA</a> <a href="/tags/XML/" style="font-size: 10px;">XML</a> <a href="/tags/XPath/" style="font-size: 10px;">XPath</a> <a href="/tags/XSS%E6%94%BB%E5%87%BB/" style="font-size: 10px;">XSS攻击</a> <a href="/tags/Zookeeper/" style="font-size: 10.32px;">Zookeeper</a> <a href="/tags/cglib/" style="font-size: 10px;">cglib</a> <a href="/tags/cross-join/" style="font-size: 10px;">cross join</a> <a href="/tags/dfs/" style="font-size: 10px;">dfs</a> <a href="/tags/dubbo/" style="font-size: 10px;">dubbo</a> <a href="/tags/epoll/" style="font-size: 10px;">epoll</a> <a href="/tags/equals/" style="font-size: 10px;">equals</a> <a href="/tags/full-outter-join/" style="font-size: 10px;">full outter join</a> <a href="/tags/hashCode/" style="font-size: 10px;">hashCode</a> <a href="/tags/inner-join/" style="font-size: 10px;">inner join</a> <a href="/tags/java/" style="font-size: 14.19px;">java</a> <a href="/tags/jmap/" style="font-size: 10px;">jmap</a> <a href="/tags/join/" style="font-size: 10px;">join</a> <a href="/tags/jps/" style="font-size: 10px;">jps</a> <a href="/tags/jstack/" style="font-size: 10px;">jstack</a> <a href="/tags/jstat/" style="font-size: 10px;">jstat</a> <a href="/tags/leetcode/" style="font-size: 17.42px;">leetcode</a> <a href="/tags/left-join/" style="font-size: 10px;">left join</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/list/" style="font-size: 10px;">list</a> <a href="/tags/math/" style="font-size: 20px;">math</a> <a href="/tags/mathng/" style="font-size: 10px;">mathng</a> <a href="/tags/paxos/" style="font-size: 10px;">paxos</a> <a href="/tags/poll/" style="font-size: 10px;">poll</a> <a href="/tags/python/" style="font-size: 10.97px;">python</a> <a href="/tags/python3-%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">python3 语法</a> <a href="/tags/redis/" style="font-size: 10px;">redis</a> <a href="/tags/right-join/" style="font-size: 10px;">right join</a> <a href="/tags/select/" style="font-size: 10px;">select</a> <a href="/tags/self-join/" style="font-size: 10px;">self join</a> <a href="/tags/set/" style="font-size: 10px;">set</a> <a href="/tags/synchronized/" style="font-size: 10px;">synchronized</a> <a href="/tags/transaction/" style="font-size: 10px;">transaction</a> <a href="/tags/union/" style="font-size: 10px;">union</a> <a href="/tags/union-all/" style="font-size: 10px;">union all</a> <a href="/tags/zuul/" style="font-size: 10.97px;">zuul</a> <a href="/tags/%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" style="font-size: 10px;">三阶段提交</a> <a href="/tags/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/" style="font-size: 10px;">两阶段提交</a> <a href="/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">中介者模式</a> <a href="/tags/%E4%B8%AD%E4%BD%8D%E6%95%B0/" style="font-size: 10px;">中位数</a> <a href="/tags/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">中序遍历</a> <a href="/tags/%E4%B8%B2%E8%A1%8C%E5%8C%96/" style="font-size: 10.32px;">串行化</a> <a href="/tags/%E4%B8%BB%E4%BB%8E/" style="font-size: 10px;">主从</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10.65px;">事务</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">二分搜索</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 13.23px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" style="font-size: 12.58px;">二叉搜索树</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 17.74px;">二叉树</a> <a href="/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/" style="font-size: 10.32px;">二进制</a> <a href="/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">享元模式</a> <a href="/tags/%E4%BB%A3%E7%90%86/" style="font-size: 10px;">代理</a> <a href="/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">代理模式</a> <a href="/tags/%E4%BC%97%E6%95%B0/" style="font-size: 10px;">众数</a> <a href="/tags/%E4%BC%9A%E8%AF%9D/" style="font-size: 10px;">会话</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 10.32px;">位运算</a> <a href="/tags/%E4%BE%9D%E8%B5%96%E4%BC%A0%E9%80%92/" style="font-size: 10px;">依赖传递</a> <a href="/tags/%E5%85%83%E7%BB%84/" style="font-size: 10px;">元组</a> <a href="/tags/%E5%85%A5%E9%97%A8/" style="font-size: 10px;">入门</a> <a href="/tags/%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95/" style="font-size: 10.32px;">全文索引</a> <a href="/tags/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/" style="font-size: 10.32px;">内存区域</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">内存模型</a> <a href="/tags/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6/" style="font-size: 10px;">写时复制</a> <a href="/tags/%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86/" style="font-size: 10px;">分代收集</a> <a href="/tags/%E5%88%86%E5%8C%BA/" style="font-size: 10.32px;">分区</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8FID/" style="font-size: 10px;">分布式ID</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" style="font-size: 10.65px;">分布式事务</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/" style="font-size: 10px;">分布式缓存</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" style="font-size: 10px;">分布式锁</a> <a href="/tags/%E5%88%86%E5%BC%8F%E5%8C%96%E7%AE%80/" style="font-size: 10px;">分式化简</a> <a href="/tags/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">前序遍历</a> <a href="/tags/%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95/" style="font-size: 10.32px;">前缀索引</a> <a href="/tags/%E5%8A%A0%E6%B3%95/" style="font-size: 10.65px;">加法</a> <a href="/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 10.32px;">动态代理</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 11.94px;">动态规划</a> <a href="/tags/%E5%8C%85%E5%86%B2%E7%AA%81/" style="font-size: 10px;">包冲突</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">单例模式</a> <a href="/tags/%E5%8E%8B%E7%BC%A9/" style="font-size: 10px;">压缩</a> <a href="/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">原型模式</a> <a href="/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/" style="font-size: 10px;">双亲委派</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 11.94px;">双指针</a> <a href="/tags/%E5%8F%8D%E5%B0%84/" style="font-size: 10px;">反射</a> <a href="/tags/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB/" style="font-size: 10.32px;">可重复读</a> <a href="/tags/%E5%90%88%E5%B9%B6/" style="font-size: 10px;">合并</a> <a href="/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 10px;">同步</a> <a href="/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">后序遍历</a> <a href="/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">命令模式</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 10px;">哈希</a> <a href="/tags/%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95/" style="font-size: 10.32px;">哈希索引</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 12.9px;">哈希表</a> <a href="/tags/%E5%93%A8%E5%85%B5/" style="font-size: 10px;">哨兵</a> <a href="/tags/%E5%9B%9E%E6%94%B6/" style="font-size: 10px;">回收</a> <a href="/tags/%E5%9B%9E%E6%96%87/" style="font-size: 13.55px;">回文</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" style="font-size: 10px;">垃圾回收器</a> <a href="/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" style="font-size: 10px;">垃圾回收算法</a> <a href="/tags/%E5%A0%86/" style="font-size: 10.65px;">堆</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 11.61px;">堆排序</a> <a href="/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">备忘录模式</a> <a href="/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">外观模式</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 18.71px;">多线程</a> <a href="/tags/%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 12.58px;">子字符串</a> <a href="/tags/%E5%AD%90%E5%BA%8F%E5%88%97/" style="font-size: 10.32px;">子序列</a> <a href="/tags/%E5%AD%90%E6%95%B0%E7%BB%84/" style="font-size: 10.65px;">子数组</a> <a href="/tags/%E5%AD%90%E9%9B%86/" style="font-size: 10px;">子集</a> <a href="/tags/%E5%AD%97%E5%85%B8/" style="font-size: 10px;">字典</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC/" style="font-size: 10px;">字符串翻转</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 15.81px;">安全</a> <a href="/tags/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/" style="font-size: 10px;">官方文档</a> <a href="/tags/%E5%AE%B9%E9%94%99/" style="font-size: 10px;">容错</a> <a href="/tags/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/" style="font-size: 10.32px;">层次遍历</a> <a href="/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">工厂模式</a> <a href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 10px;">布隆过滤器</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">平衡二叉树</a> <a href="/tags/%E5%B9%B6%E5%8F%91/" style="font-size: 12.58px;">并发</a> <a href="/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">建造者模式</a> <a href="/tags/%E5%BC%82%E6%AD%A5/" style="font-size: 10px;">异步</a> <a href="/tags/%E5%BC%95%E7%94%A8/" style="font-size: 10px;">引用</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/" style="font-size: 10.32px;">循环队列</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">微服务</a> <a href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">微服务架构</a> <a href="/tags/%E5%BF%AB%E4%B9%90%E6%95%B0/" style="font-size: 10px;">快乐数</a> <a href="/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">快速排序</a> <a href="/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">抽象工厂模式</a> <a href="/tags/%E6%8E%92%E5%88%97/" style="font-size: 10px;">排列</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 13.55px;">排序</a> <a href="/tags/%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">搜索</a> <a href="/tags/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8/" style="font-size: 10px;">摩尔投票</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4/" style="font-size: 10px;">操作系统命令</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/" style="font-size: 10px;">数据存储</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%95%B0%E7%8B%AC/" style="font-size: 10px;">数独</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 19.68px;">数组</a> <a href="/tags/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/" style="font-size: 10.32px;">文件路径</a> <a href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/" style="font-size: 10.32px;">斐波那契</a> <a href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/" style="font-size: 10px;">斐波那契数</a> <a href="/tags/%E6%97%A5%E6%9C%9F/" style="font-size: 10px;">日期</a> <a href="/tags/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80/" style="font-size: 10.32px;">最左前缀</a> <a href="/tags/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/" style="font-size: 10px;">最长公共前缀</a> <a href="/tags/%E6%9C%89%E5%BA%8F/" style="font-size: 10px;">有序</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E4%B8%B2%E8%81%94%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">服务串联模式</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">服务代理模式</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">服务共享数据模式</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%88%86%E6%94%AF%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">服务分支模式</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/" style="font-size: 10.65px;">服务发现</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">服务异步消息模式</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/" style="font-size: 10.32px;">服务治理</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E8%81%9A%E5%90%88%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">服务聚合模式</a> <a href="/tags/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8/" style="font-size: 10px;">本地消息表</a> <a href="/tags/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/" style="font-size: 10.32px;">杨辉三角</a> <a href="/tags/%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">架构</a> <a href="/tags/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6/" style="font-size: 10px;">标记-复制</a> <a href="/tags/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86/" style="font-size: 10px;">标记-整理</a> <a href="/tags/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4/" style="font-size: 10px;">标记-清除</a> <a href="/tags/%E6%A0%88/" style="font-size: 13.87px;">栈</a> <a href="/tags/%E6%A0%91/" style="font-size: 10px;">树</a> <a href="/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">桥接模式</a> <a href="/tags/%E6%A1%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">桶排序</a> <a href="/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">模板模式</a> <a href="/tags/%E6%AD%BB%E9%94%81/" style="font-size: 10.97px;">死锁</a> <a href="/tags/%E6%B1%89%E8%AF%BA%E5%A1%94/" style="font-size: 10px;">汉诺塔</a> <a href="/tags/%E6%B3%A8%E5%85%A5/" style="font-size: 13.23px;">注入</a> <a href="/tags/%E6%B3%A8%E8%A7%A3/" style="font-size: 10.32px;">注解</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" style="font-size: 10px;">深度优先搜索</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 12.58px;">源码</a> <a href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" style="font-size: 10px;">滑动窗口</a> <a href="/tags/%E7%86%94%E6%96%AD/" style="font-size: 10px;">熔断</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/" style="font-size: 10px;">牛顿迭代法</a> <a href="/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">状态模式</a> <a href="/tags/%E7%8E%AF%E5%BD%A2/" style="font-size: 10px;">环形</a> <a href="/tags/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/" style="font-size: 10px;">电子邮件</a> <a href="/tags/%E7%9F%A9%E9%98%B5/" style="font-size: 16.13px;">矩阵</a> <a href="/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">策略模式</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 19.35px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%E9%A2%98/" style="font-size: 10px;">算法题</a> <a href="/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">类加载模型</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10.97px;">索引</a> <a href="/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" style="font-size: 10.32px;">索引优化</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 10.65px;">线程</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 10px;">线程池</a> <a href="/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">组合模式</a> <a href="/tags/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F/" style="font-size: 10px;">缓存穿透</a> <a href="/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/" style="font-size: 10px;">缓存雪崩</a> <a href="/tags/%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD/" style="font-size: 10px;">缓存预热</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E7%BF%BB%E8%BD%AC/" style="font-size: 12.26px;">翻转</a> <a href="/tags/%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95/" style="font-size: 10.32px;">聚簇索引</a> <a href="/tags/%E8%8A%82%E7%82%B9/" style="font-size: 10px;">节点</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">虚拟机</a> <a href="/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">装饰器模式</a> <a href="/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">观察者模式</a> <a href="/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">解释器模式</a> <a href="/tags/%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80/" style="font-size: 10px;">解释性语言</a> <a href="/tags/%E8%AE%BE%E8%AE%A1/" style="font-size: 15.48px;">设计</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 17.1px;">设计模式</a> <a href="/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/" style="font-size: 10px;">访问控制</a> <a href="/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">访问者模式</a> <a href="/tags/%E8%AF%BB%E6%8F%90%E4%BA%A4/" style="font-size: 10.32px;">读提交</a> <a href="/tags/%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4/" style="font-size: 10.32px;">读未提交</a> <a href="/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">责任链模式</a> <a href="/tags/%E8%B4%AA%E5%BF%83/" style="font-size: 10.97px;">贪心</a> <a href="/tags/%E8%BF%AD%E4%BB%A3/" style="font-size: 11.94px;">迭代</a> <a href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">迭代器模式</a> <a href="/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">适配器模式</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 16.77px;">递归</a> <a href="/tags/%E9%80%BB%E8%BE%91/" style="font-size: 10.65px;">逻辑</a> <a href="/tags/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/" style="font-size: 10px;">逻辑运算</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 16.45px;">链表</a> <a href="/tags/%E9%94%81/" style="font-size: 14.52px;">锁</a> <a href="/tags/%E9%98%9F%E5%88%97/" style="font-size: 11.29px;">队列</a> <a href="/tags/%E9%98%B6%E4%B9%98/" style="font-size: 10px;">阶乘</a> <a href="/tags/%E9%98%BB%E5%A1%9E/" style="font-size: 10px;">阻塞</a> <a href="/tags/%E9%99%8D%E7%BA%A7/" style="font-size: 10px;">降级</a> <a href="/tags/%E9%99%90%E6%B5%81/" style="font-size: 10px;">限流</a> <a href="/tags/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/" style="font-size: 10.32px;">隔离级别</a> <a href="/tags/%E9%9B%86%E5%90%88/" style="font-size: 10.32px;">集合</a> <a href="/tags/%E9%9B%86%E7%BE%A4/" style="font-size: 10px;">集群</a> <a href="/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/" style="font-size: 10px;">静态代理</a> <a href="/tags/%E9%9D%9E%E9%98%BB%E5%A1%9E/" style="font-size: 10px;">非阻塞</a> <a href="/tags/%E9%AA%8C%E8%AF%81/" style="font-size: 10px;">验证</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/07/02/LeetCode/offer/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/">剑指 Offer 03. 数组中重复的数字</a>
          </li>
        
          <li>
            <a href="/2022/07/02/LeetCode/offer/%E5%89%91%E6%8C%87%20Offer%2005.%20%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/">剑指 Offer 05. 替换空格</a>
          </li>
        
          <li>
            <a href="/2022/07/02/LeetCode/offer/%E5%89%91%E6%8C%87%20Offer%2006.%20%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/">剑指 Offer 06. 从尾到头打印链表</a>
          </li>
        
          <li>
            <a href="/2022/07/02/LeetCode/offer/%E5%89%91%E6%8C%87%20Offer%2009.%20%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/">剑指 Offer 09. 用两个栈实现队列</a>
          </li>
        
          <li>
            <a href="/2022/07/02/LeetCode/offer/%E5%89%91%E6%8C%87%20Offer%2010-%20I.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">剑指 Offer 10- I. 斐波那契数列</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 HanSi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>